/*! ------ hmap --- v2.1.3 --- 打包时间 2020-04-26 14:18:56 ------ */
"use strict";
/**
 * 本文件用于声明或规定hmap的命名空间、全局变量、初始状态
 * @private
 */

/**
 * hmap的命名空间
 * @namespace hmap
 */

/**
 * basetype命名空间
 * @namespace hmap.basetype
 */

/**
 * control命名空间
 * @namespace hmap.control
 */

/**
 * event命名空间
 * @namespace hmap.event
 */

/**
 * feature命名空间
 * @namespace hmap.feature
 */

/**
 * format命名空间
 * @namespace hmap.format
*/

/**
* geom命名空间
* @namespace hmap.geom
*/


/**
 * geomext命名空间
 * @namespace hmap.geomext
 */

/**
 * geosolution命名空间
 * @namespace hmap.geosolution
 */

/**
 * geosolution/cell命名空间
 * @namespace hmap.geosolution.cell
 */

/**
 * geosolution/math命名空间
 * @namespace hmap.geosolution.math
 */

/**
 * language命名空间
 * @namespace hmap.language
 */

/**
 * layer命名空间
 * @namespace hmap.layer
 */

/**
 * model命名空间
 * @namespace hmap.model
 */

/**
 * overlay命名空间
 * @namespace hmap.overlay
 */

/**
 * strategy命名空间
 * @namespace hmap.strategy
 */
/**
 * proj命名空间
 * @namespace hmap.proj
 */
/**
 * style命名空间
 * @namespace hmap.style
 */

/**
 * util命名空间
 * @namespace hmap.util
 */




let hmap={};
/**
 * 初始化状态
 * @type {{version: number, language: string, browserSupport: boolean, graphicsRender: string, webglVersion: string, labelRender: string, gridSize: number, dotsPerInch: number, inchesPerUnit: {degrees: number}, renderTileOneTime: number, EPSILON: number}}
 */
hmap.initState = {
    /**
     * 版本号
     */
    version: '2.1.3',

    /**
     * 使用的语言,默认为中文，当需要英文时设置为：'en_US'
     */
    language:"zh_CN",//"en_US",//"zh_CN",

    /**
     * 浏览器是否支持当前系统运行
     *  @private
     */
    browserSupport:false,

     /**
     * 矢量图层渲染机制
     */
    graphicsRender:"webgl",

    /**
     * 矢量图层渲染机制
     */
    webglVersion:"webgl2.0",

    /**
     * 文本标注渲染机制
     *  @private
     */
    labelRender:"canvas",

    /**
     * 在被划分为网格状的图层中,默认的网格大小，像素单位。
     */
    gridSize:256,

    /**
     * 每英寸点数
     * @private
     */
    dotsPerInch:96,

    /**
     * 每单位长度对应的英寸数
     * @private
     */
    inchesPerUnit:{
        "degrees": 4374754,
        "m":39.3700787
    },

    _srid:4326,

    /**
     * 在网格式图层的渲染阶段，每次绘制瓦片数量
     */
    renderTileOneTime:1000,
    /**
     * 接受的最小误差范围
     */
    EPSILON:1.0e-10//1.0*Math.pow(10,-10);//表示可以接受的最小误差范围
};

/**
 * 设置系统支持最大并发处理线程数量，当参数值大于浏览器支持的并发数量或未时，则按线浏览器支持的线程数量计算．
 * @private
 * @param count 线程数量。
 */
hmap.initState.setThreads=function(count){};

/**
 * 判断当前浏览器是否支持系统运行。
 * @private
 * @return {Boolean} flag 是否支持运行  返回true时表示支持,false表示不支持.
 */
hmap.initState.setBrowserSupport=function(){
    let browseErr=null,webglErr=null;
    //分情况讨论：浏览器错误、webgl错误、显卡错误
    throw new Error("当前环境不支持系统运行！");
};











;// module.exports
let symbol_frag=`
precision mediump float;
uniform float u_opacity;//设置图层透明度系数控制

#include <colorI_defineF>
#include <fog_defineF>
#include <sprite_defineF>//点纹理
#include <texture2D_defineF>//矩形纹理

#include <opacity_defineF>
#include <dynamicText_defineF>

out vec4 outColor;

void main(){
    outColor = vec4(1.0);

    #include <sprite_realizeF>//点纹理
    #include <texture2D_realizeF>//矩形纹理
    #include <dynamicText_realizeF>//动态添加到图集的文字
    float alpha=1.0;
    #include <sdftext_realize>
    #include <colorI_realizeF>
    
    outColor.a = outColor.a * u_opacity*alpha;

    #include <opacity_realizeF>//要素透明度设置
    
    if(outColor.a==0.0){discard;}

    #include <fog_realizeF>//设置雾化影响

}
`;
;// module.exports
let symbol_vert=`
in vec3 a_position;//地理坐标
in vec2 a_size; //点要素的(w,h)

uniform mat4 u_vMatrix;
uniform mat4 u_pMatrix;
uniform vec2 u_viewport;

#include <opacity_defineV>

#include <colorI_defineV>
#include <mMatrix_define>
#include <precisionCorrect_define>
#include <precisionCorrectProject_define>
#include <offset_define>// 设置偏移
#include <fog_defineV>
#include <sprite_defineV>//点纹理
#include <texture2D_defineV>//矩形纹理

#include <dynamicText_defineV>//动态添加到图集上的文字

void main(){  
    vec3 position=a_position;
    mat4 vMatrix=u_vMatrix;
    mat4 pMatrix=u_pMatrix;
    #include <precisionCorrect_realize>
    #include <precisionCorrectProject_realize>
    gl_Position = vec4(position,1.0);
    #include <mMatrix_realize>
    gl_Position = pMatrix * vMatrix * gl_Position;   
    #include <offset_realize>

    gl_PointSize=a_size.x;//点纹理大小，以图标第一个值计算
    #include <colorI_realizeV>
    #include <fog_realizeV>
    #include <sprite_realizeV>//点纹理
    #include <texture2D_realizeV>//矩形纹理

    #include <opacity_realizeV>
    #include <dynamicText_realizeV>
}
`;
;let fill_frag=`
    precision mediump float; 
    
    uniform float u_opacity;  
    
    #include <texture2D_defineF>
    #include <colorI_defineF>
   // #include <fog_defineF>    
    
    out vec4 outColor;
    void main(){
        outColor = vec4(1.0);
        #include <texture2D_realizeF>
        float alpha=1.0;
        #include <sdftext_realize>
         #include <colorI_realizeF>   
        //#include <fog_realizeF>  
        outColor=vec4(outColor.rgb,outColor.a*u_opacity*alpha);          
    }
`;;let fill_vert=`
    in vec3 a_position;
    
    uniform mat4 u_vMatrix; 
    uniform mat4 u_pMatrix;
    uniform vec2 u_viewport;    
    
    #include <texture2D_defineV>
    #include <colorI_defineV>
    #include <offset_define>    
    #include <precisionCorrect_define>
    #include <precisionCorrectProject_define>
    #include <coordOffset_define>
    void main(){
        vec3 position=a_position;
        mat4 vMatrix=u_vMatrix;
        mat4 pMatrix=u_pMatrix;
        #include <precisionCorrect_realize>
        #include <precisionCorrectProject_realize>
        #include <coordOffset_realize>
        gl_Position = pMatrix * vMatrix * vec4(position, 1.0);
               
        #include <offset_realize>
        #include <colorI_realizeV>
        #include <texture2D_realizeV>
    }
`;;// module.exports
let line_frag=`
precision mediump float;
#include <colorI_defineF>
#include <dash_defineF>
uniform float u_opacity;//设置图层透明度系数控制
out vec4 outColor;
void main(){
    outColor=vec4(1.0);
    #include <colorI_realizeF>
    #include <dash_realizeF>
    outColor.a = outColor.a * u_opacity;
}
`;
;// module.exports
let line_vert=
`in vec3 a_position;
uniform mat4 u_vMatrix;
uniform mat4 u_pMatrix;
uniform vec2 u_viewport;
#include <wideSolid_define>//宽线计算
#include <colorI_defineV>
#include <offset_define>
#include <dash_defineV>
#include <precisionCorrect_define>
#include <precisionCorrectProject_define>
void main(){
    vec3 position=a_position;
    mat4 vMatrix=u_vMatrix;
    mat4 pMatrix=u_pMatrix;
    #include <precisionCorrect_realize>
    #include <precisionCorrectProject_realize>
    gl_Position = pMatrix * vMatrix * vec4(position, 1.0);
    #include <wideSolid_realize>//宽线计算

    #include <dash_realizeV>
    #include <offset_realize>

    #include <colorI_realizeV>

}
`;
;// module.exports
let fog_defineF=
`#ifdef fog
    in float v_positionW;

    uniform vec4 u_fogColor;
    uniform vec2 u_fogDist;
#endif`;;// module.exports=
let fog_realizeF=
`#ifdef fog
	float fogFactor=clamp((u_fogDist.y-v_positionW)/(u_fogDist.y-u_fogDist.x),0.0,1.0);
	outColor=mix(u_fogColor,outColor,fogFactor);
#endif
`;
;
// module.exports
let fog_defineV=
`#ifdef fog
    out float v_positionW;
#endif`;
;
// module.exports
let fog_realizeV=
`#ifdef fog
    v_positionW = gl_Position.w;
#endif`;
;// module.exports=
let mMatrix_define=
`
#ifdef mMatrix
    in mat4 u_mMatrix;
#endif
`;;// module.exports=
let mMatrix_realize=
`
#ifdef mMatrix
    gl_Position = u_mMatrix * gl_Position;
#endif
`;;// module.exports=
let offset_define=
`
#ifdef offset
	in vec2 a_offset;
#endif
`;;// module.exports=
let offset_realize=
`#ifdef offset
	vec2 b_side;
	#if offset==0 
		//相对于地图,偏移方向不变
    	mat2 rotateZ=mat2(u_vMatrix[0][0],u_vMatrix[0][1],u_vMatrix[1][0],u_vMatrix[1][1]);
		b_side = rotateZ * a_offset;
	#endif
	#if offset==1
		//相对于屏幕,偏移方向不变
		b_side = a_offset;
	#endif
		vec2 temp_offset=vec2(b_side.x/u_viewport.x,b_side.y/u_viewport.y)*2.0*gl_Position.w;
		gl_Position.x=gl_Position.x+temp_offset.x;
		gl_Position.y=gl_Position.y+temp_offset.y;    
#endif
`;
;// module.exports=
let precisionCorrect_define=
`
#ifdef precisionCorrect
	in vec3 a_positionL;
	uniform vec3 u_eyeH;
    uniform vec3 u_eyeL;
#endif
`;;// module.exports=
let precisionCorrect_realize=
`
#ifdef precisionCorrect
    position=vec3(a_position.x-u_eyeH.x+a_positionL.x-u_eyeL.x,a_position.y-u_eyeH.y+a_positionL.y-u_eyeL.y,a_position.z-u_eyeH.z+a_positionL.z-u_eyeL.z);
    mat4 mvR2Eye=vMatrix;
    mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
    vMatrix=mvR2Eye;
#endif
`;;// module.exports=
let precisionCorrectProject_define=
`
#ifdef precisionCorrectProject
	in vec3 a_positionL;
	uniform vec3 u_eyeH;
    uniform vec3 u_eyeL;
#endif
`;;// module.exports=
let precisionCorrectProject_realize=
`
#ifdef precisionCorrectProject
    position=vec3((a_position.x-u_eyeH.x)*65536.0+a_positionL.x-u_eyeL.x,(a_position.y-u_eyeH.y)*65536.0+a_positionL.y-u_eyeL.y,(a_position.z-u_eyeH.z)*65536.0+a_positionL.z-u_eyeL.z);
    mat4 mvR2Eye=vMatrix;
    mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
    vMatrix=mvR2Eye;
#endif
`;;// module.exports=
let sprite_defineV=
`
#ifdef sprite
	in vec4 a_texAttr;//(x,y,w,h)图集信息
	in float a_angle;//点纹理的旋转角度，单位弧度；正值是逆时针旋转，负值是顺时针旋转。

	out vec4 v_texAttr;
	out mat2 v_rotateMatrix;
	out float v_angle;
	out float v_ratio;

#endif
`;;// module.exports=
let sprite_defineF=
`
#ifdef sprite
	in vec4 v_texAttr;
	in mat2 v_rotateMatrix;
	uniform sampler2D u_pattern0;

	in float v_angle;
	in float v_ratio;

#endif
`;;// module.exports=
let sprite_realizeV=
`
#ifdef sprite
	v_texAttr=a_texAttr;

	// 计算旋转矩阵
    float sinV = sin(a_angle);
    float cosV = cos(a_angle);
    v_rotateMatrix = mat2(cosV,sinV,-sinV,cosV);


    if(a_angle==0.0){
    	gl_PointSize=gl_PointSize;
    	v_ratio = 1.0;
    }else{
    	// 直接由比例，求出长边和对角线的比值
	    float ratio;
	    if(a_texAttr.z>a_texAttr.w){//宽>高
	    	float diagonal = sqrt(a_texAttr.z*a_texAttr.z + a_texAttr.w*a_texAttr.w);
	    	ratio = diagonal/a_texAttr.z;
	    }else{//高>宽
	    	float diagonal = sqrt(a_texAttr.z*a_texAttr.z + a_texAttr.w*a_texAttr.w);
	    	ratio = diagonal/a_texAttr.w;
	    }
    	gl_PointSize=gl_PointSize*ratio;
    	v_ratio = ratio;
    }
    v_angle = a_angle;
    

#endif
`;;// module.exports=
let sprite_realizeF=
`
#ifdef sprite
    vec2 pointCoord;
    if(v_angle==0.0){
        pointCoord = v_rotateMatrix*(gl_PointCoord-vec2(0.5))+vec2(0.5);// 旋转纹理映射区域
    }else{
        pointCoord = gl_PointCoord*v_ratio;//缩小v_ratio倍
        float centerOffset = (v_ratio-1.0)/2.0;
        pointCoord = pointCoord-vec2(centerOffset);//偏移中心
        pointCoord = v_rotateMatrix*(pointCoord-vec2(0.5))+vec2(0.5);//旋转纹理映射区域
    }

    float boxSize=max(v_texAttr.z,v_texAttr.w);//设置纹理映射区域的大小
    pointCoord=vec2(boxSize,boxSize)*pointCoord;

    vec2 texOffset;
    if(v_texAttr.w>v_texAttr.z){//h>w
        float l=(v_texAttr.w - v_texAttr.z)/2.0;
        if(pointCoord.x<l){discard;}
        if(pointCoord.x>l+v_texAttr.z){discard;}
        texOffset = vec2(-l,0);
    }else{//w>h
        float t=(v_texAttr.z - v_texAttr.w)/2.0;
        if(pointCoord.y<t){discard;}
        if(pointCoord.y>t+v_texAttr.w){discard;}
        texOffset = vec2(0,-t);
    }

    pointCoord = vec2(v_texAttr.x,v_texAttr.y)+pointCoord+texOffset;

    outColor = texture(u_pattern0,pointCoord);
#endif
`;

;// module.exports=
let opacity_defineV=
`
#ifdef opacity
	in float a_opacity;
	out float v_opacity;
#endif
`;;// module.exports=
let opacity_defineF=
`
#ifdef opacity
	in float v_opacity;
#endif
`;;// module.exports=
let opacity_realizeV=
`
#ifdef opacity
	v_opacity = a_opacity;
#endif
`;;// module.exports=
let opacity_realizeF=
`
#ifdef opacity
	outColor = outColor * v_opacity;
#endif
`;;// module.exports=
let colorI_defineV=
`
#ifdef colorI
    in vec4 a_color;
    out vec4 v_color;
#endif
`;;// module.exports=
let colorI_realizeV= `
#ifdef colorI
    v_color = a_color;
#endif
`;;// module.exports=
let colorI_defineF= `
#ifdef colorI
    in vec4 v_color;
#endif
`;;// module.exports=
let colorI_realizeF= `
#ifdef colorI
    outColor = outColor*v_color;
#endif
`;
;// module.exports=
let dynamicText_defineV=
`
#ifdef dynamicText
	in vec4 a_fontColor;
	in vec4 a_haloColor;
	in vec4 a_bgColor;
	in float a_haloWidth;

	out vec4 v_fontColor;
	out vec4 v_haloColor;
	out vec4 v_bgColor;
	out float v_haloWidth;
#endif
`;;// module.exports=
let dynamicText_realizeV=
`
#ifdef dynamicText
	v_fontColor = a_fontColor;
	v_haloColor = a_haloColor;
	v_bgColor = a_bgColor;
	v_haloWidth = a_haloWidth;
#endif
`;;// module.exports=
let dynamicText_defineF=
`
#ifdef dynamicText
	in vec4 v_fontColor;
	in vec4 v_haloColor;
	in vec4 v_bgColor;
	in float v_haloWidth;
#endif
`;;// module.exports=
let dynamicText_realizeF=
`
#ifdef dynamicText
	if(v_haloColor.a==0.0 || v_haloWidth==0.0){//无描边,需着色器来上色
        if(outColor.a==0.0){
            //背景色
            outColor=v_bgColor;
        }else{
            //文字色
            outColor=outColor*v_fontColor;
        }
    }
#endif
`;;// module.exports=
let wideSolid_define=
`
#ifdef wideSolid
	in vec2 a_side;
	in float a_lineWidth;
#endif
`;;// module.exports=
let wideSolid_realize=
`
#ifdef wideSolid
    mat2 rotateMatrix=mat2(u_vMatrix[0][0],u_vMatrix[0][1],u_vMatrix[1][0],u_vMatrix[1][1]);
	vec2 lineWidth = normalize(rotateMatrix*a_side) * a_lineWidth/2.0;
	lineWidth = vec2(lineWidth.x/u_viewport.x,lineWidth.y/u_viewport.y)*2.0*gl_Position.w;
	gl_Position.x = gl_Position.x + lineWidth.x;
	gl_Position.y = gl_Position.y + lineWidth.y;
#endif
`;;// 需组织数据
let dash_defineV=
    `#ifdef dash
    uniform float u_viewLength;//距离单位米
    uniform float u_pixelLength;//一个单元的像素长度
    in float a_perLength;//每个顶点在该条线段总长的占比（0.0-1.0）
    in float a_lineLength;//线段长度（单位米）

    in vec4 a_dash_ratio;//每段单元的【实、虚、实、虚】部分占单元的比例
    out vec4 v_dash_ratio;

    out float v_perLength;
    out float v_dash_array;
#endif`;
;// module.exports=
let dash_realizeV= `
#ifdef dash
    v_perLength=a_perLength;
    //v_dash_array=1.0/((a_lineLength/u_viewLength)*(u_viewport.x/u_pixelLength));
    
    float linePixelLength = a_lineLength/(u_viewLength/u_viewport.x);
    float pixelNum = linePixelLength/u_pixelLength; //线段按像素长度，分成几段
    v_dash_array = 1.0/pixelNum; //假设线段长为1.0,得到每段的长度

    v_dash_ratio = a_dash_ratio;
#endif
`;
;let dash_defineF=
`#ifdef dash
    // uniform float u_dash_ratio;//每段单元的虚线部分占单元的比例
    
    in float v_perLength;

    in float v_dash_array;

    in vec4 v_dash_ratio;
#endif`;
;let dash_realizeF=
`#ifdef dash
    // outColor.a *= ceil(mod(v_perLength, v_dash_array)- (v_dash_array * u_dash_ratio)); //计算每个片元落在每段单元的实线还是虚线 

    float ratio = mod(v_perLength, v_dash_array);
    float part1 = v_dash_array * v_dash_ratio.x;//实
    float part2 = v_dash_array * v_dash_ratio.y;//虚
    float part3 = v_dash_array * v_dash_ratio.z;//实
    float part4 = v_dash_array * v_dash_ratio.w;//虚
    if(ratio<part1){
    	outColor.a *= 1.0;
    }else if(ratio<(part1+part2)){
    	outColor.a *= 0.0;
    }else if(ratio<(part1+part2+part3)){
    	outColor.a *= 1.0;
    }else{
    	outColor.a *= 0.0;
    }
#endif`;

;// module.exports=
let texture2D_defineF=
`
#ifdef texture2D
	uniform sampler2D u_pattern0;
	in vec2 v_textureCoord;
#endif
`;;// module.exports=
let texture2D_realizeF=
`
#ifdef texture2D
	outColor = texture(u_pattern0,v_textureCoord);
#endif
`;;// module.exports=
let texture2D_defineV=
`
#ifdef texture2D
    in vec2 a_textureCoord;
    out vec2 v_textureCoord;
#endif
`;;// module.exports=
let texture2D_realizeV=
`
#ifdef texture2D
	  v_textureCoord=a_textureCoord;
#endif
`;;// module.exports=
let sdftext_realize= `
#ifdef sdftext
	float dist = outColor.r;
    float opcaity = smoothstep(0.6, 0.8, dist);
    alpha =opcaity* outColor.a;
#endif
`;;let coordOffset_define= `
#ifdef coordOffset
    in vec3 a_coordOffset;
    in float a_rotate; //道路线的旋转角度
    uniform float u_mapRotate;
#endif
`;;let coordOffset_realize= `
#ifdef coordOffset
    float reverse=1.0;
    float ag=abs(a_rotate+u_mapRotate);
    if(ag>90.0 && ag<=270.0){
        reverse = -1.0;
    }
    position.x=position.x+(a_coordOffset.x*reverse);
    position.y=position.y+(a_coordOffset.y*reverse);
    position.z=position.z+(a_coordOffset.z*reverse);
#endif
`;;"use strict";
hmap.core = hmap.core || {};
hmap.core.shader = hmap.core.shader||{};

hmap.core.shader.shaderChunk={
	base:{
		symbol:{
			vertexSource:symbol_vert,
			fragmentSource:symbol_frag,
			attributes:[
				["a_position", {count:3,type:Float32Array}],
                ["a_size",     {count:2,type:Float32Array}],
			],
		},
		fill:{
			vertexSource: fill_vert,
			fragmentSource: fill_frag,
			attributes: [
				["a_position", {count: 3, type: Float32Array}],
				// ["index", {count: 1, type: Uint32Array}]
			],
		},
        line:{
            vertexSource: line_vert,
            fragmentSource: line_frag,
            attributes: [
                ["a_position", {count: 3, type: Float32Array}],
                // ["index", {count: 1, type: Uint32Array}],
            ],
        },
	},
	common:{
		// 每个着色器必有的部分
		common:[
	      	["u_opacity",{type:"uniform1f",extra:"opacity"}],
          	["u_pMatrix",{type:"uniformMatrix4fv",extra:"pMatrix"}],
          	["u_vMatrix",{type:"uniformMatrix4fv",extra:"vMatrix"}],
            ["u_viewport",{type:"uniform2fv",extra:"viewport"}],
		],
		// 动态添加图集文字
		dynamicText_defineV:dynamicText_defineV,
		dynamicText_realizeV:dynamicText_realizeV,
		dynamicText_defineF:dynamicText_defineF,
		dynamicText_realizeF:dynamicText_realizeF,
		dynamicText:{
			"uniforms":[],
			"attributes":[
				["a_fontColor",{count:4,type:Float32Array}],
				["a_haloColor",{count:4,type:Float32Array}],
				["a_bgColor",{count:4,type:Float32Array}],
				["a_haloWidth",{count:1,type:Float32Array}],
			],
		},
		// 要素透明度
		opacity_defineV:opacity_defineV,
		opacity_realizeV:opacity_realizeV,
		opacity_defineF:opacity_defineF,
		opacity_realizeF:opacity_realizeF,
		opacity:{
			"uniforms":[],
			"attributes":[
				["a_opacity",{count:1,type:Float32Array}],
			],
		},
		// 点纹理
		sprite_defineV:sprite_defineV,
		sprite_realizeV:sprite_realizeV,
		sprite_defineF:sprite_defineF,
		sprite_realizeF:sprite_realizeF,
		sprite:{
			"uniforms":[
				["u_pattern0",{type:"uniform1i",extra:"sprite"}],
			],
			"attributes":[
				["a_texAttr",  {count:4,type:Float32Array}],
				["a_angle",    {count:1,type:Float32Array}],
			],
		},
		// color
        colorI_defineV:colorI_defineV,
        colorI_realizeV:colorI_realizeV,
        colorI_defineF:colorI_defineF,
        colorI_realizeF:colorI_realizeF,
		colorI:{
            "uniforms":[],
            "attributes":[["a_color",{count:4,type:Float32Array}]]
		},
		// 雾化
		fog_defineF:fog_defineF,
		fog_realizeF:fog_realizeF,
		fog_defineV:fog_defineV,
		fog_realizeV:fog_realizeV,
		fog:{
			"uniforms":[
				["u_fogColor",{type:"uniform4fv",extra:"fog"}],
				["u_fogDist", {type:"uniform2fv",extra:"fog"}],
			],
			"attributes":[]
		},

		// mMatrix
		mMatrix_define:mMatrix_define,
		mMatrix_realize:mMatrix_realize,
		mMatrix:{
			"uniforms":[],
            "attributes":[
                ["u_mMatrix",{type:"uniformMatrix4fv",extra:"mMatrix"}],
			]
		},

		// 偏移
		offset_define:offset_define,
		offset_realize:offset_realize,
		offset:{
			"uniforms":[],
			"attributes":[
				["a_offset",{count:2,type:Float32Array}]
			]
		},
        coordOffset_define:coordOffset_define,
        coordOffset_realize:coordOffset_realize,
		coordOffset:{
            "uniforms":[
                ["u_mapRotate",{type:"uniform1f",extra:"coordOffset"}],
			],
            "attributes":[
                ["a_coordOffset",{count:3,type:Float32Array}],
                ["a_rotate",{count:1,type:Float32Array}],
            ]
		},
        // 虚线
        dash_defineV:dash_defineV,
        dash_realizeV:dash_realizeV,
        dash_defineF:dash_defineF,
        dash_realizeF:dash_realizeF,
        dash:{
            "uniforms":[
                ["u_viewLength",{type:"uniform1f",extra:"dash"}],
                ["u_pixelLength",{type:"uniform1f",extra:"dash"}],
			],
            "attributes":[
                ["a_lineLength",{count:1,type:Float32Array}],
                ["a_perLength",{count:1,type:Float32Array}],
                ["a_dash_ratio",{count:4,type:Float32Array}],
            ]
        },

		// precision 精度糾正 经纬度
        precisionCorrect_define:precisionCorrect_define,
        precisionCorrect_realize:precisionCorrect_realize,
        precisionCorrect:{
			"uniforms":[
				["u_eyeH",{type:"uniform3fv",extra:"precision"}],
				["u_eyeL",{type:"uniform3fv",extra:"precision"}],
			],
			"attributes":[["a_positionL",{count:3,type:Float32Array}]]
		},
        // precision 精度糾正 米
        precisionCorrectProject_define:precisionCorrectProject_define,
        precisionCorrectProject_realize:precisionCorrectProject_realize,
        precisionCorrectProject:{
            "uniforms":[
                ["u_eyeH",{type:"uniform3fv",extra:"precision"}],
                ["u_eyeL",{type:"uniform3fv",extra:"precision"}],
            ],
            "attributes":[["a_positionL",{count:3,type:Float32Array}]]
        },
		// 宽实线
		wideSolid_define:wideSolid_define,
		wideSolid_realize:wideSolid_realize,
		wideSolid:{
			"uniforms":[],
			"attributes":[
				["a_side",{count:2,type:Float32Array}],
				["a_lineWidth",{count:1,type:Float32Array}],
			],
		},
		// 矩形纹理
		texture2D_defineV:texture2D_defineV,
		texture2D_realizeV:texture2D_realizeV,
		texture2D_defineF:texture2D_defineF,
		texture2D_realizeF:texture2D_realizeF,
		texture2D:{
			"uniforms":[
				["u_pattern0",{type:"uniform1i",extra:"texture2D"}],
			],
			"attributes":[
				["a_textureCoord",{count:2,type:Float32Array}]
			]
		},
		sdftext_realize:sdftext_realize,
		sdftext:{
            "uniforms":[
            ],
            "attributes":[
            ]
		}



	}
};
// module.exports={
// 	base:{
// 		symbol:{
// 			vertexSource:require('./base/symbol_vert.js'),
// 			fragmentSource:require('./base/symbol_frag.js'),
// 		},
// 	},
// 	common:{
// 		// fog
// 		fog_frag_define:require('./common/fog_frag_define.js'),
// 		fog_frag_realize:require('./common/fog_frag_realize.js'),

// 		// mMatrix
// 		mMatrix_vert_define:require('./common/mMatrix_vert_define.js'),
// 		mMatrix_vert_realize:require('./common/mMatrix_vert_realize.js'),

// 		// offset
// 		offset_vert_define:require('./common/offset_vert_define.js'),
// 		offset_vert_realize:require('./common/offset_vert_realize.js'),

// 		// opacity
// 		opacity_frag_define:require('./common/opacity_frag_define.js'),
// 		opacity_frag_realize:require('./common/opacity_frag_realize.js'),

// 		// pMatrix
// 		pMatrix_vert_define:require('./common/pMatrix_vert_define.js'),
// 		pMatrix_vert_realize:require('./common/pMatrix_vert_realize.js'),

// 		// texture2D
// 		texture2D_frag_define:require('./common/texture2D_frag_define.js'),
// 		texture2D_frag_realize:require('./common/texture2D_frag_realize.js'),

// 		// vMatrix
// 		vMatrix_vert_define:require('./common/vMatrix_vert_define.js'),
// 		vMatrix_vert_realize:require('./common/vMatrix_vert_realize.js'),
// 	},
// };;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter||{};

hmap.core.painter.Layout = class {
    constructor(gl){
        this._gl = gl;
        this.CLASS_NAME = "hmap.core.painter.Layout";
    }

    addAttribute(attributes){
        this.attributes = new Map(attributes);
    }

    addUniform(uniforms){
        this.uniforms = new Map(uniforms);
    }

    /**
     * 创建VBO
     */
    _createVBO(){
        const gl = this._gl;
        const vbos={};
        for(let [attrName,value] of this.attributes){
            vbos[attrName]=gl.createBuffer();
            if(attrName == "index"){
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,vbos[attrName]);
                continue;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, vbos[attrName]);
            gl.vertexAttribPointer(value["location"], value["count"], gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(value["location"]);
        }
        return vbos;
    }

    /**
     * 创建VAO——需要池化的时候使用
     */
    createVAO(){
        //创建顶点数组对象
        const gl = this._gl;
        const vao=gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbos=this._createVBO();
        gl.bindVertexArray(null);
        return {'vao':vao,'vbos':vbos};
    }

    deleteVBO(vbos){
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        for(let attrName in vbos){
          gl.deleteBuffer(vbos[attrName]);
          vbos[attrName]=null;
        }
        vbos=null;

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, 0, gl.STATIC_DRAW);
        gl.bufferData(gl.ARRAY_BUFFER, 0, gl.STATIC_DRAW);
        return this;
    }

    deleteVAO(vao){
        const gl = this._gl;
        gl.bindVertexArray(null);
        gl.deleteVertexArray(vao);
    }
}
// module.exports=Layout;



;// const shaderChunk = require('../shader/Index.js');
const shaderChunk = hmap.core.shader.shaderChunk;

"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter||{};
/**
 * 绘制时使用的程序
 * @type {Program}
 * @private
 * @param gl {Object} WebGL的上下文
 * @param type {String} 基础着色器类型，即index.js文件中base部分的key值。eg:"symbol".
 * @param extra {JSON}  公共着色器类型，extra的key值为:./shader/common包下的每个文件的宏名;extra的value值为:宏的值，默认为0，用于功能种类的拓展。eg:{"fog":1,"opacity":0}
 */
// class Program{
hmap.core.painter.Program = class {
    constructor(gl, type, extra) {
        this._gl = gl;
        this.uniforms = this.copyUniform(shaderChunk.common["common"]);
        this.attributes = [];
        this._shaderSource = this._buildShader(type, extra);
        this.CLASS_NAME = "hmap.core.painter.Program";
        this.id = (this._shaderSource.vertexSource + this._shaderSource.fragmentSource).replace(/[ ]/g, "").replace(/[\r\n]/g, "");
    }

    build() {
        this._program = this._compileProgram();
        this.layout = new hmap.core.painter.Layout(this._gl);
        this.layout.addAttribute(this.attributes);
        this.layout.addUniform(this.uniforms);
        this._getAttributeLocations();
        this._getUniformLocations();
        this.drawWay = {
            "drawElements": this.drawElements,
            "drawArrays": this.drawArrays
        };
    }

    copyUniform(uniform) {
        let u = [];
        for (let i = 0, len = uniform.length; i < len; i++) {
            u[u.length] = [uniform[i][0], {"type": uniform[i][1].type, "extra": uniform[i][1].extra}];
        }
        return u;
    }

    copyAttribute(attribute) {
        let a = [];
        for (let i = 0, len = attribute.length; i < len; i++) {
            a[a.length] = [attribute[i][0], {"count": attribute[i][1].count, "type": attribute[i][1].type}];
        }
        return a;
    }


    /**
     * 着色器程序的拼接
     * @private
     * @param type {String} 基础着色器类型
     * @param extra {JSON} 公共着色器类型
     * @return {JSON} 着色器程序的JSON组合
     */
    _buildShader(type, extra) {
        // 版本
        let version = `#version 300 es\n`;
        // 基础着色器
        let baseSource = shaderChunk.base[type];
        this.attributes = this.attributes.concat(baseSource.attributes);
        // 公共着色器
        let prefix = ``;
        for (let defineName in extra) {
            prefix += (`#define ` + defineName + ` ` + extra[defineName]).trim() + `\n`;
            this.uniforms = this.uniforms.concat(this.copyUniform(shaderChunk.common[defineName]["uniforms"]));
            this.attributes = this.attributes.concat(this.copyAttribute(shaderChunk.common[defineName]["attributes"]));
        }
        // console.log("vertexSource", this._parseIncludes(version+prefix+baseSource.vertexSource));
        return {
            "vertexSource": this._parseIncludes(version + prefix + baseSource.vertexSource),
            "fragmentSource": this._parseIncludes(version + prefix + baseSource.fragmentSource)
        };

    }

    /**
     * 替换着色器程序的片段
     * @private
     * @param string {String} 着色器程序
     * @return {String} 替换片段后的着色器程序
     */
    _parseIncludes(string) {
        let pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
        let replaceItem = new Set();
        let replaceFn = function (match, include) {
            if (replaceItem.has(include)) {
                return ""
            } else {
                replaceItem.add(include)
                return shaderChunk.common[include];
            }
        };
        return string.replace(pattern, replaceFn);
    }

    /**
     * 创建着色器对象
     * @private
     * @param shaderType {String} 着色器类型
     * @param shaderSource {String} 着色器程序
     * @return {Object} 着色器对象
     */
    _compileShader(shaderType, shaderSource) {
        let gl = this._gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }

    /**
     * 创建Program对象
     * @private
     * @return {Object} Program对象
     */
    _compileProgram() {
        let gl = this._gl;
        let program = gl.createProgram();
        let vertexShader = this._compileShader(gl.VERTEX_SHADER, this._shaderSource.vertexSource);
        let fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, this._shaderSource.fragmentSource);
        if (!vertexShader || !fragmentShader) {
            return null;
        }

        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);

        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);

        return program;
    }

    _getAttributeLocations() {
        for (let [name, value] of this.layout.attributes) {
            value["location"] = this._gl.getAttribLocation(this._program, name);
        }
        return this;
    }

    _getUniformLocations() {
        for (let [name, value] of this.layout.uniforms) {
            value["location"] = this._gl.getUniformLocation(this._program, name);
        }
        return this;
    }

    /**
     * 使用Program对象
     * @return {Object} 返回该类的实例化对象本身.
     */
    active() {
        this._gl.useProgram(this._program);
        return this;
    }

    setUniforms(uniformsValue) {
        for (let [name, value] of this.layout.uniforms) {
            if (value.type == "uniformMatrix4fv"){
                this._gl[value.type](value.location, false, uniformsValue[name]);
            }else{
                this._gl[value.type](value.location, uniformsValue[name]);
            }
        }
        return this;
    }


    draw(blocks) {//vao,type,mode,count
        for (let i = 0, len = blocks.length; i < len; i++) {
            const block = blocks[i];
            this.drawSingle(block);
        }
        return this;
    }
    drawSingle(block){
        if (!block.buffer) {
            return;
        }
        const vao = block.buffer.vao;
        this._gl.bindVertexArray(vao);
        const type = block.drawType;
        this.drawWay[type](block, this._gl);
        this._gl.bindVertexArray(null);
    }

    // drawTexture(blocks, glHepler) {
    //     for (let i = 0, len = blocks.length; i < len; i++) {
    //         const block = blocks[i];
    //         if (!block.buffer) {
    //             continue;
    //         }
    //         const vao = block.buffer.vao,
    //             type = block.drawType,
    //             mode = block.renderData.get("mode");
    //         this._gl.bindVertexArray(vao);
    //         let offset = 0;
    //         for(let t=0,len = block.textures.length;t<len;t++) {
    //             const texture= glHepler.getTextureObject(block.textures[t]);
    //             const count = texture["indexCount"];
    //             this._gl[type](mode, count, this._gl.UNSIGNED_INT, offset * 4);
    //             offset += count;
    //         }
    //         this._gl.bindVertexArray(null);
    //     }
    // }

    drawElements(block,gl){
        let offset = 0;
        let count = 0;
        const modes = block.renderData.get('mode');
        const drawCounts = block.renderData.get('drawCount');
        for (let i = 0, l = modes.length; i < l; i++) {
            count = drawCounts[i];
            gl[block.drawType](modes[i], count, gl.UNSIGNED_INT,offset*4);
            offset += count;
        }
    }

    drawArrays(block,gl){
        let offset = 0;
        let count = 0;
        const modes = block.renderData.get('mode');
        const drawCounts = block.renderData.get('drawCount');
        for (let i = 0, l = modes.length; i < l; i++) {
            count = drawCounts[i];
            gl[block.drawType](modes[i], offset, count);
            offset += count;
        }
    }


  /**
   * 销毁Program对象
   * @return {Object} 返回该类的实例化对象本身.
   */
  destroy(){
    this._gl.deleteProgram(this._program);
    return this;
  }
}
hmap.core.painter.Program.SYMBOL="symbol";
// module.exports=Program;
// let a=new Program(gl,'Symbol',"");
// const wm = new WeakMap();
// let key = {};
// let obj = null;
// wm.set(key,obj);
// obj = {foo : 1};
// console.log(typeof Program);
;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * 图层父类，不可实例化
 * @private
 */
hmap.core.painter.Painter = class {

    constructor(layer, type, extra, blockSize, drawType) {
        this._blocks = new Map();
        this._blockHelper = (layer.CLASS_NAME === "hmap.layer.VectorTileLayer" || layer.CLASS_NAME === "hmap.layer.TMSLayer"
            || layer.CLASS_NAME === "hmap.layer.TMSLayer"|| layer.CLASS_NAME === "hmap.layer.WMSLayer") ?
            new hmap.help.VTileBlockHelper(this.blocks) : new hmap.help.SequeBlockHelper(this.blocks, blockSize);
        this._gl = layer.gl;
        this._owner = layer;
        this._opacity = layer._opacity;
        this._visibility=true;
        this._drawType = drawType;
        this._type = type;
        this._extra = extra;
        this._program = this.createProgram(type, extra);
        this._taskManager = hmap.core.TaskManager.instance();
        this._parserOpt = {drawType: drawType, bPrecisionCorrect: layer._isRTE};
        this.add = layer.layerOctree?this._addAndOctree:this._add;
        this.remove = layer.layerOctree?this._removeAndOctree:this._remove;
        this.removeAll = layer.layerOctree?this._removeAllAndOctree:this._removeAll;
    }
    get id(){
        return this._id;
    }

    createProgram(type, extra) {
        let program = new hmap.core.painter.Program(this.gl, type, extra);
        const id = program.id;
        if (!hmap.help.glHelper.get(this.gl).hasProgram(id)) {
            program.build();
            hmap.help.glHelper.get(this.gl).addProgram(program);
        } else {
            program = null;
        }
        return hmap.help.glHelper.get(this.gl).getProgram(id);
    }

    get drawType() {
        return this._drawType;
    }

    get blocks() {
        return this._blocks;
    }

    get blockHelper() {
        return this._blockHelper;
    }

    get taskManager() {
        return this._taskManager;
    }

    get parser() {
        return this._parser;
    }

    get gl() {
        return this._gl;
    }

    get owner() {
        return this._owner;
    }

    get type() {
        return this._type;
    }

    get extra() {
        return this._extra;
    }

    set visibility(visible) {
        this._visibility = visible;
        return this;
    }

    get visibility() {
        return this._visibility;
    }


    set name(name) {
        this._name = name;
    }


    get opacity() {
        return this._opacity;
    }

    set opacity(opacity) {
        this._opacity = opacity;
    }

    get program() {
        return this._program;
    }


    /**
     * 添加要素
     * @param feature
     * @return {Vector}
     */
    _add(feature) {
        const block = this.blockHelper.get(feature);
        block.add(feature);
        this.addTask(block);
        this.owner._map.af.active();
        return this;
    }
    /**
     * 删除要素,返回删除的要素
     * @param feature
     * @return
     */
    _remove(feature) {
        if(!feature.bid){
            return null;
        }
        const block = this._blocks.get(feature.bid);
        block.delete(feature);
        if(block.features.length > 0){
            this.addTask(block);
        }else{
            this.removeBlock(block);
        }
        this.owner._map.af.active();
        return feature;
    }
    /**
     * 更新要素，返回更新后的要素
     * @param {Object}feature
     * @return {Object}
     */
    update(feature) {
        //todo 这里缺少考虑，空间分块时，几何更新导致的block不同的情况
        if(!feature.bid){
            return null;
        }
        const block = this._blocks.get(feature.bid);
        block.update(feature);

        // if (block.id === feature.bid) {
        //     block.update(feature);
        // } else {
        //     this._blocks.get(feature.bid).delete(feature);
        //     block.add(feature);
        // }

        this.addTask(block);
        this.owner._map.event.dispatch(new hmap.event.MapEvent(EventType.LAYEREVENT_DATACHANGE));
        return feature;
    }

    _addAndOctree(feature){
        this._add(feature);
        this.taskManager.addHeavy(this, function (feature) {
            if(feature.buffer){
                this.owner.layerOctree.put(feature);
            }
        }, feature);
    }
    /**
     * 删除所有要素
     * @return {Vector}
     */
    _removeAndOctree(feature){
        this._remove(feature);
        this.taskManager.addHeavy(this, function (f) {
            this.owner.layerOctree.remove(f);
        }, feature);
        return feature;
    }

    _removeAllAndOctree() {
       this._removeAll();
       this.owner.layerOctree.clear();
       return this;
    }
    removeBlock(block){
        const id=block.id;
        if (block.buffer) {
            this.program.layout.deleteVAO(block.buffer.vao);
        }
        else {
            block.doTask = 0;
            this.taskManager._simpleTaskFag.delete(this.id + block.id);
        }
        block.clear();
        this.blocks.delete(id);
        if(this.blockHelper._curBlock && block.id===this.blockHelper._curBlock.id)
            this.blockHelper._curBlock=null;
        block=null;
    }
    removeBlockById(id){
        this.removeBlock(this.blocks.get(id));
    }

    getBlockById(id){
        return this.blocks.get(id);
    }
    /**
     * 删除所有要素
     * @return {Vector}
     */
    _removeAll() {
        this._blocks.forEach((value,key) => {
            this.removeBlock(value);
        });
        this.owner._map.af.active();
        return this;
    }

    /**
     * 获取所有要素
     * @return {Array}
     */
    getAll() {
        const all = [];
        this._blocks.forEach((value,key) => {
            all.push.apply(all, value.features);
        });
        return all
    }

    getById(id) {
        for (let block of this._blocks.values()) {
            const len = block.features.length;
            for (let i = len - 1; i >= 0; i--) {
                if (block.features[i]._id === id) {
                   return block.features[i];
                }
            }
        }
        return null;
    }

    getByAttribute(attrName, attrValue) {
        let result = [];
        for (let block of this._blocks.values()) {
            const len = block.features.length;
            for (let i = len - 1; i >= 0; i--) {
                const attribute = block.features[i]._attributes;
                if (attribute&&attribute.hasOwnProperty(attrName) && attribute[attrName] === attrValue) {
                    result[result.length] = block.features[i];
                }
            }
        }
        return result;
    }

    /**
     * 根据范围获取Block
     * @param {hmap.basetype.Extent || Array} filterObject
     * @return {Array} Block数组
     * @private
     */
    _filterBlocks(filterObject) {
        return this.blockHelper.filterBlocks(filterObject);
    }

    /**
     * 添加任务
     * 子类不需要实现，但是需要实现runTask方法，参照SymbolPainter
     * @param block
     * @returns {hmap.core.painter.Painter}
     */
    addTask(block) {
        this.taskManager.addSimple(this, this.runTask, block);
        return this;
    }

    runTask(block) {
        this.parser.handleBlock(block);
    }

    /**
     * block中所有feature的绘制数据全部追加到block的绘制数据后，把绘制数据写入显存，并更新block的相关状态
     * @param block
     * @private
     */
    bufferToGPU(block) {
        let vaoInfo = block.buffer ? block.buffer : this.program.layout.createVAO();
        this._setVbosData(vaoInfo.vbos, block.renderData);
        block.buffer = vaoInfo;
        block.drawType = this._drawType;
        const attributes = this.program.layout.attributes;
        for (let key of attributes.keys()) {
            block.renderData.get(key).length = 0;
        }
    }

    /**
     * 向WebGlBuffer中写入数据
     * @param {Object} vbos 属性值为WebGlBuffer对象
     * @param {Object} data 属性名与vbos一一对应，属性值是Array类型
     * @param {Boolean} dynamic 是否是动态写入
     */
    _setVbosData(vbos, data, dynamic = false) {
        let type;
        for (let vboName in vbos) {
            type = this.program.layout.attributes.get(vboName).type;
            this._setVBO(vboName, vbos[vboName], new type(data.get(vboName)), dynamic);
        }
    }

    /**
     *
     * @param {String} bufferName 缓冲区名称，如果是index，向ELEMENTS_ARRAY_BUFFER中写数据，其他值时向ARRAY_BUFFER中写数据
     * @param {WebGLBuffer} vbo WebglBuffer对象
     * @param {Array} data 存储数据的数组
     * @param {Boolean} dynamic 是否是动态写入
     * @private
     */
    _setVBO(bufferName, vbo, data, dynamic) {
        if (bufferName === 'index') {
            this._addEleBuffer(vbo, data, dynamic);
        } else {
            this._addVerBuffer(vbo, data, dynamic);
        }
    }

    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    _addEleBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }
};
//追加类型
hmap.core.painter.SYMBOL = "symbol";

/**
 *  painter类型划分
 * @type {{LINE_WIDE_DASH: string, POLYGON: string, POLYGON_TEXTURE: string, POLYGON_BORDER: string, LINE: string, LINE_DASH: string, LINE_WIDTH: string, POINT: string}}
 */
hmap.core.painterType = {
    NONE: "none",                       //初始化用
    POINT: "Point",                     //点
    TEXT: "Text",
    // SDFPOINTTEXT:"SDFPointText",      //sdf 点文字(点精灵)
    // SDFLINETEXT:"SDFLineText",        //sdef 线文字 (矩形纹理)
    SPRITEPOINT:"SpritePoint",        //雪碧图点
    LINE: "Line",                       //细实线
    LINE_DASH: "LineDash",              //细虚线
    LINE_WIDTH: "LineWidth",            //宽实线
    LINE_WIDTH_DASH: "LineWidthDash",   //宽虚线
    POLYGON: "Polygon",                 //普通面（或带细边框）
    POLYGON_BORDER: "PolygonBorder",    //宽边框面
    POLYGON_TEXTURE: "PolygonTexture",  //纹理面
    STRETCH: "Stretch",                 //白模
}
;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};

/**
 * 动态加载纹理数据的画点的painter
 * @type {hmap.core.painter.SymbolDynamicPainter}
 */
hmap.core.painter.SymbolDynamicPainter = class extends hmap.core.painter.Painter {
    /**
     * @param layer 图层
     * @param extra
     * @param options.blockSize 块大小，缺省值2000
     * @param options.drawType 绘制方式，drawElements|drawArrays 缺省值 drawElements
     * @param options.atlasManger 图集管理对象，传入该值则公用外部图集管理对象，不传这内部创建，缺省值为内部创建
     * @returns {hmap.core.painter.SymbolDynamicPainter}
     */
    constructor(layer,extra, options={}) {
        const blockSize= options.blockSize || 2000;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type=hmap.core.painter.SYMBOL;
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.SymbolDynamicPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._atlasManager = options.atlasManager;
        
        this.glHelper = hmap.help.glHelper.get(this.gl);
        this.glHelper.getTextureObject(this._atlasManager._id).bufferImage(this._atlasManager.getAtlasImageData());

        this._parserOpt.atlas=this._atlasManager;
        this._parser = new hmap.core.parser.SymbolDynamicParser(this,this._parserOpt);
    }

    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        if(!blocks ||blocks.length<1)return;


        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this._opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        if (this._atlasManager._atlas.hasChange) {
            this.glHelper.getTextureObject(this._atlasManager._id).bufferImage(this._atlasManager.getAtlasImageData(),true);
            this.program.draw(blocks);
        }else{
            this.glHelper.getTextureObject(this._atlasManager._id).bindTexture();
            this.program.draw(blocks);
        }
        
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};

/**
 *
 * @type {hmap.core.painter.SymbolPainter}
 */
hmap.core.painter.SymbolStaticPainter = class extends hmap.core.painter.Painter {
    /**
     * @param layer 图层
     * @param extra
     * @param options.blockSize 块大小，缺省值2000
     * @param options.drawType 绘制方式，drawElements|drawArrays 缺省值 drawElements
     * @param options.atlasManger 图集管理对象，传入该值则公用外部图集管理对象，不传这内部创建，缺省值为内部创建
     * @returns {hmap.core.painter.SymbolPainter}
     */
    constructor(layer,extra, options={}, pType='') {
        const blockSize= options.blockSize || 2000;
        const drawType=options.drawType||"drawElements";
        const type=hmap.core.painter.SYMBOL;
        super(layer,type,extra,blockSize,drawType);
        this.CLASS_NAME = "hmap.core.painter.SymbolStaticPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._parser = new hmap.core.parser.SymbolStaticParser(this, this._parserOpt);
        this._tempFeatures = [];
        if (!this.owner.sprite.load) {
            this.owner.sprite.request.then(() => {
                this._redirectMethod();
                for (let i = 0, l = this._tempFeatures.length; i < l; i++) {
                    this._add(this._tempFeatures[i]);
                }
                this._tempFeatures.length = 0;
            })
        }
        else {
            this._redirectMethod();
        }
    }

    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        if(!blocks ||blocks.length<1)
            return;
        hmap.help.glHelper.get(this.gl).getTextureObject(this.owner.sprite.url).bindTexture();
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this._opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }

    /**
     * 添加要素
     * @param feature
     * @return {Vector}
     */
    _add(feature) {
        this._tempFeatures.push(feature);
    }

    /**
     * 删除要素
     * @param feature
     * @private
     */
    _remove(feature) {
        const index = this._tempFeatures.indexOf(feature);
        if (index > -1) {
            this._tempFeatures.splice(index, 1);
        }
    }

    /**
     * 删除全部要素
     * @private
     */
    _removeAll() {
        this._tempFeatures.length = 0;
    }

    _redirectMethod() {
        this._add = super._add;
        this._remove = super._remove;
        this._removeAll = super._removeAll;
        this.add = this.owner.layerOctree ? this._addAndOctree : this._add;
        this.remove = this.owner.layerOctree ? this._removeAndOctree : this._remove;
        this.removeAll = this.owner.layerOctree ? this._removeAllAndOctree : this._removeAll;
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.FillPainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra,options={}) {
        const blockSize= options.blockSize || 500;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type='fill';
        super(layer,type,extra,blockSize,drawType, blockHelperType);

        this.CLASS_NAME = "hmap.core.painter.FillPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        // TODO 先写死painter类型，后续修改
        this._parser = new hmap.core.parser.FillColorParser(this,this._parserOpt);
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        this.program.active().setUniforms({
            // u_opacity: this.opacity,
            u_opacity: this.opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [map.container.clientWidth*1.0,map.container.clientHeight*1.0],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.FillBorderPainter = class extends hmap.core.painter.Painter {
    constructor(layer, extra = {}, options = {}) {
        const blockSize = options.blockSize || 500;
        const drawType = options.drawType || "drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type = 'fill';
        super(layer, type, extra, blockSize, drawType, blockHelperType);

        this.CLASS_NAME = "hmap.core.painter.FillBorderPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); 
        this._parser = new hmap.core.parser.FillBorderParser(this,this._parserOpt);
    }

    /**
     * 绘制
     */
    draw(filterObject) {
        const map = this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));this.program.active().setUniforms({
            // u_opacity: this.opacity,
            u_opacity: this.opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [map.container.clientWidth*1.0,map.container.clientHeight*1.0],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.FillTexturePainter = class extends hmap.core.painter.Painter {
    constructor(layer, extra = {}, options = {}) {
        const blockSize = options.blockSize || 1;
        const drawType = options.drawType || "drawElements";
        const type = 'fill';
        super(layer, type, extra, blockSize, drawType);
        this.CLASS_NAME = "hmap.core.painter.FillTexturePainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        // TODO 先写死painter类型，后续修改
        this._parser = (layer instanceof hmap.layer.TMSLayer ||  hmap.layer.WMSLayer2) ?
            new hmap.core.parser.TmsParser(this, this._parserOpt) : new hmap.core.parser.FillTextureParser(this, this._parserOpt);
        this.glHelper = hmap.help.glHelper.get(this._gl);
    }

    /**
     * 绘制
     */
    draw(filterObject) {
        if (this.glHelper.textureObjects.size < 1) return;
        // let values= this.textureObjects.values();
        // this._gl.bindTexture(this._gl.TEXTURE_2D, values.next().value.texture);
        const map = this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        const XS = hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS = hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS = hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this.opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0], YS[0], ZS[0]],
            u_eyeL: [XS[1], YS[1], ZS[1]],
            u_pattern0: 0,//当前默认0号纹理单位
        });
        // this.program.drawTexture(blocks, this.glHelper);
        for (let i = 0, len = blocks.length; i < len; i++) {
            const block = blocks[i];
            if (!block.buffer) continue;
            this.glHelper.getTextureObject(block.textures[0]).bindTexture();
            this.program.drawSingle(block);
        }
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.LinePainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra={},options={}) {
        const blockSize= options.blockSize || 500;
        const drawType=options.drawType || "drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type="line";
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.LinePainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._parser = extra.hasOwnProperty("wideSolid")?new hmap.core.parser.WideLineParser(this,this._parserOpt):new hmap.core.parser.LineParser(this,this._parserOpt);
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        this.program.active().setUniforms({
            u_opacity: this.opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [map.getContainerHSpan(),map.getContainerVSpan()],
            u_viewLength: map.getExtentHSpan(),
            u_pixelLength: this.owner.pixelLength,
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
        });
        this.program.draw(blocks);
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.StretchPainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra,options={}) {
        const blockSize= options.blockSize || 100;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type='fill';
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.StretchPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        // TODO 先写死painter类型，后续修改
        this._parser = new hmap.core.parser.StretchParser(this,this._parserOpt);
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        this.program.active().setUniforms({
            // u_opacity: this.opacity,
            u_opacity: this.opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [map.container.clientWidth*1.0,map.container.clientHeight*1.0],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }
}


;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.SDFPointTextPainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra, options={}){
        const blockSize= options.blockSize || 2000;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type=options.painterType?options.painterType:hmap.core.painter.SYMBOL;
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.SDFPointTextPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this.textAtlas=options.textAtlas;
        this._parser = new hmap.core.parser.SDFPointTextParser(this, this._parserOpt);
        this.glHelper = hmap.help.glHelper.get(this._gl);
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        if(!blocks ||blocks.length<1)
            return;
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this._opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        // console.log(this.owner.textTexture);
        hmap.help.glHelper.get(this.gl).getTextureObject(this.owner.textTexture).bindTexture();
        this.program.draw(blocks);
    }
};"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.SDFLineTextPainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra, options={}){
        const blockSize= options.blockSize || 2000;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type=options.painterType?options.painterType:hmap.core.painter.SYMBOL;
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.SDFLineTextPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this.textAtlas=options.textAtlas;
        this._parser = new hmap.core.parser.SDFLineTextParser(this, this._parserOpt);
        this.glHelper = hmap.help.glHelper.get(this._gl);
    }

    /**
     * 是否超出最大角限制，（避让用到）
     */
    verifyLimitAngle(){
        const map=this.owner._map;
        return map.getCamera()._rotateX<this.owner.roadLabelLimiteAngle
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        if(this.verifyLimitAngle())
            return;
        const blocks = this._filterBlocks(filterObject);
        if(!blocks ||blocks.length<1)
            return;
        //hmap.help.glHelper.get(this.gl).getTextureObject(this.owner.textTexture,{min_filter:"NEAREST"}).bindTexture();
        hmap.help.glHelper.get(this.gl).getTextureObject(this.owner.textTexture).bindTexture();
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this._opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_mapRotate:map._camera.getRotateZ()%360,
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }
};"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * FillPainter
 * @param {hmap.layer.Layer} layer 图层名称，保持唯一
 * @param {JSON} paint.extra  公共着色器配置，extra的key值为:index.js文件中common部分引入的每个文件中的宏定义名;extra的value值为:种类。eg:{"fog":1,"opacity":''}
 * @param {JSON} options 图层属性
 * @example
 * const extra = {type:"colorFill",extra:{}}
 * const options = {zIndex:1}
 * const vector = new Vector("pointLayer",extra,options)
 */
hmap.core.painter.SDFIconPainter = class extends hmap.core.painter.Painter {
    constructor(layer,extra, options={}){
        const blockSize= options.blockSize || 2000;
        const drawType=options.drawType||"drawElements";
        const blockHelperType = options.blockHelperType || '';
        const type=options.painterType?options.painterType:hmap.core.painter.SYMBOL;
        super(layer,type,extra,blockSize,drawType, blockHelperType);
        this.CLASS_NAME = "hmap.core.painter.SDFIconPainter";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this.textAtlas=options.textAtlas;
        this._parser = new hmap.core.parser.SDFIconParser(this, this._parserOpt);
        this.glHelper = hmap.help.glHelper.get(this._gl);
    }
    /**
     * 绘制
     */
    draw(filterObject) {
        const map=this.owner._map;
        const blocks = this._filterBlocks(filterObject);
        if(!blocks ||blocks.length<1)
            return;
        hmap.help.glHelper.get(this.gl).getTextureObject(this.owner.iconTexture).bindTexture();
        const XS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("X"));
        const YS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Y"));
        const ZS=hmap.core.precision.divide(map.getCamera().getCoordinate().getOrdinate("Z"));
        const viewport = map.getViewport();
        this.program.active().setUniforms({
            u_opacity: this._opacity,
            u_pMatrix: map.getProjMatrix().getElements(),
            u_vMatrix: map.getViewMatrix().getElements(),
            u_viewport: [viewport[2], viewport[3]],
            u_fogColor: map.getFogColor(),
            u_fogDist: map.getFogDist(),
            u_eyeH: [XS[0],YS[0],ZS[0]],
            u_eyeL: [XS[1],YS[1],ZS[1]],
            u_pattern0: 0
        });
        this.program.draw(blocks);
    }
};"use strict";
hmap.core=hmap.core||{};
hmap.core.parser = hmap.core.parser || {};
/**
 * Painter基类
 * @private
 */
hmap.core.parser.Parser = class{
    /**
     * 构造函数
     * @param painter
     * @param options
     */
    constructor(painter,options){
        this._drawType =options.drawType || "drawArrays";
        this._bPrecisionCorrect= options.bPrecisionCorrect || false;
        this._owner = painter;
        this._appendBlockData = this._drawType==="drawElements" ? this._appendDataWithIndex : this._appendDataWithoutIndex;
        if(this._drawType==="drawElements"){
            this._owner.program.layout.attributes.set("index",{count: 1, type: Uint32Array});
        }
    }

    get owner(){
        return this._owner;
    }
    get dataMap(){
        let dataMap=new Map();
        const attributes = this._owner.program.layout.attributes;
        for (let key of attributes.keys()) {
            dataMap.set(key, []);
        }
        return dataMap;
    }

    /**
     * 合并block中features每一个feature的绘制数据
     * 子类runTask执行完，block的每个feature均组织好数据后，调用该方法，组织block的数据
     * @param block
     * @private
     */
    _dealBlockData(block) {
        this._initRenderData(block);
        const features = block.features;
        for (let i = 0, l = features.length; i < l; i++) {
            if((features[i].hasOwnProperty("_visible")&&!features[i]._visible)||!features[i].buffer) continue;
            this._precisionCorrect(features[i].buffer);
            this._appendBlockData(block, features[i].buffer);
        }
        this._owner.bufferToGPU(block);//将数据刷新的GPU里

        const layer = this.owner.owner;
        if (layer instanceof hmap.layer.VectorTileLayer && !layer.enableHashCode) {
            block.features.length = 0;
        }
    }

    /**
     * 精度拆分
     * @param buffer
     * @private
     */
    //todo:如果后续有其他需要额外对feature处理的操作，可以放到该函数中
    _precisionCorrect(buffer) {
        if (this._bPrecisionCorrect && buffer.has('a_positionL') && buffer.get('a_positionL').length < 1) {
            const result = hmap.core.precision.multiDivide(buffer.get('a_position'));
            buffer.set('a_position',result[0]);
            buffer.set('a_positionL',result[1]);
        }
    }

    /**
     * 初始化保存block绘制数据的对象的结构
     * @param block
     * @private
     */
    _initRenderData(block) {
        if (block.renderData.size<1) {
            const attributes = this._owner.program.layout.attributes;
            for (let key of attributes.keys()) {
                block.renderData.set(key, []);
            }
        }
        block.renderData.set('mode', []);
        block.renderData.set('drawCount', []);
        block.pointCount = 0;
    }

    /**
     * 绘制数据包含index信息时，调用该方法
     * 对新追加的index值，需要重新计算index，并且追加后需要复原原始数据中的index值
     * @param block
     * @param data
     * @private
     */
    _appendDataWithIndex(block, data) {
        //console.time("merge1")
        this._appendDataIndex(block.renderData, data, block.pointCount);
        //console.timeEnd("merge1")
        this._checkLastMode(block);

        data.set('index', data.get('index'));

        block.pointCount += data.get('a_position').length / 3;
    }

    /**
     * 绘制数据不包括index信息
     * @param block
     * @param data
     * @private
     */
    _appendDataWithoutIndex(block, data) {
        this._appendData(block.renderData, data);
        this._checkLastMode(block);

        block.pointCount += data.get('a_position').length / 3;
    }

    /**
     * 追加数据到目标对象对应属性值
     * @param desMap
     * @param srcMap
     * @private
     */
    _appendData(desMap, srcMap) {
        for (let [key, value] of desMap) {
            const v=srcMap.get(key);
            value.push(...v);
        }
        srcMap=null;
    }

    _appendDataIndex(desMap, srcMap, pointCount=0) {
        const srcIndex = srcMap.get('index'),
            index = [...srcIndex];
        for (let i = srcIndex.length - 1; i > -1; i--) {
            srcIndex[i] += pointCount;
        }
        this._appendData(desMap, srcMap);

        srcMap.set('index', index);
    }

    _checkLastMode(block) {
        const renderData = block.renderData,
            modes = renderData.get('mode'),
            drawCount = renderData.get('drawCount');
        let lastIndex = modes.length - 1;
        if (modes[lastIndex] === modes[lastIndex - 1]) {
            modes.splice(lastIndex, 1);
            const count = drawCount.splice(lastIndex, 1)[0];
            lastIndex--;
            drawCount[lastIndex] += count;
        }
    }
}
;"use strict";
hmap.core=hmap.core||{};
hmap.core.parser = hmap.core.parser || {};
/**
 * 动态加载纹理数据的画点的parser
 * @private
 */
hmap.core.parser.SymbolDynamicParser = class extends hmap.core.parser.Parser {
    constructor(painter, options={}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.SymbolDynamicParser";
        this._atlas = options.atlas;
    }

    /**
     * 处理任务，任务单元是block
     * @param block
     */
    handleBlock(block) {
        const promises = [],
            features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }

            const geom = feature.getGeometry();
            feature.buffer = this.dataMap;
            if (geom instanceof hmap.geom.Point) {
                promises.push(this._handleFeature(feature, geom));
            }
            else {
                promises.push(this._handleMPointFeature(feature, geom));
            }
        }
        Promise.all(promises)
            .then(() => {
                this._dealBlockData(block);
                this.owner.owner._map.event.dispatch(new hmap.event.MapEvent(EventType.LAYEREVENT_DATACHANGE));
            })
            .catch(err => {
                console.log(err.message)
            });
    }

    /**
     * 添加要素
     * @param feature
     * @param layer
     * @returns {Array}
     */
    async _handleFeature(feature, geom) {
        const coord = geom.getCoordinate(),
            style = feature.getStyle(),
            xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")],
            buffer = feature.buffer,
            textData = this._addText(xyz, style, feature.getAttributes()),
            iconPromises = this._addIcon(buffer, xyz, style, textData);

        await Promise.all(iconPromises)
            .then(() => {
                buffer.set('mode', [this._owner.gl.POINTS]);
                buffer.set('drawCount', [buffer.get('a_position').length / 3]);
            });
        // return iconPromises;
    }

    async _handleMPointFeature(feature, geom) {
        const promises = [],
            coords = geom.getCoordinates(),
            style = feature.getStyle(),
            buffer = feature.buffer;

        for (let i = 0, l = coords.length; i < l; i++) {
            const coord = coords[i],
                xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")];
            const textData = this._addText(xyz, style, feature.getAttributes());
            const iconPromises = this._addIcon(buffer, xyz, style, textData);
            promises.push(...iconPromises);
        }
        await Promise.all(promises)
            .then(() => {
                buffer.set('mode', [this._owner.gl.POINTS]);
                buffer.set('drawCount', [buffer.get('a_position').length / 3]);
            });

        // return promises;
    }

    _addIcon(buffer, xyz, style, textData) {
        const promises = [],
            me = this,
            markerSymbols = style.getMarkerSymbols();
        for (let i = 0, len = markerSymbols.length; i < len; i++) {
            const markerSymbol = markerSymbols[i];
            const iconPromise = this._getIconAsyncData(markerSymbol, this._atlas, xyz);
            const ipt = iconPromise.then(function (iconInfo) {
                //feature保存生成的结构化数组
                me._appendData(buffer, iconInfo);
                me._appendData(buffer, textData);
            });
            promises.push(ipt);
        }
        if (promises.length == 0) {
            this._appendData(buffer, textData);
        }
        return promises;
    }

    /**
     * 从MarkerSymbol中获取icon的渲染数据，包括size、opacity、offset、textureCoord
     * @param markerSymbol
     * @param resolution
     * @returns {Promise<any>}
     * @private
     */
    _getIconAsyncData(markerSymbol, atlas, xyz){
        const scope=this;
        return new Promise(function(res,rej){
            markerSymbol.getRenderData({atlasMgr: atlas}, function (info) {
                //转化成着色器能用的数据
                const iconInfo = scope.dataMap;
                iconInfo.set('a_texAttr', info.textureCoord);
                iconInfo.set('a_offset', info.offset);
                // iconInfo.set('a_color', info.textColor);
                iconInfo.set('a_size', info.size);
                iconInfo.set('a_angle', info.angle);
                iconInfo.set('a_position', xyz);
                iconInfo.set('a_opacity', info.opacity);
                iconInfo.set('a_fontColor', [1,1,1,1]);//暂未用到
                iconInfo.set('a_bgColor', [1,1,1,1]);//暂未用到
                iconInfo.set('a_haloWidth', [1]);//暂未用到
                iconInfo.set('a_haloColor', [1,1,1,1]);//透明度必须为1来区分文字和图标
                res(iconInfo);
            });
        });
    }

    _addText(xyz, style, attributes) {
        const textSymbols = style.getTextSymbols();
        const textData = this.dataMap;
        for (let i = 0, len = textSymbols.length; i < len; i++) {
            const textSymbol = textSymbols[i];
            let text = textSymbol.getText().trim();
            if (text.indexOf("{") != -1) {//判断是否需要从attri中获取字段
                const fieldName = text.substring(1, text.length - 1);
                text = attributes[fieldName].trim();
            }
            if (text === '') {
                continue;
            }
            const textInfo = this._getTextData(textSymbol, text, this._atlas);
            const me = this;
            for (let i = 0, textNum = textInfo.get('textNum'); i < textNum; i++) {
                textInfo.get("a_position").push(...xyz);
                // textInfo.get("index").push(i);
            }
            me._appendData(textData, textInfo);
        }
        return textData;
    }

    /**
     * 获取text的渲染数据，从TextSymbol中
     * @param textSymbol
     * @param resolution
     * @param text
     * @returns {Promise<any>}
     * @private
     */
    _getTextData(textSymbol, text, atlas){
        const info = textSymbol.getRenderData({text: text, atlasMgr: atlas});
        //转化成着色器能用的数据
        const textInfo =this.dataMap;
        textInfo.set('a_texAttr', info.textureCoord);
        textInfo.set('a_offset', info.offset);
        // textInfo.set('a_color', info.textColor);
        textInfo.set('a_size', info.size);
        textInfo.set('a_angle', info.angle);
        textInfo.set('a_opacity', info.opacity);
        textInfo.set('textNum', info.textNum);
        textInfo.set('a_fontColor', info.fontColor);
        textInfo.set('a_haloColor', info.haloColor);
        textInfo.set('a_bgColor', info.bgColor);
        textInfo.set('a_haloWidth', info.haloWidth);
        return textInfo;
    }
}
;"use strict";
hmap.core=hmap.core||{};
hmap.core.parser = hmap.core.parser || {};
/**
 * 使用雪碧图画点的parser
 * @private
 */
hmap.core.parser.SymbolStaticParser = class extends hmap.core.parser.Parser {
    constructor(painter, options={}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.SymbolStaticParser";
    }

    /**
     * 处理任务，任务单元是block
     * @param block
     */
    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i >=0; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }

            const geom = feature.getGeometry();
            feature.buffer = this.dataMap;
            if (geom instanceof hmap.geom.Point) {
                this._handleFeature(feature, geom);
            }
            else {
                this._handleMPointFeature(feature, geom);
            }
        }

        this._dealBlockData(block);
    }

    /**
     * 添加要素
     * @param feature
     * @param layer
     * @returns {Array}
     */
    _handleFeature(feature, geom) {
        const coord = geom.getCoordinate(),
            style = feature.getStyle(),
            xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")],
            buffer = feature.buffer;

        this._addIcon(buffer, xyz, style);
        this._addText(buffer, xyz, style, feature.getAttributes());

        buffer.set('mode', [this._owner.gl.POINTS]);
        buffer.set('drawCount', [buffer.get('a_position').length / 3]);
    }

    _handleMPointFeature(feature, geom) {
        const coords = geom.getCoordinates(),
            style = feature.getStyle(),
            buffer = feature.buffer;

        for (let i = 0, l = coords.length; i < l; i++) {
            const coord = coords[i],
                xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")];
            this._addIcon(buffer, xyz, style);
            this._addText(buffer, xyz, style, feature.getAttributes());
        }

        buffer.set('mode', [this._owner.gl.POINTS]);
        buffer.set('drawCount', [buffer.get('a_position').length / 3]);
    }

    _addIcon(buffer, xyz, style) {
        const markerSymbols = style.getMarkerSymbols();
        for (let i = 0, len = markerSymbols.length; i < len; i++) {
            const markerSymbol = markerSymbols[i];
            const iconData = this._getIconAsyncData(markerSymbol, xyz);
            //feature保存生成的结构化数组
            this._appendData(buffer, iconData);
        }
    }

    /**
     * 从MarkerSymbol中获取icon的渲染数据，包括size、opacity、offset、textureCoord
     * @param markerSymbol
     * @param resolution
     * @returns {Promise<any>}
     * @private
     */
    _getIconAsyncData(markerSymbol, xyz){
        const iconName = markerSymbol.getImgSrc(),
            textureCoord = this._owner._owner.sprite.getTextureCoord(iconName),
            sizeArr =[],
            opacityArr = [],
            offsetArr = [],
            textColorArr = [],
            rotationArr = [];

        //图标大小
        const pointSize = markerSymbol.getSize();
        sizeArr.push(pointSize.getWidth(), pointSize.getHeight());

        //透明度
        opacityArr.push(markerSymbol.getOpacity());

        //图标最终的偏移量
        const xOffset = pointSize.getWidth()*(0.5 - markerSymbol.getAnchor()[0]) + markerSymbol.getOffset().getValue("X");
        const yOffset = pointSize.getHeight()*(markerSymbol.getAnchor()[1] - 0.5) - markerSymbol.getOffset().getValue("Y");
        offsetArr.push(xOffset, yOffset);

        //颜色值
        textColorArr.push(1.0, 1.0, 1.0, 1.0);

        //旋转角度
        rotationArr.push(markerSymbol.getRotation() * Math.PI/180);

        //转化成着色器能用的数据
        const iconInfo = this.dataMap;
        iconInfo.set('a_texAttr', textureCoord);
        iconInfo.set('a_offset', offsetArr);
        // iconInfo.set('a_color', textColorArr);
        iconInfo.set('a_size', sizeArr);
        iconInfo.set('a_angle', rotationArr);
        iconInfo.set('a_position', xyz);
        // iconInfo.set('index', [0]);

        return iconInfo;
    }

    _addText(buffer, xyz, style, attributes) {
        const textSymbols = style.getTextSymbols();
        const textData = this.dataMap;
        textData.set('a_texAttr', []);
        textData.set('a_offset', []);
        // textData.set('a_color', []);
        textData.set('a_size', []);
        textData.set('a_angle', []);
        // textData.set('index', []);
        textData.set('a_position', []);
        for (let i = 0, len = textSymbols.length; i < len; i++) {
            const textSymbol = textSymbols[i];
            let text = textSymbol.getText().trim();
            if (text.indexOf("{") != -1) {//判断是否需要从attri中获取字段
                const fieldName = text.substring(1, text.length - 1);
                text = attributes[fieldName].trim();
            }
            if (text === '') {
                continue;
            }
            const textInfo = this._getTextData(textSymbol, text, this._atlas);
            const me = this;
            for (let i = 0, textNum = textInfo.get('textNum'); i < textNum; i++) {
                textInfo.get("a_position").push(...xyz);
                // textInfo.get("index").push(i);
            }
            me._appendData(textData, textInfo);
        }

        this._appendData(buffer, textData);
    }

    /**
     * 获取text的渲染数据，从TextSymbol中
     * @param textSymbol
     * @param resolution
     * @param text
     * @returns {Promise<any>}
     * @private
     */
    _getTextData(textSymbol, text, atlas){
        const info = textSymbol.getRenderData({text: text, atlasMgr: atlas});
        //转化成着色器能用的数据
        const textInfo = this.dataMap;
        textInfo.set('a_texAttr', info.textureCoord);
        textInfo.set('a_offset', info.offset);
        // textInfo.set('a_color', info.textColor);
        textInfo.set('a_size', info.size);
        textInfo.set('a_angle', info.angle);
        // textInfo.set('index', []);
        textInfo.set('a_position', []);
        textInfo.set('textNum', info.textNum);
        return textInfo;
    }
}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.FillColorParser = class  extends hmap.core.parser.Parser {
    /**
     * @param layer
     * @param option.drawType 绘制方式，drawArrays|drawElements(默认)
     * @param option.bPrecisionCorrect 精度补偿，缺省为true
     */
    constructor(painter, options = {}) {
        options.drawType = 'drawElements';
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.FillColorParser";
    }

    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }
            const geom = feature.getBasicGeometry();
            feature.buffer = this.dataMap;

            if (!(geom instanceof hmap.geom.MultiPolygon)) {
                this._handleFeature(feature, geom);
            }
            else {
                this._handleMPolygonFeature(feature, geom);
            }
        }
        this._dealBlockData(block);
    }

    _handleFeature(feature, geom) {
        const buffer = feature.buffer,
            style = feature.getStyle();
        buffer.set("mode", []);
        buffer.set("drawCount", []);
        this._handlePolygonGeom(buffer, geom, style);
    }

    _handleMPolygonFeature(feature, geom) {
        const buffer = feature.buffer,
            style = feature.getStyle(),
            polygons = geom.getPolygons();
        buffer.set("mode", []);
        buffer.set("drawCount", []);

        for (let i = 0, l = polygons.length; i < l; i++) {
            this._handlePolygonGeom(buffer, polygons[i], style);
        }
    }

    _handlePolygonGeom(buffer, geom, style) {
        this._addFill(buffer, geom, style.getFillSymbols()[0]);
        this._addLine(buffer, geom, style.getLineSymbols()[0]);
    }

    _addLine(buffer, geom, symbol) {
        if (!symbol) return;
        const coordSeqs = geom.getCoordSeqs();
        let color = null;
        if (symbol instanceof hmap.style.GradientFill) {
            color = symbol.fromColor;
        }else{
            color = symbol._color;
        }

        const info = this.dataMap;
        const [xyzs, index] = this._coordSeqToArray(coordSeqs[0]);
        const a_color = this._addSingleColor(xyzs.length / 3, color);
        const a_offset = [].concat.apply([], new Array(xyzs.length / 3).fill([0, 0]));
        info.set('a_position', xyzs);
        info.set('index', index);
        info.set('a_color', a_color);
        info.set('a_offset', a_offset);
        info.set('mode', []);
        info.set('drawCount', []);
        this._appendDataIndex(buffer, info, buffer.get("a_position").length / 3);
        buffer.get('mode').push(this._owner.gl.LINES);
        buffer.get('drawCount').push(index.length);
    }

    _addFill(buffer, geom, fillSymbol) {
        if (!fillSymbol) return;
        const coordSeqs = geom.getCoordSeqs();
        const triangleData = this._triangulate(coordSeqs);
        const index = triangleData.index,
            pointCount = triangleData["positionCount"][0],
            xyzs = triangleData.a_position;

        const fillInfo = this.dataMap;
        fillInfo.set("mode", []);
        fillInfo.set("drawCount", []);
        fillInfo.set('a_position', xyzs);
        fillInfo.set('index', index);
        fillInfo.set('a_offset', [].concat.apply([], new Array(pointCount).fill([0, 0])));
        let a_color = [];
        if(fillSymbol instanceof hmap.style.GradientFill){
            a_color = this._addGradientColor(xyzs, geom, fillSymbol.fromColor,fillSymbol.toColor,fillSymbol.angle);
        }else {
            a_color = this._addSingleColor(pointCount, fillSymbol._color);
        }

        fillInfo.set('a_color', a_color);
        this._appendDataIndex(buffer, fillInfo, buffer.get("a_position").length / 3);

        buffer.get('mode').push(this._owner.gl.TRIANGLES);
        buffer.get('drawCount').push(index.length);
    }


    _coordSeqToArray(coordSeq) {
        let xyzs = [], index = [];
        for (let i = 0, len = coordSeq.getCoordCount(); i < len; i++) {
            const coord = coordSeq.getCoordinate(i);
            xyzs.push(coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z"));
            index.push(i);
            index.push(i + 1);
        }
        index.pop();
        index.pop();
        return [xyzs, index];
    }


    _addSingleColor(count, color) {
        const c = color.toNormalizeArray();
        const a_color = [].concat.apply([], new Array(count).fill(c));
        return a_color;
    }

    _addGradientColor(xyzs, geometry, from,to,angle) {
        const polygon = geometry.clone();
        const centroid = polygon.getCentroid();
        polygon.rotate('Z', -angle, centroid);
        const extent = polygon.getExtent();
        const distance = extent.getWidth(),
            y0 = extent.getTopRight(),
            y1 = extent.getBottomRight();
        let line = new hmap.geom.Line([new hmap.geom.Point(y0), new hmap.geom.Point(y1)]);
        line.rotate('Z', angle, centroid);
        const a_color = [];
        for (let i = 0, l = xyzs.length / 3; i < l; i++) {
            const x = xyzs[i * 3],
                y = xyzs[i * 3 + 1],
                z = xyzs[i * 3 + 2];
            const pt = new hmap.geom.Point(new hmap.basetype.Coordinate(x, y, z));
            const distanceToLine = pt.distanceTo(line),
                ratio = distanceToLine / distance;
            let cl = hmap.util.InterpolateColor.interpolateColorByLine(from, to, ratio);
            a_color.push(...cl.toNormalizeArray());
        }
        polygon.destroy();
        line.destroy();
        return a_color;
    }

    _triangulate(coordSeqs) {
        let xyzs, indices;
        const coordData = hmap.strategy.EarCut.getCoordDataFromCoordSeq(coordSeqs);
        if (coordData.coordData.length === 12) {
            xyzs = coordData.coordData.slice(0, 9);
            indices = [0, 1, 2];
            const flag = hmap.strategy.Topology.checkCollinear(new hmap.basetype.Coordinate(xyzs[0], xyzs[1], xyzs[2])
                , new hmap.basetype.Coordinate(xyzs[3], xyzs[4], xyzs[5]), new hmap.basetype.Coordinate(xyzs[6], xyzs[7], xyzs[8]));
            if (flag === -1) {
                indices.reverse();
            }
        } else {
            xyzs = coordData.coordData;
            indices = hmap.strategy.EarCut.earcut(coordData.coordData, coordData.holeIndices, 3);
        }
        return {
            a_position: xyzs,
            index: indices,
            positionCount: [xyzs.length / 3],
            indexCount: [indices.length]
        };
    }

}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.FillBorderParser = class  extends hmap.core.parser.FillColorParser {
    /**
     * 带宽边框面
     * @param layer
     * @param option.drawType 绘制方式，drawArrays|drawElements(默认)
     * @param option.bPrecisionCorrect 精度补偿，缺省为true
     */
    constructor(painter, options = {}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.FillBorderParser";
    }

    handleBlock(block) {
        super.handleBlock(block)
    }

    // _handleFeature(feature, geom) {
    //     const buffer = feature.buffer,
    //         style = feature.getStyle();
    //     buffer.set('mode', []);
    //     buffer.set('drawCount', []);
    //     this._handlePolygonGeom(buffer, geom, style)
    // }
    //
    // _handleMPolygonFeature(feature, geom) {
    //     const buffer = feature.buffer,
    //         style = feature.getStyle(),
    //         polygons = geom.getPolygons();
    //     buffer.set("mode", []);
    //     buffer.set("drawCount", []);
    //
    //     for (let i = 0, l = polygons.length; i < l; i++) {
    //         this._handlePolygonGeom(buffer, polygons[i], style);
    //     }
    // }

    _handlePolygonGeom(buffer, geom, style) {
        this._addFill(buffer, geom, style.getFillSymbols()[0]);
        this._addBorderFill2(buffer, geom, style.getLineSymbols()[0]);
    }

    _addBorderFill2(buffer, geom, lineSymbol) {
        if (!lineSymbol) return;

        const coordSeqs = geom.getCoordSeqs();
        const [xyzs, index] = this._coordSeqToArray(coordSeqs[0]);
        xyzs.push(xyzs[3],xyzs[4],xyzs[5])
        const data = this._setWideLineData(xyzs, lineSymbol.getWidth()/2);

        const fillInfo = this.dataMap;
        fillInfo.set('mode', []);
        fillInfo.set('drawCount', []);
        fillInfo.set('a_position', data.get("a_position"));
        fillInfo.set('index', data.get("index"));
        fillInfo.set('a_offset', data.get("a_side"));

        let color = null;
        if(lineSymbol instanceof hmap.style.GradientFill){
            color = lineSymbol.fromColor;
        }else{
            color = lineSymbol._color;
        }

        fillInfo.set('a_color', this._addSingleColor(data.get("a_position").length / 3, color));

        this._appendDataIndex(buffer, fillInfo, buffer.get("a_position").length / 3);
        buffer.get('mode').push(this._owner.gl.TRIANGLES);
        buffer.get('drawCount').push(data.get("index").length);
    }

    _setWideLineData(xyzs, lineWidth) {
        const a_position = [];
        const a_side = [];
        const index = [];
        let c = 0;
        const map = this.dataMap;
        for (let i = 0, len = xyzs.length / 3; i < len; i++) {
            //i不是第一个点也不是最后一个点，计算拐点处需要的小矩形
            if (i > 0 && i < len - 1) {
                //在拐点处阔成三个点
                a_position.push(xyzs[3 * i], xyzs[3 * i + 1], xyzs[3 * i + 2]);
                a_position.push(xyzs[3 * i], xyzs[3 * i + 1], xyzs[3 * i + 2]);
                c += 2;
                const delta = this._getDelta(xyzs, i, lineWidth);
                const x1 = delta[0], y1 = delta[1];
                a_side.push(-y1, x1, y1, -x1);
                index.push(c - 2, c - 1, c);
                index.push(c, c - 1, c + 1);
            }
            //存入第i个点对应的坐标值
            a_position.push(xyzs[3 * i], xyzs[3 * i + 1], xyzs[3 * i + 2]);
            a_position.push(xyzs[3 * i], xyzs[3 * i + 1], xyzs[3 * i + 2]);
            c += 2;
            //拐点处三角形
            if (i < len - 1) {
                const delta = this._getDelta(xyzs, i + 1, lineWidth);
                const x = delta[0], y = delta[1];
                a_side.push(-y, x, y, -x);
                //第一个三角形
                index.push(c - 2, c - 1, c);
                //第二个三角形
                index.push(c, c - 1, c + 1);
            } else {// i==len -1 最后一个点
                const delta = this._getDelta(xyzs, i, lineWidth);
                const x2 = delta[0], y2 = delta[1];
                a_side.push(-y2, x2, y2, -x2);
            }
        }
        map.set("a_position", a_position);
        map.set("index", index);
        map.set("a_side", a_side);
        return map;
    }

    _getDelta(xyzs, i, lineWidth) {
        const x = xyzs[3 * (i)] - xyzs[3 * (i - 1)],
            y = xyzs[3 * (i) + 1] - xyzs[3 * (i - 1) + 1];
        if (x !== 0 || y !== 0) {
            const length = Math.abs(Math.sqrt(x * x + y * y));
            return [x / length * lineWidth, y / length * lineWidth]
        } else {
            const z = xyzs[3 * (i) + 2] - xyzs[3 * (i - 1) + 2];
            const length = Math.abs(Math.sqrt(x * x + z * z));
            return [x / length * lineWidth, z / length * lineWidth]
        }
    }

    _addBorderFill(feature) {
        const lineSymbol = feature.getStyle().getLineSymbols()[0];
        if (!lineSymbol) return;

        //只处理最外层边框
        const coordSeqs = feature.getGeometry().getCoordSeqs();
        const [xyzs, index] = this._coordSeqToArray(coordSeqs[0]);
        const data = this._calcBorderIndex(xyzs, index, lineSymbol.getWidth());

        const fillInfo = this.dataMap;
        fillInfo.set('mode', []);
        fillInfo.set('drawCount', []);
        fillInfo.set('a_position', data.xyzs);
        fillInfo.set('index', data.index);
        fillInfo.set('a_offset', data.offset);

        let color = lineSymbol.getColor();
        if (color instanceof hmap.style.GradientFill) {
            color = color.fromColor;
        }
        fillInfo.set('a_color', this._addSingleColor(data.xyzs.length / 3, color));

        let indexOffset = 0;
        if (feature.buffer.get("drawCount").length > 0) {
            indexOffset = feature.buffer.get("a_position").length / 3;
        }
        this._appendDataIndex(feature.buffer, fillInfo, indexOffset);
        feature.buffer.get('mode').push(this._owner.gl.TRIANGLES);
        feature.buffer.get('drawCount').push(data.index.length);
    }
    //计算边框顶点和索引
    _calcBorderIndex(xyzs, index, width) {
        const length = xyzs.length;
        const clockwise = this._antiClockwise(xyzs, 0, length);
        const a_side = this._calcSide(xyzs, index, clockwise, width);

        let offset = [].concat.apply([], new Array(length / 3).fill([0, 0]));
        offset.push.apply(offset, a_side);//顶点扩充两倍
        xyzs.push.apply(xyzs, xyzs);//顶点扩充两倍
        index = this._dealIndex(xyzs.length / 3, clockwise);
        return {
            xyzs: xyzs,
            index: index,
            offset: offset
        }
    }


    _dealIndex(length, clockwise) {
        const tempIndex = [];
        const halfLength = length / 2;
        if (clockwise > 0) {
            for (let i = 0; i < halfLength - 1; i++) {
                //   v1   v2     v3                v4
                //   i,  i+1,    i+1+halfLength,   i+halfLength;
                tempIndex.push(i, i + 1, i + 1 + halfLength,
                    i + 1 + halfLength, i + halfLength, i)
            }
        } else {
            for (let i = 0; i < halfLength - 1; i++) {
                //   v1   v2     v3                v4
                //   i,  i+1,    i+1+halfLength,   i+halfLength;
                tempIndex.push(i, i + halfLength, i + 1 + halfLength,
                    i, i + 1 + halfLength, i + 1)
            }
        }
        return tempIndex;
    }

    //计算边框顶点偏移量
    _calcSide(data, index, clockwise, width, offset = [0, 0]) {
        const side = [];
        const length = data.length;
        const last2 = length - 2 * 3;
        //起点
        const [x, y] = this._calcOffset(last2, 0, 3, data, clockwise, width);
        side.push(x + offset[0], y + offset[1]);
        for (let i = 3; i < length - 3; i += 3) {
            const [x, y] = this._calcOffset(i - 3, i, i + 3, data, clockwise, width);
            side.push(x + offset[0], y + offset[1]);
        }
        //终点（同起点）
        side.push(x + offset[0], y + offset[1]);
        return side;
    }


    _antiClockwise(data, start, end) {
        //沿着多边形的边求曲线积分,若积分为正,则是沿着边界曲线正方向(逆时针),反之为顺时针
        let d = 0;
        for (let i = start; i < end - 3; i += 3) {
            d += -0.5 * (data[i + 1 + 3] + data[i + 1]) * (data[i + 3] - data[i]);
        }
        //小于零为顺时针，大于零为逆时针
        return d > 0 ? -1 : 1;
    }

    _calcOffset(i1, i2, i3, data, clockwise, w) {
        const xn = data[i1], yn = data[i1 + 1], zn = data[i1 + 2],
            x0 = data[i2], y0 = data[i2 + 1], z0 = data[i2 + 2],
            x1 = data[i3], y1 = data[i3 + 1], z1 = data[i3 + 2];

        const v1 = new hmap.util.Vector3(x0 - xn, y0 - yn, z0 - zn).normalize(),
            v2 = new hmap.util.Vector3(x1 - x0, y1 - y0, z1 - z0).normalize();

        //拐点凸凹性判断
        const d = (x0 - xn) * (y1 - y0) - (y0 - yn) * (x1 - x0);
        const symbol = d > 0 ? 1 : -1;
        //点偏移方向
        v2.substract(v1).multiplyScalar(clockwise * symbol).normalize();
        //法向量偏移量计算
        const cos = -v1._elements[1] * v2._elements[0] + v1._elements[0] * v2._elements[1];
        const wd = Math.abs(w / cos);
        return [v2._elements[0] * wd, v2._elements[1] * wd];
    }


}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.FillTextureParser = class  extends hmap.core.parser.FillColorParser {
    constructor(painter, options = {}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.FillTextureParser";
        this.glHelper = hmap.help.glHelper.get(this.owner.gl);
    }

    handleBlock(block) {
        if (!block.textures) {
            block.textures = [];
        }
        const promises = [];
        const features = block.features;
        for (let i = 0, len = features.length; i < len; i++) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }
            const geom = feature.getBasicGeometry();
            feature.buffer = this.dataMap;

            if (!(geom instanceof hmap.geom.MultiPolygon)) {
                promises.push(this._handleFeature(feature, geom, block));
            }
            else {
                promises.push(...this._handleMPolygonFeature(feature, geom, block));
            }
        }
        Promise.all(promises).then(() => {
            this._dealBlockData(block);
            this.owner.owner._map.event.dispatch(new hmap.event.MapEvent(EventType.LAYEREVENT_DATACHANGE));
        })
        //     .catch(err => {
        //     console.error(err.message)
        // });
    }

    _handleFeature(feature,geom, block) {
        const buffer = feature.buffer,
            fillSymbol = feature.getStyle().getFillSymbols()[0];
        buffer.set('mode', []);
        buffer.set('drawCount', []);
        if (!fillSymbol instanceof hmap.style.TextureFill) {
            return;
        }
        block.textures.push(fillSymbol._id);
        return this._addFill(buffer, fillSymbol, geom);
    }

    _handleMPolygonFeature(feature, geom, block) {
        const buffer = feature.buffer,
            fillSymbol = feature.getStyle().getFillSymbols()[0],
            polygons = geom.getPolygons();
        buffer.set('mode', []);
        buffer.set('drawCount', []);
        if (!fillSymbol instanceof hmap.style.TextureFill) {
            return;
        }
        block.textures.push(fillSymbol._id);

        let promises = [];
        for (let i = 0, l = polygons.length; i < l; i++) {
            promises.push(this._addFill(buffer, fillSymbol, polygons[i]))
        }
        return promises;
    }

    _addFill(buffer, fillSymbol, geom) {
        const coordSeqs = geom.getCoordSeqs();
        const triangleData = this._triangulate(coordSeqs);
        const index = triangleData.index,
            pointCount = triangleData["positionCount"][0],
            xyzs = triangleData.a_position;

        let extent = coordSeqs[0].getExtent();
        for (let i = 1, len = coordSeqs.length; i < len; i++) {
            extent.extendExtent(coordSeqs[i].getExtent())
        }
        let info = this.dataMap;
        info.set("a_position", xyzs);
        info.set("index", index);
        info.set("a_textureCoord", []);
        info.set('a_offset', [].concat.apply([], new Array(pointCount).fill([0,0])));
        info.set('mode', []);
        info.set('drawCount', []);
        let xMin = extent.getLeft(),
            yMin = extent.getBottom(),
            yMax = extent.getTop(),
            unitWidth = fillSymbol.unitWidth || extent.getWidth(),
            unitHeight = fillSymbol.unitHeight || extent.getHeight();
        //y轴反转
        for (let i = 0, l = xyzs.length / 3; i < l; i++) {
            let coord = new hmap.basetype.Coordinate(xyzs[i * 3], xyzs[i * 3 + 1], xyzs[i * 3 + 2]);
            let x = coord.getOrdinate('X'),
                y = coord.getOrdinate('Y');
            info.get("a_textureCoord").push((x - xMin) / unitWidth, (unitHeight - y + yMin) / unitHeight);
        }
        const id = fillSymbol._id;
        const me = this;
        let promise;
        if (!this.glHelper.getTextureObject(id,0,fillSymbol).image) {
            const texture = fillSymbol.getTexure();
            if (texture) {
                me._bindData(buffer, info, index, id, texture);
            } else {
                promise = fillSymbol.promise.then(symbol => {
                    me._bindData(buffer, info, index, id, symbol._texture);
                })
            }
        }else{
            const texture = fillSymbol.getTexure();
            me._bindData(buffer, info, index, id, texture);
        }
        return promise;
    }

    //数据绑定
    _bindData(buffer, info, index, id, texture) {
        this.glHelper.getTextureObject(id).bufferImage(texture);
        this.glHelper.getTextureObject(id)["indexCount"] = index.length;

        this._appendDataIndex(buffer, info, buffer.get('a_position').length / 3);
        buffer.set('mode', [this._owner.gl.TRIANGLES]);
        buffer.set('drawCount', [buffer.get('index').length]);
    }

}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.LineParser = class  extends hmap.core.parser.Parser {
    /**
     * @param layer
     * @param option.drawType 绘制方式，drawArrays|drawElements(默认)
     * @param option.bPrecisionCorrect 精度补偿，缺省为true
     */
    constructor(painter, options = {}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.LineParser";
    }

    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }

            const geom = feature.getBasicGeometry();
            feature.buffer = this.dataMap;

            if (geom instanceof hmap.geom.Line) {
                this._handleFeature(feature, geom);
            }
            else {
                this._handleMLineFeature(feature, geom);
            }
        }

        this._dealBlockData(block);
    }

    /**
     * 添加要素
     * @param feature
     * @param layer
     * @returns {Array}
     */
    _handleFeature(feature, geom) {
        const lineSymbols = feature.getStyle() ? feature.getStyle().getLineSymbols() : this._owner.owner.getStyle().getLineSymbols(),
            buffer = feature.buffer;

        this._handLineGeom(feature.buffer, geom, lineSymbols);

        buffer.set('mode', [this._owner.gl.LINES]);
        buffer.set('drawCount', [buffer.get('index').length]);
    }

    _handleMLineFeature(feature, geom) {
        const lines = geom.getLines(),
            lineSymbols = feature.getStyle() ? feature.getStyle().getLineSymbols() : this._owner.owner.getStyle().getLineSymbols(),
            buffer = feature.buffer;

        for (let i = 0, l = lines.length; i < l; i++) {
            this._handLineGeom(buffer, lines[i], lineSymbols);
        }

        buffer.set('mode', [this._owner.gl.LINES]);
        buffer.set('drawCount', [buffer.get('index').length]);
    }
    _getDashRatio(dashType){
        switch(dashType){
            case "dot": return [1/4,3/4,0,0];
            case "dash":return [1/2,1/2,0,0];
            case "dashdot":return [1/3,4/15,2/15,4/15];
            case "longdash":return [3/4,1/4,0,0];
            case "longdashdot":return [1/2,1/5,1/10,1/5];
        }
    }

    _handLineGeom(buffer, geo, lineSymbols) {
        const lineLen = geo.getLength();

        for (let i = 0, l = lineSymbols.length; i < l; i++) {
            const lineSymbol = lineSymbols[i],
                lineOffset = lineSymbol.getLineOffset(),
                lineStyle = lineSymbol.getLineStyle();
            let lineData,
                lineColor = lineSymbol.getColor();
            if (lineColor instanceof hmap.style.Color) {
                lineData = this._preLineData(geo, lineOffset, lineColor, lineColor, true);
                if (lineStyle !== 'solid') {
                    const ratios = this._calVerticesPercent(geo, lineLen);
                    const dashRatio = this._getDashRatio(lineStyle);
                    lineData.set('a_perLength', ratios);
                    lineData.set('a_lineLength', new Array(lineData.get('a_position').length / 3).fill(lineLen));

                    lineData.set('a_dash_ratio', [].concat.apply([], new Array(lineData.get('a_position').length / 3).fill(dashRatio)));
                }
            }
            else {
                const subLines = this._divideLineByGradientColor(geo, lineColor);
                let prePercent = 0;
                lineData = this.dataMap;
                for (let i = 0, l = subLines.length; i < l; i++) {
                    const fromColor = lineColor[i * 2 + 1],
                        toColor = lineColor[(i + 1) * 2 + 1],
                        line = subLines[i];
                    const data = this._preLineData(line, lineOffset, fromColor, toColor, false);
                    if (lineStyle !== 'solid') {
                        const ratios = this._calVerticesPercent(line, lineLen, prePercent);
                        const dashRatio = this._getDashRatio(lineStyle);
                        prePercent = ratios[ratios.length - 1];
                        data.set('a_perLength', ratios);
                        data.set('a_lineLength', new Array(data.get('a_position').length / 3).fill(lineLen));
                        data.set('a_dash_ratio', [].concat.apply([], new Array(data.get('a_position').length / 3).fill(dashRatio)));
                    }
                    this._appendDataIndex(lineData, data, lineData.get('a_position').length / 3);
                }
            }
            this._appendDataIndex(buffer, lineData, buffer.get('a_position').length / 3);
        }
    }

    /**
     * @param xyzs
     * @param lineOffset
     * @param fromColor
     * @param toColor
     * @param isPureColor
     * @returns {Map<any, any>}
     * @private
     */
    _preLineData(geo, lineOffset, fromColor, toColor=fromColor, isPureColor=true) {
        const xyzs = this._lineToXYZ(geo),
            index = [],
            position = [...xyzs],
            color = [],
            l = xyzs.length / 3;
        let side;

        if (isPureColor) {
            color.push(...[].concat.apply([], new Array(l).fill(fromColor.toNormalizeArray())));
        }
        else {
            const ratios = this._calVerticesPercent(geo);
            color.push(...fromColor.toNormalizeArray());
            for (let i = 1; i < l - 1; i++) {
                const curColor = hmap.util.InterpolateColor.interpolateColorByLine(fromColor, toColor, ratios[i]);
                color.push(...curColor.toNormalizeArray());
            }
            color.push(...toColor.toNormalizeArray());
        }

        //lineOffset参数为Offset，分别为X、Y方向的偏移，此时所有点向X、Y方向偏移量一致
        if (lineOffset instanceof hmap.basetype.Offset) {
            side = [].concat.apply([], new Array(l).fill([lineOffset.getValue('x'), lineOffset.getValue('y')]));
        }
        else {
            //沿法向量偏移，正值偏移方向为线方向右侧，负值偏移方向为线方向左侧
            side = [];

            //计算第0个点的偏移
            let [dx, dy] = this._getDelta(xyzs, 0);
            side.push(dy * lineOffset, -dx * lineOffset);
            let nextDx = dx,
                nextDy = dy;

            for (let i = 0; i < l - 2; i++) {
                //计算第i+1个点的偏移
                dx = nextDx;
                dy = nextDy;
                const [nextDx1, nextDy1, xOffset, yOffset] = this._calNextPtNormalAndOffset(xyzs, i, dx, dy, lineOffset);
                nextDx = nextDx1;
                nextDy = nextDy1;
                side.push(yOffset, -xOffset);
            }

            //计算最后一个点的偏移
            side.push(nextDy * lineOffset, -nextDx * lineOffset);
        }

        for (let i = 0; i < l - 1; i++) {
            index.push(i, i + 1);
        }

        const res =this.dataMap;
        res.set('a_color', color);
        res.set('a_position', position);
        res.set('index', index);
        res.set('a_offset', side);
        return res;
    }

    _calNextPtNormalAndOffset(xyzs, i, dx, dy, lineOffset) {
        const [nextDx, nextDy] = this._getDelta(xyzs, i + 1);
        const [avgx, avgy] = this._normalize([dx + nextDx, dy + nextDy]);
        let cosa = dy * avgy + dx * avgx;
        cosa = cosa !== 0 ? cosa : 1;
        const offset = lineOffset / cosa;
        return [nextDx, nextDy, avgx * offset, avgy * offset];
    }

    _normalize(vec2) {
        let x = vec2[0],
            y = vec2[1];
        const len = Math.sqrt(x * x + y * y);
        if (len > 0) {
            x = x / len;
            y = y / len;
        }
        else {
            x = 0;
            y = 0;
        }

        return [x, y];
    }

    _getDelta(xyzs, i) {
        const dx = xyzs[3 * (i + 1)] - xyzs[3 * i],
            dy = xyzs[3 * (i + 1) + 1] - xyzs[3 * i + 1];
        return this._normalize([dx, dy]);
    }

    _divideLineByGradientColor(line, lineColor) {
        const ratios = [],
            colors = [];
        for (let i = 0, l = lineColor.length / 2; i < l; i++) {
            ratios[i] = lineColor[i * 2] * 10;
            colors[i] = lineColor[i * 2 + 1];
        }
        const divisor = hmap.util.InterpolateColor.getArrGreatestDivisor(ratios),
            parts = 10 / divisor,
            divideLines = line.divide(parts, this.owner.owner._map.getCrs().getSrid()),
            lines = [];
        for (let i = 1, l = ratios.length; i < l; i++) {
            const pre = ratios[i - 1] / divisor,
                cur = ratios[i] / divisor,
                len = cur - pre;
            lines[i - 1] = divideLines[pre];
            for (let j = 1; j < len; j++) {
                this._mergeLines(lines[i - 1], divideLines[pre + j]);
            }
        }
        return lines;
    }

    _mergeLines(destLine, srcLine) {
        const points = srcLine.getPoints(1);
        destLine.addPoints(points);
    }

    _lineToXYZ(line) {
        const coordSeq = line.getCoordSeq(),
            xyzs = [];
        for (let i = 0, l = coordSeq.getCoordCount(); i < l; i++) {
            const coord = coordSeq.getCoordinate(i);
            xyzs.push(coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z"));
        }
        return xyzs;
    }

    /**
     * 根据指定比例，计算线中每个点到起点的距离占给定长度的比例
     * @param line {hmap.geom.Line}
     * @param totalLength {Number}
     * @param prePercent {Number}
     * @returns {number[]}
     * @private
     */
    _calVerticesPercent(line, totalLength=line.getLength(), prePercent=0) {
        const ratios = [0 + prePercent],
            points = line.getPoints();
        let curDistance = 0;
        for (let i = 1, l = points.length; i < l; i++) {
            const coord1 = points[i - 1].getCoordinate(),
                coord2 = points[i].getCoordinate(),
                distance = coord2.get2Dist(coord1);
            curDistance += distance;
            ratios[ratios.length] = curDistance / totalLength + prePercent;
        }
        return ratios;
    }
}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.WideLineParser = class  extends hmap.core.parser.LineParser {
    /**
     * @param painter
     * @param option.drawType 绘制方式，drawArrays|drawElements(默认)
     * @param option.bPrecisionCorrect 精度补偿，缺省为true
     */
    constructor(painter, options = {}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.WideLineParser";
        this._lineWay = options.lineWay || 'parallelChange';//线交汇方式：parallelChange平交；interChange立交
    }

    handleBlock(block) {
        const features = block.features;

        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }

            const geom = feature.getBasicGeometry();
            feature.buffer = this.dataMap;
            let lineDatas;

            if (geom instanceof hmap.geom.Line) {
                lineDatas = this._handleFeature(feature, geom);
            }else{
                lineDatas = this._handleMLineFeature(feature, geom);
            }
            this._appendData(feature.buffer, lineDatas[0]);
            if (this._lineWay === 'parallelChange') {
                lineDatas[1] = lineDatas[1] ? lineDatas[1] : this.dataMap;
                //buffer1记录平交时第二次绘制的数据
                feature.buffer1 = lineDatas[1];
                if (feature.buffer1.get('a_position').length > 0) {
                    feature.buffer1.set('mode', [this._owner.gl.TRIANGLES]);
                    feature.buffer1.set('drawCount', [feature.buffer1.get('index').length]);
                }
                else {
                    feature.buffer1.set('mode', []);
                    feature.buffer1.set('drawCount', []);
                }
            }
            else if (lineDatas[1]) {
                this._appendDataIndex(feature.buffer, lineDatas[1], feature.buffer.get('a_position').length() / 3);
            }

            feature.buffer.set('mode', [this._owner.gl.TRIANGLES]);
            feature.buffer.set('drawCount', [feature.buffer.get('index').length]);
        }

        this._dealBlockData(block);
        if (this._lineWay === 'parallelChange') {
            for (let i = 0, l = features.length; i < l; i++) {
                this._precisionCorrect(features[i].buffer1);
                this._appendDataWithIndex(block, features[i].buffer1, block.renderData.get('a_position').length / 3);
            }
        }

        this._owner.bufferToGPU(block);//将数据刷新的GPU里
        const attributes = this.owner.program.layout.attributes;
        for (let key of attributes.keys()) {
            block.renderData.get(key).length = 0;
        }
    }

    _dealBlockData(block) {
        this._initRenderData(block);
        const features = block.features;
        for (let i = 0, l = features.length; i < l; i++) {
            if(!features[i]._visible) continue;
            //todo: 可以考虑把针对feature的特殊处理，在父类parser中剥离出一个单独的方法
            if (this._bPrecisionCorrect&&features[i].buffer.has('a_positionL')&&features[i].buffer.get('a_positionL').length<1) {
                const result=hmap.core.precision.multiDivide(features[i].buffer.get('a_position'));
                features[i].buffer.set('a_position',result[0]);
                features[i].buffer.set('a_positionL',result[1]);
            }
            this._appendBlockData(block, features[i].buffer);
        }
    }

    /**
     * 添加要素
     * @param feature
     * @param layer
     * @returns {Array}
     */
    _handleFeature(feature, geom) {
        const lineSymbols = feature.getStyle() ? feature.getStyle().getLineSymbols() : this._owner.owner.getStyle().getLineSymbols();

        return this._handLineGeom(geom, lineSymbols);
    }

    _handleMLineFeature(feature, geom) {
        const lineSymbols = feature.getStyle() ? feature.getStyle().getLineSymbols() : this._owner.owner.getStyle().getLineSymbols(),
            lines = geom.getLines(),
            linesData = [this.dataMap];

        for (let i = 0, l = lines.length; i < l; i++) {
            const lineData = this._handLineGeom(lines[i], lineSymbols);
            this._appendDataIndex(linesData[0], lineData[0], linesData[0].get('a_position').length / 3);
            if (lineData.length > 1) {
                linesData[1] = linesData[1] ? linesData[1] : this.dataMap;
                this._appendDataIndex(linesData[1], lineData[1], linesData[1].get('a_position').length / 3);
            }
        }

        return linesData;
    }

    _handLineGeom(geo, lineSymbols) {
        const totalLength = geo.getLength(),
            lineSymbolNum = lineSymbols.length>2?2:lineSymbols.length;//限制一个line的feature最多有两个lineSymbol;多出来的不做处理。
        let lineDatas = [];

        for(let i=0;i<lineSymbolNum;i++){
            const lineSymbol = lineSymbols[i],
                lineWidth = lineSymbol.getWidth(),
                lineStyle = lineSymbol.getLineStyle(),
                lineColor = lineSymbol.getColor(),
                lineOffset = lineSymbol.getLineOffset(),
                offset = [lineOffset.getValue('x'), lineOffset.getValue('y')];

            let lineData,
                positionCount;

            if(lineColor instanceof hmap.style.Color){//纯色
                const xyzs = this._lineToXYZ(geo);
                lineData = this._setWideLineData(xyzs,lineWidth);
                positionCount=lineData.get("a_position").length/3;
                lineData.set("a_color",[].concat.apply([], new Array(positionCount).fill(lineColor.toNormalizeArray())));
                // 虚线
                if(lineStyle!=="solid"){
                    const ratios = this._calVerticesPercent(geo, totalLength),
                        a_perLength = [];//记录每个顶点的占比=>// 虚线
                    let ratio = ratios[0];
                    a_perLength.push(ratio, ratio);
                    for (let i = 1, l = ratios.length - 1; i < l; i++) {
                        ratio = ratios[i];
                        a_perLength.push(ratio, ratio, ratio, ratio);
                    }
                    ratio = ratios[ratios.length - 1];
                    a_perLength.push(ratio, ratio);
                    lineData.set("a_perLength",a_perLength);
                    lineData.set("a_lineLength",new Array(positionCount).fill(totalLength));
                    const dashRatio = this._getDashRatio(lineStyle);
                    lineData.set('a_dash_ratio', [].concat.apply([], new Array(positionCount).fill(dashRatio)));
                }

                lineData.set("a_lineWidth",new Array(positionCount).fill(lineWidth));
                lineData.set("a_offset",[].concat.apply([], new Array(positionCount).fill(offset)));
            }else{//带渐变色
                const subLines = this._divideLineByGradientColor(geo, lineColor);
                let prePercent = 0;
                lineData = this.dataMap;
                for (let i = 0, l = subLines.length; i < l; i++) {
                    const fromColor = lineColor[i * 2 + 1],
                        toColor = lineColor[(i + 1) * 2 + 1],
                        line = subLines[i],
                        xyzs = this._lineToXYZ(line),
                        data = this._setWideLineData(xyzs, lineWidth),
                        positionCount = data.get('a_position').length / 3,
                        ratios = this._calVerticesPercent(line);
                    let a_color = [],
                        colorNormalize = fromColor.toNormalizeArray();
                    a_color.push(...colorNormalize, ...colorNormalize);
                    for (let j = 1, ll = ratios.length - 1; j < ll; j++) {
                        const curColor = hmap.util.InterpolateColor.interpolateColorByLine(fromColor, toColor, ratios[j]);
                        colorNormalize = curColor.toNormalizeArray();
                        a_color.push(...colorNormalize, ...colorNormalize, ...colorNormalize, ...colorNormalize)
                    }
                    colorNormalize = toColor.toNormalizeArray();
                    a_color.push(...colorNormalize, ...colorNormalize);
                    data.set("a_color",a_color);

                    if (lineStyle !== 'solid') {
                        const ratios = this._calVerticesPercent(line, totalLength, prePercent),
                            a_perLength = [];//记录每个顶点的占比=>// 虚线
                        let ratio = ratios[0];
                        a_perLength.push(ratio, ratio);
                        for (let i = 1, l = ratios.length - 1; i < l; i++) {
                            ratio = ratios[i];
                            a_perLength.push(ratio, ratio, ratio, ratio);
                        }
                        ratio = ratios[ratios.length - 1];
                        a_perLength.push(ratio, ratio);
                        prePercent = ratios[ratios.length - 1];
                        data.set('a_perLength', a_perLength);
                        data.set('a_lineLength', new Array(positionCount).fill(totalLength));
                        const dashRatio = this._getDashRatio(lineStyle);
                        data.set('a_dash_ratio', [].concat.apply([], new Array(positionCount).fill(dashRatio)));
                    }

                    data.set("a_lineWidth",new Array(positionCount).fill(lineWidth));
                    data.set("a_offset",[].concat.apply([], new Array(positionCount).fill(offset)));
                    this._appendDataIndex(lineData, data, lineData.get('a_position').length / 3);
                }
            }

            lineDatas[i] = lineData;
        }//for_end

        return lineDatas;
    }

    _setWideLineData(xyzs,lineWidth){
        const a_position = [];
        const a_side = [];
        const index=[];
        let c=0;
        const map=this.dataMap;
        for(let i=0,len=xyzs.length/3;i<len;i++){
            //i不是第一个点也不是最后一个点，计算拐点处需要的小矩形
            if(i>0&&i<len-1){
                //在拐点处阔成三个点
                a_position.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                a_position.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                c+=2;
                const delta=this._getDelta(xyzs,i);
                const x1=delta[0],y1=delta[1];
                a_side.push(-y1,x1,y1,-x1);
                index.push(c-2,c-1,c);
                index.push(c,c-1,c+1);
            }
            //存入第i个点对应的坐标值
            a_position.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
            a_position.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
            c+=2;
            //拐点处三角形
            if(i<len-1){
                const delta=this._getDelta(xyzs,i+1);
                const x=delta[0],y=delta[1];
                a_side.push(-y,x,y,-x);
                //第一个三角形
                index.push(c-2,c-1,c);
                //第二个三角形
                index.push(c,c-1,c+1);
            }else{// i==len -1 最后一个点
                const delta=this._getDelta(xyzs,i);
                const x2=delta[0],y2=delta[1];
                a_side.push(-y2,x2,y2,-x2);
            }
        }
        map.set("a_position",a_position);
        map.set("index",index);
        map.set("a_side",a_side);
        return map;
    }

    _getDelta(xyzs,i) {
         const x = xyzs[3 * (i)] - xyzs[3 * (i - 1)],
             y = xyzs[3 * (i) + 1] - xyzs[3 * (i - 1) + 1];
         if (x !== 0 || y !== 0) {
             return [x, y]
         } else {
             const z = xyzs[3 * (i) + 2] - xyzs[3 * (i - 1) + 2];
             return [x, z]
         }
    }


}
;'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.StretchParser = class  extends hmap.core.parser.Parser {
    /**
     * @param painter
     * @param option.drawType 绘制方式，drawArrays|drawElements(默认)
     * @param option.bPrecisionCorrect 精度补偿，缺省为true
     */
    constructor(painter, options = {}) {
        options.drawType = "drawElements";
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.StretchParser";
        this._mapUnit = this.owner.owner._map && this.owner.owner._map.getCrs().getUnit() || 'degrees';
    }

    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }
            this._handleFeature(feature);
        }
        this._dealBlockData(block);
    }

    _handleFeature(feature) {
        feature.buffer = this.dataMap;
        const geometry = feature.getGeometry();
        const attributes = feature.getAttributes() || {};
        let height = attributes.height || 10 + Math.random() * 590;
        if (this._mapUnit === 'degrees') {
            height = height / 111000;
        }
        this._calculateBBox(feature, geometry, height);
        const surfaceColor = attributes.surfaceColor || new hmap.style.Color(0, 211, 211, 0.7);
        const topColor = surfaceColor.clone().deepen(1.3) || new hmap.style.Color(0, 211, 211, 0.7).deepen(1.3);
        const topBorderColor = attributes.topBorderColor || new hmap.style.Color(211, 211, 211, 1);
        if (geometry instanceof hmap.geom.Polygon) {
            this._createPolygonStretch(geometry.getCoordSeqs()[0], height, surfaceColor, topBorderColor, topColor, feature);
        } else if (geometry instanceof hmap.geom.MultiPolygon) {
            let coordSeqs = geometry.getCoordSeqs()[0];
            coordSeqs.forEach(coordSeq => this._createPolygonStretch(coordSeq, height, surfaceColor, topBorderColor, topColor, feature));
        } else if (geometry instanceof hmap.geom.Line) {
            this._createPolylineStretch(geometry.getCoordSeq(), height, surfaceColor, topBorderColor, topColor, feature);
        } else if (geometry instanceof hmap.geom.MultiLine) {
            let coordSeqs = geometry.getCoordSeqs();
            coordSeqs.forEach(coordSeq => this._createPolylineStretch(coordSeq, height, surfaceColor, topBorderColor, topColor, feature));
        } else {
            throw TypeError("the geometry of vector must be instance of hmap.style.Polyline, hmap.geometry.Polygon, hmap.geom.MultiLine " +
                "or hmap.geom.MultiPolygon");
        }
        feature.buffer.set('mode', [this._owner.gl.TRIANGLES]);
        feature.buffer.set('drawCount', [feature.buffer.get('index').length]);
    }


    _createPolygonStretch(baseCoordSeq, height, surfaceColor, topBorderColor, topColor, feature) {
        baseCoordSeq.encloseRing();
        let needReverse = this._needToReverse(baseCoordSeq);
        if (needReverse) baseCoordSeq = baseCoordSeq.reverse();
        let baseCoords = baseCoordSeq.extractCoords();
        let topCoords = baseCoords.map(coord => {
            let x = coord.getOrdinate('X');
            let y = coord.getOrdinate('Y');
            let z = coord.getOrdinate('Z') + height;
            return new hmap.basetype.Coordinate(x, y, z);
        })
        let topCoordSeq = new hmap.basetype.CoordSeq(topCoords);
        this._createPlaneSurface([topCoordSeq], topColor, feature.buffer.get('a_position'), feature.buffer.get('a_color'),
            feature.buffer.get('index'));
        this._createPlaneSurface([baseCoordSeq], surfaceColor, feature.buffer.get('a_position'), feature.buffer.get('a_color'),
            feature.buffer.get('index'), true);
        this._createVerticalSurface(topCoords, baseCoords, surfaceColor, feature.buffer.get('a_position'), feature.buffer.get('a_color'),
            feature.buffer.get('index'));

    }

    /**
     * 生成水平面的顶点，顶点索引，颜色，法向量数组
     * @param coordSeqs {Array} coordSeq数组
     * @param color {hmap.style.Color} 颜色
     * @param surfacePosition {Array} 存放表面顶点位置的数组
     * @param surfaceColor {Array} 存放顶点颜色的数组
     * @param surfaceIndices {Array} 存放顶点索引的数组
     * @param normals {Array} 存放每个顶点法向量的数组
     * @param isReverse {Boolean} 是否反转顶点，顶面不需要反转，底面需要反转，默认为false
     * @private
     */
    _createPlaneSurface(coordSeqs, color, surfacePosition, surfaceColor, surfaceIndices, isReverse = false) {
        let ptsCount = surfacePosition.length / 3;
        let XYZs = hmap.strategy.EarCut.triangulatePolygon(coordSeqs);
        if (isReverse) {
            let tempXYZs = [],
                len = XYZs.length / 3;
            tempXYZs.push(...XYZs.slice((len - 1) * 3));
            for (let i = len - 2; i > -1; i--) {
                tempXYZs.push(...XYZs.slice(i * 3, (i + 1) * 3));
            }
            XYZs = tempXYZs;
        }
        for (let i = 0, len = XYZs.length / 3; i < len; i++) {
            surfacePosition.push(XYZs[i * 3]);
            surfacePosition.push(XYZs[i * 3 + 1]);
            surfacePosition.push(XYZs[i * 3 + 2]);
            surfaceColor.push(...color.toNormalizeArray());
            surfaceIndices.push(ptsCount + i);
        }
    }

    /**
     * 生成垂直面顶点，顶点索引，颜色，法向量
     * @param topCoords {Array} 顶部坐标数组
     * @param baseCoords {Array} 底部坐标数组
     * @param color {hmap.style.Color} 颜色
     * @param surfacePosition{Array} 存放表面顶点位置的数组
     * @param surfaceColor {Array} 存放顶点颜色的数组
     * @param surfaceIndices {Array} 存放顶点索引的数组
     * @param normals {Array} 存放每个顶点法向量的数组
     * @private
     */
    _createVerticalSurface(topCoords, baseCoords, color, surfacePosition, surfaceColor, surfaceIndices) {
        for (let i = 1, len = topCoords.length; i < len; i++) {
            let ptsCount = surfacePosition.length / 3;
            let preTopCoord = topCoords[i - 1];
            let preBaseCoord = baseCoords[i - 1];
            let topCoord = topCoords[i];
            let baseCoord = baseCoords[i];
            let [preTopX, preTopY, preTopZ] = [preTopCoord.getOrdinate('X'), preTopCoord.getOrdinate('Y'), preTopCoord.getOrdinate('Z')];
            let [preBaseX, preBaseY, BaseZ] = [preBaseCoord.getOrdinate('X'), preBaseCoord.getOrdinate('Y'), preBaseCoord.getOrdinate('Z')];
            let [topX, topY, topZ] = [topCoord.getOrdinate('X'), topCoord.getOrdinate('Y'), topCoord.getOrdinate('Z')];
            let [baseX, baseY, baseZ] = [baseCoord.getOrdinate('X'), baseCoord.getOrdinate('Y'), baseCoord.getOrdinate('Z')];
            surfacePosition.push(preTopX, preTopY, preTopZ, preBaseX, preBaseY, BaseZ, topX, topY, topZ, baseX, baseY, baseZ);
            let colorArray = color.toNormalizeArray();
            surfaceColor.push(...colorArray, ...colorArray, ...colorArray, ...colorArray);
            surfaceIndices.push(ptsCount, ptsCount + 1, ptsCount + 3,
                ptsCount, ptsCount + 3, ptsCount + 2);
        }
    }

    /**
     * 判断坐标序列是否需要反转，如果是逆时针，返回false；顺时针，返回true
     * @param coordSeq {hmap.basetype.CoordSeq} 待判断的坐标序列
     * @returns {Boolean} 坐标序列是逆时针返回false，顺时针返回true
     * @private
     */
    _needToReverse(coordSeq) {
        let coords = coordSeq.extractCoords(),
            len = coords.length;
        let xMax = -180,
            xMaxIndex = 0,
            preCoord = null;
        for (let i = 0; i < len - 1; i++) {
            let x = coords[i].getOrdinate('X');
            if (x >= xMax) {
                xMax = x;
                xMaxIndex = i;
            }
        }
        let currCoord = coords[xMaxIndex];
        if (xMaxIndex == 0) preCoord = coords[len - 2];
        else preCoord = coords[xMaxIndex - 1];
        let nextCoord = xMaxIndex + 1 >= len ? coords[0] : coords[xMaxIndex + 1];
        let x0 = preCoord.getOrdinate('X'), y0 = preCoord.getOrdinate('Y'),
            x1 = currCoord.getOrdinate('X'), y1 = currCoord.getOrdinate('Y'),
            x2 = nextCoord.getOrdinate('X'), y2 = nextCoord.getOrdinate('Y');
        let res = (x1 - x0) * (y2 - y1) - (y1 - y0) * (x2 - x1);
        return res < 0;
    }

    /**
     * 计算拉伸体三维包围盒
     * @param {hmap.geom.Geometry} geometry 构建拉伸体的几何体，可以是线、多边形、多线、多面。
     * @param {Number} height 拉伸体高度
     * @private
     */
    _calculateBBox(feature, geometry, height) {
        let bbox = geometry.getBBox();
        let maxZ = bbox.getMaxZ();
        maxZ += height;
        bbox.setMaxZ(maxZ);
        feature._bbox = bbox;
        geometry._bbox = bbox;
    }
}
;"use strict";
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.SDFLineTextParser=class extends hmap.core.parser.Parser{
    constructor(painter, options={}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.SDFLineTextParser";
    }
    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.buffer) {
                continue;
            }
            if(!this._handleFeature(feature)){
                block.features.splice(i,1);
            };
        }
        // console.log(block.features)
        this._dealBlockData(block);
    }
    _dealBlockData(block) {
        this._initRenderData(block);
        const features = block.features;
        for (let i = 0, l = features.length; i < l; i++) {
            if(!features[i]._attributes.showLabel){
                features[i]._attributes["showLabel"]=true;
                continue;
            }
            this._precisionCorrect(features[i].buffer);
            this._appendBlockData(block, features[i].buffer);
        }

        this._owner.bufferToGPU(block);//将数据刷新的GPU里
    }

    _handleFeature(feature){
        const buffer = this.dataMap;
        feature.buffer = buffer;
        const coord = feature.getGeometry().getCoordinate();
        const xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")];
        const text=feature._attributes.text;
        const angle=feature._attributes.angle;
        const len=text.length;
        const symbol=feature.getStyle()._textSymbols[0];
        if(!symbol){
            return false;
        }
        if(!symbol.display){
            return false;
        }
        const color=symbol._fontColor.toNormalizeArray();
        const textInfo=this.owner.owner.textInfo;
        const scale=symbol._fontSize/textInfo.fontSize;
        // const extent=feature._attributes.extent;
        // extent[0]=extent[0]*scale;
        // extent[1]=extent[1]*scale;
        // extent[2]=extent[2]*scale;
        // extent[3]=extent[3]*scale;
        // feature._attributes.extent=extent;
        for(let i=0;i<len;i++){
            buffer.get('a_rotate').push(angle,angle,angle,angle)
            const position=buffer.get('a_position');
            position.push(...xyz);
            position.push(...xyz);
            position.push(...xyz);
            position.push(...xyz);
            // position.push(xyz[0]+offset[0][0]*scale,xyz[1]+offset[0][1]*scale,xyz[2]);
            // position.push(xyz[0]+offset[1][0]*scale,xyz[1]+offset[1][1]*scale,xyz[2]);
            // position.push(xyz[0]+offset[2][0]*scale,xyz[1]+offset[2][1]*scale,xyz[2]);
            // position.push(xyz[0]+offset[3][0]*scale,xyz[1]+offset[3][1]*scale,xyz[2]);
            const offset=feature._attributes.offset[i];
            const coordOffset=buffer.get('a_coordOffset');
            coordOffset.push(offset[0][0]*scale,offset[0][1]*scale,0);
            coordOffset.push(offset[1][0]*scale,offset[1][1]*scale,0);
            coordOffset.push(offset[2][0]*scale,offset[2][1]*scale,0);
            coordOffset.push(offset[3][0]*scale,offset[3][1]*scale,0);
            const textArr=this.owner.textAtlas.texture[text[i]];
            const textCoord=buffer.get('a_textureCoord');
            textCoord.push((textArr.x+textInfo.buffer)/textInfo.w,(textArr.y+textInfo.buffer)/textInfo.h);
            textCoord.push((textArr.x+textInfo.buffer)/textInfo.w,(textArr.y+textInfo.fontSize+textInfo.buffer)/textInfo.h);
            textCoord.push((textArr.x+textArr.w+textInfo.buffer)/textInfo.w,(textArr.y+textInfo.fontSize+textInfo.buffer)/textInfo.h);
            textCoord.push((textArr.x+textArr.w+textInfo.buffer)/textInfo.w,(textArr.y+textInfo.buffer)/textInfo.h);
            buffer.get('a_color').push(color[0],color[1],color[2],color[3],color[0],color[1],color[2],color[3],color[0],color[1],color[2],color[3],color[0],color[1],color[2],color[3]);
            buffer.get('index').push(i*4,i*4+1,i*4+2,i*4,i*4+2,i*4+3);
            // console.log(text[i]+"|"+buffer.get('a_coordOffset')+"|"+buffer.get('index'));
        }
        buffer.set('mode', [this._owner.gl.TRIANGLES]);
        buffer.set('drawCount', [buffer.get('index').length]);
        return true;
    }
};"use strict";
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.SDFPointTextParser=class extends hmap.core.parser.Parser{
    constructor(painter, options={}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.SDFPointTextParser";
    }
    handleBlock(block) {
        const features = block.features;
        let len=features.length;
        for (let i = len - 1; i >=0; i--) {
            const feature = features[i];
            if (feature.bufferText) {
                continue;
            }
            if(!this._handleFeature(feature)){
                block.features.splice(i,1);
            }
        }
        // console.log(block.features)
        this._dealBlockData(block);
    }
    _dealBlockData(block) {
        this._initRenderData(block);
        const features = block.features;

        const len=features.length;
        for (let i = len-1;i>=0; i--) {
            // console.log("Label:"+features[i]._attributes.text+features[i]._attributes.showLabel)
            if(!features[i]._attributes.showLabel){
                features[i]._attributes["showLabel"]=true;
                continue;
            }
            this._precisionCorrect(features[i].bufferText);
            this._appendBlockData(block, features[i].bufferText);
        }

        this._owner.bufferToGPU(block);//将数据刷新的GPU里
    }
    _handleFeature(feature){
        const buffer = this.dataMap;
        feature.bufferText = buffer;
        const coord = feature.getGeometry().getCoordinate();
        const xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")];
        const text=feature._attributes.text;
        if(!text){
            return false;
        }
        const len=text.length;
        const style=feature.getStyle();
        const iconStyle=style._markerSymbols[0];
        const textStyle=style._textSymbols[0];
        if(!textStyle){
            return false;
        }
        if(!textStyle.display){
            return false;
        }
        let offsetIcon=0;
        if(iconStyle){
            offsetIcon=iconStyle._fontSize/2;
        }
        const color=textStyle._fontColor.toNormalizeArray();
        const textInfo=this.owner.owner.textInfo;
        const scale=textStyle._fontSize/textInfo.fontSize;
        const extent=feature._attributes.extent;
        extent[0]=extent[0]*scale;
        extent[1]=extent[1]*scale-offsetIcon;
        extent[2]=extent[2]*scale;
        extent[3]=extent[3]*scale+offsetIcon;
        feature._attributes.extent=extent;
        // console.log(text)
        for(let i=0;i<len;i++){
            buffer.get('a_position').push(...xyz);
            const offset=feature._attributes.offset[i];
            const textArr=this.owner.textAtlas.texture[text[i]];
            buffer.get('a_offset').push(offset[0]*scale,-offset[1]*scale-offsetIcon);
            buffer.get('a_size').push(textInfo.fontSize*scale,textInfo.fontSize*scale);
            buffer.get('a_angle').push(0);
            buffer.get('a_texAttr').push((textArr.x+textInfo.buffer)/textInfo.w,(textArr.y+textInfo.buffer)/textInfo.h,(textArr.w)/textInfo.w,textInfo.fontSize/textInfo.h);
            buffer.get('a_color').push(...color);
            // console.log(text[i]+"|"+textArr.x+","+textArr.y)
        }
        buffer.set('mode', [this._owner.gl.POINTS]);
        buffer.set('drawCount', [buffer.get('a_position').length / 3]);
        return true;
    }
};"use strict";
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.SDFIconParser=class extends hmap.core.parser.Parser{
    constructor(painter, options={}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.SDFIconParser";
    }
    handleBlock(block) {
        const features = block.features;
        for (let i = features.length - 1; i > -1; i--) {
            const feature = features[i];
            if (feature.bufferIcon) {
                continue;
            }
            if(!this._handleFeature(feature)){
                block.features.splice(i,1);
            }
        }
        // console.log(block.features)
        this._dealBlockData(block);
    }
    _dealBlockData(block) {
        this._initRenderData(block);
        const features = block.features;
        for (let i = features.length-1;i>=0; i--) {
            // console.log("icon:" + features[i]._attributes.text + features[i]._attributes.showIcon)
            if (!features[i]._attributes.showIcon) {
                features[i]._attributes["showIcon"] = true;
                continue;
            }
            this._precisionCorrect(features[i].bufferIcon);
            this._appendBlockData(block, features[i].bufferIcon);
        }

        this._owner.bufferToGPU(block);//将数据刷新的GPU里
    }
    _handleFeature(feature){
        const buffer = this.dataMap;
        feature.bufferIcon = buffer;
        const coord = feature.getGeometry().getCoordinate();
        const xyz = [coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z")];
        buffer.set('a_position', []);
        buffer.set('a_size', []);
        buffer.set('a_offset', []);
        buffer.set('a_angle', []);
        buffer.set('a_texAttr', []);
        const iconStyle=feature.getStyle()._markerSymbols[0];
        if(!iconStyle){
            return false;
        }
        if(!iconStyle.display){
            return false;
        }
        const textInfo=this.owner.owner.iconInfo;
        const textArr=this.owner.owner.iconJson[feature._attributes.featureType];
        if(!textArr){
            return false;
        }
        const fontSize=iconStyle._fontSize;
        const offset = iconStyle.getOffset();
        buffer.get('a_position').push(...xyz);
        buffer.get('a_offset').push(offset.getValue("X"), offset.getValue("Y"));
        buffer.get('a_size').push(fontSize,fontSize);
        buffer.get('a_texAttr').push(textArr.x/textInfo.w,textArr.y/textInfo.h,textArr.w/textInfo.w,textArr.w/textInfo.h);
        buffer.get('a_angle').push(0);
        buffer.set('mode', [this._owner.gl.POINTS]);
        buffer.set('drawCount', [buffer.get('a_position').length / 3]);
        return true;
    }
};'use strict';
hmap.core = hmap.core || {};
hmap.core.parser = hmap.core.parser || {};
hmap.core.parser.TmsParser = class  extends hmap.core.parser.Parser {
    constructor(painter, options = {}) {
        super(painter, options);
        this.CLASS_NAME = "hmap.core.parser.TmsParser";
        this.glHelper = hmap.help.glHelper.get(this.owner.gl);
    }

    handleBlock(block) {
        const promises = [],
            feature = block.features[0];
        feature.buffer = this.dataMap;
        block.textures = [];
        block.textures.push(block.id);
        promises.push(...this._handleFeature(feature));

        Promise.all(promises).then(() => {
            this._dealBlockData(block);
            this.owner.owner._map.event.dispatch(new hmap.event.MapEvent(EventType.LAYEREVENT_DATACHANGE));
        })
        //     .catch(err => {
        //     console.error(err.message)
        // });
    }

    _handleFeature(tile) {
        const buffer = tile.buffer,
            ext = tile.get("ext"),
            l = ext.getLeft(),
            r = ext.getRight(),
            t = ext.getTop(),
            b = ext.getBottom(),
            tiles = tile.get('subXYZ'),
            promises = [];
        buffer.set('a_position', [
            l,t,0.0,
            l,b,0.0,
            r,t,0.0,
            r,b,0.0,
        ]);
        buffer.set('a_textureCoord', [
            0.0,0.0,
            0.0,1.0,
            1.0,0.0,
            1.0,1.0,
        ]);
        buffer.set('mode', [this.owner.gl.TRIANGLE_STRIP]);
        buffer.set('drawCount', [4]);

        const layer = this.owner.owner,
            tileSize = layer.getTileSize(),
            width = tileSize.getWidth(),
            height = tileSize.getHeight(),
            texture = this.glHelper.getTextureObject(tile.url);
        texture.bufferImage2(width * layer._groupSideLength, height * layer._groupSideLength, 'RGBA', 'UNSIGNED_BYTE', null);

        for(let i = tiles.length - 1; i > -1; i--) {
            const subTile = tiles[i],
                texFill = subTile.texFill,
                offset = subTile.offset,
                img = texFill.getTexure();
            if (img) {
                texture.bufferSubImage(offset[0], offset[1], width, height, img);
                delete subTile.texFill;
                // texture.bufferImage(img);
            }
            else {
                const promise = texFill.promise.then(() => {
                    texture.bindTexture();
                    texture.bufferSubImage(offset[0], offset[1], width, height, texFill.getTexure());
                    // texture.bufferImage(texFill.getTexure());
                    delete subTile.texFill;
                });
                promises.push(promise);
            }
        }

        return promises;
    }
}
;hmap.core=hmap.core||{};
hmap.core.Time=class{
    constructor(){
        this._start=this.now();
        this.CLASS_NAME = "hmap.core.Time";
    }
    reset(){
        this._start=this.now();
    }
    timeDown(total=13){
        return total-(this.now()-this._start);
    }
    now(){
        return Date.now();
    }
}
;'use strict';
hmap.core = hmap.core || {};

/**
 * 精度辅助计算
 * @type {hmap.core.Precision}
 * @private
 */
class Precision{
    constructor(unit){
        if(unit==="m"){
            this.divide=this.divideMi;
            this.multiDivide=this.multiDivideMi;
        }else{
            this.divide=this.divideDu;
            this.multiDivide=this.multiDivideDu;
        }
        this.CLASS_NAME = "hmap.core.Precision";
    }
    divideMi(num){
        const high=Math.floor((num/65536));
        const low=num-high*65536;
        return [high,low];
    }
    multiDivideMi(nums){
        let high=[];
        let low=[];
        for(let i=0,len=nums.length;i<len;i++){
            let dv=this.divideMi(nums[i]);
            high[high.length]=dv[0];
            low[low.length]=dv[1];
            dv=null;
        }
        return [high,low];
    }
    divideDu(num){
        const high = Math.floor(num);
        const low = num-high;
        return [high, low];

    }
    multiDivideDu(nums){
        let high=[];
        let low=[];
        for(let i=0,len=nums.length;i<len;i++){
            let dv=this.divideDu(nums[i]);
            high[high.length]=dv[0];
            low[low.length]=dv[1];
            dv=null;
        }
        return [high,low];
    }
};
hmap.core.Precision=Precision;
;hmap.help = hmap.help || {};
hmap.help.SequeBlockHelper = class {
    constructor(blocks, size = 2000) {
        this._size = size;
        this._blocks = blocks;
        this._curBlock;
        this.CLASS_NAME = "hmap.help.SequeBlockHelper";
    }

    get() {
        if (!this._curBlock||this._curBlock.features.length >= this._size) {
            this._curBlock = this._createBlock();
        }
        return this._curBlock;
    }

    //进行分段重组
    merge() {

    }

    filterBlocks(extent) {
        return [...this._blocks.values()]
    }

    _createBlock() {
        let block = new hmap.core.Block();
        block.renderData=new Map();
        this._blocks.set(block.id, block);
        return block;
    }
}
;hmap.help = hmap.help || {};
hmap.help.VTileBlockHelper = class {
    constructor(blocks) {
        this._blocks = blocks;
        this.CLASS_NAME = "hmap.help.VTileBlockHelper";
    }

    get(feature) {
        const url = feature.url;
        if (!this._blocks.has(url)) {
            this._curBlock = this._createBlock(url);
            return this._curBlock;
        }
        return this._blocks.get(url);
    }

    //进行分段重组
    merge() {
        return this;
    }

    filterBlocks(urls) {
        const arrBlocks = [];
        for (let url of urls.keys()) {
            const block = this._blocks.get(url);
            if (block) {
                arrBlocks.push(block);
            }
        }
        return arrBlocks;
    }

    _createBlock(url) {
        let block = new hmap.core.Block(url);
        block.renderData=new Map();
        this._blocks.set(url, block);
        return block;
    }

    // 根据url删除block
    deleteBlock(url){
        this._blocks.delete(url);
        return this;
    }
}
;hmap.help = hmap.help || {};
hmap.help.Sprite = class {
    constructor(url){
        this.url = url;
        this.request = this._sendRequest();
        this.load = false;
        this.CLASS_NAME = "hmap.help.Sprite";
    }

    _sendRequest(){
        const me = this;
        const loadImage=new Promise((resolve,reject)=>{
            hmap.util.Ajax.get(me.url + ".png", 'blob',
                blob => {
                    const img = new Image(),
                        url = URL.createObjectURL(blob);
                    img.onload = () => {
                        resolve(img);
                    }
                    img.src = url;
                },
                err => {
                    reject(err);
                })
            }
        );
        const loadJson = new Promise(function(resolve,reject){
            hmap.util.Ajax.get(me.url+".json","json",
                function(result){
                    resolve(result);
                },
                function(error){
                    reject(error);
                }
            );
        });
        return new Promise(resolve => {
            Promise.all([loadImage, loadJson]).then((result) => {
                this.spriteImg = result[0];
                this._width = this.spriteImg.width;
                this._height = this.spriteImg.height;
                this._info = result[1];
                this.load = true;
                resolve();
            }).catch((error) => {
                console.log(error)
            })
        })
    }

    /**
     * 返回指定图标的纹理坐标
     * @param name {String} 图标名称
     * @returns {Array} 图标的纹理坐标，顺序为从图标左上角，按逆时针旋转
     */
    getTextureCoord(name) {
        const info = this._info[name];
        if (!info.textureCoord) {
            const left = (info.x + 1) / this._width;
            const top = (info.y + 1) / this._height;
            const width = (info.width - 2) / this._width;
            const height = (info.height - 2) / this._height;
            info.textureCoord = [left, top, width, height];
        }
        return info.textureCoord;
    }
}
;class GLHelper{
    constructor(gl){
        this.gl=gl;
        this.helpers=new Map();
        this.textureObjects=new Map();
        this.programs=new Map();
        this.CLASS_NAME = "hmap.help.glHelper";
    }
    get(gl){
        if(!this.helpers.has(gl)){
            this.helpers.set(gl,new GLHelper(gl));
        }
        return this.helpers.get(gl);
    }
    _createTextureObject(name,unit=0,textureSymbol={}){
        const gl=this.gl;
        let texture=gl.createTexture();

        const min_filter=textureSymbol.min_filter?gl[textureSymbol.min_filter]:gl.LINEAR;
        const mag_filter=textureSymbol.mag_filter?gl[textureSymbol.mag_filter]:gl.LINEAR;
        const wrap_s=textureSymbol.wrap_s?gl[textureSymbol.wrap_s]:gl.CLAMP_TO_EDGE;
        const wrap_t=textureSymbol.wrap_t?gl[textureSymbol.wrap_t]:gl.CLAMP_TO_EDGE;

        gl.activeTexture(gl.TEXTURE0+unit);
        gl.bindTexture(gl.TEXTURE_2D,texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,min_filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,mag_filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap_s);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap_t);
        const textureObject=new TextureObject(gl,texture,unit);
        this.textureObjects.set(name,textureObject);
        return this.textureObjects.get(name);
    }
    destroy(){
        this.textureObjects.forEach((value,key)=>{
            value.destroy();
        });
        this.textureObjects.clear();
        this.programs.forEach((value,key)=>{
            value.destroy();
        });
        this.programs.clear();
    }

    removeTextureObject(name){
        let textureOjb=this.getTextureObject(name);
        textureOjb.destroy();
        textureOjb=null;
        this.textureObjects.delete(name);
    }
    getTextureObject(name,unit=0,textureSymbol){
        if(!name){
           throw new Error("异常");
        }
        if(!this.textureObjects.has(name)){
            this._createTextureObject(name,unit,textureSymbol);
        }else{
            this.textureObjects.get(name).bindTexture();
        }
        return this.textureObjects.get(name);//textureObject
    }
    addProgram(program) {
        // this.programs.set(program.id, program);
        // return program;
        const id = program.id;
        if (this.programs.has(id)) {
            program.destroy();
            program = null;
            return this.programs.get(id);
        } else {
            this.programs.set(program.id, program);
            return program;
        }
    }
    hasProgram(id){
        return this.programs.has(id);
    }
    getProgram(id){
        return this.programs.get(id);
    }
}
class TextureObject{
    constructor(gl,texture,unit=0){
        this.gl=gl;
        this.texture=texture||null;
        this.unit=unit;
        this.image=null;
    }
    bufferImage(img,force=false){
        if(!this.image ||force){
            const gl = this.gl;
            gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
            this.image=img;
            return this;
        }
    }

    bufferImage2(width, height, format, type, data) {
        const gl = this.gl;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl[format], width, height, 0, gl[format], gl[type], data);
    }

    bufferSubImage(offsetX, offsetY, width, height, img) {
        const gl = this.gl;
        gl.texSubImage2D(gl.TEXTURE_2D, 0, offsetX, offsetY, width, height, gl.RGBA, gl.UNSIGNED_BYTE, img);
    }

    bindTexture(){
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0+this.unit);
        gl.bindTexture(gl.TEXTURE_2D,this.texture);
    }


    destroy(){
        this.gl.deleteTexture(this.texture);
        for(const e in this){
            delete this[e];
        }
    }
}

hmap.help = hmap.help || {};
hmap.help.glHelper = new GLHelper();
;hmap.core=hmap.core||{};
hmap.core.AF=class {
    /**
     * @param map 地图容器
     * @param i idel时间 单个任务不超过50ms
     * @param a 每一帧的绘制时间
     */
    constructor(map,i=50,a=16){
        this.CLASS_NAME = "hmap.core.AF";
        this.i=i;
        this.a=a;
        this.state=0;//0 空闲  ，1 正在执行帧
        this.map=map;
        this.taskManager=hmap.core.TaskManager.instance();
        this.time=new hmap.core.Time();
        this.map.event.addListener(EventType.MAPEVENT_CENTERCHANGE,this.active.bind(this));
        this.map.event.addListener(EventType.MAPEVENT_ZOOMCHANGE,this.active.bind(this));
        this.map.event.addListener(EventType.MAPEVENT_HEADINGCHANGE,this.active.bind(this));
        this.map.event.addListener(EventType.MAPEVENT_TILTCHANGE,this.active.bind(this));
        this.map.event.addListener(EventType.LAYEREVENT_DATACHANGE,this.active.bind(this));
    }
    active(){
        this.runFrame();
        return this;
    }
    runFrame(){
        if(this.state!=1){
            this.state=1;
            window.requestAnimationFrame(this.runAnimateframe.bind(this));
        }
        return this;
    }
    runAnimateframe(){
        //计时器重置
        this.time.reset();
        let doSimpleTask=true;
        let doHeavyTask=true;
        while (this.time.timeDown(this.a)>0&& doSimpleTask){
            doSimpleTask=this.taskManager.runSimple();
        }
        this.map.redraw(1);
        this.state=0;
        if(this.taskManager.hasSimpleTask()){
            this.active();
            return;
        }else{
            this.time.reset();
            while(this.time.timeDown(this.i)>5 && doHeavyTask){
                doHeavyTask=this.taskManager.runHeavy();
            }
            if(this.taskManager.hasHeavyTask()){
                this.active();
                return;
            }
        }
    }
}
;hmap.core=hmap.core||{};
hmap.core.TaskManager=class {
    constructor(){
        this.CLASS_NAME = "hmap.core.TaskManager";
        this._simpleTask=[];
        this._heavyTask=[];
        this._simpleTaskFag=new Set();
        this._heavyTaskFag=new Set();
    }
    get simpleTask(){
        return this._simpleTask;
    }
    get heavyTask(){
        return this._heavyTask;
    }

    static instance(){
        if(!this._instance) {
            this._instance = new hmap.core.TaskManager();
        }
        return this._instance;
    }

    hasSimpleTask(){
        return this.simpleTask.length>0;
    }
    hasHeavyTask(){
        return this.heavyTask.length>0;
    }
    addSimple(scope,fun,param){
        const key=scope.id + param.id;
        if(!this._simpleTaskFag.has(key)){
            this.simpleTask[this.simpleTask.length]={"scope":scope,"fun":fun,"param":param,"key":key};
            this._simpleTaskFag.add(key);
        }
        return this;
    }
    addFilterTask(scope,fun,param){
        const key=scope.id+param.id;
        if(!this._simpleTaskFag.has(key)){
            this.filter = {"scope":scope,"fun":fun,"param":param,"key":key};
            this.filter.param.doTask=1;
            this.simpleTask[this.simpleTask.length] =this.filter;
            this._simpleTaskFag.add(key);
        }else{
            this.filter.param=param;
            this.filter.param.doTask=1;
        }
        return this;
    }
    addHeavy(scope,fun,param){
        this.heavyTask[this.heavyTask.length]={"scope":scope,"fun":fun,"param":param};
        return this;
    }
    runSimple(){
        //如果执行了任务，则返回true，否则返回false
        if(!this.hasSimpleTask()) {
            return false;
        }
        const len=this.simpleTask.length;
        for (let i=len-1;i>=0;i--){
            let task=this.simpleTask[i];
            if (task.param.doTask) {
                task.fun.call(task.scope,task.param);
            }
            this.simpleTask.splice(i,1);
            this._simpleTaskFag.delete(task.key);
            task=null;
            return true;
        }
    }
    runHeavy(){
        //如果执行了任务，则返回true，否则返回false
        if(!this.hasHeavyTask()) {
            return false;
        }
        const len=this.heavyTask.length;
        for (let i=len-1;i>=0;i--){
            let task=this.heavyTask[i];
            task.fun.call(task.scope,task.param);
            this.heavyTask.splice(i,1);
            // this._heavyTaskFag.delete(task.key);
            task=null;
            return true;
        }
    }
}
// =====testCase==============
// function  add(a) {
//     console.log(a)
// }
// let t=hmap.core.TaskManager.instance();
// t.addSimple(this,add,1);
// t.addSimple(this,add,2);
// t.runSimple();
// t.runSimple();
// t.runSimple();
;hmap.core=hmap.core||{};
hmap.core.Throttle=class {
    constructor(scope,delay=0){
        this.CLASS_NAME = "hmap.core.Throttle";
        this.delay=delay;
        if(delay===0){
            this.run=this.run2;
        }else{
            this.run=this.run1;
        }
        this.timer=null;
        this.previous=0;
        this.now=0;
        this.scope=scope;
    }
    run1(func,...params){
        const scope=this.scope;
        this.now = new Date().getTime();
        if (this.now - this.previous <= this.delay) {
            clearTimeout(this.timer);
        }
        this.timer = setTimeout(function () {
            func.call(scope,...params);
            this.timer=null;
        }.bind(this), this.delay);
        this.previous=this.now;
    }
    run2(func,...params){
        const scope=this.scope;
        clearTimeout(this.timer);
        this.timer = setTimeout(function () {
            func.call(scope,...params);
            this.timer=null;
        }.bind(this));
    }
    destroy(){
        if(this.timer){
            clearTimeout(this.timer);
        }
        this.timer=null;
    }
}

// let bb=0;
// const ss=function(a,b,c) {
//     console.log(bb+a+b+c)
// }
// let t=new Throttle(this,0);
// for(let i=0;i<100;i++){
//     bb++;
//     t.run(ss,1,2,3)
// }
;hmap.core = hmap.core || {};
hmap.core.Block = class {
    constructor(id) {
        this.buffer = null;
        this.features = [];
        this.CLASS_NAME = "hmap.core.Block";
        this.id = id || hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.doTask = 1;
    }

    add(feature) {
        this.features[this.features.length] = feature;
        feature.bid = this.id;
    }

    delete(feature) {
        const len = this.features.length;
        for (let i = len - 1; i >= 0; i--) {
            if (feature._id === this.features[i]._id) {
                feature.buffer = null;
                delete feature.bid;
                this.features.splice(i, 1);
                break;
            }
        }
    }

    update(feature) {
        feature.buffer = null;
    }

    clear() {
        this.buffer = null;
        const len = this.features.length;
        for (let i = len - 1; i >= 0; i--) {
            const feature = this.features[i];
            feature.buffer = null;
            delete feature.bid;
            delete feature.bufferText;
            delete feature.bufferIcon;
        }
        this.features=[];
    }
}
;hmap.help = hmap.help || {};
hmap.help.SpatialBlockHelper = class {
    constructor(blocks, option) {
        this._blocks = blocks;
        this._size = option.size;       //格网大小
        this._level = option.level;     //空间划分等级
        this._worldExtent = option.worldExtent;         //坐标系范围
        this._origin = this._worldExtent.getTopLeft();  //切片计算原点
        const res0 = this._worldExtent.getWidth() / this._size[0];
        this._resolution = res0 / Math.pow(2, this._level); //等级对应分辨率
        this.CLASS_NAME = "hmap.help.SpatialBlockHelper";
    }

    get(feature) {
        const id = this._createId(...this._getXYByCoord(feature.getExtent().getCenter()));
        if (feature.bid && feature.bid === id) {
            return this._blocks.get(id);
        }
        if (!this._blocks.has(id)) {
            this._createBlock(id);
        }
        return this._blocks.get(id);
    }

    //进行分段重组
    merge() {
        return this;
    }

    filterBlocks(extent) {
        const [minX, minY] = this._getXYByCoord(extent.getTopLeft());
        const [maxX, maxY] = this._getXYByCoord(extent.getBottomRight());
        const arrBlocks = [];
        for (let x = maxX + 1; x >= minX - 1; x--) {
            for (let y = maxY + 1; y >= minY - 1; y--) {
                const id = this._createId(x, y, this._level);
                if (this._blocks.has(id)) {
                    arrBlocks.push(this._blocks.get(id));
                }
            }
        }
        return arrBlocks;
    }

    _getXYByCoord(coord) {
        const minGeoY = (this._origin.getOrdinate("Y") - coord.getOrdinate("Y")) / this._resolution;
        const minY = Math.floor(minGeoY / this._size[1]);
        const minGeoX = (coord.getOrdinate("X") - this._origin.getOrdinate("X")) / this._resolution;
        const minX = Math.floor(minGeoX / this._size[0]);
        return [minX, minY];
    }

    _createId(x, y) {
        return x + "-" + this._level + "-" + y;
    }

    _createBlock(id) {
        let block = new hmap.core.Block();
        block.id = id;
        block.renderData=new Map();
        this._blocks.set(block.id, block);
        return block;
    }
};"use strict";
hmap.basetype = hmap.basetype || {};
/**
 * 表达一个对象尺寸的类，含有宽度和高度。
 * @type {hmap.basetype.Size}
 * @example
 * let size = new hmap.basetype.Size(20,30);
 */
hmap.basetype.Size = class {
    /**
     * 构造函数
     * @param width 宽度，大于等于0的数值类型。
     * @param height 高度，大于等于0的数值类型。
     * @throws 当参数width、height不是数值类型时或者当参数width、height是小于0的数值时，抛出异常
     */
    constructor(width = 0, height = 0) {
        if (Number.isFinite(width) && Number.isFinite(height) && width >= 0 && height >= 0) {
            this._width = width;
            this._height = height;
        } else {
            throw new TypeError("Parameter must be a number and greater than or equal to zero");
        }
        this.CLASS_NAME = "hmap.basetype.Size";
    }

    /**
     * 克隆Size对象
     * @return {hmap.basetype.Size}
     * @example
     * let newSize = size.clone();
     */
    clone() {
        return new hmap.basetype.Size(this._width, this._height);
    }

    /**
     * 判断两个Size实例是否相等
     * @param size 待检测的size对象
     * @return {Boolean} 相等返回true，否则返回false。
     * @example
     * let size2 = new hmap.basetype.Size(21,31);
     * let result = size.equals(size2);
     */
    equals(size) {
        if (size instanceof hmap.basetype.Size) {
            if (size._width === this._width && size._height === this._height) {
                return true;
            }
        }
        return false;
    }

    /**
     * 销毁Size对象
     * @example
     * size.destroy();
     */
    destroy() {
        delete this._width;
        delete this._height;
    }

    /**
     * 获取宽度值
     * @return {Number} 宽度值
     * @example
     * let width = size.getWidth();
     */
    getWidth() {
        return this._width;
    }

    /**
     * 获取高度值
     * @return {Number} 高度值
     * @example
     * let height = size.getHeight();
     */
    getHeight() {
        return this._height;
    }

    /**
     * 设置宽度
     * @param {Number} width 大于等于0的数值
     * @throws 当参数width不是数值类型或者是小于0的数值时，抛出异常
     * @example
     * size.setWidth(22);
     */
    setWidth(width) {
        if (Number.isFinite(width) && width >= 0) {
            this._width = width;
        } else {
            throw new TypeError("Parameter should be a number and greater than or equal to zero.");
        }
    }

    /**
     * 设置高度
     * @param {Number} height  大于等于0的数值
     * @throws 当参数height不是数值类型或者是小于0的数值时，抛出异常
     * @example
     * size.setHeight(22);
     */
    setHeight(height) {
        if (Number.isFinite(height) && height >= 0) {
            this._height = height;
        } else {
            throw new TypeError("Parameter should be a number and greater than or equal to zero.");
        }
    }

    /**
     * 返回当前实例字符串表示
     * @return {String} 一个字符串
     * @example
     * let str = size.toString();
     */
    toString() {
        return this._width + "," + this._height;
    }
};"use strict";
hmap.basetype=hmap.basetype || {};
/**
 * 像素坐标，像素单位。
 * @type {hmap.basetype.Pixel}
 * @example
 * let pixel = new hmap.basetype.Pixel(100,200);
 */
hmap.basetype.Pixel=class{
    /**
     * 构造一个像素坐标。
     * @param {Number} x  横坐标，向右为正
     * @param {Number} y  竖坐标，向下为正
     * @throws 当参数x或者参数y不是数值类型时，抛出异常
     */
    constructor(x,y){
        if(!Number.isFinite(x) || !Number.isFinite(y)){
            throw new Error("the params must be numbers!");
        }else{
            this._x=x;
            this._y=y;
        }
        this.CLASS_NAME = "hmap.basetype.Pixel";
    }
    /**
     * 克隆一个新像素
     * @return {hmap.basetype.Pixel} 新的像素对象
     * @example
     * let newPixel = pixel.clone();
     */
    clone(){
       return new hmap.basetype.Pixel(this._x,this._y);
    }

    /**
     * 计算两个像素坐标之间的距离。
     * @param {hmap.basetype.Pixel} pixel 像素坐标。
     * @return {Number} 两个像素之间的距离,像素单位。
     * @throws 当参数不是像素坐标对象时，抛出异常
     * @example
     * let pixel1 = new hmap.basetype.Pixel(1,2);
     * let pixel2 = new hmap.basetype.Pixel(4,5);
     * let result = pixel1.distanceTo(pixel2);//result=4.242640687119285
     */
    distanceTo(pixel){
        if(!(pixel instanceof hmap.basetype.Pixel)){
            throw new Error("the parameter pixel must be hmap.basetype.Pixel! ");
        }
	    const dis=Math.sqrt(Math.pow(this._x-pixel._x,2)+Math.pow(this._y-pixel._y,2));
        return dis;
    }

    /**
     * 检测两个像素是否相等
     * @param {hmap.basetype.Pixel} pixel 待比较的像素
     * @param {Number} tolerance 容差值,单位像素;
     * @return {Boolean} 相等返回true;不相等返回false
     * @throws 当第二个参数tolerance小于0时，抛出异常
     * @example
     * let pixel1 = new hmap.basetype.Pixel(1,2);
     * let pixel2 = new hmap.basetype.Pixel(4,5);
     * let result = pixel1.equals(pixel2,4);//result=false通过勾股定理计算得出
     */
    equals(pixel,tolerance=0){
        const flag=pixel instanceof hmap.basetype.Pixel && Number.isFinite(tolerance);
        if(tolerance<0){
            throw new Error("the tolerance must be a positive number!");
        }
        let c = Math.sqrt(Math.pow(pixel._x - this._x, 2) + Math.pow(pixel._y - this._y, 2))
        return flag ? c <= tolerance : false;
    }

    /**
     * 获取像素的横坐标
     * @return {Number}
     * @example
     * let x = pixel.getX();
     */
    getX(){
        return this._x;
    }

    /**
     * 获取像素的纵坐标
     * @return {Number}
     * @example
     * let y = pixel.getY();
     */
    getY(){
        return this._y;
    }

    /**
     * 获取像素的字符串表达形式
     * @return {String}
     * @example
     * let str = pixel.toString();
     */
    toString(){
        return this._x + "," +
            this._y ;
    }
}

;"use strict";
hmap.basetype = hmap.basetype || {};
/**
 * 在X-Y平面内，由最小、最大地理坐标合围起来的一个矩形地理范围。 Extent通常用来表示地理边界或范围，不包含高程信息，在hmap中也可以称为边界盒。
 * @type {hmap.basetype.Extent}
 * @throws 当左边界left大于右边界right或者下边界bottom大于上边界top时，抛出异常。
 * @example
 * let extent = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
 */
hmap.basetype.Extent = class {
    /**
     * 构造方法。创建一个地理范围实例。
     * @param left {Number} 左边界坐标值
     * @param bottom {Number} 下边界坐标值
     * @param right {Number} 右边界坐标值
     * @param top {Number} 上边界坐标值
     */
    constructor(left, bottom, right, top) {
        if(left> right || bottom> top){
            throw new TypeError("please make sure left<=right or bottom<=top!");
        }
        this._left = left;
        this._bottom = bottom;
        this._right = right;
        this._top = top;
        this.CLASS_NAME = "hmap.basetype.Extent";
    }
    /**
     * 复制一个新Extent对象,这个副本相对于正本，独立存在
     * @returns {hmap.basetype.Extent} 返回新的地理范围对象
     * @example
     * let newExtent = extent.clone();
     */
    clone() {
        const extent = new hmap.basetype.Extent(this.getLeft(), this.getBottom(), this.getRight(), this.getTop());
        return extent;
    }

    /**
     * 检测是一个地理坐标是否被包含在当前地理范围之内。
     * @param {hmap.basetype.Coordinate} coordinate 地理坐标
     * @param {Boolean} inclusive 考虑地理坐标落在在地理范围的边界上的情况：为true时，表示即使地理坐标落在地理范围的边界上，也按坐标在地理范围以内计算。否则按不在地理范围以内计算。默认为true。
     * @returns {Boolean} 包含返回true;不包含返回false,如果参数不合法，直接返回false
     * @example
     * let extent = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let coord = new hmap.basetype.Coordinate(120.3,30.2);
     * let result = extent.containsCoord(coord,true);//result=true
     */
    containsCoord(coordinate, inclusive = true) {
        const x = coordinate.getOrdinate("X"), y = coordinate.getOrdinate("Y");
        if (inclusive) {
            return this.getLeft() <= x && this.getRight() >= x && this.getBottom() <= y && this.getTop() >= y;
        } else {
            return this.getLeft() < x && this.getRight() > x && this.getBottom() < y && this.getTop() > y;
        }
    }

    /**
     * 检测一个地理范围是否包含了另外一个地理范围，（含边界共用的情况）。
     * @param {hmap.basetype.Extent} extent 给出的另外一个地理范围
     * @returns {Boolean} 包含返回true;不包含返回false
     * @example
     * let extentOut = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let extentIn  = new hmap.basetype.Extent(120.1,30.01,120.3,30.2);
     * let result = extentOut.containsExtent(extentIn);//result=true
     */
    containsExtent(extent) {
        return (extent.getLeft() >= this.getLeft() && extent.getRight() <= this.getRight()
            && extent.getBottom() >= this.getBottom() && extent.getTop() <= this.getTop());
    }

    /**
     * 扩展地理范围，使其包含给定的坐标。坐标中的Z值对地理范围的扩展无效
     * @param {hmap.basetype.Coordinate} coord 给定的一个坐标
     * @returns {hmap.basetype.Extent} 返回包含给定坐标的地理位置
     * @example
     * let coord = new hmap.basetype.Coordinate(120.3,30.6);
     * let extent = new hmap.basetype.Extent(110.1,20.01,130.3,40.2);
     * let result = extent.extendXY(coord);// result = new hmap.basetype.Extent(110.1,20.01,130.3,40.2);
     */
    extendXY(coord) {
        const x = coord.getOrdinate("X"), y = coord.getOrdinate("Y");
        this._left = this._left < x ? this._left : x;
        this._right = this._right > x ? this._right : x;
        this._top = this._top < y ? y : this._top;
        this._bottom = this._bottom < y ? this._bottom : y;
        return this;
    }

    /**
     * 扩展地理范围，使之包含参数指定的地理范围。并返回扩展后的地理范围。
     * @param {hmap.basetype.Extent} extent 需要扩展的地理范围
     * @returns {hmap.basetype.Extent} 返回扩展后的地理范围
     * @example
     * let extent  = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let extent2 = new hmap.basetype.Extent(121.1,31.07,122.7,32.3);
     * let result = extent.extendExtent(extent2);//result=new hmap.basetype.Extent(120.1,30.01,122.7,32.3);
     */
    extendExtent(extent) {
        const left = extent.getLeft(), right = extent.getRight(), top = extent.getTop(), bottom = extent.getBottom();
        this._left = Math.min(this._left, left);
        this._right = Math.max(this._right, right);
        this._bottom = Math.min(this._bottom, bottom);
        this._top = Math.max(this._top, top);
        return this;
    }
    /**
     * 判断两个地理范围是否相等。在允许的容差范围以内，四至相同就可以认为相等，否则不相等。
     * @param {hmap.basetype.Extent} extent 需要对比的地理范围
     * @param {Number} tolerance 容差。Extent四至的单位相同
     * @returns {Boolean} 地理范围相等返回true;地理范围不相等返回false
     * @example
     * let newExtent = new hmap.basetype.Extent(121.1,30.01,120.7,30.3);
     * let result = extent.equals(newExtent, 0.1);
     */
    equals(extent, tolerance) {
        return this._compareNumbers(extent.getTop(), this.getTop(), tolerance) &&
            this._compareNumbers(extent.getLeft(), this.getLeft(), tolerance) &&
            this._compareNumbers(extent.getBottom(), this.getBottom(), tolerance) &&
            this._compareNumbers(extent.getRight(), this.getRight(), tolerance);
    }

    /**
     * 比较两个数字是否在容差范围以内。浮点数转换成整数，解决因为精度问题导致的异常。
     * @param m
     * @param n
     * @param tolerance
     * @returns {Boolean}
     * @private
     */
    _compareNumbers(m, n, tolerance) {
        let l1, l2, c;
        try {
            //浮点
            l1 = m.toString().split(".")[1].length;
        } catch (e) {
            //整型
            l1 = 0;
        }
        try {
            l2 = n.toString().split(".")[1].length;
        } catch (e) {
            l2 = 0;
        }
        //位数差的绝对值
        c = Math.abs(l1 - l2);
        if (c > 0) {
            //位数相差
            var cm = Math.pow(10, c);
            if (l1 > l2) {
                m = Number(m.toString().replace(".", "")); //转化成数字
                n = Number(n.toString().replace(".", "")) * cm;
                tolerance = tolerance * Math.pow(10, l1)
            } else {
                m = Number(m.toString().replace(".", "")) * cm;
                n = Number(n.toString().replace(".", ""));
                tolerance = tolerance * Math.pow(10, l2)
            }
        } else {
            //位数相等
            m = Number(m.toString().replace(".", ""));
            n = Number(n.toString().replace(".", ""));
            tolerance = tolerance * Math.pow(10, l1);
        }
        return Math.abs(m - n) <= tolerance;
    }


    /**
     * 从字符串中解析出地理范围实例。
     * @param {String} str 该字符串是由逗号分割的4个可以转换为数值的数字组成，例： "83,42,10,45"。 不符合规范的字符串将发生解析异常。
     * @return {hmap.basetype.Extent} 地理范围实例
     * @throws 当转换后得到的数值，不等于4时，抛出异常
     * @example
     * let result = hmap.basetype.Extent.fromString("118,30,120,31");
     * //result=new hmap.basetype.Extent(118,30,120,31);
     */
    static fromString(str) {
        const arr = str.split(",").map(c=>Number.parseInt(c));
        if (arr.length!==4) {
            throw new Error("length of splited str  is not 4!");
        }
        return hmap.basetype.Extent.fromArray(arr);
    }
    /**
     * 计算经线方向的跨度
     * @return {Number} 返回经线方向的跨度。
     * @example
     * let width = extent.getWidth();
     */
    getWidth() {
        return this.getRight() - this.getLeft();
    }
    /**
     * 计算纬线方向的跨度
     * @return {Number} 返回纬线方向的跨度
     * @example
     * let height = extent.getHeight();
     */
    getHeight() {
        return this.getTop() - this.getBottom();
    }
    /**
     * 返回当前地理范围尺寸
     * @return {hmap.basetype.Size} 尺寸，由经线跨度与纬线跨度组成。
     * @example
     * let size = extent.getSize();
     */
    getSize() {
        return new hmap.basetype.Size(this.getWidth(), this.getHeight());
    }
    /**
     * 获取地理范围的面积。地理坐标系下计算结果仅表示一个近似值。
     * @return {Number} 面积，单位取决于地图单位，例平方米。
     * @example
     * let area = extent.getArea();
     */
    getArea() {
        return this.getHeight() * this.getWidth();
    }
    /**
     * 计算左边界经线值
     * @return {Number} 左边界经线值
     * @example
     * let left = extent.getLeft();
     */
    getLeft() {
        return this._left;
    }
     /**
     * 设置左边界经线值
     * @param {Number} left 经线值
     * @return {hmap.basetype.Extent} 返回新的地理范围
     * @throws 当参数大于地理范围的右边界经线值，抛出异常
     * @example
     * extent.setLeft(-170);
     */
    setLeft(left) {
        if(left>this.getRight()){
            throw "left value must be smaller than right"
        }
        this._left = left;
        return this;
    }
    /**
     * 计算右边界经线值
     * @return {Number} 右边界经线值
     * @example
     * let right = extent.getRight();
     */
    getRight() {
        return this._right;
    }
    /**
     * 设置右边界经线值
     * @param {Number} right 需要设置的右边界经线值
     * @return {hmap.basetype.Extent} 设置后的地理范围
     * @throws 当参数小于地理范围的左边界经线值时，抛出异常
     * @example
     * extent.setRight(170);
     */
    setRight(right) {
        if(right<this.getLeft()){
            throw "right value must be larger than left"
        }
        this._right = right;
        return this;
    }
    /**
     * 计算下边界纬线值
     * @return {Number} 下边界纬线值
     * @example
     * let bottom = extent.getBottom();
     */
    getBottom() {
        return this._bottom;
    }
    /**
     * 设置下边界纬线值
     * @param {Number} bottom 需要设置的下边界纬线值 
     * @return {hmap.basetype.Extent} 返回新的地理范围
     * @throws 当参数大于地理范围的上边界纬线值时，抛出异常
     * @example
     * extent.setBottom(-80);
     */
    setBottom(bottom) {
        if(bottom>this.getTop()){
            throw "bottom value must be smaller than top"
        }
        this._bottom = bottom;
        return this;
    }
    /**
     * 设置上边界纬线值
     * @param {Number} top 上边界纬线值
     * @return {hmap.basetype.Extent} 返回新的地理范围
     * @throws 当参数小于地理范围的下边界纬线值时，抛出异常
     * @example
     * extent.setTop(80);
     */
    setTop(top) {
        if(top<this.getBottom()){
            throw "top must be larger than bottom"
        }
        this._top = top;
        return this;
    }
    /**
     * 计算上边界纬线值
     * @return {Number} 上边界纬线值
     * @example
     * let top = extent.getTop();
     */
    getTop() {
        return this._top;
    }
    /**
     * 计算两个地理范围相交的部分。
     * @param {hmap.basetype.Extent} extent 地理范围
     * @return {hmap.basetype.Extent} extent 相交的范围，如果不相交，则返回null。
     * @example
     * let extent2 = new hmap.basetype.Extent(120.1,30.01,122.7,32.3);
     * let interstExtent = extent.getIntersection(extent2);
     */
    getIntersection(extent) {
        const left = Math.max(extent.getLeft(), this.getLeft());
        const bottom = Math.max(extent.getBottom(), this.getBottom());
        const right = Math.min(extent.getRight(), this.getRight());
        const top = Math.min(extent.getTop(), this.getTop());
        if (left > right || bottom > top) {
            return null;
        } else {
            let interstExtent = this.clone();
            interstExtent.setLeft(left);
            interstExtent.setRight(right);
            interstExtent.setBottom(bottom);
            interstExtent.setTop(top);
            return interstExtent;
        }
    }
    /**
     * 获取地理范围的中心坐标
     * @return {hmap.basetype.Coordinate} 坐标，表示地理范围的中心。
     * @example
     * let centerCoord = extent.getCenter();
     */
    getCenter() {
        const centerX = (this.getLeft() + this.getRight()) / 2;
        const centerY = (this.getBottom() + this.getTop()) / 2;
        return new hmap.basetype.Coordinate(centerX, centerY);
    }

    /**
     * 获取左上角坐标
     * @return {hmap.basetype.Coordinate} 表示左上角的坐标
     * @example
     * let coordinate = extent.getTopLeft();
     */
    getTopLeft() {
        return new hmap.basetype.Coordinate(this.getLeft(), this.getTop(), 0);
    }
    /**
     * 获取右上角坐标
     * @return {hmap.basetype.Coordinate} 表示右上角的坐标
     * @example
     * let coordinate = extent.getTopRight();
     */
    getTopRight() {
        return new hmap.basetype.Coordinate(this.getRight(), this.getTop(), 0);
    }
    /**
     * 获取左下角坐标
     * @return {hmap.basetype.Coordinate} 表示左下角的坐标
     * @example
     * let coordinate = extent.getBottomLeft();
     */
    getBottomLeft() {
        return new hmap.basetype.Coordinate(this.getLeft(), this.getBottom(), 0);
    }
    /**
     * 获取右下角坐标
     * @return {hmap.basetype.Coordinate} 表示右下角的坐标
     * @example
     * let coordinate = extent.getBottomRight();
     */
    getBottomRight() {
        return new hmap.basetype.Coordinate(this.getRight(), this.getBottom(), 0);
    }

    /**
     * 判断两个地理范围是否相交。如果两个地理存在包含关系，也按相交计算。
     * @param {hmap.basetype.Extent} extent 指定的地理范围
     * @param {Boolean} inclusive 边界有重合的情况。如果为true,那么当发生全部或部分边界重合时，按相交计算。否则不按相交计算。
     * @return {Boolean} 相交返回true;不相交返回false
     * @example
     * let extent1 = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let extent2 = new hmap.basetype.Extent(120.1,31.07,122.7,32.3);
     * let result = extent1.intersects(extent2,true);//result=false
     */
    intersects(extent, inclusive = true) {
        const left = extent.getLeft(), right = extent.getRight(), top = extent.getTop(), bottom = extent.getBottom();
        let lr, bt;
        if (inclusive) {
            lr = this._left <= right && this._right >= left;
            bt = this._bottom <= top && this._top >= bottom;
        } else {
            lr = this._left < right && this._right > left;
            bt = this._bottom < top && this._top > bottom;
        }
        return lr && bt;
    }

    /**
     * 判断当前地理范围是否为空
     * @return {Boolean} 为true时表示当前对象是一个空的地理范围。否则表示一个正常的地理范围。
     * @example
     * let result = extent.isEmpty();
     */
    isEmpty() {
        return this._left >= this._right || this._bottom >= this._top;
    }

    /**
     * 根据给出的水平与垂直方向的平移量，对当前地理范围的四至整体平移。
     * @param {Number} deltaX 水平方向的平移量
     * @param {Number} deltaY 垂直方向的平移量
     * @return {hmap.basetype.Extent} 发生偏移的地理范围
     * @throws 当参数deltaX或者参数deltaY不是数值类型时，抛出异常
     * @example
     * let newExtent = extent.offset(2, 3);
     */
    offset(deltaX, deltaY) {
        if (!Number.isFinite(deltaX) || !Number.isFinite(deltaY)) {
            throw "the parameter deltaX and deltaY must be Number ";
        } else {
            this._left = this._left + deltaX;
            this._right = this._right + deltaX;
            this._top = this._top + deltaY;
            this._bottom = this._bottom +deltaY;
        }
        return this;
    }

    /**
     * 以原点为中心，缩放地理范围。
     * @param {Number} ratio 缩放倍率，大于等于0的数值，其它值结果都是错误的。
     * @return {hmap.basetype.Extent} 缩放后的地理范围,如果ratio=0则范围变成0；如果0<ratio<1,为缩小；若ratio>1，则为放大
     * @throws 当参数ratio不是数值类型时，抛出异常。
     * @example
     * let newExtent = extent.scale(2);
     */
    scale(ratio) {
        if (typeof(ratio) !== 'number' || ratio < 0) throw new TypeError('the parameter ratio must be a number greater or equal to 0')
        this._left = this._left * ratio;
        this._bottom = this._bottom * ratio;
        this._right = this._right * ratio;
        this._top = this._top * ratio;
        return this;
    }

    /**
     * 地理范围对象的数组表现形式。返回的数组[l,b,r,t]分别表示[左边界，下边界，右边界、上边界]等几个坐标值。
     * @return {Array}  按照left、bottom、 right、 top 顺序组成的数组。
     * @example
     * let arr = extent.toArray();
     */
    toArray() {
        const arr = [];
        arr.push(this.getLeft());
        arr.push(this.getBottom());
        arr.push(this.getRight());
        arr.push(this.getTop());
        return arr;
    }

    /**
     * 将当前地理范围转换成一条线状几何体。
     * @return {hmap.geom.Line} 线状几何体
     * @example
     * let line = extent.toLine();
     */
    toLine() {
        const lb = new hmap.basetype.Coordinate(this._left, this._bottom);
        const lt = new hmap.basetype.Coordinate(this._left, this._top);
        const rt = new hmap.basetype.Coordinate(this._right, this._top);
        const rb = new hmap.basetype.Coordinate(this._right, this._bottom);
        const lineArr = [new hmap.geom.Point(lb), new hmap.geom.Point(lt), new hmap.geom.Point(rt), new hmap.geom.Point(rb)];
        return new hmap.geom.Line(lineArr);
    }

    /**
     * 将当前地理范围转换成线环
     * @returns {hmap.geom.LinearRing} 线环
     * @example
     * let linearRing = extent.toLinearRing();
     */
    toLinearRing() {
        const lb = this.getBottomLeft(), lt = this.getTopLeft(), rt = this.getTopRight(), rb = this.getBottomRight();
        const lbp = new hmap.geom.Point(lb), ltp = new hmap.geom.Point(lt), rtp = new hmap.geom.Point(rt),rbp = new hmap.geom.Point(rb);
        const points = [lbp, ltp, rtp, rbp, lbp];
        return new hmap.geom.LinearRing(points);
    }

    /**
     * 转换成一个面状几何体。
     * @return {hmap.geom.Polygon} 面状几何体
     * @example
     * let extent = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let result = extent.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([this.toLinearRing()]);
    }

    /**
     * 从Extent转化到String,地理范围的字符串形式。
     * @return {string} 返回“left,bottom,right,top”的字符串形式
     * @example
     * let extent = new hmap.basetype.Extent(120.1,30.01,120.7,30.3);
     * let result = extent.toString();//result="120.1,30.01,120.7,30.3"
     */
    toString() {
        return this.getLeft() + "," + this.getBottom() + "," + this.getRight() + "," + this.getTop();
    }

    /**
     * 从一个数组来构建地理范围。
     * @param {Array<float>} arr 由左下角坐标与右上角坐标组成
     * @return {hmap.basetype.Extent} 地理坐标
     * @throws 当参数arr不是4个元素的数组或者数组的元素不是数值类型时，抛出异常
     * @example
     * let newExtent = hmap.basetype.Extent.fromArray([120,30,120.2,30.3]);
     */
    static fromArray(arr) {
        const errMsg = "Parameter arr must be an Array contains 4 Number elements!";
        if(arr instanceof Array && arr.length === 4){
            for(let elem of arr){
                if(!Number.isFinite(elem)){
                    throw errMsg;
                }
            }
            return new hmap.basetype.Extent(arr[0], arr[1], arr[2], arr[3]);
        }
        throw errMsg;
    }
};

;"use strict";
hmap.basetype=hmap.basetype||{};
/**
 * 构造一个偏移量对象
 * @type {hmap.basetype.Offset}
 * @example
 * let offset = new hmap.basetype.Offset(1,2,3);
 */
hmap.basetype.Offset=class{
    /**
     * 偏移量类，用于描述锚点位置与真实位置的偏差
     * @param {Number} x 在经线方向上的偏移量
     * @param {Number} y 在纬线方向上的偏移量
     * @param {Number} z 在高程方向上的偏移量
     */
    constructor(x=0,y=0,z=0){
        this._x=x;
        this._y=y;
        this._z=z;
        this.CLASS_NAME = "hmap.basetype.Offset";
    }
    /**
     * 返回某个坐标轴方向上的偏移值.
     * @param {String} axis x、y、z三个坐标轴之一。不区分大小写
     * @return {Number|undefined} 偏移值或undefined，当传入的参数不是x、y或z时
     * @example
     * let value = offset.getValue("x");
     */
    getValue(axis){
        return this["_"+axis.toLowerCase()];
    }
    /**
     * 设置某坐标轴方向上的偏移量
     * 如果坐标轴不在限定值之内，则此方法不生效。
     * @param {String} axis x、y、z三者之一，不区分大小写
     * @param {Number} val 设置某个坐标轴方向上的偏移量
     * @example
     * offset.setValue("y",10);
     */
    setValue(axis,val){
        this["_"+axis.toLowerCase()]=val;
    }
    /**
     * 克隆方法
     * @return {hmap.basetype.Offset} 克隆后的偏移对象
     * @example
     * let newOffset = offset.clone();
     */
    clone(){
        let offset=new hmap.basetype.Offset(this.getValue("X"),this.getValue("Y"),this.getValue("Z"));
        return offset;
    }
    /**
     * 获取字符串格式的偏移量
     * @return {String} 偏移量
     * @example
     * let str = offset.toString();
     */
    toString(){
        return this._x+","+this._y+","+this._z;
    }
};
;"use strict";
hmap.basetype = hmap.basetype || {};
/**
 * 地理坐标，由经线分量、纬线分量、高程分量三个维度上的数值组成的坐标对象 。坐标仅表示地理实体的位置信息，是组成地理实体的属性之一，但不等于地理实体，特别是不能等同于点状实体。
 * 坐标对象可以是以度为单位来衡量、也可以由米为单位来衡量。 它的X、Y、Z分别代表经线分量、纬线分量、高程分量。
 * @type {hmap.basetype.Coordinate}
 * @example
 * let coord = new hmap.basetype.Coordinate(120,30,0);
 */
hmap.basetype.Coordinate = class {
    /**
     * 构造一个地理坐标。
     * @param {Number} x 经线分量,默认为0
     * @param {Number} y 纬线分量,默认为0
     * @param {Number} z 高程分量,默认为0
     * @throws 当坐标分量参数不是数字时,抛出异常
     */
    constructor(x = 0, y = 0, z = 0) {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
            throw new TypeError("the ordinate value must be numbers!");
        }
        this._x = x;
        this._y = y;
        this._z = z;
        this.CLASS_NAME = "hmap.basetype.Coordinate";
    }

    /**
     * 对当前坐标进行偏移处理。当前坐标被处理后会发生变化。
     * @param {hmap.basetype.Offset} offset 偏移量。
     * @return {hmap.basetype.Coordinate} 偏移后的坐标。
     * @example
     * let offset = new hmap.basetype.Offset(2,1,0);
     * let result = coord.addOffset(offset);
     * //result=new hmap.basetype.Coordinate(122,31,0)
	 * @throws 当入参不是hmap.basetype.Offset时，抛出异常
     */
    addOffset(offset) {
		 if (!(offset instanceof hmap.basetype.Offset)) {
            throw new ReferenceError('Parameter "offset"' + offset + ' is not a hmap.basetype.Offset instance!');
        }
        if (offset instanceof hmap.basetype.Offset) {
            this._x += offset.getValue('X');
            this._y += offset.getValue('Y');
            this._z += offset.getValue('Z');
        }
        return this;
    }
    /**
     * 坐标对象克隆。
     * @return {hmap.basetype.Coordinate} 一个新的坐标。
     * @example
     * let result = coord.clone();
     * //result=new hmap.basetype.Coordinate(120,30,0)
     */
    clone() {
        return new hmap.basetype.Coordinate(this._x, this._y, this._z);
    }
    /**
     * 销毁坐标对象
     * @example
     * coord.destroy();
     */
    destroy() {
        for (let i in this) {
            delete this[i];
        }
    }

    /**
     * 判断两个坐标是否相等，返回true则表示相等，反之表示不相等。
     * @param {hmap.basetype.Coordinate} coord 地理坐标
     * @return {Boolean} 相等返回true;不相等返回false
     * @throws 当入参不是坐标对象类型时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,30,0);
     * let result = coord1.equals(coord2);//result=false
     */
    equals(coord) {
        if (!coord instanceof hmap.basetype.Coordinate) {
                throw new  TypeError("parameter coordinate" + coord + " is not a Coordinate instance ");
        }
        //坐标的每个分量小于0.000000001视为相等
        const _cz = 0.000000001;
        const flag = (Math.abs(coord._x - this._x) < _cz && Math.abs(coord._y - this._y) < _cz && Math.abs(coord._z - this._z) < _cz) ? true : false;
        return flag;
    }
    /**
     * 用字符串模板格式化坐标。
     * @param {String} template 字符串模板。模板中的{x}将被替换成真实的经线分量；{y}将被替换成真实纬线分量；{z}将被替换成真实高程分量。
     * @param {Number} precision 坐标精度，1-13的整数，不指定，默认为1，精确到小数点后一位。
     * @return {String} 格式化后的坐标字符串,如果格式化失败（没有匹配上）,返回Coordinate本身。
     * @example
     * let  originCoord = new hmap.basetype.Coordinate(120.325,30.589);
     * let  template = '模版字符串是 ({x},{y}) ';
     * let  out = originCoord.format(template, 2);//输出结果: '模版字符串是 (120.33,30.59) '
     */
    format(template, precision = 1) {
        if(template.indexOf('{x}')<0 && template.indexOf('{y}')<0 && template.indexOf('{z}')<0){
            return this;
        }
        template = template.replace('{x}', this._x.toFixed(precision));
        template = template.replace('{y}', this._y.toFixed(precision));
        template = template.replace('{z}', this._z.toFixed(precision));
        return template.toString();
    }

    /**
     * 用字符串构造坐标。
     * @param {String} coordStr 1-3个浮点型数值用逗号分隔构成的字符串，每个浮点数值依次对应坐标对象x,y,z三个坐标分量，当1个浮点数字时，自动用0 补全Y Z 分量，2个浮点数字时，自动用0补全z分量。
     * @return {hmap.basetype.Coordinate} 一个地理坐标。
     * @example
     * let str1 = "120,20,30,123,12";
     * let coord=hmap.basetype.Coordinate.fromString(str1);//输出结果：coord=(120,20,30)
     * let ste2 = "120";
     * let coord=hmap.basetype.Coordinate.fromString(str2);//输出结果：coord=(120,0,0)
     */
    static fromString(coordStr) {
        let x = 0, y = 0, z = 0;
        let coordArr = coordStr.split(',').map(item => item * 1);
        const len = coordArr.length;
         if(len === 1){
            x = coordArr[0];
        }else if (len === 2) {
            x = coordArr[0];
            y = coordArr[1];
        }else if (len >= 3) {
            x = coordArr[0];
            y = coordArr[1];
            z = coordArr[2];
        }
      return  new hmap.basetype.Coordinate(x,y,z);
    }
    /**
     * 用数组来构造坐标对象。
     * @param {Array<float>} coordArr 含1-3个数字值组成的数组，依次对应坐标对象的x,y,z三个坐标分量。数组长度为1时，自动用0补全y z分量，数组长度为2时，自动用0补全z分量。
     * @return {hmap.basetype.Coordinate} 坐标对象
     * @example
     * let coord = hmap.basetype.Coordinate.fromArray([120.2,30,0]);
     */
    static fromArray(coordArr) {
        let x = 0, y = 0, z = 0;
        const len = coordArr.length;
        if(len === 1){
            x = coordArr[0];
        }else if (len === 2) {
            x = coordArr[0];
            y = coordArr[1];
        }else if (len >= 3) {
            x = coordArr[0];
            y = coordArr[1];
            z = coordArr[2];
        }
        return new hmap.basetype.Coordinate(x, y, z);
    }

    /**
     * 计算当前坐标与传入坐标，地理坐标系或投影坐标系下的球面距离（单位为米）。地理坐标系距离采用haversine大圆最短距离计算公式，半径采用WGS84椭球的平均地球半径(1/3 * (2a + b))，计算结果的最大误差为0.3%。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @param {Number} srid 坐标系标识。可用选项为4326、4490(即CGCS2000)、3857和900913，默认为4326。
     * @return {Number} 二维坐标距离（单位：米）
     * @throws 当第一个参数不是地理坐标对象时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(180,40,0);
     * let result = coord1.get2Dist(coord2, 4326);
     * //result=5473489.163137614
     */
    get2Dist(coord, srid = 4326) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new ReferenceError('parameter coord must be instance of hmap.basetype.Coordinate!');
        }
        const epsgKey = "EPSG" + srid;
        const crs = hmap.proj.Transformer.CrsList[epsgKey];//new hmap.proj.Crs(srid);
        const crsType = crs.getCrsType();
        if (crsType === 'GeoCRS') { //根据坐标系类型判断使用单位，使用地理坐标系（经纬度）作为单位则使用该块代码，否则使用else块代码
            const DEFAULT_RADIUS = crs.getRadius(); //根据坐标系获取地球半径
            const radius = DEFAULT_RADIUS;
            const lat1 = this._toRadians(this._y);
            const lat2 = this._toRadians(coord.getOrdinate("Y"));
            const deltaLatBy2 = (lat2 - lat1) / 2;
            const deltaLonBy2 = this._toRadians(coord.getOrdinate("X") - this._x) / 2;
            const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
                Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
                Math.cos(lat1) * Math.cos(lat2);
            return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        } else {
            const offset = coord.minus(this);
            const x = offset.getValue("x");
            const y = offset.getValue("y");
            return Math.sqrt(x * x + y * y);
        }
    }


    /**
     * 计算当前坐标与传入坐标，三维坐标距离
     * @param {hmap.basetype.Coordinate} coord 同一坐标系下的目标坐标点
     * @param {Number|String} srid 坐标系标识，可选项为4326（WGS84）和3857（WGS84 Web Mercator），默认为4326。使用4326时计算将球面坐标系转为直角坐标系下的坐标并计算距离，使用900913时直接计算直角坐标系下坐标间的距离。
     * @returns {Number} 三维坐标距离,单位是米
     * @throws 当第一个参数不是地理坐标对象时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(180,40,0);
     * let result = coord1.get3Dist(coord2);//result=5473489.163137614
     */
    get3Dist(coord, srid = 4326) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new ReferenceError("parameter coord must be instance of hmap.basetype.Coordinate!");
        }
        const epsgKey = "EPSG" + srid;
        const crs = hmap.proj.Transformer.CrsList[epsgKey];//new hmap.proj.Crs(srid);
        const crsType = crs.getCrsType();
        let coord1, coord2;
        if (crsType ==='GeoCRS') { //地理坐标系
            const DEFAULT_RADIUS = crs.getRadius(); //根据坐标系获取地球半径
            coord1 = hmap.basetype.Coordinate._sphericalCoordinateToOrthogonalCoordinate(this, DEFAULT_RADIUS);
            coord2 = hmap.basetype.Coordinate._sphericalCoordinateToOrthogonalCoordinate(coord, DEFAULT_RADIUS);
        } else{//投影坐标系
            coord1 = this;
            coord2 = coord;
        }
        const offset = coord1.minus(coord2);
        const x = offset.getValue("x");
        const y = offset.getValue("y");
        const z = offset.getValue("z");
        return Math.sqrt(x * x + y * y + z * z);
    }

    /**
     * @private
     */
    static _sphericalCoordinateToOrthogonalCoordinate(coord, r) {
        const actualR = coord.getOrdinate("Z") + r;
        const angleLon = coord._toRadians(coord.getOrdinate("X"));
        const angleLat = coord._toRadians(coord.getOrdinate("Y"));

        const orthogonalCoord = new hmap.basetype.Coordinate();
        orthogonalCoord.setOrdinate("X", actualR * Math.cos(angleLat) * Math.cos(angleLon));
        orthogonalCoord.setOrdinate("Y", actualR * Math.cos(angleLat) * Math.sin(angleLon));
        orthogonalCoord.setOrdinate("Z", actualR * Math.sin(angleLat));
        return orthogonalCoord;
    }

    /**
     * 获取坐标维度。默认返回3，表示三维坐标。
     * @return 坐标点的维度
     * @example
     * let num = coord.getDimension();
     */
    getDimension() {
        return 3;
    }

    /**
     * 获取坐标分量。坐标分量指的是坐标对在各坐标轴上对应的值。
     * @param {String} axis 坐标轴，大写字母。"X":经线坐标轴,"Y"：纬线坐标轴,"Z"：高程坐标轴。
     * @return {Number} 坐标分量。未按给定坐标分量传参时将抛出坐标轴未能识别的异常。
     * @throws 当参数不是"X"或"Y"或"Z"时，抛出异常
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let x = coord.getOrdinate("X");
     * let y = coord.getOrdinate("Y");
     * let z = coord.getOrdinate("Z");
     * //result:x=120;y=30;z=0
     */
    getOrdinate(axis) {
        let val = 0;
        switch (axis) {
            case "X":
                val = this._x;
                break;
            case "Y":
                val = this._y;
                break;
            case "Z":
                val = this._z;
                break;
            default:
                throw new Error("parameter axis is not valid, must be X, or Y, or Z");
        }
        return val;
    }

    /**
     * 验证坐标在指定坐标系的限制下是否有效。
     * @param {hmap.proj.Crs} crs 4326坐标系范围x：[-180,180],y:[-90,90]。900913坐标系范围x：[-20037508.342789,20037508.342789],y:[-20037508.342789,20037508.342789]
     * @return {Boolean} true表示在当前坐标系最大的范围内，坐标有效；false表示超过当前坐标系最大的范围，坐标无效。坐标系不被支持时抛出异常。
     * @example
     * let isValid = coord.isValid(new hmap.proj.Crs('4326'));
     */
    isValid(crs) {
        if(crs instanceof hmap.proj.Crs){
            const extent = crs.getExtent();
            return extent.containsCoord(this,true);
        }else{
            throw new TypeError('crs should be instance of hmap.proj.Crs.');
        }
    }

    /**
     * 计算两个坐标的差值，当前坐标减去入参坐标。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @return {hmap.basetype.Offset} 偏移量，表示两个坐标间的差值。
     * @throws 当参数不是地理坐标对象时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(122,30,0);
     * let result = coord1.minus(coord2);//result=new hmap.basetype.Offset(-2, 0, 0)
     */
    minus(coord) {
        if (!coord instanceof hmap.basetype.Coordinate) {
            throw new Error("parameter coordinate" + coord + " is not a Coordinate instance ");
        }
        const x1 = coord.getOrdinate("X"), y1 = coord.getOrdinate("Y"), z1 = coord.getOrdinate("Z");
        const x2 = this.getOrdinate("X"), y2 = this.getOrdinate("Y"), z2 = this.getOrdinate("Z");
        const x = x2 - x1, y = y2 - y1, z = z2 - z1;
        return new hmap.basetype.Offset(x, y, z);
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",缺省'Z'.
     * @param {Number} angle 旋转的角度，超过360度时，取angle/360的余数。逆时针为正，顺时针为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @return {hmap.basetype.Coordinate} 旋转后的坐标
     * @throws 参数类型不对时，都会抛出异常
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.basetype.Coordinate(122,32,0);
     * let result = coord.rotate("Z", 180, center);//result=new hmap.basetype.Coordinate(124,34,0)
     */
    rotate(axis = "Z", angle = 0, center) {
        if (typeof angle !== "number") {
            throw new TypeError("angle "+angle+" is not a number!");
        }
        if (axis !== 'X' && axis !== 'Y' && axis !== 'Z')
            throw new Error('parameter axis is not valid, must be X, or Y, or Z.')
        //环绕指定的坐标轴旋转
        if(!center){
            this._rotateAroundAxis(axis, angle);
        }else{
            if (!(center instanceof hmap.basetype.Coordinate)) {
                throw new TypeError("center is not an instance of hmap.basetype.Coordinate!");
            } else {
                center = hmap.basetype.Coordinate.fromString(center.toString())//创建拷贝 防止原数据被修改
                switch (axis) {
                    case "Z":
                        this.setOrdinate("X", this._x - center._x);
                        this.setOrdinate("Y", this._y - center._y);
                        this._rotateAroundAxis(axis, angle);
                        this.setOrdinate("X", this._x + center._x);
                        this.setOrdinate("Y", this._y + center._y);
                        break;
                    case "X":
                        this.setOrdinate("Y", this._y - center._y);
                        this.setOrdinate("Z", this._z - center._z);
                        this._rotateAroundAxis(axis, angle);
                        this.setOrdinate("Y", this._y + center._y);
                        this.setOrdinate("Z", this._z + center._z);
                        break;
                    case "Y":
                        this.setOrdinate("X", this._x - center._x);
                        this.setOrdinate("Z", this._z - center._z);
                        this._rotateAroundAxis(axis, angle);
                        this.setOrdinate("X", this._x + center._x);
                        this.setOrdinate("Z", this._z + center._z);
                        break;
                }
            }
        }
        return this;
    }

    /**
     * @private
     */
    _rotateAroundAxis(axis = "Z", angle = 0) {
        angle = angle * Math.PI / 180;
        let xt = 0, yt = 0, zt = 0;
        switch (axis) {
            case "Z":
                xt = this.tinyRound(Math.cos(angle)) * this._x - this.tinyRound(Math.sin(angle)) * this._y;
                yt = this.tinyRound(Math.sin(angle)) * this._x + this.tinyRound(Math.cos(angle)) * this._y;
                this.setOrdinate("X", xt);
                this.setOrdinate("Y", yt);
                break;
            case "X":
                yt = this.tinyRound(Math.cos(angle)) * this._y - this.tinyRound(Math.sin(angle)) * this._z;
                zt = this.tinyRound(Math.sin(angle)) * this._y + this.tinyRound(Math.cos(angle)) * this._z;
                this.setOrdinate("Z", zt);
                this.setOrdinate("Y", yt);
                break;
            case "Y":
                zt = this.tinyRound(Math.cos(angle)) * this._z - this.tinyRound(Math.sin(angle)) * this._x;
                xt = this.tinyRound(Math.sin(angle)) * this._z + this.tinyRound(Math.cos(angle)) * this._x;
                this.setOrdinate("X", xt);
                this.setOrdinate("Z", zt);
                break;
        }
        return this;
    }

    /**
     *  去掉数字15位以后的数字
     *  用于排除Math.sin(Math.PI) 不等于0，排除Math.cos(Math.PI/2) 不等于0的情况
     * */
    tinyRound(value){
        return Math.round(value*Math.pow(10,15))/Math.pow(10,15)
    }

    /**
     * 修改坐标分量
     * @param {String} axis 坐标轴标识，支持"X":经线坐标轴,"Y"：纬线坐标轴,"Z"：高程坐标轴,缺省值为'X'。
     * @param {Number} val 坐标分量
     * @return {hmap.basetype.Coordinate} 修改后的坐标
     * @throws 第一个参数必须为大写的'X'、'Y'、'Z'，否则抛出异常；第二个参数不是数值类型，抛出异常
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * coord.setOrdinate('X',100);
     * coord.setOrdinate('Y',40);
     * coord.setOrdinate('Z',10);
     * //coord修改后的坐标分量值为(100,40,10)
     */
    setOrdinate(axis='X', val) {
        if (!Number.isFinite(val)) {
            throw new Error("val of ordinate is not a number");
        }
        switch (axis) {
            case "X":
                this._x = val;
                break;
            case "Y":
                this._y = val;
                break;
            case "Z":
                this._z = val;
                break;
            default:
                throw new Error("parameter axis is not valid, must be X, or Y, or Z");
        }
        return this;
    }

    /**
     * 缩放坐标。即在坐标的各分量上，以参数坐标指定的倍数缩放.
     * @param {Number} scaleX 经线分量缩放倍数，如果0<scaleX<1,为缩小；若scaleX>1，则放大
     * @param {Number} scaleY 纬线分量缩放倍数，如果0<scaleY<1,为缩小；若scaleY>1，则放大
     * @param {Number} scaleZ 高程分量缩放倍数，如果0<scaleZ<1,为缩小；若scaleZ>1，则放大
     * @return {hmap.basetype.Coordinate} 缩放后的新坐标。
     * @throws 当参数不是数值类型或者是小于等于0的数值类型时，抛出异常
     * @example
     * let result = coord.scale(2, 2, 2);
     * //result=new hmap.basetype.Coordinate(240, 60, 0)
     */
    scale(scaleX=1, scaleY=1, scaleZ=1) {
        if (!Number.isFinite(scaleX) || !Number.isFinite(scaleY) || !Number.isFinite(scaleZ)) {
            throw new Error("the parameters must be Numbers!");
        }else if(scaleX<=0 || scaleY<=0 || scaleZ<=0){
            throw new Error('RangeError: Parameter "xFactor", "yFactor" and "zFactor" must be positive Number!')
        }
        this.setOrdinate('X', scaleX * this.getOrdinate('X'));
        this.setOrdinate('Y', scaleY * this.getOrdinate('Y'));
        this.setOrdinate('Z', scaleZ * this.getOrdinate('Z'));
        return this;
    }

    /**
     * 精确一个坐标中每个分量的小数点后的位数。在IE10及以上版本中是正常的四舍五入，在Chrome浏览器的不同版本中就不一样了。
     * 小数位数支持0~14。强烈建议最多保留6位小数。当大于10时，返回结果在不同浏览器版本上可能不稳定。
     * @param {Number} precision 小数位数,一个包括0在内的正整数。参数非法时，坐标不会被精确.
     * @returns {hmap.basetype.Coordinate}  被精确到指定的小数位数的坐标对象。返回的坐标对象中的x、y、z值的位数不一定等于要精确的位数，后面的0会被省略。
     * @example
     * let result = coord.toFixed(6);
     */
    toFixed(precision) {
        //precision 合法性检测
        let rule = /^[0-9]*[0-9][0-9]*$/;
        if (rule.test(precision)) {
            this.setOrdinate('X', this.getOrdinate('X').toFixed(precision) * 1);
            this.setOrdinate('Y', this.getOrdinate('Y').toFixed(precision) * 1);
            this.setOrdinate('Z', this.getOrdinate('Z').toFixed(precision) * 1);
        }
        return this;
    }


    /**
     * 将坐标值转换为字符串
     * @return {String} 字符串形式的坐标值
     * @example
     * let result = coord.toString();
     */
    toString() {
        return this._x + "," + this._y + "," + this._z;
    }

    /**
     * 将坐标值的XY转换为对应的字符串
     * @return {String} 字符串形式的坐标值
     * @example
     * let result = coord.to2DString();
     */
    to2DString(){
        return this._x + "," + this._y ;
    }

    /**
     * 从源坐标系转换到目标坐标系(暂不启用)
     * @param {int} source 源坐标系标识
     * @param {int} dest 目标坐标系标识
     */
    transform(source, dest) {
    }

    /**
     * @private
     */
    _toRadians(angleInDegrees) {
        return angleInDegrees * Math.PI / 180;
    }
};
;"use strict";
hmap.basetype = hmap.basetype || {};
/**
 * 坐标序列，用来管理坐标（Coordinate）对象组成的数组的类。
 * @type {hmap.basetype.Coordinate}
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2]);
 */
hmap.basetype.CoordSeq = class {
    /**
     * 构造一个坐标序列对象。
     * @param {Array<hmap.basetype.Coordinate>} coordArr - 存放坐标对象的数组
     * @throws 当参数不是数组类型或者数组元素不是地理坐标对象时，抛出异常
     */
    constructor(coordArr=[]) {
        if (Array.isArray(coordArr)) {
            for (let value of coordArr) {
                if (!(value instanceof hmap.basetype.Coordinate))
                    throw new TypeError("the Array element must be hmap.basetype.Coordinate!");
            }
            this._coordArr = [...coordArr];

        }else {
            throw new TypeError("the parameter coordArr must be Array!");
        }
        this.CLASS_NAME = "hmap.basetype.CoordSeq";
    }

    /**
     * 在当前坐标序列指定索引位置，添加一个新的坐标对象。
     * @param {hmap.basetype.Coordinate} coord - 新坐标对象
     * @param {Number} index - 索引。当index小于等于0，往前添加；当index大于等于坐标序列的长度或者为空时，往后添加。
     * @returns {hmap.basetype.CoordSeq} 返回修改后的坐标序列。
     * @example
     * let newCoord = new hmap.basetype.Coordinate(122,32,0);
     * let result = coordSeq.addCoord(newCoord,0);//result为坐标序列长度
     */
    addCoord(coord, index = this._coordArr.length) {
        if (!(coord instanceof hmap.basetype.Coordinate) || !Number.isFinite(index)){
            throw new TypeError("the parameter \"coord\" must be coordinate and \"index\" must be number!");
        }
        if (index <= 0) {
            this._coordArr.unshift(coord);
        } else if (index >= this.getCoordCount()) {
            this._coordArr.push(coord);
        } else {
            this._coordArr.splice(index, 0, coord);
        }
        return this;
    }
    /**
     * 合并两个坐标序列，指定的坐标序列追加到当前坐标序列之后。合并操作不影响原来的坐标序列。
     * @param {hmap.basetype.CoordSeq} coorSeq 坐标序列
     * @return {hmap.basetype.CoordSeq} 新的坐标序列
     */
    concat(coordSeq){
        let  a=this._coordArr,b=coordSeq._coordArr;
        const c=a.concat(b);
        const newCoordSeq=new hmap.basetype.CoordSeq(c);
        return newCoordSeq;
    }

    /**
     * 克隆坐标序列实例
     * @returns {hmap.basetype.CoordSeq} 返回复制的坐标序列
     * @example
     * let newCoordSeq = coordSeq.clone();
     */
    clone() {
        const coordArr = [];
        for(let i=0; i<this._coordArr.length; i++){
            coordArr.push( this._coordArr[i].clone() );
        }
        return new hmap.basetype.CoordSeq([...coordArr]);
    }
    /**
     * 判断坐标序列是否包含给定坐标。
     * @param {hmap.basetype.Coordinate} coord  坐标
     * @returns {Number}  包含给定坐标,则返回坐标在序列中的索引,否则返回-1
     * @throws 当参数不是地理坐标对象时，抛出异常
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let flag=coordSeq.containsCoord(coord);
     */
    containsCoord(coord){
        if(!(coord instanceof hmap.basetype.Coordinate)){
            throw new TypeError("parameter coord must be instance of hmap.basetype.Coordinate!");
        }
        for(let i=0;i<this._coordArr.length;i++){
            if(this._coordArr[i].equals(coord)){
                return i;
            }
        }
        return -1;
    }
    /**
     * 销毁CoordSeq对象
     * @example
     * coordSeq.destroy();
     */
    destroy() {
        //依次销毁坐标序列中的每个坐标
        for (let i = 0, len = this._coordArr.length; i < len; i++) {
            this._coordArr[i].destroy();
        }
        for (let j in this) {
            delete this[j];
        }
    }
    /**
     * 使坐标序列成为一个闭环。1.坐标序列中的点数量大于等于3，否则抛异常;2.如果当前坐标序列已经是一个闭环，那么直接返回;3.如果当前坐标序列不是闭环，追加序列中的第一个点到末尾，使其成为闭环。
     * @returns {Array<hmap.basetype.Coordinate>} 新坐标数组
     * @throws 当组成坐标序列的点数量少于3个时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = coordSeq.encloseRing();
     * //result=[
     * //     new hmap.basetype.Coordinate(120,30,0),
     * //     new hmap.basetype.Coordinate(121,31,0),
     * //     new hmap.basetype.Coordinate(122,30,0),
     * //     new hmap.basetype.Coordinate(120,30,0)
     * //]
     */
    encloseRing() {
        if(this.getCoordCount()>2){
            if (!this.isRing()) {
                this._coordArr.push(this._coordArr[0]);
            }
            return this._coordArr;
        }else{
            throw "Less than 3 points cannot form a closed ring";
        }
    }
    /**
     * 从指定索引处开始提取n个坐标，如果n大于坐标数量，返回从索引位置开始的所有坐标。
     * @param {Integer} index - 指定的索引
     * @param {Integer} n - 要提取的坐标个数。当n为0，或者index超出范围，或者坐标序列长度为0， 返回null；2.n为负时，从索引位置处向前，依次提取n个坐标。3.n为正时，从索引位置处向后，依次提取n个坐标。
     * @returns {Array<hmap.basetype.Coordinate>} 提取的坐标序列的数组
     * @throws 当第一个参数不是数值类型或者第二个参数不是数值类型时，抛出异常
     * @example
     * let result = coordSeq.extractCoords(0,1);//result=[new hmap.basetype.Coordinate(120,30,0)];
     */
    extractCoords(index = 0, n = this._coordArr.length) {
        if (!Number.isFinite(index) || !Number.isFinite(n)) {
            throw new Error("the parameter must be number!");
        }
        const len = this.getCoordCount();
        if (n === 0 || len === 0 || index < 0 || index > len) {
            return null;
        } else if (n < 0) {//反向提取
            return ((-n) > index + 1) ? this._coordArr.slice(0, index + 1).reverse() : this._coordArr.slice(index + n + 1, index + 1).reverse();
        } else if (n > 0) {
            return (n < len - index) ? this._coordArr.slice(index, index + n) : this._coordArr.slice(index, len);
        }
    }
    /**
     * 获取坐标序列中索引值对应的坐标。
     * @param {Number} index - 坐标在序列中的索引
     * @returns {hmap.basetype.Coordinate} 获取到的坐标
     * @throws {TypeError} 当索引参数不是数值类型时，抛出类型异常
     *         {RangeError} 当索引参数超出坐标序列中坐标数组的边界时，抛出越界异常
     * @example
     * let result = coordSeq.getCoordinate(0);//result=new hmap.basetype.Coordinate(120,30,0)
     */
    getCoordinate(index) {
        if (!Number.isFinite(index)) {
            throw new TypeError("the parameter must be number!");
        }

        const len = this.getCoordCount();

        if (index < 0 || index >= len) {
            throw new RangeError(`the parameter ${index} has beyond the coordinates boundary`)
        }

        if (len === 0) {
            return null;
        }
        return this._coordArr[index];
    }
    /**
     * 获取坐标序列长度，即当前坐标序列中所包含的坐标个数。
     * @returns {Number}  坐标个数
     * @example
     * let coordCount = coordSeq.getCoordCount();
     */
    getCoordCount() {
        return this._coordArr.length;
    }
    /**
     * 获取第一个坐标对象。
     * @returns {hmap.basetype.Coordinate} 坐标序列中的第一个坐标对象。如果该坐标序列中没有坐标，那么返回null。
     * @example
     * let firstCoordinate = coordSeq.getFirstCoordinate();
     */
    getFirstCoordinate() {

        const len = this.getCoordCount();

        return (len > 0) ? this._coordArr[0] : null;
    }
    /**
     * 获取最后一个坐标
     * @returns {@link hmap.basetype.Coordinate} 最后一个坐标
     * @example
     * let lastCoordinate = coordSeq.getLastCoordinate();
     */
    getLastCoordinate() {

        const len = this.getCoordCount();

        return (len > 0) ? this._coordArr[len - 1] : null;
    }
    /**
     * 获取指定索引处坐标的坐标分量值。
     * @param {Number} coordIndex - 坐标在序列中的索引。
     * @param {String} ordinateIndex - 坐标轴标识。取值必须 "X"、"Y"、或"Z"，缺省值"X".
     * @returns {Number} 一个数值，表示坐标分量。
     * @throws 当第一个参数不是数值类型时抛出异常;当第二个参数不是"X"或"Y"或"Z"时，抛出异常。
     * @example
     * let xValue = coordSeq.getOrdinate(0, "X");
     */
    getOrdinate(coordIndex, ordinateIndex="X") {
        if (!Number.isFinite(coordIndex)) {
            throw new Error("the first parameter must be Number");
        }
        return this.getCoordinate(coordIndex).getOrdinate(ordinateIndex);
    }
    /**
     * 检测两个坐标序列是否相等。
     * @param {hmap.basetype.CoordSeq} coordSeq - 另一个坐标序列对象
     * @returns {Boolean} 相等返回true;不相等返回false
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let coordSeq1 = new hmap.basetype.CoordSeq([coord]);
     * let coordSeq2 = new hmap.basetype.CoordSeq([coord]);
     * let result = coordSeq1.equals(coordSeq2);//result=true
     */
    equals(coordSeq) {
        if (this.getCoordCount() !== coordSeq.getCoordCount()) {
            return false;
        }
        for (let i = 0, len = this.getCoordCount(); i < len; i++) {
            if (this._coordArr[i].equals(coordSeq.getCoordinate(i))) {
                if (i === (len - 1)) {
                    return true;
                }
                continue;
            } else {
                return false;
            }
        }
    }

    /**
     * 判断坐标序列是否闭合。闭合的片段依据是首尾坐标相等，且当前坐标序列中至少包含3个坐标。
     * @returns {Boolean} 闭合返回true;不闭合返回false
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1]);
     * let result = coordSeq.isRing();//result=false
     */
    isRing() {
        return this.getCoordCount() > 2 && this._coordArr[0].equals(this._coordArr[this.getCoordCount() - 1]);
    }
    /**
     * 从数组中指定索引处删除指定个数的元素。
     * @param {Number} index - 要删除的起始位置处的索引
     * @param {Number} num - 要删除的个数
     * @returns {Number} 返回删除元素的数量
     * @throws 当参数index不在坐标序列数组的索引值范围内时，抛出异常
     * @example
     * coordSeq.remove(0, 1);//只删除了索引值为0的一个坐标
     */
    remove(index, num) {

        if (index >= 0 && index < this.getCoordCount()) {
            num = this._coordArr.splice(index, num).length;
        } else {
            throw new Error(index + " beyond the array boundary.");
        }
        return num;
    }



    /**
     * 去除重复的坐标。假如坐标序列中相邻的两个坐标是相同的，则会删除后面的坐标，直到相邻的坐标没有相同的为止。
     * @returns {Number} 返回删除坐标的个数。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120,30,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = coordSeq.removeRepeat();//result=1
     */
    removeRepeat() {

        let len = this.getCoordCount();
        if (len < 2) {
            return 0;
        }
        let num = 0;
        for (let i = 1; i < len; i++) {
            if (this._coordArr[i].equals(this._coordArr[i - 1])) {
                this._coordArr.splice(i, 1);
                i--;
                len--;
                num++;
            }
        }
        return num;
    }

    /**
     * 返回一个与原坐标序列中坐标顺序相反的坐标序列,可根据传入的参数为true或false控制是否改变原坐标序列中坐标的顺序。
     * @param {Boolean} originModified - 指定原坐标序列中坐标的顺序是否被反转，默认值是false，表示不改变原坐标序列中坐标的顺序。该值为true时，会改变原坐标序列中坐标的顺序。
     * @returns {hmap.basetype.CoordSeq} 反转后的坐标序列
     * @example
     * const coord1 = new hmap.basetype.Coordinate(120,30,0);
     * const coord2 = new hmap.basetype.Coordinate(120,30,0);
     * const coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = coordSeq.reverse();//不改变coordSeq这个坐标序列中坐标的顺序
     * coordSeq.reverse(true);//反转coordSeq这个坐标序列中坐标的顺序
     */
    reverse(originModified=false) {
        if(originModified){//反转原序列中坐标的顺序
            this._coordArr.reverse();
            return this;
        }else{//不改变原坐标序列中坐标的顺序。
            const coordSeq = this.clone();
            coordSeq._coordArr.reverse();
            return coordSeq;
        }
    }
    /**
     * 设置坐标分量。
     * @param {Number} coordIndex - 坐标在当前坐标序列中的索引，索引从0开始计算。
     * @param {String} ordinateIndex - 坐标轴标识。取值必须 "X"、"Y"、或"Z"，缺省值"X".
     * @param {Number} val - 坐标分量。
     * @throws 当第一个参数不是数值类型时抛出异常;当第二个参数不是"X"或"Y"或"Z"时，抛出异常。
     * @example
     * coordSeq.setOrdinate(0, "X", 124);//设置坐标序列中第一个坐标的x轴值为124.
     */
    setOrdinate(coordIndex, ordinateIndex="X", val) {
        if (!Number.isFinite(coordIndex) || !Number.isFinite(val)) {
            throw new Error("the parameter coordIndex and val must both be Number!");
        }
        this.getCoordinate(coordIndex).setOrdinate(ordinateIndex, val);
    }
    /**
     * 简化坐标序列。采用道格拉斯-普克算法，坐标序列中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * @param {Number} tolerance 简化所用容差值，大于等于0。容差值越大,坐标序列越精简。但注意：容差值不表示两个坐标点之间的距离。
     * @param {Boolean} isRing 是否是线环，默认是false。
     * @returns {hmap.basetype.CoordSeq} 返回简化后的坐标序列。
     * @throws 当参数不是数值类型或者参数小于0时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = coordSeq.simplify(10);
     * //result=new hmap.basetype.CoordSeq([
     * //       new hmap.basetype.Coordinate(120,30,0),
     * //       new hmap.basetype.Coordinate(122,32,0)
     * //]);
     */
    simplify(tolerance, isRing = false) {
        if(!Number.isFinite(tolerance) || tolerance < 0){
            throw "Parameter tolerance must be type of Number with positive finite value!";
        }
        if (this && this !== null) {
            const coords = this.extractCoords();
            if (coords.length < 3) {
                return this;
            }

            //用于计算点距离的向量，在迭代过程中复用
            const vec1 = new hmap.util.Vector3();
            const vec2 = new hmap.util.Vector3();
            const vec = new hmap.util.Vector3();

            let firstCoord = 0;
            let lastCoord = isRing ? coords.length - 2 : coords.length - 1;
            const coordIndexesToKeep = [];
            let indexFarthest = 0;

            //计算点到线的距离，coord1，起始点,coord2,终止点，coord非端点
            let _perpendicularDistance = function (coord1, coord2, coord) {
                vec1.set(coord1.getOrdinate('X'), coord1.getOrdinate('Y'), coord1.getOrdinate('Z'));
                vec2.set(coord2.getOrdinate('X'), coord2.getOrdinate('Y'), coord2.getOrdinate('Z'));
                vec.set(coord.getOrdinate('X'), coord.getOrdinate('Y'), coord.getOrdinate('Z'));
                const cross=(vec.clone().substract(vec1).cross(vec2.clone().substract(vec1))).length();
                const model=vec2.clone().substract(vec1).length();
                return Math.abs(cross/model);
            };
            //道格拉斯和普克算法
            let _douglasPeuckerReduction = function (points, firstCoord, lastCoord, tolerance) {
                let maxDistance = 0;
                // let indexFarthest = 0;
                for (let index = firstCoord+1, distance; index < lastCoord; index++) {
                    distance = _perpendicularDistance(points[firstCoord], points[lastCoord], points[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }
                if (maxDistance > tolerance && indexFarthest !== firstCoord) {
                    //添加超出tolerance最大距离的点
                    coordIndexesToKeep.push(indexFarthest);
                    _douglasPeuckerReduction(points, firstCoord, indexFarthest, tolerance);
                    _douglasPeuckerReduction(points, indexFarthest, lastCoord, tolerance);
                }
            };
            //保留第一个和最后一个索引
            coordIndexesToKeep.push(firstCoord);
            coordIndexesToKeep.push(lastCoord);

            //第一个和最后一个点不能相同
            while (coords[firstCoord].equals(coords[lastCoord])) {
                lastCoord--;
                coordIndexesToKeep.splice(1, 1, lastCoord)
            }

            _douglasPeuckerReduction(coords, firstCoord, lastCoord, tolerance);
            const returnCoords = [];
            if (isRing && coordIndexesToKeep.length === 2) coordIndexesToKeep.push(indexFarthest)
            coordIndexesToKeep.sort((a, b) => a - b);
            const arrIndex = Array.from(new Set([...coordIndexesToKeep]));
            for (let index = 0; index < arrIndex.length; index++) {
                returnCoords.push(coords[arrIndex[index]]);
            }
            if (isRing) {
                returnCoords.push(coords[0])
            }
            this._coordArr = returnCoords;
        }
        return this;
    }
    /**
     * 在坐标序列中，坐标分量按大小重新排列坐标次序。
     * @param {String} axis - 坐标轴。字符串，仅限于"X"、"Y"、"Z"。
     * @param {String} order - 升序（ASC）或降序（DESC）
     * @returns {hmap.basetype.CoordSeq} 排序后的新坐标序列，所包含的坐标次序已经过重新排列。
     * @example
     * let newCoordSeq = coordSeq.sort("X", "ASC");//将坐标序列中的坐标，按照x坐标分量进行升序排列。
     */
    sort(axis = "X", order = "ASC") {
        order = order.toUpperCase();
        if (order !== 'ASC' && order !== 'DESC') throw new Error("The parameter order should be 'ASC' or 'DESC'")
        const result = this.clone();
        const sort = {
            "ASC": function (i, j, axis) {
                return i.getOrdinate(axis) - j.getOrdinate(axis);
            },
            "DESC": function (i, j, axis) {
                return j.getOrdinate(axis) - i.getOrdinate(axis);
            }
        };

        result._coordArr.sort(function(i,j){return sort[order](i,j,axis);});
        return result;
    }
    /**
     * 交换坐标位置。
     * @param {Number} i - 坐标在当前序列中的索引。
     * @param {Number} j - 坐标在当前序列中的索引。
     * @returns {hmap.basetype.CoordSeq} 交换坐标后的新坐标序列
     * @throws 当第一个参数或者第二个参数超出坐标序列数组的索引范围时，抛出异常
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120,30,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = coordSeq.swap(1,2);
     * //result=new hmap.basetype.CoordSeq([
     * //       new hmap.basetype.Coordinate(120,30,0),
     * //       new hmap.basetype.Coordinate(122,32,0),
     * //       new hmap.basetype.Coordinate(120,30,0)
     * //]);
     */
    swap(i, j) {

        const len = this.getCoordCount();

        if (i >= 0 && i < len && j >= 0 && j < len) {
            //ES6语法
            [this._coordArr[i], this._coordArr[j]] = [this._coordArr[j], this._coordArr[i]];
        } else {
            throw new Error(i + " or " + j + " beyond the array boundary.");
        }
        return this;
    }

    /**
     * 计算该坐标序列的外接矩形地理范围。
     * 当坐标序列中只有两个坐标并且两个坐标相同都为(x,y)，则坐标序列的地理范围为:[x,y,x,y]
     * @returns {hmap.basetype.Extent} 该坐标序列的外接矩形地理范围
     */
    getExtent() {
        if (this._coordArr.length <= 0) {
            return new hmap.basetype.Extent(0, 0, 0, 0);
        }

        //第一个点坐标
        let fpc = this._coordArr[0];
        let l = fpc.getOrdinate("X"), t = fpc.getOrdinate("Y"), r = fpc.getOrdinate("X"), b = fpc.getOrdinate("Y");
        for (let i = 1, len = this._coordArr.length; i < len; i++) {
            let x = this._coordArr[i].getOrdinate("X"),
                y = this._coordArr[i].getOrdinate("Y");
            l = l > x ? x : l;
            r = r < x ? x : r;
            t = t < y ? y : t;
            b = b > y ? y : b;
        }
        return new hmap.basetype.Extent(l, b, r, t);
    }
};
;"use strict";
hmap.basetype = hmap.basetype || {};
/**
 * 三维包围盒对象
 * @param {Number} minX X轴方向最小值，应比maxX小，必须
 * @param {Number} minY Y轴方向最小值，应比maxY小，必须
 * @param {Number} minZ Z轴方向最小值，应比maxZ小，必须
 * @param {Number} maxX X轴方向最大值，应比minX大，必须
 * @param {Number} maxY Y轴方向最大值，应比minY大，必须
 * @param {Number} maxZ Z轴方向最大值，应比minZ大，必须
 */
hmap.basetype.BBox = class {
    constructor(minX, minY, minZ, maxX, maxY, maxZ) {
        this._minX = minX;
        this._minY = minY;
        this._minZ = minZ;
        this._maxX = maxX;
        this._maxY = maxY;
        this._maxZ = maxZ;
    }

    /**
     * 设置X轴方向最小值
     * @param {Number} n X轴方向最小值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMinX(n) {
        this._minX = n;
        return this;
    }

    /**
     * 设置Y轴方向最小值
     * @param {Number} n Y轴方向最小值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMinY(n) {
        this._minY = n;
        return this;
    }

    /**
     * 设置Z轴方向最小值
     * @param {Number} n Z轴方向最小值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMinZ(n) {
        this._minZ = n;
        return this;
    }

    /**
     * 设置X轴方向最大值
     * @param {Number} n X轴方向最大值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMaxX(n) {
        this._maxX = n;
        return this;
    }

    /**
     * 设置Y轴方向最大值
     * @param {Number} n Y轴方向最大值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMaxY(n) {
        this._maxY = n;
        return this;
    }

    /**
     * 设置Z轴方向最大值
     * @param {Number} n Z轴方向最大值
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    setMaxZ(n) {
        this._maxZ = n;
        return this;
    }

    /**
     * 获取X轴方向最小值
     * @returns {Number} X轴方向最小值
     */
    getMinX() {
        return this._minX;
    }

    /**
     * 获取Y轴方向最小值
     * @returns {Number} Y轴方向最小值
     */
    getMinY() {
        return this._minY;
    }

    /**
     * 获取Z轴方向最小值
     * @returns {Number} Z轴方向最小值
     */
    getMinZ() {
        return this._minZ;
    }

    /**
     * 获取X轴方向最大值
     * @returns {Number} X轴方向最大值
     */
    getMaxX() {
        return this._maxX;
    }

    /**
     * 获取Y轴方向最大值
     * @returns {Number} Y轴方向最大值
     */
    getMaxY() {
        return this._maxY;
    }

    /**
     * 获取Z轴方向最大值
     * @returns {Number} Z轴方向最大值
     */
    getMaxZ() {
        return this._maxZ;
    }

    /**
     * 获取由X轴、Y轴、Z轴各方向最小值组成的坐标点
     * @returns {hmap.basetype.Coordinate} 由X轴、Y轴、Z轴各方向最小值组成的坐标点
     */
    getMin() {
        return new hmap.basetype.Coordinate(this._minX, this._minY, this._minZ);
    }

    /**
     * 在X轴、Y轴、Z轴分别根据参数平移三维包围盒。当参数为正时，沿坐标轴正方向平移；参数为负，则沿坐标轴负方向平移。
     * @param {Number} x x轴方向平移距离
     * @param {Number} y y轴方向平移距离
     * @param {Number} z z轴方向平移距离
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    moveByDelta(x, y, z) {
        this._minX += x;
        this._minY += y;
        this._minZ += z;
        this._maxX += x;
        this._maxY += y;
        this._maxZ += z;
        return this;
    }

    /**
     * 获取由X轴、Y轴、Z轴各方向最大值组成的坐标点
     * @returns {hmap.basetype.Coordinate} 由X轴、Y轴、Z轴各方向最大值组成的坐标点
     */
    getMax() {
        return new hmap.basetype.Coordinate(this._maxX, this._maxY, this._maxZ);
    }

    /**
     * 计算该包围盒是否与另外一个包围盒相同。
     * @param {hmap.basetype.BBox} bbox 三维包围盒
     * @returns {Boolean} 相同，返回true，不同则返回false。
     */
    equals(bbox) {
        return bbox.getMin().equals(this.getMin()) && bbox.getMax().equals(this.getMax());
    }

    /**
     * 扩展三维包围盒，使其包含指定的坐标。
     * @param {Number} x 在X轴方向扩展三维包围盒的值。
     * @param {Number} y 在Y轴方向扩展三维包围盒的值。
     * @param {Number} z 在Z轴方向扩展三维包围盒的值。
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    extendXYZ(x, y, z) {
        if (x < this._minX) {
            this._minX = x;
        } else if (x > this._maxX) {
            this._maxX = x;
        }

        if (y < this._minY) {
            this._minY = y;
        } else if (y > this._maxY) {
            this._maxY = y;
        }

        if (z < this._minZ) {
            this._minZ = z;
        } else if (z > this._maxZ) {
            this._maxZ = z;
        }
        return this;
    }

    /**
     * 扩展三维包围盒，使其包含指定的三维包围盒。
     * @param {hmap.basetype.BBox} bbox 指定的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回包围盒本身。
     */
    extendBBox(bbox) {
        let min = bbox.getMin(),
            max = bbox.getMax();
        let minX = min.getOrdinate('X'),
            minY = min.getOrdinate('Y'),
            minZ = min.getOrdinate('Z'),
            maxX = max.getOrdinate('X'),
            maxY = max.getOrdinate('Y'),
            maxZ = max.getOrdinate('Z');
        this.extendXYZ(minX, minY, minZ);
        this.extendXYZ(maxX, maxY, maxZ);
        return this;
    }

    /**
     * 获取该三维包围盒在XY平面的最大地理范围
     * @returns {hmap.basetype.Extent} 三维包围盒在XY平面的最大地理范围。
     */
    getExtent() {
        return new hmap.basetype.Extent(this._minX, this._minY, this._maxX, this._maxY);
    }

    /**
     * 和另一包围盒的相交判断
     * @param {hmap.basetype.BBox} b 另一包围盒对象
     * @returns {Boolean} 两个包围盒相交，返回true，否则返回false
     */
    intersectBBox(b) {
        const tMin = this.getMin();
        const tMax = this.getMax();
        const bMin = b.getMin();
        const bMax = b.getMax();
        return bMax.getOrdinate("X") >= tMin.getOrdinate("X") && bMax.getOrdinate("Y") >= tMin.getOrdinate("Y") && bMax.getOrdinate("Z") >= tMin.getOrdinate("Z")
            && bMin.getOrdinate("X") <= tMax.getOrdinate("X") && bMin.getOrdinate("Y") <= tMax.getOrdinate("Y") && bMin.getOrdinate("Z") <= tMax.getOrdinate("Z");
    }

    /**
     * 与射线的相交判断
     * @param {hmap.strategy.Raycaster} ray 射线
     * @returns {Object|Null} 相交则返回对象，否则返回null
     * @private
     */
    intersectRay(ray) {
        //首先采用包围盒排除部分对象
        if (!this.intersectBBox(ray._line.getBBox())) {
            return null;
        }
        let closePoint = hmap.strategy.Intersect3D.rayIntersectBox(this, ray.origin, ray.direction);
        if (closePoint) {
            let pointToCamera = ray.distanceSquare(closePoint.getCoordinate());
            // return {
            //     distance: pointToCamera,
            //     box: this
            // }
            return pointToCamera;
        }
        return null;
    }
}
;hmap.proj = hmap.proj||{};
hmap.proj.Math = class{

    /**
     *
     * @param eccent
     * @param sinphi
     * @param cosphi
     * @returns {number}
     */
    static msfnz(eccent, sinphi, cosphi) {
        let con = eccent * sinphi;
        return cosphi / (Math.sqrt(1 - con * con));
    }

    /**
     *
     * @param eccent
     * @param phi
     * @param sinphi
     * @returns {number}
     */
    static tsfnz(eccent, phi, sinphi) {
        let con = eccent * sinphi;
        let com = 0.5 * eccent;
        con = Math.pow(((1 - con) / (1 + con)), com);
        return (Math.tan(0.5 * (PROJ_HALF_PI - phi)) / con);
    }

    /**
     * 判断正负，如果为负数则返回-1,否则返回1.
     * @param x
     * @returns {number}
     */
    static  sign(x) {
        return x<0 ? -1 : 1;
    }

    /**
     * 调整经度
     * @param x
     * @returns {number}
     */
    static adjust_lon(x) {
        return (Math.abs(x) <= PROJ_SPI) ? x : (x - (this.sign(x) * PROJ_TWO_PI));
    }

    /**
     *
     * @param eccent
     * @param ts
     * @returns {number}
     */
    static phi2z(eccent, ts) {
        let eccnth = 0.5 * eccent;
        let con, dphi;
        let phi = PROJ_HALF_PI - 2 * Math.atan(ts);
        for (let i = 0; i <= 15; i++) {
            con = eccent * Math.sin(phi);
            dphi = PROJ_HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
            phi += dphi;
            if (Math.abs(dphi) <= 0.0000000001) {
                return phi;
            }
        }
        return -9999;
    }

    /**
     *
     * @param es
     * @returns {Array}
     */
    static pj_enfn(es) {
        let math = hmap.proj.Math;
        let en = [];
        en[0] = math.C00 - es * (math.C02 + es * (hmap.proj.Math.C04 + es * (math.C06 + es * math.C08)));
        en[1] = es * (math.C22 - es * (math.C04 + es * (math.C06 + es * math.C08)));
        let t = es * es;
        en[2] = t * (math.C44 - es * (math.C46 + es * math.C48));
        t *= es;
        en[3] = t * (math.C66 - es * math.C68);
        en[4] = t * es * math.C88;
        return en;
    }

    /**
     *
     * @param phi
     * @param sphi
     * @param cphi
     * @param en
     * @returns {number}
     */
    static pj_mlfn(phi, sphi, cphi, en) {
        cphi *= sphi;
        sphi *= sphi;
        return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
    }

    /**
     * 调整区域
     * @param zone
     * @param lon
     * @returns {*}
     */
    static adjust_zone(zone, lon) {
        if (zone === undefined) {
            zone = Math.floor((this.adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

            if (zone < 0) {
                return 0;
            } else if (zone > 60) {
                return 60;
            }
        }
        return zone;
    }

    /**
     *
     * @param pp
     * @param B
     * @returns {*}
     */
    static gatg(pp, B) {
        let cos_2B = 2 * Math.cos(2 * B);
        let i = pp.length - 1;
        let h1 = pp[i];
        let h2 = 0;
        let h;

        while (--i >= 0) {
            h = -h2 + cos_2B * h1 + pp[i];
            h2 = h1;
            h1 = h;
        }

        return (B + h * Math.sin(2 * B));
    }

    /**
     *
     * @param x
     * @returns {number}
     */
    static log1py(x) {
        let y = 1 + x;
        let z = y - 1;

        return z === 0 ? x : x * Math.log(y) / z;
    }

    /**
     * 反双曲正弦函数
     * @param x
     * @returns {number}
     */
    static asinhy(x) {
        let y = Math.abs(x);
        y = log1py(y * (1 + y / (hypot(1, y) + 1)));

        return x < 0 ? -y : y;
    }

    /**
     * 双曲正弦函数
     * @param x
     * @returns {*}
     */
    static sinh(x) {
        let r = Math.exp(x);
        r = (r - 1 / r) / 2;
        return r;
    }

    /**
     * 双曲余弦函数
     * @param x
     * @returns {*}
     */
    static cosh(x) {
        let r = Math.exp(x);//以自然常数e为底的指数函数
        r = (r + 1 / r) / 2;
        return r;
    }

    /**
     * @param pp
     * @param arg_r
     * @param arg_i
     * @returns {Array}
     */
    static clens_cmplx(pp, arg_r, arg_i) {
        let sin_arg_r = Math.sin(arg_r);
        let cos_arg_r = Math.cos(arg_r);
        let sinh_arg_i = sinh(arg_i);
        let cosh_arg_i = cosh(arg_i);
        let r = 2 * cos_arg_r * cosh_arg_i;
        let i = -2 * sin_arg_r * sinh_arg_i;
        let j = pp.length - 1;
        let hr = pp[j];
        let hi1 = 0;
        let hr1 = 0;
        let hi = 0;
        let hr2;
        let hi2;

        while (--j >= 0) {
            hr2 = hr1;
            hi2 = hi1;
            hr1 = hr;
            hi1 = hi;
            hr = -hr2 + r * hr1 - i * hi1 + pp[j];
            hi = -hi2 + i * hr1 + r * hi1;
        }

        r = sin_arg_r * cosh_arg_i;
        i = cos_arg_r * sinh_arg_i;

        return [r * hr - i * hi, r * hi + i * hr];
    }

    /**
     *
     * @param pp
     * @param arg_r
     * @returns {number}
     */
    static clens(pp, arg_r) {
        let r = 2 * Math.cos(arg_r);
        let i = pp.length - 1;
        let hr1 = pp[i];
        let hr2 = 0;
        let hr;

        while (--i >= 0) {
            hr = -hr2 + r * hr1 + pp[i];
            hr2 = hr1;
            hr1 = hr;
        }

        return Math.sin(arg_r) * hr;
    }

    /**
     *
     * @param x
     * @param y
     * @returns {number}
     */
    static hypot(x, y) {
        x = Math.abs(x);
        y = Math.abs(y);
        let a = Math.max(x, y);
        let b = Math.min(x, y) / (a ? a : 1);

        return a * Math.sqrt(1 + Math.pow(b, 2));
    }
    /**
     * 匹配方法
     * @param obj
     * @param key
     * @returns {*}
     * @private
     */
    static match(obj, key) {
        if (obj[key]) {
            return obj[key];
        }
        let keys = Object.keys(obj);
        let lkey = key.toLowerCase().replace(PROJ_ignoredChar, '');
        let i = -1;
        let testkey, processedKey;
        while (++i < keys.length) {
            testkey = keys[i];
            processedKey = testkey.toLowerCase().replace(PROJ_ignoredChar, '');
            if (processedKey === lkey) {
                return obj[testkey];
            }
        }
    };
};
hmap.proj.Math.C00 = 1;
hmap.proj.Math.C02 = 0.25;
hmap.proj.Math.C04 = 0.046875;
hmap.proj.Math.C06 = 0.01953125;
hmap.proj.Math.C08 = 0.01068115234375;
hmap.proj.Math.C22 = 0.75;
hmap.proj.Math.C44 = 0.46875;
hmap.proj.Math.C46 = 0.01302083333333333333;
hmap.proj.Math.C48 = 0.00712076822916666666;
hmap.proj.Math.C66 = 0.36458333333333333333;
hmap.proj.Math.C68 = 0.00569661458333333333;
hmap.proj.Math.C88 = 0.3076171875;;
const PROJ_PJD_3PARAM = 1;
const PROJ_PJD_7PARAM = 2;
const PROJ_PJD_WGS84 = 4; // WGS84 or equivalent
const PROJ_PJD_NODATUM = 5; //
const PROJ_SPI = 3.14159265359;
const PROJ_TWO_PI = Math.PI * 2;
const PROJ_HALF_PI = Math.PI/2;
const PROJ_FORTPI = Math.PI/4;
const PROJ_R2D = 57.29577951308232088;
const PROJ_D2R = 0.01745329251994329577;
const PROJ_SEC_TO_RAD = 4.84813681109535993589914102357e-6;//秒转弧度时乘的系数
const PROJ_EPSLN = 1.0e-10;
const R = 6378245;
const ee = 0.006693421622965823;
const PROJ_SIXTH = 0.1666666666666666667;
/* 1/6 */
const PROJ_RA4 = 0.04722222222222222222;
/* 17/360 */
const PROJ_RA6 = 0.02215608465608465608;
const PROJ_units = {
    ft: {to_meter: 0.3048},
    'us-ft': {to_meter: 1200 / 3937}
};
//本初子午线
const PROJ_PrimeMeridian= {
    greenwich: 0.0,//"0dE",
    lisbon:-9.131906111111, //"9d07'54.862\"W",
    paris : 2.337229166667, //"2d20'14.025\"E",
    bogota : -74.080916666667, //"74d04'51.3\"W",
    madrid: -3.687938888889, //"3d41'16.58\"W",
    rome :12.452333333333, //"12d27'8.4\"E",
    bern : 7.439583333333, //"7d26'22.5\"E",
    jakarta : 106.807719444444, //"106d48'27.79\"E",
    ferro : -17.666666666667, //"17d40'W",
    brussels : 4.367975, //"4d22'4.71\"E",
    stockholm : 18.058277777778, //"18d3'29.8\"E",
    athens : 23.7163375, //"23d42'58.815\"E",
    oslo : 10.722916666667, //"10d43'22.5\"E"
};
const PROJ_ignoredChar = /[\s_\-\/\(\)]/g;;'use strict';
hmap.proj=hmap.proj||{};
/**
 * 根据大地基准面编码、基准面转换参数、长半轴、短半轴、扁率、第二偏心率定义大地基准面
 * @private
 */
hmap.proj.Datum = class {
    /**
     *
     * @param datumCode 大地基准编码
     * @param datum_params 基准面转换参数
     * @param a 长半轴
     * @param b 短半轴
     * @param es (a*a-b*b)/(a*a)=1-(b*b)/(a*a)
     * @param ep2 第二偏心率 Math.sqrt(a*a-b*b)/b
     */
    constructor(datumCode, datum_params, a, b, es, ep2) {
        if (datumCode === undefined || datumCode === 'none') {
            this.datum_type = PROJ_PJD_NODATUM;//没有指定基准
        } else {
            this.datum_type = PROJ_PJD_WGS84;//wgs84基准或与wgs84等价的基准
        }

        if (datum_params) {
            this.datum_params = datum_params.map(parseFloat);//将datum_params数组中的每个元素都转成数字类型
            if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {
                this.datum_type = PROJ_PJD_3PARAM;
            }
            if (this.datum_params.length > 3) {
                //需要设置七参数
                if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {
                    this.datum_type = PROJ_PJD_7PARAM;
                    this.datum_params[3] *= PROJ_SEC_TO_RAD;//秒转弧度
                    this.datum_params[4] *= PROJ_SEC_TO_RAD;
                    this.datum_params[5] *= PROJ_SEC_TO_RAD;
                    this.datum_params[6] = (this.datum_params[6] / 1000000.0) + 1.0;//???????? 为什么要除以100万 再加上1？
                }
            }
        }

        this.a = a; //datum object also uses these values
        this.b = b;
        this.es = es;//ellipticity of spheroid 椭球体的椭圆度
        this.ep2 = ep2;//第二偏心率
    }
}
/**
 * 定义并返回一个球体
 * @param a 长半轴
 * @param b 短半轴
 * @param rf 扁率的分母
 * @param ellps 椭球体
 * @param sphere 是否为正球体，为true表示是正球体，为false表示是椭球体
 * @private
 */
hmap.proj.Ellipse = class {
    constructor(a, b, rf, ellps, sphere) {
        if (!a) { // do we have an ellipsoid?
            let ellipse = hmap.proj.Math.match(hmap.proj.ellipses, ellps);
            if (!ellipse) {
                ellipse = WGS84;
            }
            a = ellipse.a;
            b = ellipse.b;
            rf = ellipse.rf;
        }

        if (rf && !b) {
            b = (1.0 - 1.0 / rf) * a;
        }
        if (rf === 0 || Math.abs(a - b) < PROJ_EPSLN) {
            sphere = true;
            b = a;
        }
        this.a = a;
        this.b = b;
        this.rf = rf;
        this.sphere = sphere;
    }

    /**
     * 计算离心率
     * @param a
     * @param b
     * @param rf
     * @param R_A
     * @returns {{es: number, e: number, ep2: number}}
     */
    eccentricity(a, b, rf, R_A) {
        a = a||this.a;
        b = b||this.b;
        rf = rf||this.rf;

        let a2 = a * a; // used in geocentric
        const b2 = b * b; // used in geocentric
        let es = (a2 - b2) / a2; // e ^ 2
        let e = 0;
        if (R_A) {
            a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
            a2 = a * a;
            es = 0;
        } else {
            e = Math.sqrt(es); // eccentricity
        }
        let ep2 = (a2 - b2) / b2; // used in geocentric
        return {
            es: es,//
            e: e, //第一偏心率
            ep2: ep2// 第二偏心率
        };
    }
};

/**
 * 各种椭球体的定义
 * @private
 */
hmap.proj.ellipses={};
hmap.proj.ellipses.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
};

hmap.proj.ellipses.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
};

hmap.proj.ellipses.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
};

hmap.proj.ellipses.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
};

hmap.proj.ellipses.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
};

hmap.proj.ellipses.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
};

hmap.proj.ellipses.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
};

hmap.proj.ellipses.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
};

hmap.proj.ellipses.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

hmap.proj.ellipses.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
};

hmap.proj.ellipses.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
};

hmap.proj.ellipses.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
};

hmap.proj.ellipses.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
};

hmap.proj.ellipses.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
};

hmap.proj.ellipses.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
};

hmap.proj.ellipses.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
};

hmap.proj.ellipses.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
};

hmap.proj.ellipses.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
};

hmap.proj.ellipses.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
};

hmap.proj.ellipses.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
};

hmap.proj.ellipses.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
};

hmap.proj.ellipses.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
};

hmap.proj.ellipses.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
};

hmap.proj.ellipses.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
};

hmap.proj.ellipses.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
};

hmap.proj.ellipses.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
};

hmap.proj.ellipses.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
};

hmap.proj.ellipses.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
};

hmap.proj.ellipses.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
};

hmap.proj.ellipses.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
};

hmap.proj.ellipses.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
};

hmap.proj.ellipses.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
};

hmap.proj.ellipses.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
};

hmap.proj.ellipses.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
};

hmap.proj.ellipses.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
};
//北京54使用的椭球体
hmap.proj.ellipses.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
};

hmap.proj.ellipses.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
};

hmap.proj.ellipses.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
};

hmap.proj.ellipses.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
};

hmap.proj.ellipses.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
};

hmap.proj.ellipses.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
};

hmap.proj.ellipses.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
};

hmap.proj.ellipses.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
};


/**
 * 各种基准面的定义
 * @type {{}}
 * @private
 */
hmap.proj.datums={};
hmap.proj.datums.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
};

hmap.proj.datums.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
};

hmap.proj.datums.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
};

hmap.proj.datums.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
};
hmap.proj.datums.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
};

hmap.proj.datums.potsdam = {
    towgs84: "606.0,23.0,413.0",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
};

hmap.proj.datums.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
};

hmap.proj.datums.hermannskogel = {
    towgs84: "653.0,-212.0,449.0",
    ellipse: "bessel",
    datumName: "Hermannskogel"
};

hmap.proj.datums.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
};

hmap.proj.datums.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
};

hmap.proj.datums.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
};

hmap.proj.datums.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
};

hmap.proj.datums.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
};

hmap.proj.datums.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
};

hmap.proj.datums.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
};

hmap.proj.datums.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
};

hmap.proj.datums.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
};
hmap.proj.datums.Beijing54={
    towgs84:"-79.012056,104.541645,19.399969,-0.000001,0.319096,-0.081277,0.319405",
    ellipse:'krass',
    datumName:'Beijing54'
}

;hmap.proj.Merc =  class {
    constructor(){
        this.init();
        this.CLASS_NAME = 'hmap.proj.Merc';
    }
    init(){
        const con = this.b / this.a;
        this.es = 1 - con * con;
        if (!('x0' in this)) {
            this.x0 = 0;
        }
        if (!('y0' in this)) {
            this.y0 = 0;
        }
        this.e = Math.sqrt(this.es);
        if (this.lat_ts) {
            if (this.sphere) {
                this.k0 = Math.cos(this.lat_ts);
            }
            else {
                this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
        }
        else {
            if (!this.k0) {
                if (this.k) {
                    this.k0 = this.k;
                }
                else {
                    this.k0 = 1;
                }
            }
        }
    }

    /**
     * 投影，将对应的地理坐标系的坐标转换为投影坐标系下的坐标。
     * @param coord 坐标对象
     * @returns {hmap.basetype.Coordinate|null}
     */
    forward(coord){
        const lon = coord.getOrdinate('X')*PROJ_D2R;
        const lat = coord.getOrdinate('Y')*PROJ_D2R;
        // convert to radians
        if (lat * PROJ_R2D > 90 && lat * PROJ_R2D < -90 && lon * PROJ_R2D > 180 && lon * PROJ_R2D < -180) {
            return null;
        }

        let x, y;
        if (Math.abs(Math.abs(lat) - PROJ_HALF_PI) <= PROJ_EPSLN) {
            return null;
        }
        else {
            if (this.sphere) {
                x = this.x0 + this.a * this.k0 * hmap.proj.Math.adjust_lon(lon - this.long0);
                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(PROJ_FORTPI + 0.5 * lat));
            }
            else {
                const sinphi = Math.sin(lat);
                const ts = tsfnz(this.e, lat, sinphi);
                x = this.x0 + this.a * this.k0 * hmap.proj.Math.adjust_lon(lon - this.long0);
                y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            coord.setOrdinate('X',x);
            coord.setOrdinate('Y',y);
            return coord;
        }
    }

    /**
     * 反投影，将投影坐标系的坐标转换为对应的地理坐标系的坐标。
     * @param coord 坐标对象
     * @returns {hmap.basetype.Coordinate|null} 转换后的坐标对象或null
     */
    inverse(coord){
        const x = coord.getOrdinate('X') - this.x0;
        const y = coord.getOrdinate('Y') - this.y0;
        let lon, lat;

        if (this.sphere) {
            lat = PROJ_HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
        }
        else {
            let ts = Math.exp(-y / (this.a * this.k0));
            lat = hmap.proj.Math.phi2z(this.e, ts);
            if (lat === -9999) {
                return null;
            }
        }
        lon = hmap.proj.Math.adjust_lon(this.long0 + x / (this.a * this.k0));

        coord.setOrdinate('X',lon*PROJ_R2D);
        coord.setOrdinate('Y',lat*PROJ_R2D);
        return coord;
    }

    /**
     * 供Transformer类内部调用的方法
     * @param p
     * @returns {*}
     * @private
     */
    _forward(p){
        const lon = p.x;
        const lat = p.y;
        // convert to radians
        if (lat * PROJ_R2D > 90 && lat * PROJ_R2D < -90 && lon * PROJ_R2D > 180 && lon * PROJ_R2D < -180) {
            return null;
        }

        let x, y;
        if (Math.abs(Math.abs(lat) - PROJ_HALF_PI) <= PROJ_EPSLN) {
            return null;
        }
        else {
            if (this.sphere) {
                x = this.x0 + this.a * this.k0 * hmap.proj.Math.adjust_lon(lon - this.long0);
                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(PROJ_FORTPI + 0.5 * lat));
            }
            else {
                const sinphi = Math.sin(lat);
                const ts = tsfnz(this.e, lat, sinphi);
                x = this.x0 + this.a * this.k0 * hmap.proj.Math.adjust_lon(lon - this.long0);
                y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            p.x = x;
            p.y = y;
            return p;
        }
    }

    /**
     *  供Transformer类内部调用的方法
     * @param p
     * @returns {*}
     * @private
     */
    _inverse(p){
        const x = p.x - this.x0;
        const y = p.y - this.y0;
        let lon, lat;

        if (this.sphere) {
            lat = PROJ_HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
        }
        else {
            let ts = Math.exp(-y / (this.a * this.k0));
            lat = hmap.proj.Math.phi2z(this.e, ts);
            if (lat === -9999) {
                return null;
            }
        }
        lon = hmap.proj.Math.adjust_lon(this.long0 + x / (this.a * this.k0));

        p.x = lon;
        p.y = lat;
        return p;
    }
};;hmap.proj.Tmerc=class{
    constructor(){
        this.init();
        this.CLASS_NAME = 'hmap.proj.Tmerc';
    }
    init(){
        this.x0 = this.x0 !== undefined ? this.x0 : 0;
        this.y0 = this.y0 !== undefined ? this.y0 : 0;
        this.long0 = this.long0 !== undefined ? this.long0 : 0;
        this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

        if (this.es) {
            this.en = hmap.proj.Math.pj_enfn(this.es);
            this.ml0 = hmap.proj.Math.pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
        }
    }

    /**
     * 投影，将对应的地理坐标系的坐标转换为投影坐标系下的坐标。
     * @param p
     * @returns {*}
     */
    forward(p) {
        let lon = p.x;
        let lat = p.y;

        let delta_lon = hmap.proj.Math.adjust_lon(lon - this.long0);
        let con;
        let x, y;
        let sin_phi = Math.sin(lat);
        let cos_phi = Math.cos(lat);

        if (!this.es) {
            let b = cos_phi * Math.sin(delta_lon);

            if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
                return (93);
            }
            else {
                x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
                y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
                b = Math.abs(y);

                if (b >= 1) {
                    if ((b - 1) > EPSLN) {
                        return (93);
                    }
                    else {
                        y = 0;
                    }
                }
                else {
                    y = Math.acos(y);
                }

                if (lat < 0) {
                    y = -y;
                }

                y = this.a * this.k0 * (y - this.lat0) + this.y0;
            }
        }
        else {
            let al = cos_phi * delta_lon;
            let als = Math.pow(al, 2);
            let c = this.ep2 * Math.pow(cos_phi, 2);
            let cs = Math.pow(c, 2);
            let tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
            let t = Math.pow(tq, 2);
            let ts = Math.pow(t, 2);
            con = 1 - this.es * Math.pow(sin_phi, 2);
            al = al / Math.sqrt(con);
            let ml = hmap.proj.Math.pj_mlfn(lat, sin_phi, cos_phi, this.en);

            x = this.a * (this.k0 * al * (1 +
                als / 6 * (1 - t + c +
                    als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
                        als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
                this.x0;

            y = this.a * (this.k0 * (ml - this.ml0 +
                sin_phi * delta_lon * al / 2 * (1 +
                    als / 12 * (5 - t + 9 * c + 4 * cs +
                        als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
                            als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
                this.y0;
        }

        p.x = x;
        p.y = y;

        return p;
    }

    /**
     * 反投影，将投影坐标系的坐标转换为对应的地理坐标系的坐标。
     * @param p
     * @returns {*}
     */
    inverse(p) {
        let con, phi;
        let lat, lon;
        let x = (p.x - this.x0) * (1 / this.a);
        let y = (p.y - this.y0) * (1 / this.a);

        if (!this.es) {
            let f = Math.exp(x / this.k0);
            let g = 0.5 * (f - 1 / f);
            let temp = this.lat0 + y / this.k0;
            let h = Math.cos(temp);
            con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
            lat = Math.asin(con);

            if (y < 0) {
                lat = -lat;
            }

            if ((g === 0) && (h === 0)) {
                lon = 0;
            }
            else {
                lon = adjust_lon(Math.atan2(g, h) + this.long0);
            }
        }
        else { // ellipsoidal form
            con = this.ml0 + y / this.k0;
            phi = pj_inv_mlfn(con, this.es, this.en);

            if (Math.abs(phi) < HALF_PI) {
                let sin_phi = Math.sin(phi);
                let cos_phi = Math.cos(phi);
                let tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
                let c = this.ep2 * Math.pow(cos_phi, 2);
                let cs = Math.pow(c, 2);
                let t = Math.pow(tan_phi, 2);
                let ts = Math.pow(t, 2);
                con = 1 - this.es * Math.pow(sin_phi, 2);
                let d = x * Math.sqrt(con) / this.k0;
                let ds = Math.pow(d, 2);
                con = con * tan_phi;

                lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
                    ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
                        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
                            ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

                lon = adjust_lon(this.long0 + (d * (1 -
                    ds / 6 * (1 + 2 * t + c -
                        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
                            ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
            }
            else {
                lat = HALF_PI * hmap.proj.Math.sign(y);
                lon = 0;
            }
        }

        p.x = lon;
        p.y = lat;

        return p;
    }
};;hmap.proj.Etmerc = class {
    constructor(){
        this.init();
        this.CLASS_NAME = 'hmap.proj.Etmerc';
    }

    init(){
        if (this.es === undefined || this.es <= 0) {
            throw new Error('incorrect elliptical usage');
        }

        this.x0 = this.x0 !== undefined ? this.x0 : 0;
        this.y0 = this.y0 !== undefined ? this.y0 : 0;
        this.long0 = this.long0 !== undefined ? this.long0 : 0;
        this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

        this.cgb = [];
        this.cbg = [];
        this.utg = [];
        this.gtu = [];

        let f = this.es / (1 + Math.sqrt(1 - this.es));
        let n = f / (2 - f);
        let np = n;

        this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
        this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

        np = np * n;
        this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
        this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

        np = np * n;
        this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
        this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

        np = np * n;
        this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
        this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

        np = np * n;
        this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
        this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

        np = np * n;
        this.cgb[5] = np * (601676 / 22275);
        this.cbg[5] = np * (444337 / 155925);

        np = Math.pow(n, 2);
        this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

        this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
        this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

        this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
        this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

        np = np * n;
        this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
        this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

        np = np * n;
        this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
        this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

        np = np * n;
        this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
        this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

        np = np * n;
        this.utg[5] = np * (-20648693 / 638668800);
        this.gtu[5] = np * (212378941 / 319334400);

        let Z = hmap.proj.Math.gatg(this.cbg, this.lat0);
        this.Zb = -this.Qn * (Z + hmap.proj.Math.clens(this.gtu, 2 * Z));
    }

    /**
     * 投影，将对应的地理坐标系的坐标转换为投影坐标系下的坐标。
     * @param p
     * @returns {*}
     */
    forward(p){
        let Ce = hmap.proj.Math.adjust_lon(p.x - this.long0);
        let Cn = p.y;

        Cn = hmap.proj.Math.gatg(this.cbg, Cn);
        let sin_Cn = Math.sin(Cn);
        let cos_Cn = Math.cos(Cn);
        let sin_Ce = Math.sin(Ce);
        let cos_Ce = Math.cos(Ce);

        Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
        Ce = Math.atan2(sin_Ce * cos_Cn, hmap.proj.Math.hypot(sin_Cn, cos_Cn * cos_Ce));
        Ce = hmap.proj.Math.asinhy(Math.tan(Ce));

        let tmp = hmap.proj.Math.clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

        Cn = Cn + tmp[0];
        Ce = Ce + tmp[1];

        let x;
        let y;

        if (Math.abs(Ce) <= 2.623395162778) {
            x = this.a * (this.Qn * Ce) + this.x0;
            y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
        }
        else {
            x = Infinity;
            y = Infinity;
        }

        p.x = x;
        p.y = y;

        return p;
    }

    /**
     * 反投影，将投影坐标系的坐标转换为对应的地理坐标系的坐标。
     * @param p
     * @returns {*}
     */
    inverse(p){
        let Ce = (p.x - this.x0) * (1 / this.a);
        let Cn = (p.y - this.y0) * (1 / this.a);

        Cn = (Cn - this.Zb) / this.Qn;
        Ce = Ce / this.Qn;

        let lon;
        let lat;

        if (Math.abs(Ce) <= 2.623395162778) {
            let tmp = hmap.proj.Math.clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

            Cn = Cn + tmp[0];
            Ce = Ce + tmp[1];
            Ce = Math.atan(hmap.proj.Math.sinh(Ce));

            let sin_Cn = Math.sin(Cn);
            let cos_Cn = Math.cos(Cn);
            let sin_Ce = Math.sin(Ce);
            let cos_Ce = Math.cos(Ce);

            Cn = Math.atan2(sin_Cn * cos_Ce, hmap.proj.Math.hypot(sin_Ce, cos_Ce * cos_Cn));
            Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

            lon = hmap.proj.Math.adjust_lon(Ce + this.long0);
            lat = hmap.proj.Math.gatg(this.cgb, Cn);
        }
        else {
            lon = Infinity;
            lat = Infinity;
        }

        p.x = lon;
        p.y = lat;

        return p;
    }
};;hmap.proj.Utm = class {
    constructor(){
        this.init();
        this.CLASS_NAME = 'hmap.proj.Utm';
    }
    init(){
        let zone = hmap.proj.Math.adjust_zone(this.zone, this.long0);
        if (zone === undefined) {
            throw new Error('unknown utm zone');
        }
        this.lat0 = 0;//自然原点纬度
        this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;//自然原点经度
        this.x0 = 500000;//东向偏移
        this.y0 = this.utmSouth ? 10000000 : 0;//北向偏移
        this.k0 = 0.9996;//自然原点处的比例因子

        //etmerc.init.apply(this);
        let etmerc =new hmap.proj.Etmerc();
        etmerc.init.apply(this);

        this.forward = etmerc.forward;
        this.inverse = etmerc.inverse;
    }
};;"use strict";
hmap.proj = hmap.proj || {};
/**
 * 本类用于坐标系对象的定义
 * 每种坐标系在EPSG中,都拥有唯一的标识，即srid。
 * 已经支持的坐标系srid有：4326(或4490)、3857(或900913)，其他坐标系需传options参数进行定义或通过添加到hmap.proj.defs中来定义。
 * 参考http://epsg.io/ 或 https://spatialreference.org/
 *
 * @type {hmap.proj.Crs}
 * @example
 * let crs1 = new hmap.proj.Crs('4326');
 * let crs2 = new hmap.proj.Crs('3857');
 * 或者
 * let options = {
 *      a: 6378137,
 *      b: 6378137,
 *      datumCode: "none",
 *      k0: 1,
 *      lat_ts: 0,
 *      long0: 0,
 *      no_defs: true,
 *      projName: "merc",
 *      title: "WGS 84 / Pseudo-Mercator",
 *      units: "m",
 *      x0: 0,
 *      y0: 0
 * }
 * let crs3 = new hmap.proj.Crs('1234',options);
 * hmap.proj.defs['EPSG:4214'] = "+proj=longlat +ellps=krass +datum=Beijing54 +no_defs"//Beijing54
 * let crs4 = new hmap.proj.Crs('4214');
 *
 */
hmap.proj.Crs = class {
    /**
     * 构造函数
     * @param {String|Number} srid  必选项，坐标系在EPSG中的唯一标识，比如srid为4326，3857等
     * @param {Object|String} options 坐标系定义需要的参数。
     * @param {Number} options.a  坐标系采用的椭球体的长半轴的长度
     * @param {Number} options.b  坐标系采用的椭球体的短半轴的长度
     * @param {String} options.datumCode  基准面的编码
     * @param {String} options.units  坐标的单位
     * @param {hmap.basetype.Extent} options.extent  坐标系的范围
     * @param {String} options.crsType  坐标系的类型
     * @param {Number} options.metersPerUnit  每个坐标单位对应多少米
     * @param {hmap.basetype.Extent} options.worldExtent  坐标系的世界范围
     * @param {String} options.axisOrientation  
     * @throws 当第一个参数srid没有被提供时，抛出异常
     *
     */
    constructor(srid,options={}) {
        if(!srid){
            throw new Error('The param srid must be supplied!');
        }
        let crsKey = 'EPSG:' + srid;
        if(hmap.proj.defs[crsKey]){
            options = hmap.proj.defs[crsKey];
        }

        if(typeof options ==='string'){//如果options是字符串，则将字符串转为json对象。
            options = hmap.proj.Crs.fromString(options);
        }

        this._srid = srid;
        this._name = options.name||'WGS84';
        this._units = options.units||'degrees';//坐标系的单位，默认为度

        //初始化椭球体和基准面
        this._initDatum(options);

        //扩展其他参数
        this._extend(this,options);

        this.k0 = options.k0||0.0;//比例因子
        this.axis = options.axis||'enu';//坐标轴朝向

        this._metersPerUnit = options.to_meter?options.to_meter:111000;//转换为米时的乘数
        this.vUnit =options.vunits?options.vunits:'m';//垂直单位默认是米

        //设置坐标系的类型
        let projName = options.projName||'longlat';
        switch(projName){
            case 'longlat':
                this._crsType = 'GeoCRS';
                this._worldExtent = new hmap.basetype.Extent(-180,-90,180,90);
                break;
            case 'geocent'://地心空间直角坐标系
                this._crsType = 'GeoCentCRS';
                this._units='m';
                break;
            default:
                this._crsType = 'ProjCRS';
                //this._worldExtent = new hmap.basetype.Extent(-20026376.39,-20048966.10,20026376.39,20048966.10);
                this._worldExtent = new hmap.basetype.Extent(-20037508.342789, -20037508.342789,20037508.342789, 20037508.342789);
                if(this._units==='degrees'){
                    this._units='m';
                }
        }
        if(options.worldExtent){
            this._worldExtent = options.worldExtent;
        }

        this._extent = options.extent||this._worldExtent;

        projName = options.projName;
        //如果定义了投影，则按指定的投影方式进行投影
        if(hmap.proj.Projs[projName]){
            this.init = hmap.proj.Projs[projName].init;
            this.forward = hmap.proj.Projs[projName].forward;
            this.inverse = hmap.proj.Projs[projName].inverse;
            this._forward = hmap.proj.Projs[projName]._forward;
            this._inverse = hmap.proj.Projs[projName]._inverse;
        }

        this.init();
        this.CLASS_NAME = 'hmap.proj.Crs';
    }

    /**
     * 初始化投影坐标系需要赋值的参数
     */
    init(){
        //扩展投影坐标系时
    }

    /**
     * 从地理坐标转换到投影坐标，针对投影坐标系有效，如果Crs是地理坐标系返回地理坐标本身。
     * @param coord {hmap.basetype.Coordinate} 地理坐标对象
     * @returns {hmap.basetype.Coordinate} 投影坐标对象
     */
    forward(coord){
        return coord;
    }

    /**
     * 从投影坐标转换到地理坐标，针对投影坐标系有效，如果Crs是地理坐标系返回坐标本身。
     * @param coord {hmap.basetype.Coordinate} 投影坐标对象
     * @returns {hmap.basetype.Coordinate}  地理坐标对象
     */
    inverse(coord){
        return coord;
    }

    /**
     * 将地心空间直角坐标系的坐标对象转换为对应的地理坐标系的坐标对象。
     * @param coord {hmap.basetype.Coordinate} 坐标对象
     * @returns {hmap.basetype.Coordinate} 地理坐标系下的坐标对象，坐标值的单位是度。
     * @private
     */
    toGeodetic(coord) {
        if(this._crsType==="GeoCentCRS"){//地心空间直角坐标系
            let p = {
                x: coord.getOrdinate("X"),
                y: coord.getOrdinate('Y'),
                z: coord.getOrdinate('Z')
            };

           p = hmap.proj.DatumUtil.geocentricToGeodetic(p, this.es, this.a, this.b);
           coord.setOrdinate('X',p.x*PROJ_R2D);
           coord.setOrdinate('Y',p.y*PROJ_R2D);
           coord.setOrdinate('Z',p.z);
        }
        return coord;
    }

    /**
     * 从当前坐标系转换到地理坐标系，Transformer类内部调用，不对外公开。
     * @param pt pt为包含x、y、z的地心空间直角坐标系的坐标，单位为米。
     * @private
     */
    _toGeodetic(pt) {
        pt = hmap.proj.DatumUtil.geocentricToGeodetic(pt, this.es, this.a, this.b);
        return pt;
    }
    /**
     * 从当前坐标系转换到地心空间直角坐标系，Transformer类内部调用，不对外公开。
     * @param pt pt为包含x、y、z的地理坐标系坐标，且单位是弧度。
     * @private
     */
    _toGeocentric(pt){
        pt = hmap.proj.DatumUtil.geodeticToGeocentric(pt, this.es, this.a);
        return pt;
    }

    /**
     * 将地理坐标系的坐标对象转换为对应的地心空间直角坐标系的坐标对象。
     * @param coord {hmap.basetype.Coordinate} 地理坐标系的坐标对象
     * @returns {hmap.basetype.Coordinate} 地心空间直角坐标系下的坐标对象，坐标值的单位是米。
     * @private
     */
    toGeocentric(coord){
        if(this._crsType==='GeoCRS') {
            let p = {
                x: coord.getOrdinate('X')*PROJ_D2R,
                y: coord.getOrdinate('Y')*PROJ_D2R,
                z: coord.getOrdinate('Z')
            };
            p = hmap.proj.DatumUtil.geodeticToGeocentric(p, this.es, this.a);
            coord.setOrdinate('X', p.x);
            coord.setOrdinate('Y', p.y);
            coord.setOrdinate('Z', p.z);
        }
        return coord;
    }

    /**
     * 初始化椭球体和基准面
     * @private
     */
    _initDatum(options){
        if(options.datumCode && options.datumCode!=='none'){
            let datumDef = hmap.proj.Math.match(hmap.proj.datums,options.datumCode);
            if(datumDef){
                options.datum_params = datumDef.towgs84?datumDef.towgs84.split(','):null;
                options.ellps = datumDef.ellipse;
                options.datumName = datumDef.datumName?datumDef.datumName:options.datumCode;
            }
        }
        this.ellps = options.ellps||'wgs84';//椭球体名称
        //椭球体
        let ellipse = new hmap.proj.Ellipse(options.a,options.b,options.rf,options.ellps,options.sphere);
        //椭球体参数
        this.a = ellipse.a;//长半轴长度
        this.b = ellipse.b;//短半轴长度
        this.rf = ellipse.rf;//扁率的分母，即扁率的倒数
        this.sphere = ellipse.sphere;//是否为正球体

        //曲率
        let ecc = ellipse.eccentricity(null,null,null,options.R_A);
        this.es = ecc.es;
        this.e = ecc.e;
        this.ep2 = ecc.ep2;
        //基准面
        this.datum = options.datum||new hmap.proj.Datum(options.datumCode,options.datum_params,ellipse.a,ellipse.b,ecc.es,ecc.ep2);
        this.datumCode=options.datumCode||'none';
    }
    /**
     * 获取当前坐标系的单位，米或者度
     * @returns {String} 坐标系的单位
     */
    getUnit () {
        return this._units;
    }

    /**
     * 获取坐标系的空间参考标识srid
     * @returns {String} 唯一标识srid
     */
    getSrid() {
        return this._srid;
    }

    /**
     * 获取坐标系名称
     * @returns {String} 坐标系名称
     */
    getName () {
        return this._name;
    }

    /**
     * 获取坐标系的范围
     * @returns {hmap.basetype.Extent} 坐标系的范围
     */
    getExtent(){
        return this._extent;
    }

    /**
     * 获取坐标系的类型
     * @returns {String} 若是地理坐标系，返回"GeoCRS";若是投影坐标系，返回"ProjCRS"。
     */
    getCrsType(){
        return this._crsType;
    }

    /**
     * 获取坐标系使用椭球体的地球半径
     * @returns {Number} 地球半径
     */
    getRadius(){
        return this._radius||(2*this.a+this.b)/3.0;
    }

    /**
     * 获取高程的单位
     * @returns {String} 高程的单位
     * @private
     */
    getEllipseHeightUnit(){
        return this.vUnit;
    }

    /**
     * 获取坐标系采用的椭球体的长半轴
     * @returns {Number} 长半轴长度
     */
    getSemiMajorAxis() {
        return this.a;
    }

    /**
     * 获取坐标系采用椭球体的短半轴
     * @returns {Number} 短半轴长度
     */
    getSemiMinorAxis() {
        if(this.b) {
            return this.b;
        }else if(this.rf){
            return this.a * (1 - 1/this.rf);
        }
    }

    /**
     * 获取坐标系采用椭球体的扁率
     * @returns {Number} 扁率
     */
    getFlattening() {
        if(this.rf){
            return 1/this.rf;
        }else{
            return (a-b)/a;
        }
    }

    /**
     * 获取地图单位对应多少米
     * @returns {Number} 地图单位对应多少米
     * @private
     */
    getMetersPerUnit(){
        return this._metersPerUnit;
    }

    /**
     * 获取坐标系的世界范围
     * @returns {hmap.basetype.Extent} 坐标系的世界范围
     * @private
     */
    getWorldExtent(){
        return this._worldExtent;
    }

    /**
     * 把坐标系定义的字符串转换为json对象。
     * @param defString {String}字符串格式的坐标系定义，参考http://epsg.io网站上坐标系中Proj4js格式的坐标系定义。
     * @returns {{}} 返回json格式的坐标系定义。
     * @example
     * const crsStr = "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs";
     * let crsJson = hmap.proj.Crs.fromString(crsStr);
     *
     */
    static fromString(defString){
        let self = {};
        //坐标系参数对象
        const paramObj = defString.split('+').map(function(v) {
            return v.trim();
        }).filter(function(a) {
            return a;
        }).reduce(function(p, a) {
            let split = a.split('=');
            split.push(true);
            p[split[0].toLowerCase()] = split[1];
            return p;
        }, {});
        let paramName, paramVal, paramOutname;
        let params = {
            proj: 'projName',
            datum: 'datumCode',
            rf: function(v) {
                self.rf = parseFloat(v);
            },
            lat_0: function(v) {
                self.lat0 = v * PROJ_D2R;
            },
            lat_1: function(v) {
                self.lat1 = v * PROJ_D2R;
            },
            lat_2: function(v) {
                self.lat2 = v * PROJ_D2R;
            },
            lat_ts: function(v) {
                self.lat_ts = v * PROJ_D2R;
            },
            lon_0: function(v) {
                self.long0 = v * PROJ_D2R;
            },
            lon_1: function(v) {
                self.long1 = v * PROJ_D2R;
            },
            lon_2: function(v) {
                self.long2 = v * PROJ_D2R;
            },
            alpha: function(v) {
                self.alpha = parseFloat(v) * PROJ_D2R;
            },
            lonc: function(v) {
                self.longc = v * PROJ_D2R;
            },
            x_0: function(v) {
                self.x0 = parseFloat(v);
            },
            y_0: function(v) {
                self.y0 = parseFloat(v);
            },
            k_0: function(v) {
                self.k0 = parseFloat(v);
            },
            k: function(v) {
                self.k0 = parseFloat(v);
            },
            a: function(v) {
                self.a = parseFloat(v);
            },
            b: function(v) {
                self.b = parseFloat(v);
            },
            r_a: function() {
                self.R_A = true;
            },
            zone: function(v) {
                self.zone = parseInt(v, 10);
            },
            south: function() {
                self.utmSouth = true;
            },
            towgs84: function(v) {
                self.datum_params = v.split(",").map(function(a) {
                    return parseFloat(a);
                });
            },
            to_meter: function(v) {
                self.to_meter = parseFloat(v);
            },
            units: function(v) {
                self.units = v;
                let unit = hmap.proj.Math.match(PROJ_units, v);
                if (unit) {
                    self.to_meter = unit.to_meter;
                }
            },
            from_greenwich: function(v) {
                self.from_greenwich = v * PROJ_D2R;
            },
            pm: function(v) {
                let pm = hmap.proj.Math.match(PrimeMeridian, v);
                self.from_greenwich = (pm ? pm : parseFloat(v)) * PROJ_D2R;
            },
            nadgrids: function(v) {
                if (v === '@null') {
                    self.datumCode = 'none';
                }
                else {
                    self.nadgrids = v;
                }
            },
            axis: function(v) {
                let legalAxis = "ewnsud";
                if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                    self.axis = v;
                }
            }
        };
        for (paramName in paramObj) {
            paramVal = paramObj[paramName];
            if (paramName in params) {
                paramOutname = params[paramName];
                if (typeof paramOutname === 'function') {
                    paramOutname(paramVal);
                }
                else {
                    self[paramOutname] = paramVal;
                }
            }
            else {
                self[paramName] = paramVal;
            }
        }
        if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
            self.datumCode = self.datumCode.toLowerCase();
        }
        return self;
    }

    /**
     *
     * @param destination
     * @param source
     * @returns {*|{}}
     * @private
     */
    _extend(destination, source) {
        destination = destination || {};
        let value, property;
        if (!source) {
            return destination;
        }
        for (property in source) {
            value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }
        return destination;
    }

    /**
     * 计算在某纬度附近时一度代表多少米
     * @param  {Number} atLat 所在的纬度，单位是度，可选参数，纬度范围为-90 ~ 90,当不传时按纬度为0进行计算。
     * @returns {Number} 每一度代表多少米
     */
    getMeterPerDegree(atLat=0) {
        const R = Math.cos(atLat*PROJ_SPI/180) * this.getRadius();// 纬度atLat 所在纬线圈的半径,单位为米
        const meterSpan = Math.abs(PROJ_SPI * R / 180);
        return meterSpan;
    }

    /**
     * 计算某纬度处一米代表多少度
     * @param {Number} atLat 所在的纬度，单位是度，可选参数，纬度范围为-90 ~ 90,当不传时按纬度为0进行计算。
     * @returns {Number} 每一米代表多少度
     */
    getDegreePerMeter(atLat){
        return 1/this.getMeterPerDegree(atLat);
    }

};
/**
 * 常用坐标系的参数定义
 * @type {{"EPSG:4326": string, "EPSG:4269": string, "EPSG:3857": string, "EPSG:4214": string, "EPSG:2045": string, "EPSG:2058": string}}
 * @private
 */
hmap.proj.defs = {
    'EPSG:4326': "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
    "EPSG:4479": "+proj=geocent +ellps=GRS80 +units=m +no_defs",//4479 为 Geocentric 地心测量
    'EPSG:4269': "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees",
    'EPSG:3857': "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs",
    'EPSG:4214': "+proj=longlat +ellps=krass +datum=Beijing54 +no_defs",//Beijing54
    'EPSG:2045': "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=19500000 +y_0=0 +ellps=krass +towgs84=-17.51,-108.32,-62.39,0,0,0,0 +units=m +no_defs",//Gauss-Kruger zone 19
    'EPSG:2058': "+proj=utm +zone=38 +ellps=intl +units=m +no_defs"//UTM 38N
};
hmap.proj.defs['EPSG:900913'] = hmap.proj.defs['EPSG:3857'];
hmap.proj.defs['EPSG:4490'] = hmap.proj.defs['EPSG:4326'];//4490 为 Geodetic 大地测量

/**
 * 投影坐标系的扩展
 * @type {{merc: hmap.proj.Merc, tmerc: hmap.proj.Tmerc}}
 * @private
 */
hmap.proj.Projs={
    'merc':new hmap.proj.Merc(),
    'tmerc':new hmap.proj.Tmerc(),
    // 'utm':new hmap.proj.Utm()
};

;'use strict';
hmap.proj = hmap.proj||{};
hmap.proj.DatumUtil=class{
    /**
     * 对比两个大地基准面，判断是否相等
     * @private
     */
    static compareDatums(source, dest) {
        if (source.datum_type !== dest.datum_type) {
            return false; // false, datums are not equal
        } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
            // the tolerance for es is to ensure that GRS80 and WGS84
            // are considered identical
            return false;
        } else if (source.datum_type === PROJ_PJD_3PARAM) {
            return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
        } else if (source.datum_type === PROJ_PJD_7PARAM) {
            return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
        } else {
            return true; // datums are equal
        }
    } // cs_compare_datums()

    /*
     * 将大地坐标系坐标转换为地心空间直角坐标系的坐标。大地坐标系是球面坐标系
     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
     * according to the current ellipsoid parameters.
     *
     *    Latitude  : Geodetic latitude in radians                     (input)
     *    Longitude : Geodetic longitude in radians                    (input)
     *    Height    : Geodetic height, in meters                       (input)
     *    X         : Calculated Geocentric X coordinate, in meters    (output)
     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
     *
     * @param p 大地坐标
     * @param es 扁率
     * @param a 长半轴长度
     * @private
     *
     */
    static geodeticToGeocentric(p, es, a) {
        let Longitude = p.x;
        let Latitude = p.y;
        let Height = p.z ? p.z : 0; //Z value not always supplied

        let Rn; /*  Earth radius at location  */
        let Sin_Lat; /*  Math.sin(Latitude)  */
        let Sin2_Lat; /*  Square of Math.sin(Latitude)  */
        let Cos_Lat; /*  Math.cos(Latitude)  */

        /*
         ** Don't blow up if Latitude is just a little out of the value
         ** range as it may just be a rounding issue.  Also removed longitude
         ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
         */
        if (Latitude < -PROJ_HALF_PI && Latitude > -1.001 * PROJ_HALF_PI) {
            Latitude = -PROJ_HALF_PI;
        } else if (Latitude > PROJ_HALF_PI && Latitude < 1.001 * PROJ_HALF_PI) {
            Latitude = PROJ_HALF_PI;
        } else if (Latitude < -PROJ_HALF_PI) {
            /* Latitude out of range */
            //..reportError('geocent:lat out of range:' + Latitude);
            return { x: -Infinity, y: -Infinity, z: p.z };
        } else if (Latitude > PROJ_HALF_PI) {
            /* Latitude out of range */
            return { x: Infinity, y: Infinity, z: p.z };
        }

        if (Longitude > Math.PI) {
            Longitude -= (2 * Math.PI);
        }
        Sin_Lat = Math.sin(Latitude);
        Cos_Lat = Math.cos(Latitude);
        Sin2_Lat = Sin_Lat * Sin_Lat;
        Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
        return {
            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
            z: ((Rn * (1 - es)) + Height) * Sin_Lat
        };
    } // cs_geodetic_to_geocentric()
    /**
     * 将地心直角坐标系的坐标转换为大地坐标系的坐标（经度、纬度、高程）
     * @param p 地心坐标
     * @param es 扁率
     * @param a 长半轴长度
     * @param b 短半轴长度
     * @private
     */
    static geocentricToGeodetic(p, es, a, b) {
        /* local defintions and variables */
        /* end-criterium of loop, accuracy of sin(Latitude) */
        const genau = 1e-12;
        const genau2 = (genau * genau);
        const maxiter = 30;

        let P; /* distance between semi-minor axis and location */
        let RR; /* distance between center and location */
        let CT; /* sin of geocentric latitude */
        let ST; /* cos of geocentric latitude */
        let RX;
        let RK;
        let RN; /* Earth radius at location */
        let CPHI0; /* cos of start or old geodetic latitude in iterations */
        let SPHI0; /* sin of start or old geodetic latitude in iterations */
        let CPHI; /* cos of searched geodetic latitude */
        let SPHI; /* sin of searched geodetic latitude */
        let SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
        let iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

        let X = p.x;
        let Y = p.y;
        let Z = p.z ? p.z : 0.0; //Z value not always supplied
        let Longitude;
        let Latitude;
        let Height;

        P = Math.sqrt(X * X + Y * Y);
        RR = Math.sqrt(X * X + Y * Y + Z * Z);

        /*      special cases for latitude and longitude */
        if (P / a < genau) {

            /*  special case, if P=0. (X=0., Y=0.) */
            Longitude = 0.0;

            /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
             *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
            if (RR / a < genau) {
                Latitude = HALF_PI;
                Height = -b;
                return {
                    x: p.x,
                    y: p.y,
                    z: p.z
                };
            }
        } else {
            /*  ellipsoidal (geodetic) longitude
             *  interval: -PI < Longitude <= +PI */
            Longitude = Math.atan2(Y, X);
        }

        /* --------------------------------------------------------------
         * Following iterative algorithm was developped by
         * "Institut for Erdmessung", University of Hannover, July 1988.
         * Internet: www.ife.uni-hannover.de
         * Iterative computation of CPHI,SPHI and Height.
         * Iteration of CPHI and SPHI to 10**-12 radian resp.
         * 2*10**-7 arcsec.
         * --------------------------------------------------------------
         */
        CT = Z / RR;
        ST = P / RR;
        RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
        CPHI0 = ST * (1.0 - es) * RX;
        SPHI0 = CT * RX;
        iter = 0;

        /* loop to find sin(Latitude) resp. Latitude
         * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
        do {
            iter++;
            RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

            /*  ellipsoidal (geodetic) height */
            Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

            RK = es * RN / (RN + Height);
            RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
            CPHI = ST * (1.0 - RK) * RX;
            SPHI = CT * RX;
            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
            CPHI0 = CPHI;
            SPHI0 = SPHI;
        }
        while (SDPHI * SDPHI > genau2 && iter < maxiter);

        /*      ellipsoidal (geodetic) latitude */
        Latitude = Math.atan(SPHI / Math.abs(CPHI));
        return {
            x: Longitude,
            y: Latitude,
            z: Height
    };
    } // cs_geocentric_to_geodetic()

    /****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


    /** point object, nothing fancy, just allows values to be
     passed back and forth by reference rather than by value.
     Other point classes may be used as long as they have
     x and y properties, which will get modified in the transform method.
     * 将其他地心直角坐标系的坐标通过3参数或7参数转成以WGS84为椭球的空间直角坐标系的坐标
     * @param p 地心坐标点
     * @param datum_type 参数类型
     * @param datum_params 参数
     * @returns wgs84地心点
     * @private
     */
    static geocentricToWgs84(p, datum_type, datum_params) {

        if (datum_type === PROJ_PJD_3PARAM) {
            // if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: p.x + datum_params[0],
                y: p.y + datum_params[1],
                z: p.z + datum_params[2],
            };
        } else if (datum_type === PROJ_PJD_7PARAM) {
            const Dx_BF = datum_params[0];
            const Dy_BF = datum_params[1];
            const Dz_BF = datum_params[2];
            const Rx_BF = datum_params[3];
            const Ry_BF = datum_params[4];
            const Rz_BF = datum_params[5];
            const M_BF = datum_params[6];
            // if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
                y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
                z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
            };
        }
    } // cs_geocentric_to_wgs84

    /****************************************************************/
// 将以wgs84为参考椭球的直角坐标系的坐标通过3参数或7参数转换为其他地心直角坐标系的坐标
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
    /**
     * @param p wgs84地心点
     * @param datum_type
     * @param datum_params
     * @returns 指定参数对应基准面的地心点
     * @private
     */
    static geocentricFromWgs84(p, datum_type, datum_params) {

        if (datum_type === PROJ_PJD_3PARAM) {
            //if( x[io] === HUGE_VAL )
            //    continue;
            return {
                x: p.x - datum_params[0],
                y: p.y - datum_params[1],
                z: p.z - datum_params[2],
            };

        } else if (datum_type === PROJ_PJD_7PARAM) {
            const Dx_BF = datum_params[0];
            const Dy_BF = datum_params[1];
            const Dz_BF = datum_params[2];
            const Rx_BF = datum_params[3];
            const Ry_BF = datum_params[4];
            const Rz_BF = datum_params[5];
            const M_BF = datum_params[6];
            const x_tmp = (p.x - Dx_BF) / M_BF;
            const y_tmp = (p.y - Dy_BF) / M_BF;
            const z_tmp = (p.z - Dz_BF) / M_BF;
            //if( x[io] === HUGE_VAL )
            //    continue;

            return {
                x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
                y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
                z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
            };
        } //cs_geocentric_from_wgs84()
    }


    static checkParams(type) {
        return (type === PROJ_PJD_3PARAM || type === PROJ_PJD_7PARAM);
    }
    /**
     * 将点坐标从源基准面变换到目标基准面
     * @param source 源基准面
     * @param dest 目标基准面
     * @param point 点
     * @private
     */
    static datum_transform(source, dest, point) {
        // Short cut if the datums are identical.
        if (this.compareDatums(source, dest)) {
            return point; // in this case, zero is sucess,
            // whereas cs_compare_datums returns 1 to indicate TRUE
            // confusing, should fix this
        }

        // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
        if (source.datum_type === PROJ_PJD_NODATUM || dest.datum_type === PROJ_PJD_NODATUM) {
            return point;
        }

        // If this datum requires grid shifts, then apply it to geodetic coordinates.

        // Do we need to go through geocentric coordinates? 我们是否要经过地心坐标转换 如果椭球体的参数相等，则不需要经过地心坐标转换
        if (source.es === dest.es && source.a === dest.a && !this.checkParams(source.datum_type) &&  !this.checkParams(dest.datum_type)) {
            return point;
        }

        // Convert to geocentric coordinates. 转成源基准的地心坐标
        point = this.geodeticToGeocentric(point, source.es, source.a);
        // Convert between datums
        if (this.checkParams(source.datum_type)) {
            point = this.geocentricToWgs84(point, source.datum_type, source.datum_params);//转成wgs84的地心坐标
        }
        if (this.checkParams(dest.datum_type)) {
            point = this.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);//转成目标基准的地心坐标
        }
        return this.geocentricToGeodetic(point, dest.es, dest.a, dest.b);//转成地理坐标

    }
};"use strict";
hmap.proj = hmap.proj || {};
/**
 * 实现坐标转换功能的静态类
 * @type {hmap.proj.Transformer}
 */
hmap.proj.Transformer = class{

    /**
     * 将一个坐标系的坐标转换到在另一种坐标系中的坐标值。目前支持4326和3857之间的相互转换，如果需要支持其他转换请先通过add方法添加坐标系。
     * @param {hmap.basetype.Coordinate} coord 需要转换的坐标对象
     * @param {hmap.proj.Crs|String|Number} source 源坐标系或源坐标系对应的srid
     * @param {hmap.proj.Crs|String|Number} dest 目标坐标系或目标坐标系对应的srid
     * @returns {hmap.basetype.Coordinate} 坐标对象
     * @example
     * const coord1 = new hmap.basetype.Coordinate(120.99,30.8886,-1.5);
     * const coord2 = hmap.proj.Transformer.transform(coord1,4326,3857);
     * const coord3 = hmap.proj.Transformer.transform(coord2,3857,4326);
     * console.log('coord3:',coord3)
     */
    static transform(coord, source, dest) {
        let pt =hmap.proj.Transformer._coordToPoint(coord);
        let sourceCrs=source,destCrs = dest;
        if(typeof source ==="number" || typeof source==='string'){
            sourceCrs = hmap.proj.Transformer.CrsList['EPSG'+source];
            if(sourceCrs===undefined){
                throw new Error(source + " is not in hmap.proj.Transformer.CrsList,please add first.");
            }
        }
        if(typeof dest ==="number" || typeof dest==='string'){
            destCrs = hmap.proj.Transformer.CrsList['EPSG'+dest];
            if(destCrs===undefined){
                throw new Error(dest + ' is not in hmap.proj.Transformer.CrsList,please add first.');
            }
        }

        if(sourceCrs.axis!=='enu'){
            pt = hmap.proj.Transformer.adjust_axis(sourceCrs,false,pt);
        }
        const crsType = sourceCrs.getCrsType();
        if(crsType==='GeoCRS'){//是经纬度坐标系
            pt = {
                x:pt.x*PROJ_D2R,
                y:pt.y*PROJ_D2R,
                z:pt.z
            }
        }else if(crsType==="ProjCRS"){//投影坐标系
            if(sourceCrs.to_meter){
                pt={
                    x:pt.x*sourceCrs.to_meter,
                    y:pt.y*sourceCrs.to_meter,
                    z:pt.z
                }
            }
            //coord=hmap.proj.Transformer._pointToCoord(pt);
            pt = sourceCrs._inverse(pt);
            //pt = hmap.proj.Transformer._coordToPoint(coord);
        }else if(crsType==='GeoCentCRS'){//地心空间直角坐标系
            pt = sourceCrs._toGeodetic(pt);
        }

        if(sourceCrs.from_greenwich){
            pt.x +=source.from_greenwich;
        }
        //在需要并可能的情况下转换基准面。
        pt = hmap.proj.DatumUtil.datum_transform(sourceCrs.datum,destCrs.datum,pt);

        if(destCrs.from_greenwich){
            pt = {
                x:pt.x - destCrs.from_greenwich,
                y:pt.y
            };
        }
        const destCrsType = destCrs.getCrsType();
        if(destCrsType==='GeoCRS'){
            pt = {
                x: pt.x*PROJ_R2D,
                y: pt.y*PROJ_R2D
            };
        }else if(destCrsType==='ProjCRS'){
            pt = destCrs._forward(pt);
            if(destCrs.to_meter){
                pt = {
                    x: pt.x/destCrs.to_meter,
                    y: pt.y/destCrs.to_meter
                };
            }
        }else if(destCrsType==="GeoCentCRS"){
           pt = destCrs._toGeocentric(pt);
        }

        if(destCrs.axis!=='enu'){
            return hmap.proj.Transformer.adjust_axis(dest,true,pt);
        }

        coord.setOrdinate('X',pt.x);
        coord.setOrdinate('Y',pt.y);
        if(pt.z) {
            coord.setOrdinate('Z', pt.z);
        }
        return coord;
    }


    /**
     * 将加密后的坐标还原成原始的WGS84坐标，即将GCJ02坐标系下的坐标转换为WGS84坐标系下的坐标。当经纬度坐标在中国国内时进行转换，在国外时原样返回，不进行转换。
     * @param {Array} coord 待转换的由经度和纬度组成的数组。
     * @returns {Array} 转换后的经度和纬度组成的数组
     */
    static GCJ02ToWGS84(coord){
        const [lon, lat] = coord;

        if (!hmap.proj.Transformer.isInChinaBbox(lon, lat)) return [lon, lat];

        let [wgsLon, wgsLat] = [lon, lat];

        let tempPoint = hmap.proj.Transformer.WGS84ToGCJ02([wgsLon, wgsLat]);

        let dx = tempPoint[0] - lon;
        let dy = tempPoint[1] - lat;

        while (Math.abs(dx) > 1e-6 || Math.abs(dy) > 1e-6) {
            wgsLon -= dx;
            wgsLat -= dy;

            tempPoint = hmap.proj.Transformer.WGS84ToGCJ02([wgsLon, wgsLat]);
            dx = tempPoint[0] - lon;
            dy = tempPoint[1] - lat;
        }

        return [wgsLon, wgsLat];
    }

    /**
     * 将wgs84的坐标值进行加密，即转换为GCJ02坐标系下对应的坐标。当经纬度坐标在中国国内时进行加密，在国外时原样返回，不进行加密。
     * @param  {Array} coord 由经度和纬度组成的数组
     * @returns {Array} 加密之后的经纬度数组
     */
    static WGS84ToGCJ02(coord){
        const [lon, lat] = coord;

        if (!hmap.proj.Transformer.isInChinaBbox(lon, lat)) return [lon, lat];

        const d = hmap.proj.Transformer.delta(lon, lat);

        return [lon + d[0], lat + d[1]];
    }

    /**
     * 转换纬度值
     * @param x
     * @param y
     * @returns {Number}
     * @private
     */
    static transformLat(x, y){
        let ret = -100 + 2 * x + 3 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
        ret += (20 * Math.sin(6 * x * PROJ_SPI) + 20 * Math.sin(2 * x * PROJ_SPI)) * 2 / 3;
        ret += (20 * Math.sin(y * PROJ_SPI) + 40 * Math.sin(y / 3 * PROJ_SPI)) * 2 / 3;
        ret += (160 * Math.sin(y / 12 * PROJ_SPI) + 320 * Math.sin(y * PROJ_SPI / 30)) * 2 / 3;
        return ret;
    }

    /**
     * 转换经度值
     * @param x
     * @param y
     * @returns {*}
     * @private
     */
    static transformLon(x, y){
        let ret = 300 + x + 2 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
        ret += (20 * Math.sin(6 * x * PROJ_SPI) + 20 * Math.sin(2 * x * PROJ_SPI)) * 2 / 3;
        ret += (20 * Math.sin(x * PROJ_SPI) + 40 * Math.sin(x / 3 * PROJ_SPI)) * 2 / 3;
        ret += (150 * Math.sin(x / 12 * PROJ_SPI) + 300 * Math.sin(x / 30 * PROJ_SPI)) * 2 / 3;
        return ret;
    }

    /**
     * 根据传入的经纬度值，计算出加密的偏移量
     * @param lon 经度值
     * @param lat 纬度
     * @returns {Array} 经度上和纬度上的偏移量组成的数组
     * @private
     */
    static delta(lon, lat) {

        let dLon = hmap.proj.Transformer.transformLon(lon - 105, lat - 35);
        let dLat = hmap.proj.Transformer.transformLat(lon - 105, lat - 35);

        const radLat = lat / 180 * PROJ_SPI;
        let magic = Math.sin(radLat);

        magic = 1 - ee * magic * magic;

        const sqrtMagic = Math.sqrt(magic);
        dLon = (dLon * 180) / (R / sqrtMagic * Math.cos(radLat) * PROJ_SPI);
        dLat = (dLat * 180) / ((R * (1 - ee)) / (magic * sqrtMagic) * PROJ_SPI);

        return [dLon, dLat];
    }

    /**
     * 判断给定的经纬度是否在中国范围内
     * @param lon 经度值
     * @param lat 纬度值
     * @returns {boolean} 在中国范围内返回true，不在中国范围内返回false。
     * @private
     */
    static isInChinaBbox(lon, lat){
        return lon >= 72.004 && lon <= 137.8347 && lat >= 0.8293 && lat <= 55.8271;
    }

    /**
     * 添加一种坐标系到转换器中
     * @param {hmap.proj.Crs|String|Number} crs 坐标系对象或坐标系的srid。
     * @returns {hmap.proj.Transformer}
     * @example
     * const crs1 = new hmap.proj.Crs('4479');
     * hmap.proj.Transformer.add(crs);
     *
     * const srid1 = '900913';
     * hmap.proj.Transformer.add(srid1);
     *
     */
    static add(crs){
        if(typeof crs ==='string' || typeof crs ==='number'){
            crs=new hmap.proj.Crs(crs);
        }
        const srid = crs.getSrid();
        hmap.proj.Transformer.CrsList['EPSG'+srid] = crs;
        return this;
    }

    /**
     * 根据srid获取转换器中对应的坐标系
     * @param {String|Number} srid 坐标系的srid值
     * @returns {hmap.proj.Crs} 坐标系对象
     */
    static get(srid){
        if(typeof srid ==='string' || typeof srid ==='number'){
            const key = 'EPSG' + srid;
            return hmap.proj.Transformer.CrsList[key];
        }else{
            throw new TypeError("The srid should be string or number.");
        }
    }


    /**
     * 移除指定的坐标系
     * @param {String|Number} srid  坐标系的id
     * @returns {Number}  删除成功返回1,未删除返回0.
     */
    static remove(srid){
        if(typeof srid ==='string' || typeof srid ==='number'){
            const key='EPSG'+srid;
            const crs=hmap.proj.Transformer.CrsList[key];
            if(crs){
                delete hmap.proj.Transformer.CrsList[key];
                return 1
            }else {
                return 0;
            }
        }else{
            throw new TypeError("The srid should be string or number.");
        }
    }
    /**
     * 判断一个对象是否为空对象，即没有属性和值
     * @private
     * @param e
     * @returns {Boolean}
     */
    static isEmptyObject(e){
        let t;
        for(t in e){
            return false;
        }
        return true;
    }
    /**
     * 调整坐标系的坐标轴
     * @param crs
     * @param denorm
     * @param point
     * @returns {*}
     * @private
     */
    static adjust_axis(crs, denorm, point) {
        let xin = point.x,
            yin = point.y,
            zin = point.z || 0.0;
        let v, t, i;
        let out = {};
        for (i = 0; i < 3; i++) {
            if (denorm && i === 2 && point.z === undefined) {
                continue;
            }
            if (i === 0) {
                v = xin;
                t = 'x';
            }
            else if (i === 1) {
                v = yin;
                t = 'y';
            }
            else {
                v = zin;
                t = 'z';
            }
            switch (crs.axis[i]) {
                case 'e':
                    out[t] = v;
                    break;
                case 'w':
                    out[t] = -v;
                    break;
                case 'n':
                    out[t] = v;
                    break;
                case 's':
                    out[t] = -v;
                    break;
                case 'u':
                    if (point[t] !== undefined) {
                        out.z = v;
                    }
                    break;
                case 'd':
                    if (point[t] !== undefined) {
                        out.z = -v;
                    }
                    break;
                default:
                    //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
                    return null;
            }
        }
        return out;
    }

    /**
     * {x,y,z} 转为 Coordinate, 注意参入的参数只能是{x,y,z}
     * @private
     * @param {Object} pointObj
     * @returns {hmap.basetype.Coordinate}   返回坐标对象
     */
    static _pointToCoord(pointObj){
        return new hmap.basetype.Coordinate(pointObj.x,pointObj.y,pointObj.z);
    }

    /**
     * Coordinate转为{x,y,z}  注意返回的格式就是{x,y,z}
     * @private
     * @param {hmap.basetype.Coordinate} coord 
     * @returns {Object} 返回{x,y,z}
     */
    static _coordToPoint(coord){
        return {
            x:coord.getOrdinate('X'),
            y:coord.getOrdinate('Y'),
            z:coord.getOrdinate('Z')
        }
    }
};
hmap.proj.Transformer.CrsList={
    'EPSG4326':new hmap.proj.Crs('4326'),
    'EPSG3857':new hmap.proj.Crs('3857'),
    'EPSG900913':new hmap.proj.Crs('3857')
    // 'EPSG4269':new hmap.proj.Crs('4269'),
    // 'EPSG4214':new hmap.proj.Crs('4214'),//Beijing54
    // 'EPSG2045':new hmap.proj.Crs('2045'),//Gauss-Kruger zone 19
    // 'EPSG2058':new hmap.proj.Crs('2058'),//UTM 38N
};

;(function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	let installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		let module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		let getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

let Pbf=__webpack_require__(1);
let Tile=__webpack_require__(3);
hmap.format=hmap.format||{};
hmap.format.Pbf=Pbf;
hmap.format.Tile=Tile.Tile;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

let ieee754 = __webpack_require__(2);

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

let SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            let val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) {
                this.skip(val);
            }
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        let val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        let val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        let val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        let val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        let val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        let val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        let buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        let num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        let end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        let end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        let end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        let type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        let length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            let buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        let startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        let len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        let len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (let i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        let startPos = this.pos;
        fn(obj, this);
        let len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    let buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
    pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    let low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    let lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    let extraLen =
        len <= 0x3fff ? 1 :
            len <= 0x1fffff ? 2 :
                len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (let i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (let i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (let i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (let i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (let i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (let i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (let i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (let i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (let i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (let i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// LineBuffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    let str = '';
    let i = pos;

    while (i < end) {
        let b0 = buf[i];
        let c = null; // codepoint
        let bytesPerSequence =
            b0 > 0xEF ? 4 :
                b0 > 0xDF ? 3 :
                    b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        let b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (let i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue ;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  let e, m
  let eLen = nBytes * 8 - mLen - 1
  let eMax = (1 << eLen) - 1
  let eBias = eMax >> 1
  let nBits = -7
  let i = isLE ? (nBytes - 1) : 0
  let d = isLE ? -1 : 1
  let s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  let e, m, c
  let eLen = nBytes * 8 - mLen - 1
  let eMax = (1 << eLen) - 1
  let eBias = eMax >> 1
  let rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  let i = isLE ? 0 : (nBytes - 1)
  let d = isLE ? 1 : -1
  let s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax;

  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

let Tile = exports.Tile = {};
Tile.read = function (pbf, end) {
    return pbf.readFields(Tile._readField, {layers: []}, end);
};
Tile._readField = function (tag, obj, pbf) {
    if (tag === 3) obj.layers.push(Tile.Layer.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 4) {
        const labels = pbf.readString();
        if (labels) {
            obj.labels = labels.substring(3);
        }
    } else if (tag === 5) {
        const labelImg = pbf.readString();
        if (labelImg) {
            obj.labelImg = "data:image/png;base64," + labelImg.substring(3);
        }
    }
};
Tile.write = function (obj, pbf) {
    if (obj.layers) for (let i = 0; i < obj.layers.length; i++) pbf.writeMessage(3, Tile.Layer.write, obj.layers[i]);
};

Tile.GeomType = {
    "UNKNOWN": 0,
    "POINT": 1,
    "LINESTRING": 2,
    "POLYGON": 3
};

// Tile.Value ========================================

Tile.Value = {};

Tile.Value.read = function (pbf, end) {
    return pbf.readFields(Tile.Value._readField, {string_value: "", float_value: 0, double_value: 0, int_value: 0, uint_value: 0, sint_value: 0, bool_value: false}, end);
};
Tile.Value._readField = function (tag, obj, pbf) {
    if (tag === 1) obj.string_value = pbf.readString();
    else if (tag === 2) obj.float_value = pbf.readFloat();
    else if (tag === 3) obj.double_value = pbf.readDouble();
    else if (tag === 4) obj.int_value = pbf.readVarint(true);
    else if (tag === 5) obj.uint_value = pbf.readVarint();
    else if (tag === 6) obj.sint_value = pbf.readSVarint();
    else if (tag === 7) obj.bool_value = pbf.readBoolean();
};
Tile.Value.write = function (obj, pbf) {
    if (obj.string_value) pbf.writeStringField(1, obj.string_value);
    if (obj.float_value) pbf.writeFloatField(2, obj.float_value);
    if (obj.double_value) pbf.writeDoubleField(3, obj.double_value);
    if (obj.int_value) pbf.writeVarintField(4, obj.int_value);
    if (obj.uint_value) pbf.writeVarintField(5, obj.uint_value);
    if (obj.sint_value) pbf.writeSVarintField(6, obj.sint_value);
    if (obj.bool_value) pbf.writeBooleanField(7, obj.bool_value);
};

// Tile.Feature ========================================

Tile.Feature = {};

Tile.Feature.read = function (pbf, end) {
    return pbf.readFields(Tile.Feature._readField, {id: 0, tags: [], type: 0, geometry: [], holeIndex: [],lineDists:[]}, end);
};
Tile.Feature._readField = function (tag, obj, pbf) {
    if (tag === 1) obj.id = pbf.readVarint();
    else if (tag === 2) pbf.readPackedVarint(obj.tags);
    else if (tag === 3) obj.type = pbf.readVarint();
    else if (tag === 4) pbf.readPackedFloat(obj.geometry);
    else if (tag === 5) pbf.readPackedFloat(obj.lineDists);
    else if (tag === 6) pbf.readPackedVarint(obj.holeIndex);
};
Tile.Feature.write = function (obj, pbf) {
    if (obj.id) pbf.writeVarintField(1, obj.id);
    if (obj.tags) pbf.writePackedVarint(2, obj.tags);
    if (obj.type) pbf.writeVarintField(3, obj.type);
    if (obj.geometry) pbf.writePackedVarint(4, obj.geometry);
    if (obj.lineDists) pbf.writePackedVarint(5, obj.lineDists);
    if (obj.holeIndex) pbf.writePackedVarint(6, obj.holeIndex);
};

// Tile.Layer ========================================

Tile.Layer = {};

Tile.Layer.read = function (pbf, end) {
    return pbf.readFields(Tile.Layer._readField, {version: 1, name: "", features: [], keys: [], values: [], extent: 4096}, end);
};
Tile.Layer._readField = function (tag, obj, pbf) {
    if (tag === 15) obj.version = pbf.readVarint();
    else if (tag === 1) obj.name = pbf.readString();
    else if (tag === 2) obj.features.push(Tile.Feature.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) obj.keys.push(pbf.readString());
    else if (tag === 4) obj.values.push(Tile.Value.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) obj.extent = pbf.readVarint();
    //else if (tag === 8) obj.geolt =pbf.readString();
};
Tile.Layer.write = function (obj, pbf) {
    if (obj.version != undefined && obj.version !== 1) pbf.writeVarintField(15, obj.version);
    if (obj.name) pbf.writeStringField(1, obj.name);
    if (obj.features) for (let i = 0; i < obj.features.length; i++) pbf.writeMessage(2, Tile.Feature.write, obj.features[i]);
    if (obj.keys) for (i = 0; i < obj.keys.length; i++) pbf.writeStringField(3, obj.keys[i]);
    if (obj.values) for (i = 0; i < obj.values.length; i++) pbf.writeMessage(4, Tile.Value.write, obj.values[i]);
    if (obj.extent != undefined && obj.extent !== 4096) pbf.writeVarintField(5, obj.extent);
    //if (obj.geolt) pbf.writeStringField(8, obj.geolt);
};

/***/ })
/******/ ]);;"use strict";
hmap.format=hmap.format||{};
/**
 * 海康矢量瓦片格式。读写解析PBF格式的地理数据，用于解析海康威视发布的矢量瓦片地图服务(暂不对外开放)
 * @private
 * @type {hmap.format.Hvt}
 */
hmap.format.Hvt=class{
    constructor(){
        this.CLASS_NAME = "hmap.format.Hvt";
    }

    static read(buffer){
        const pbf=new hmap.format.Pbf(buffer);
        try{
            const tiles=hmap.format.Tile.read(pbf);
            return tiles;
        }catch(err){
            return null;
        }
    }
};;"use strict";
hmap.format = hmap.format || {};
/**
 * WKT格式数据的解析器，负责WKT数据的读写。 [点击链接查看详情]{@link https://en.wikipedia.org/wiki/Well-known_text }
 * @type {hmap.format.WKT}
 * @example
 * let wkt = new hmap.format.WKT();
 */
hmap.format.WKT = class {
    /**
     * 构造函数。
     */
    constructor(){
        this.regExps={
            //从wkt字符串中获取捕获组 匹配type、flag、content
			wktPattern:/^\s*((\w+)\s*(\w*))\s*(\(\s*(.*)\s*\))?\s*$/,
            // 匹配 ),(
            parenComma:/\)\s*,\s*\(/,
            doubleParenComma:/\)\s*\)\s*,\s*\(\S*\(/,
            //匹配（或）
            trimParens:/^\s*\(*(.*?)\)*\s*$/
        };
        this.CLASS_NAME = "hmap.format.WKT";
    }

    /**
     * 将一个WKT字符串转换成矢量地理要素。当参数不符合WKT标准时，返回null。
     * @param {String} wktstr WKT格式字符串。支持POINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION
     * @return {hmap.feature.Vector} 一个地理要素
     * @example
     * let wkt = new hmap.format.WKT();
     * let pointWKT="POINT Z(1  2  3)";
     * let feature = wkt.readFeature(pointWKT);
     */
    readFeature(wktstr){
        const geo=this.readGeometry(wktstr);
        if (geo)
            return new hmap.feature.Vector(geo);
        else
            return geo;
    }


    /**
     * 将WKT字符串转为地理几何体。当参数不符合WKT标准时，返回null。
     * @param {String} wktstr WKT格式字符串。支持POINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION
     * @return {hmap.geom.Geometry} 一个地理几何体对象
     * @example
     * let wkt = new hmap.format.WKT();
     * let polygonWKT="POLYGON Z((1 2 0,2 3 0,2 4 0))";
     * let result = wkt.readGeometry(polygonWKT);
     */
    readGeometry(wktstr){
        //将所有的空字符换成空格,以及将连续的空字符转为一个空格
        wktstr=wktstr.replace(/\s+/g,' ');
        const matches=this.regExps.wktPattern.exec(wktstr);
        let geo = null
        //如果匹配上则获取类型和内容
        if(matches){
			//获取geometry类型，point、polygon等
			let wktType=matches[2].toLowerCase();
			//获取geometryExtraFlag，如Z、ZM、M、EMPTY
			let wktExtraFlag=matches[3].toLowerCase();
			//获取wkt中的内容，括号内部信息，如 x y z
			let wktContent=matches[5];
            //组装geometry
            geo=this._createGeometry(wktType,wktExtraFlag,wktContent);
        }
        return geo
    }

    /**
     * 把一个矢量地理要素编码成WKT字符串
     * @param {hmap.feature.Vector} vector 矢量地理要素
     * @param {Number} flag 默认是3，转为的wkt包含z值；如果传2,则表示wkt的每一个坐标只包含xy的值，舍弃了z轴
     * @return {String} 编码后的字符串
     * @example
     * let wkt = new hmap.format.WKT();
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let style = hmap.style.Style.getDefault();
     * let feature = new hmap.feature.Vector(point,{},style);
     * let result = wkt.writeFeature(feature, 3);
     * @throws 当参数不是 hmap.feature.Vector实例时，抛出异常
     */
    writeFeature(vector, flag = 3){
        if(!(vector instanceof hmap.feature.Vector)){
            throw new TypeError("The paramter must be an object of hmap.feature.Vector!");
        }
        return this.writeGeometry(vector.getGeometry(), flag);
    }

    /**
     * 将一个地理几何体编码成WKT字符串。当geom不是一个地理几何对象或者不支持的地理几何对象，或者flag是2和3以外的值时，返回空字符串。
     * @param {hmap.geom.Geometry} geom 一个地理几何体对象，支持：Point、MultiPoint、Line、MultiLine、Polygon、MultiPolygon、Collection、Circle、Rectangle、Triangle
     * @param {Number} flag 默认是3，转为的wkt包含z值；如果传2,则表示wkt的每一个坐标只包含xy的值，舍弃了z轴
     * @return {String} WKT字符串
     * @example
     * let wkt = new hmap.format.WKT();
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let result1 = wkt.writeGeometry(point,3);
     * let result2 = wkt.writeGeometry(point,2);
     */
	writeGeometry(geom,flag=3){
		if((!geom instanceof hmap.geom.Geometry) || (flag !== 2 && flag !== 3)){
            return '';
        }
		let wktStr='';
		const geoType=geom.getType();
		switch(geoType){
            case hmap.geom.GeometryType.Point:
				wktStr=this._pointToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.MultiPoint:
				wktStr=this._mPointToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.Line:
			case hmap.geom.GeometryType.LinearRing:
				wktStr=this._lineToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.MultiLine:
				wktStr=this._mLineToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.Polygon:
				wktStr=this._polygonToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.MultiPolygon:
				wktStr=this._mPolygonToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.Collection:
				wktStr=this._collectionToWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.Circle:
				wktStr=this.writeGeometry(geom.toPolygon(),flag);
                break;
            case hmap.geom.GeometryType.Rectangle:
				wktStr=this.writeGeometry(geom.toPolygon(),flag);
                break;
            case hmap.geom.GeometryType.Triangle:
				wktStr=this._triangletoWkt(geom,flag);
                break;
            case hmap.geom.GeometryType.Hexagon:
                break;
            default:
                break;
		}
		return wktStr;
	 }

	/**
     * 提取三维坐标对象的坐标值,转换为"x,y,z"
     * @private
     * @param {hmap.basetype.Coordinate} coordinate 三维坐标对象
     * @returns {String} 坐标值
     */
	_extractNumFromCoord(coordinate){
		return coordinate.toString().replace(/,/g,' ');
	}

    /**
     * 提取二维坐标对象的坐标值,转换为"x,y"
     * @private
     * @param {hmap.basetype.Coordinate} coordinate 二维坐标对象
     * @returns {String} 坐标值
     */
    _extractNumFromCoord2(coordinate){
        return coordinate.to2DString().replace(/,/g,' ');
    }

    /**
     * 提取数组中的地理坐标对象，转换为字符串"x1 y1 z1,x2 y2 z2"
     * @private
     * @param {Array<hmap.basetype.Coordinate>} coords 三维地理坐标对象的数组
     * @returns {String} 地理坐标信息的字符串
     */
	_extractNumFromCoords(coords){
        let numArr=[];
        for(let i=0,len=coords.length;i<len;i++){
            numArr.push(this._extractNumFromCoord(coords[i]));
        }
        return numArr.join(',');
    }

    /**
     * 提取数组中的地理坐标对象，转换为字符串"x1 y1,x2 y2"
     * @private
     * @param {Array<hmap.basetype.Coordinate>} coords 二维地理坐标对象的数组
     * @returns {String} 地理坐标信息的字符串
     */
    _extractNumFromCoords2(coords){
        let numArr=[];
        for(let i=0,len=coords.length;i<len;i++){
            numArr.push(this._extractNumFromCoord2(coords[i]));
        }
        return numArr.join(',');
    }

    /**
     * 提取坐标序列对象的数据，转换为字符串"x1 y1 z1,x2 y2 z2"
     * @private
     * @param {hmap.basetype.CoordSeq} coordSeq 三维坐标信息构成的坐标序列对象
     * @returns {String} 地理坐标信息的字符串
     */
	_extractNumFromCoordSeq(coordSeq){
        let numArr=[];
        for(let i=0,len=coordSeq.getCoordCount();i<len;i++){
            numArr.push(this._extractNumFromCoord(coordSeq.getCoordinate(i)));
        }
        return numArr.join(',');
    }

    /**
     * 提取坐标序列对象的数据，转换为字符串"x1 y1,x2 y2"
     * @private
     * @param {hmap.basetype.CoordSeq} coordSeq 二维坐标信息构成的坐标序列对象
     * @returns {String} 地理坐标信息的字符串
     */
    _extractNumFromCoordSeq2(coordSeq){
        let numArr=[];
        for(let i=0,len=coordSeq.getCoordCount();i<len;i++){
            numArr.push(this._extractNumFromCoord2(coordSeq.getCoordinate(i)));
        }
        return numArr.join(',');
    }

	/**
     * 点几何体转为wkt
     * @private
     * @param {hmap.geom.Point} geom 点几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_pointToWkt(geom,flag){
        let numStr;
        if(flag==3){
            numStr=this._extractNumFromCoord(geom.getCoordinate());
            return "POINT Z("+numStr+")";
		}else if(flag==2){
            numStr=this._extractNumFromCoord2(geom.getCoordinate());
            return "POINT("+numStr+")";
		}
	}

	/**
     * 多点几何体转化为wkt
     * @private
     * @param {hmap.geom.MultiPoint} geom 多点几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_mPointToWkt(geom,flag){
        let numStr;
        if(flag==3){
            numStr=this._extractNumFromCoords(geom.getCoordinates());
            return "MULTIPOINT Z("+numStr+")";
        }else if(flag==2){
            numStr=this._extractNumFromCoords2(geom.getCoordinates());
            return "MULTIPOINT("+numStr+")";
        }
	}
	/**
     * 线几何体转化为wkt
     * @private
     * @param {hmap.geom.Line} geom 线几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_lineToWkt(geom,flag){
        let numStr;
        if(flag==3){
            numStr=this._extractNumFromCoordSeq(geom.getCoordSeq());
            return "LINESTRING Z("+numStr+")";
        }else if(flag==2){
            numStr=this._extractNumFromCoordSeq2(geom.getCoordSeq());
            return "LINESTRING("+numStr+")";
        }
	}

	/**
     * 将坐标序列数组转换为字符串 eg：[coordSeq1,coordSeq2,coordSeq2]转换为"(10 10 10,11 11 11,12 12 12),(20 20 20,21 21 21,22 22 22),(30 30 30,31 31 31,32 32 32)"
     * @private
     * @param {Array<hmap.basetype.CoordSeq>} coordSeqs 坐标序列数组,地理坐标是三维的
     * @returns {String} 字符串
     */
	_coordSeqsToStr(coordSeqs){
		const lines=[];
        for(let i=0,len=coordSeqs.length;i<len;i++){
			lines.push("("+ this._extractNumFromCoordSeq(coordSeqs[i]) +")");
        }
		return lines.join(',');
	}

    /**
     * 将坐标序列数组转换为字符串 eg：[coordSeq1,coordSeq2,coordSeq2]转换为"(10 10,11 11,12 12),(20 20,21 21,22 22),(30 30,31 31,32 32)"
     * @private
     * @param {Array<hmap.basetype.CoordSeq>} coordSeqs 坐标序列数组,地理坐标是二维的
     * @returns {String} 字符串
     */
    _coordSeqsToStr2(coordSeqs){
        const lines=[];
        for(let i=0,len=coordSeqs.length;i<len;i++){
            lines.push("("+ this._extractNumFromCoordSeq2(coordSeqs[i]) +")");
        }
        return lines.join(',');
    }

	/**
     * 多线几何体转化为wkt格式字符串
     * @private
     * @param {hmap.geom.MultiLine} geom 多线几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_mLineToWkt(geom,flag){
        let numStr;
        if(flag==3){
            numStr=this._coordSeqsToStr(geom.getCoordSeqs());
            return "MULTILINESTRING Z("+numStr+")";
        }else if(flag==2){
            numStr=this._coordSeqsToStr2(geom.getCoordSeqs());
            return "MULTILINESTRING("+numStr+")";
        }
	}

	/**
     * 面几何体转化为wkt格式字符串
     * @private
     * @param {hmap.geom.Polygon} geom 面几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_polygonToWkt(geom,flag){
        let numStr;
        if(flag==3){
            numStr=this._coordSeqsToStr(geom.getCoordSeqs());
            return "POLYGON Z("+numStr+")";
        }else if(flag==2){
            numStr=this._coordSeqsToStr2(geom.getCoordSeqs());
            return "POLYGON("+numStr+")";
        }
	}

	/**
     * 多面几何体转化为wkt格式的字符串
     * @private
     * @param {hmap.geom.MultiPolygon} geom 多面几何体
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_mPolygonToWkt(geom,flag){
		const polygonStrs=[];
		const polygons=geom.getPolygons();
		if(flag==3){
            for(let i=0,len=polygons.length;i<len;i++){
                //每一个polygon是((),())
                const polygonStr=this._coordSeqsToStr(polygons[i].getCoordSeqs());
                polygonStrs.push("("+polygonStr+")");
            }
            return "MULTIPOLYGON Z("+polygonStrs.join(',')+")";
		}else if(flag==2){
            for(let i=0,len=polygons.length;i<len;i++){
                //每一个polygon是((),())
                const polygonStr=this._coordSeqsToStr2(polygons[i].getCoordSeqs());
                polygonStrs.push("("+polygonStr+")");
            }
            return "MULTIPOLYGON("+polygonStrs.join(',')+")";
		}
	}

	/**
     * 几何体集合转化为wkt格式的字符串
     * @private
     * @param {hmap.geom.Collection} geom 集合体
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_collectionToWkt(geom,flag){
		const geoms=geom.getGeoms();
        const geomStrs=[];//此时这里装填wkts
        for(let i=0,len=geoms.length;i<len;i++){
			geomStrs.push(this.writeGeometry(geoms[i],flag));
        }
        if(flag==3){
            return "GEOMETRYCOLLECTION Z("+geomStrs.join(",")+")";
		}else if(flag==2){
            return "GEOMETRYCOLLECTION("+geomStrs.join(",")+")";
		}

	}

	/**
     * 三角形转化为wkt格式的字符串
     * @private
     * @param {hmap.geom.Triangle} geom 三角形几何对象
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @returns {String} wkt格式的字符串
     */
	_triangletoWkt(geom,flag){
	    let numArr;
		if(flag==3){
            numArr=this._extractNumFromCoordSeq(geom.getCoordSeq());
            return "TRIANGLE Z(("+numArr+"))";
		}else if(flag==2){
            numArr=this._extractNumFromCoordSeq2(geom.getCoordSeq());
            return "TRIANGLE (("+numArr+"))";
		}
	}

	/**
     * 根据类型和内容组装成几何体
     * @private
     * @param {String} type 对应类型的字符串
	 * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 关于坐标的字符串
     * @returns {hmap.geom.Geometry} 返回组装成的几何对象
     */
	_createGeometry(type,flag,content){
		let geometry=null;
		if(flag==="empty"){
			return geometry;
		}
		switch(type){
			case "point":
				geometry=this._createPoint(flag,content);
				break;
			case "multipoint":
				geometry=this._createMPoint(flag,content);
				break;
			case "linestring":
				geometry=this._createLine(flag,content);
				break;
			case "multilinestring":
				geometry=this._createMLine(flag,content);
				break;
			case "polygon":
			case "triangle":
				geometry=this._createPolygon(flag,content);
				break;
            case "multipolygon":
				geometry=this._createMPolygon(flag,content);
				break;
            case "geometrycollection":
				geometry=this._createCollection(flag,content);
				break;
			case "tin":
			case "polyhedron":
			case "polyhedralsurface":
				//暂时当作多面看待,不一定合适
				geometry=this._createMPolygon(flag,content);
				break;
			default:
                break;
		}
		return geometry
	}

	/**
     * 提取一个坐标的字符串，得到坐标数组[x,y,z].eg:"10 10 10" =>[10,10,10]
     * @private
     * @param {String} coordStr 一个坐标的字符串
     * @returns {Array} 坐标数组[x,y,z]
     */
	_getCoord(coordStr){
		return coordStr.trim().split(' ').map(item=>item*1);
	}

	/**
     * 提取多个坐标的字符串，得到坐标数组[[x1,y1,z1],[x2,y2,z2]].eg:"10 10 10，20 20 20" =>[[10,10,10],[20,20,20]]
     * @private
     * @param {String} coordsStr 多个坐标的字符串
     * @returns {Array} 坐标数组[[x1,y1,z1],[x2,y2,z2]]
     */
	_getCoords(coordsStr){
		const coordStrArr = coordsStr.trim().split(",");
		const coords=[];
		for(let i=0,len=coordStrArr.length;i<len;i++){
			const coord=this._getCoord(coordStrArr[i]);
			coords.push(coord);
		}
		return coords;
	}

	/**
     * 组装单点几何体
     * @private
	 * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 一个坐标的字符串eg:"10 10 10"
     * @returns {hmap.geom.Point} 返回单点几何对象
     */
	_createPoint(flag,content){
		const coord=this._getCoord(content);
		if(flag==='' || flag==='m'){
			return new hmap.geom.Point(new hmap.basetype.Coordinate(coord[0],coord[1]));
		}else if(flag==='z' || flag==='zm'){
			return new hmap.geom.Point(new hmap.basetype.Coordinate(coord[0],coord[1],coord[2]));
		}
	}

	/**
     * 由多个点的坐标数组创建点几何对象的数组 [[10,10,10],[20,20,20]]=>[p1,p2]
     * @private
     * @param {Array} coords 多个点的坐标数组eg:[[10,10,10],[20,20,20]]
     * @param {Boolean} is3D 坐标是否是三维的，是传入true；不是传入false
     * @returns {Array} 返回点几何对象的数组
     */
	_cretePoints(coords,is3D){
		const ps=[];
		if(is3D){
			for(let i=0,len=coords.length;i<len;i++){
				const coord=coords[i];
				ps.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord[0],coord[1],coord[2])));
			}
		}else{
			for(let i=0,len=coords.length;i<len;i++){
				const coord=coords[i];
				ps.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord[0],coord[1])));
			}
		}
		return ps;
	}

	/**
     * 组装多点几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多个坐标的字符串eg:"10 10 10，20 20 20"
     * @returns {hmap.geom.MultiPoint} 返回多点几何对象
     */
	_createMPoint(flag,content){
		const coords=this._getCoords(content);
		if(flag==='' || flag==='m'){
			return new hmap.geom.MultiPoint(this._cretePoints(coords,false));
		}else if(flag==='z' || flag==='zm'){
			return new hmap.geom.MultiPoint(this._cretePoints(coords,true));
		}
	}

	/**
     * 组装线几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多个坐标的字符串eg:"10 10 10，20 20 20"
     * @returns {hmap.geom.Line} 返回线几何对象
     */
	_createLine(flag,content){
		const coords=this._getCoords(content);
		if(flag==='' || flag==='m'){
			return new hmap.geom.Line(this._cretePoints(coords,false));
		}else if(flag==='z' || flag==='zm'){
			return new hmap.geom.Line(this._cretePoints(coords,true));
		}
	}

	/**
     * 组装线环几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多个坐标的字符串eg:"10 10 10，20 20 20"
     * @returns {hmap.geom.LinearRing} 返回线环几何对象
     */
	_createLinearRing(flag,content){
		const coords=this._getCoords(content);
		if(flag==='' || flag==='m'){
			return new hmap.geom.LinearRing(this._cretePoints(coords,false));
		}else if(flag==='z' || flag==='zm'){
			return new hmap.geom.LinearRing(this._cretePoints(coords,true));
		}
	}

	/**
     * 组装多线几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多线坐标的字符串eg:"(10 10 10,20 20 20,30 30 30),(40 40 40,50 50 50,60 60 60)"
     * @returns {hmap.geom.MultiLine} 返回多线几何对象
     */
	_createMLine(flag,content){
		const coordsStrArr=content.trim().split(this.regExps.parenComma);
		const lines=[];
        for(let i=0,len=coordsStrArr.length;i<len;i++){
			//将捕获组第一项返回，即去掉（或）
            const coordsStr=coordsStrArr[i].trim().replace(this.regExps.trimParens,'$1');
			lines.push(this._createLine(flag,coordsStr));
        }
		return new hmap.geom.MultiLine(lines);
	}

	/**
     * 组装面几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多边形坐标的字符串eg:"(10 10 10,20 20 20,30 30 30),(30 30 30,30 35 30),(30 35 30,10 10 10)"
     * @returns {hmap.geom.Polygon} 返回多边形几何对象
     */
	_createPolygon(flag,content){
		const coordsStrArr=content.trim().split(this.regExps.parenComma);
		const linearringArr=[];
        for(let i=0,len=coordsStrArr.length;i<len;i++){
			//将捕获组第一项返回，即去掉（或）
            const coordsStr=coordsStrArr[i].trim().replace(this.regExps.trimParens,'$1');
			linearringArr.push(this._createLinearRing(flag,coordsStr));
		}
		return new hmap.geom.Polygon(linearringArr);
	}

	/**
     * 组装多面几何体
     * @private
     * @param {Number} flag 三维地理坐标时，传入3；二维地理坐标时，传入2
     * @param {String} content 多面几何坐标的字符串eg:"((10 10 10,20 20 20,30 30 30),(30 30 30,30 35 30),(30 35 30,10 10 10))"
     * @returns {hmap.geom.MultiPolygon} 返回多面几何对象
     */
	_createMPolygon(flag,content){
		const polygonArr=[];
		const polygonCStrArr=content.trim().split(this.regExps.doubleParenComma);
		for(let i=0,len=polygonCStrArr.length;i<len;i++){
			const polygonCStr=polygonCStrArr[i].trim();
			polygonArr.push(this._createPolygon(flag,polygonCStr));
		}
		return new hmap.geom.MultiPolygon(polygonArr);
	}

	/**
     * 组装单点几何体集合
     * @private
     */
	_createCollection(flag,content){
		const geoArr=[];
		//将不同几何体以|隔开
		const geosStr=content.replace(/,\s*([A-Za-z])/g,'|$1');
		const geoWKTs=geosStr.split('|');
		for(let i=0,len=geoWKTs.length;i<len;i++){
			geoArr.push(this.readGeometry(geoWKTs[i]));
        }
		return new hmap.geom.Collection(geoArr);
	};
};
;"use strict";
hmap.format = hmap.format||{};
/**
 * GeoJSON解析器。负责对GeoJSON格式类数据的读写。
 * @type {hmap.format.GeoJSON}
 * @example
 * let geoJSON = new hmap.format.GeoJSON();
 */
hmap.format.GeoJSON = class {
    /**
     * 构造一个GeoJSON解析器
     */
    constructor(){
        this.CLASS_NAME = "hmap.format.GeoJSON";
    }

    /**
     * 解析一个JSON字符串，构造由字符串描述的JavaScript值或对象.
     * @private
     * @param {String} source JSON字符串
     * @param {Function} filter 可选项。过滤函数，处理JSON对象中每个键值对，过滤函数返回的结果将替代原对象中的值。
     * @returns {Object} 返回转换后的JSON对象
     * @throws 当参数source不存在时，抛出异常
     */
    _getObject(source, filter) {
        let object = null;
        if (typeof source === 'string') {
            object = JSON.parse(source, filter);
            return object ? object : null;
        } else if (source !== null) {
            return source;
        } else {
            if (!source) {
                throw `Bad JSON: ${source}`;
            } else if (typeof(source.type) !== 'string') {
                throw `Bad GeoJSON - no type: ${source}`;
            }
        }
    }

    /**
     * 从GeoJSON对象中解析出地理要素数组。
     * @param {Object} geoJsonObject “FeatureCollection”类型的GeoJSON对象。当参数不是FeatureCollection时，返回空数组。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * // geoJson参数为：FeatureCollection
     * const exampleData1 = {
     *     "type": "FeatureCollection",
     *    "features": [{
     *         "type": "Feature",
     *        "geometry": {
     *            "type": "Point",
     *            "coordinates": [102.0, 0.5, 0]
     *        },
     *        "properties": {
     *            "prop0": "value0"
     *        }
     *    }]
     * };
     * let result = geoJSON.readFeaturesFromObject(exampleData1);
     */
    readFeaturesFromObject(geoJsonObject) {
        const results = [];
        if (geoJsonObject && geoJsonObject.type === 'FeatureCollection') {
            if(!geoJsonObject.hasOwnProperty("features") || !Array.isArray(geoJsonObject.features)){
                return results;
            }
            for (let i = 0, len = geoJsonObject.features.length; i < len; ++i) {
                const feature = this.readFeatureFromObject(geoJsonObject.features[i]);
                if(!feature){
                    continue;
                }
                results.push(feature);
            }
        }
        return results;
    }

    /**
     * 从GeoJSON对象中解析出地理要素。
     * @param {Object} geoJsonObject “Feature”类型的GeoJSON对象。
     * @return {hmap.feature.Vector} 地理要素。如果geoJsonObject的图形信息不能正确解析，返回null值。
     * @example
     * // geoJson参数为：Feature
     * const exampleData = {
     *         "type": "Feature",
     *        "geometry": {
     *            "type": "Point",
     *            "coordinates": [102.0, 0.5, 0]
     *        },
     *        "properties": {
     *            "prop0": "value0"
     *        }
     * };
     * let result = geoJSON.readFeaturesFromObject(exampleData);
     */
    readFeatureFromObject(geoJsonObject) {
        let geoJSONFeatureObject = null;
        if (geoJsonObject.type === 'Feature') {
            geoJSONFeatureObject = geoJsonObject;
        }

        const attributes = (geoJSONFeatureObject.properties) ? geoJSONFeatureObject.properties : {};
        const geometry = this.readGeometryFromObject(geoJSONFeatureObject.geometry);
        if(!geometry){
            return null;
        }
        const feature = new hmap.feature.Vector(geometry, attributes);
        if (geoJSONFeatureObject.id) {
            feature.setFid(geoJSONFeatureObject.id);
        }
        return feature;
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象解析出地理要素。
     * @param {Object} geoJson “Feature”类型的GeoJSON格式字符串或GeoJSON对象，当类型是字符串时，可以使用第二个参数指定的过滤函数进行过滤。
     * @param {Function} filter 可选项。过滤函数，处理JSON对象中每个键值对，过滤函数返回的结果将替代原对象中的值。
     * @return {hmap.feature.Vector} 地理要素。
     * @example
     * // geoJson参数为：Feature
     * const exampleData = `{
     *         "type": "Feature",
     *        "geometry": {
     *            "type": "Point",
     *            "coordinates": [102.0, 0.5, 0]
     *        },
     *        "properties": {
     *            "prop0": "value0"
     *        }
     * }`;
     * let result = geoJSON.readFeature(exampleData,function(key,value){
     *         if(key == "properties"){
     *              value.name = "point";
     *              return value;
     *         }
     * });
     */
    readFeature(geoJson, filter){
        return this.readFeatureFromObject(this._getObject(geoJson, filter));
    }

    /**
     * 从GeoJSON对象中解析出几何体。
     * @param {Object} geoJsonObject GeoJSON对象，支持“Point”，“MultiPoint”，“LineString”，“MultiLineString”，“Polygon”，“MultiPolygon”和“GeometryCollection”。
     * @return {hmap.geom.Geometry} 几何体。如果参数geoJsonObject为null，返回空对象null。
     * @throws 当GeoJSON对象坐标数组或者GeoJSON对象类型不支持时，抛出异常
     */
    readGeometryFromObject(geoJsonObject) {
        if (geoJsonObject === null) {
            return null;
        }
        let geometry;
        if (geoJsonObject.type === 'GeometryCollection') {
            geometry = hmap.format.GeoJSON._readGeometryCollectionGeometry(geoJsonObject);
        } else {
            if (!(Array.isArray(geoJsonObject.coordinates))) {
                throw 'Geometry must have coordinates array: ' + geoJsonObject;
            }
            if (!hmap.format.GeoJSON._GEOMETRY_READERS[geoJsonObject.type]) {
                throw 'Unsupported geometry type: ' + geoJsonObject.type;
            }
            geometry = hmap.format.GeoJSON._GEOMETRY_READERS[geoJsonObject.type].apply(hmap.format.GeoJSON,[geoJsonObject]);
        }
        //TODO:参考系
        return geometry;
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象解析出几何体。
     * @param {String} geoJson GeoJSON格式字符串或GeoJSON对象，支持“Point”，“MultiPoint”，“LineString”，“MultiLineString”，“Polygon”，“MultiPolygon”和“GeometryCollection”。
     * @param {Function} filter 可选项。过滤函数，处理JSON对象中每个键值对，过滤函数返回的结果将替代原对象中的值。
     * @return {hmap.geom.Geometry} 几何体。
     */
    readGeometry(geoJson, filter){
      return  this.readGeometryFromObject(this._getObject(geoJson, filter));
    }

    /**
     * 从GeoJSON对象中解析出指定类型的地理要素数组。
     * @param {Object} geoJsonObject “FeatureCollection”类型的GeoJSON对象，如果不是“FeatureCollection”类型，返回空数组。
     * @param type {String} 地理要素的几何类型，可以是“Point”，“MultiPoint”，“LineString”，“MultiLineString”，“Polygon”，“MultiPolygon”中的一种，
     * 其他类型将返回空数组。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * // geoJson参数为：FeatureCollection
     * const exampleData = {
     *     "type": "FeatureCollection",
     *    "features": [{
     *         "type": "Feature",
     *        "geometry": {
     *            "type": "Point",
     *            "coordinates": [102.0, 0.5, 0]
     *        },
     *        "properties": {
     *            "prop0": "value0"
     *        }
     *    }]
     * };
     * let result = geoJSON.readFeaturesByGeometryType(exampleData,"Point");
     */
    readFeaturesByGeometryType(geoJsonObject, type) {
        const result = [];
        if(geoJsonObject && geoJsonObject.type === 'FeatureCollection'){
            if(!geoJsonObject.hasOwnProperty("features") || !Array.isArray(geoJsonObject.features)){
                return result;
            }
            const features = geoJsonObject.features;
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                if (!type || feature.geometry.type === type) {
                    result.push(this.readFeatureFromObject(feature));
                }
            }
        }
        return result;
    }

    /**
     * 将带有坐标信息的数组转化为坐标对象
     * @private
     * @param {Array} 包括坐标信息的数组
     * @returns {hmap.basetype.Coordinate} 坐标对象
     * @throws 当坐标信息不是二维和三维的坐标信息时，抛出异常。
     */
    static _readCoordinate(coord) {
        if (coord.length !== 2 && coord.length !== 3) {
            throw `Only 2D and 3D coordinates are supported: ${coord}`;
        }
        return new hmap.basetype.Coordinate(...coord);
    }

    /**
     * @private
     */
    static _readPointGeometry(geoJsonObject) {
        const coord = this._readCoordinate(geoJsonObject.coordinates);
        return new hmap.geom.Point(coord);
    }

    /**
     * @private
     */
    static _readMultiPointGeometry(geoJsonObject) {
        return new hmap.geom.MultiPoint(this._readPoints(geoJsonObject.coordinates));
    }

    /**
     * @private
     */
    static _readLineStringGeometry(geoJsonObject) {
        return new hmap.geom.Line(this._readPoints(geoJsonObject.coordinates));
    }

    /**
     * @private
     */
    static _readMultiLineStringGeometry(geoJsonObject) {
        const array = geoJsonObject.coordinates;
        const lines = [];
        for (let i = 0; i < array.length; ++i) {
            lines.push(hmap.format.GeoJSON._readLineStringGeometry({coordinates:array[i]}));
        }
        return new hmap.geom.MultiLine(lines);
    }

    /**
     * @private
     */
    static _readPolygonGeometry(geoJsonObject) {
        const array = geoJsonObject.coordinates;
        if(!array||array.length==0){
            return null;
        }
        const rings = [];
        let ring;
        for (let i = 0; i < array.length; ++i) {
            ring = new hmap.geom.LinearRing(this._readPoints(array[i]));
            rings.push(ring);
        }
        return new hmap.geom.Polygon(rings);
    }

    /**
     * @private
     */
    static _readMultiPolygonGeometry(geoJsonObject) {
        const array = geoJsonObject.coordinates;
        if(!array||array.length==0){
            return null;
        }
        const polys = [];
        for (let i = 0; i < array.length; ++i) {
            polys.push(this._readPolygonGeometry({coordinates:array[i]}));
        }
        return new hmap.geom.MultiPolygon(polys);
    }

    /**
     * 将GeometryCollection类型的GeoJSON对象转换为Collection几何体对象
     * @private
     * @param {Object} geoJsonObject GeometryCollection类型的GeoJSON对象
     * @returns {hmap.geom.Collection} 返回转换后的Collection几何体对象
     * @throws 当GeoJSON对象中没有几何信息或者几何信息格式不对时，抛出异常
     */
    static _readGeometryCollectionGeometry(geoJsonObject) {
        if (!(Array.isArray(geoJsonObject.geometries))) {
            throw 'GeometryCollection must have geometries array: ' + geoJsonObject;
        }
        const numGeom = geoJsonObject.geometries.length;
        const components = new Array(numGeom);
        for (let i = 0; i < numGeom; ++i) {
            components[i] = hmap.format.GeoJSON._GEOMETRY_READERS[geoJsonObject.geometries[i].type].apply(hmap.format.GeoJSON,[geoJsonObject.geometries[i]]);
        }
        return new hmap.geom.Collection(components);
    }

    /**
     * @private
     */
    static _readPoints(coords) {
        const result = [];
        for (let i = 0; i < coords.length; ++i) {
            result.push(new hmap.geom.Point(this._readCoordinate(coords[i])));
        }
        return result;
    }

    /**
     * @private
     */
    static _coordinateToArray(coord) {
        return [coord.getOrdinate('X'), coord.getOrdinate('Y'), coord.getOrdinate('Z')];
    }

    /**
     * @private
     */
    static _coordinatesToArray(coords) {
        const array = [];
        for (let i = 0; i < coords.length; ++i) {
            array.push(this._coordinateToArray(coords[i]));
        }
        return array;
    }

    /**
     * @private
     */
    static _writePointGeometry(point) {
        const coord = point.getCoordinate();
        return {
            type: 'Point',
            coordinates: this._coordinateToArray(coord)
        };
    }

    /**
     * @private
     */
    static _writeMultiPointGeometry(multipoint) {
        return {
            type: 'MultiPoint',
            coordinates: this._coordinatesToArray(multipoint.getCoordinates())
        };
    }

    /**
     * @private
     */
    static _writeLineStringGeometry(line) {
        const coordSeq = line.getCoordSeq();
        return {
            type: 'LineString',
            coordinates: this._coordinatesToArray(coordSeq.extractCoords())
        };
    }

    /**
     * @private
     */
    static _writeMultiLineStringGeometry(multiline) {
        const coordinates = [];
        const coordSeqs = multiline.getCoordSeqs();
        for (let i = 0; i < coordSeqs.length; ++i) {
            const coordSeqLength = coordSeqs[i].getCoordCount();
            coordinates.push(this._coordinatesToArray(coordSeqs[i].extractCoords()));
        }
        return {
            type: 'MultiLineString',
            coordinates: coordinates
        };
    }

    /**
     * @private
     */
    static _writePolygonGeometry(polygon) {
        const coordinates = [];
        const coordSeqs = polygon.getCoordSeqs(0,polygon.getLinearRingCount());
        for (let i = 0; i < coordSeqs.length; ++i) {
            coordinates.push(this._coordinatesToArray(coordSeqs[i].extractCoords()));
        }
        return {
            type: 'Polygon',
            coordinates: coordinates
        };
    }

    /**
     * @private
     */
    static _writePlotPolygonGeometry(polygon) {     //标绘面要素
        const coordinates = [];
        const coordSeqs = polygon.getCoordSeqs();
        for (let i = 0; i < coordSeqs.length; ++i) {
            coordinates.push(this._coordinatesToArray(coordSeqs[i].extractCoords()));
        }
        return {
            type: 'Polygon',
            coordinates: coordinates
        };
    }

    /**
     * @private
     */
    static _writePlotLineGeometry(line) {           //标绘线要素
        const coordSeq = line.getCoordSeq();
        return {
            type: 'LineString',
            coordinates: this._coordinatesToArray(coordSeq.extractCoords())
        };
    }

    /**
     * @private
     */
    static _writeCircleGeometry(circle){
        return this._writePolygonGeometry(circle.toPolygon());
    }

    /**
     * @private
     */
    static _writeRectangleGeometry(rect){
        return this._writePolygonGeometry(rect.toPolygon());
    }

    /**
     * @private
     */
    static _writeLinearRingGeometry(linearRing){
        return this._writeLineStringGeometry(linearRing);
    }

    /**
     * @private
     */
    static _writeTriangleGeometry(triangle){
        return this._writePolygonGeometry(triangle.toPolygon());
    }


    /**
     * @private
     */
    static _writeMultiPolygonGeometry(multipolygon) {
        const coordinates = [];
        const coordSeqsArray = multipolygon.getCoordSeqs();
        for (let i = 0; i < coordSeqsArray.length; ++i) {
            const coordSeqs = coordSeqsArray[i];
            coordinates.push([]);
            for (let j = 0; j < coordSeqs.length; ++j) {
                coordinates[i].push(hmap.format.GeoJSON._coordinatesToArray(coordSeqs[j].extractCoords()));
            }
        }
        return {
            type: 'MultiPolygon',
            coordinates: coordinates
        };
    }

    /**
     * @private
     */
    static _writeGeometryCollectionGeometry(collection) {
        const geoms = collection.getGeoms();
        let len = geoms.length;
        let array = new Array(len);
        for (let i = 0; i < len; ++i) {
            const geomType = geoms[i].getType();
            array[i] = hmap.format.GeoJSON._GEOMETRY_WRITERS[geomType].apply(hmap.format.GeoJSON,[geoms[i]]);
        }
        return {
            type: 'GeometryCollection',
            coordinates: array
        };
    }

    /**
     * 检测GeoJSON对象的类型是否与指定类型一致。当type是“Geometry”时，geoJson的type是“Point”，“MultiPoint”，“LineString”，“MultiLineString”，
     * “Polygon”，“MultiPolygon”和“GeometryCollection”中的一种返回true，否则返回false；当type是其他类型时，判断geoJson的type是否和type相同，相同返回true，
     * 不同返回false。
     * @param {Object} geoJson GeoJSON对象。
     * @param {String} type 类型
     * @returns {Boolean} 为true时表示该对象类型与给定类型一致；为false则不一致。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * let jsonObj ={
     *  "type": "FeatureCollection",
     *  "features": [
     *    { "type": "Feature",
     *      "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
     *      "properties": {"prop0": "value0"}
     *    },
     *    { "type": "Feature",
     *      "geometry": {
     *        "type": "LineString",
     *        "coordinates": [
     *           [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
     *        ]
     *       },
     *     "properties": {
     *         "prop0": "value0",
     *         "prop1": 0.0
     *      }
     *  },
     * ]
     * };
     * let isValid = geoJSON.isValidType(jsonObj,"FeatureCollection");
     * let jsonObj2 = {
     *   "type": "Feature",
     *   "geometry": {
     *      "type": "Polygon",
     *      "coordinates": [
     *          [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
     *          [100.0, 1.0], [100.0, 0.0] ]
     *          ]
     *    },     *
     *   "properties": {
     *       "prop0": "value0",
     *      "prop1": {"this": "that"}
     *    }
     * };
     * isValid = geoJSON.isValidType(jsonObj2,"Geometry");
     */
    isValidType(geoJson, type) {
        let valid = false;
        switch (type) {
            case 'Geometry':
                if (['Point', 'MultiPoint', 'LineString', 'MultiLineString',
                        'Polygon', 'MultiPolygon', 'GeometryCollection'].indexOf(geoJson.type) > -1) {
                    valid = true;
                }
                break;
            default:
                if (geoJson.type === type) {
                    valid = true;
                }
                break;
        }
        return valid;
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象解析出地理要素数组(注意：GeoJSON类型定义中不包含线环（LinearRing）类型)。
     * @param {Object} geoJson “FeatureCollection”类型的GeoJSON格式字符串或GeoJSON对象,当为字符串格式时，可通过filter函数进行过滤。
     * 当不是FeatureCollection类型时，返回空数组。
     * @param {Function} filter 可选项。过滤函数，处理JSON对象中每个键值对，过滤函数返回的结果将替代原对象中的值。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * // geoJson参数为：FeatureCollection
     * const exampleData1 = {
     *     "type": "FeatureCollection",
     *    "features": [{
     *         "type": "Feature",
     *        "geometry": {
     *            "type": "Point",
     *            "coordinates": [102.0, 0.5, 0]
     *        },
     *        "properties": {
     *            "prop0": "value0"
     *        }
     *    }]
     * };
     * let result = geoJSON.readFeatures(exampleData1);
     */
    readFeatures(geoJson, filter) {
        return this.readFeaturesFromObject(this._getObject(geoJson, filter));
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象解析出含有点状几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readPointFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'Point');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有多点几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readMPointFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'MultiPoint');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有线状几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readLineFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'LineString');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有多线几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readMLineFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'MultiLineString');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有面状几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readPolyFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'Polygon');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有多面几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readMPolyFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'MultiPolygon');
    }

    /**
     * 从GeoJSON格式字符串或GeoJSON对象对解析出含有集合几何体的地理要素数组。
     * 结果以几何体数组的形式返回，数组中几何体的类型相同。
     * @param {Object} geoJson GeoJSON对象。
     * @return {Array<hmap.feature.Vector>} 地理要素数组。
     */
    readCollectionFeatures(geoJson) {
        return this.readFeaturesByGeometryType(this._getObject(geoJson), 'GeometryCollection');
    }

    /**
     * 把一个几何体转化成GeoJSON格式对象。
     * @param {hmap.geom.Geometry} geom 几何体。
     * @return {Object} GeoJSON对象。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let result = geoJSON.writeGeometry(point);
     */
    writeGeometry(geom) {
        if (geom === null) {
            return null;
        }
        //TODO:参考系
        let geomType = geom.getType();
        return hmap.format.GeoJSON._GEOMETRY_WRITERS[geomType].apply(hmap.format.GeoJSON,[geom]);
    }

    /**
     * 把一个地理要素转换成"Feature"类型的GeoJSON格式的数据。
     * @param {hmap.feature.Vector} feature 地理要素。
     * @return {Object} GeoJSON格式的数据。
     * @example
     * let geoJSON = new hmap.format.GeoJSON();
     * const point = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     * let feature = new hmap.feature.Vector(point,{'name':'name1','type':'type1'});
     * let result = geoJSON.writeFeatureObject(feature);
     */
    writeFeatureObject(feature){
        let geom = this.writeGeometry(feature.getGeometry());
        let geojson = {
            'type': 'Feature',
            'properties': feature.getAttributes(),
            'geometry': geom
        };
        if (feature.fid !== null) {
            geojson.id = feature.getFid();
        }
        return geojson;
    }

    /**
     * 把一个地理要素解析成"Feature"类型的GeoJSON格式的数据。
     * @param {hmap.feature.Vector} feature 地理要素。
     * @return {String} GeoJSON格式数据的字符串。
     * @example
     * let point = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     * let feature = new hmap.feature.Vector(point);
     * let geoJSON = new hmap.format.GeoJSON();
     * let result = geoJSON.writeFeature(feature);
     */
    writeFeature(feature) {
        return JSON.stringify(this.writeFeatureObject(feature));
    }

    /**
     * 把一个地理要素数组解析成"FeatureCollection"类型的GeoJSON格式的数据。
     * @param {Array<hmap.feature.Vector>} features 地理要素数组。
     * @returns {Object} GeoJSON格式的数据。
     * @throws 当参数features数组中的元素不是地理要素时，抛出异常
     */
    writeFeaturesObject(features){
        let geojson = {
            type: 'FeatureCollection'
        };
        let numFeatures = features.length;
        geojson.features = new Array(numFeatures);
        for (let i = 0; i < numFeatures; ++i) {
            let element = features[i];
            if (!(element instanceof hmap.feature.Vector)) {
                throw 'FeatureCollection only supports collections of features: ' + element;
            }
            geojson.features[i] = this.writeFeatureObject(element);
        }
        return geojson;
    }

    /**
     * 把一个地理要素数组解析成"FeatureCollection"类型的GeoJSON数据格式。
     * @param {Array<hmap.feature.Vector>} features 地理要素数组。
     * @return {String} GeoJSON数据格式的字符串。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let feature1 = new hmap.feature.Vector(point1);
     * let feature2 = new hmap.feature.Vector(point2);
     * let geoJSON = new hmap.format.GeoJSON();
     * let result = geoJSON.writeFeatures([feature1,feature2]);
     */
    writeFeatures(features) {
        return JSON.stringify(this.writeFeaturesObject(features));
    }
};

hmap.format.GeoJSON._GEOMETRY_READERS = {
    'Point': hmap.format.GeoJSON._readPointGeometry,
    'MultiPoint': hmap.format.GeoJSON._readMultiPointGeometry,
    'LineString': hmap.format.GeoJSON._readLineStringGeometry,
    'MultiLineString': hmap.format.GeoJSON._readMultiLineStringGeometry,
    'Polygon': hmap.format.GeoJSON._readPolygonGeometry,
    'MultiPolygon': hmap.format.GeoJSON._readMultiPolygonGeometry,
    'GeometryCollection': hmap.format.GeoJSON._readGeometryCollectionGeometry
};

hmap.format.GeoJSON._GEOMETRY_WRITERS = {
    'Point': hmap.format.GeoJSON._writePointGeometry,
    'MultiPoint': hmap.format.GeoJSON._writeMultiPointGeometry,
    'Line': hmap.format.GeoJSON._writeLineStringGeometry,
    'LinearRing':hmap.format.GeoJSON._writeLinearRingGeometry,
    'MultiLine': hmap.format.GeoJSON._writeMultiLineStringGeometry,
    'Polygon': hmap.format.GeoJSON._writePolygonGeometry,
    'MultiPolygon': hmap.format.GeoJSON._writeMultiPolygonGeometry,
    'Collection': hmap.format.GeoJSON._writeGeometryCollectionGeometry,
    'Triangle':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'RectFlag':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'TriangleFlag':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'CurveFlag':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Arc':hmap.format.GeoJSON._writePlotLineGeometry,
    'BezierCurve2':hmap.format.GeoJSON._writePlotLineGeometry,
    'BezierCurve3':hmap.format.GeoJSON._writePlotLineGeometry,
    'BezierCurveN':hmap.format.GeoJSON._writePlotLineGeometry,
    'CardinalCurve':hmap.format.GeoJSON._writePlotLineGeometry,
    'CloseCurve':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'GatheringPlace':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'CircleExt':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Ellipse':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Sector':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Lune':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Circle':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Rectangle':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'RoundedRect':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'Flag':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'StraightArrow':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'DiagonalArrow':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'DoubleArrow':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'DoveTailStraightArrow':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'DoveTailDiagonalArrow':hmap.format.GeoJSON._writePlotPolygonGeometry,
    'PolylineArrow':hmap.format.GeoJSON._writeMultiLineStringGeometry,
    'ParallelSearch':hmap.format.GeoJSON._writeMultiLineStringGeometry,
    'SectorSearch':hmap.format.GeoJSON._writeMultiLineStringGeometry,
    'BezierCurveArrow':hmap.format.GeoJSON._writeMultiLineStringGeometry,
    'CardinalCurveArrow':hmap.format.GeoJSON._writeMultiLineStringGeometry
};
;"use strict";
hmap.format = hmap.format || {};
hmap.format.obj = hmap.format.obj || {};
/**
 * The main Mesh class. The constructor will parse through the OBJ file data
 * and collect the vertex, vertex normal, texture, and face information. This
 * information can then be used later on when creating your VBOs. See
 * OBJ.initMeshBuffers for an example of how to use the newly created Mesh
 * @private
 */
hmap.format.obj.Mesh = class {
    /**
     * Create a Mesh
     * @param {String} objectData - a string representation of an OBJ file with
     *     newlines preserved.
     * @param {Object} options - a JS object containing valid options. See class
     *     documentation for options.
     * @param {Boolean} options.enableWTextureCoord - Texture coordinates can have
     *     an optional "w" coordinate after the u and v coordinates. This extra
     *     value can be used in order to perform fancy transformations on the
     *     textures themselves. Default is to truncate to only the u an v
     *     coordinates. Passing true will provide a default value of 0 in the
     *     event that any or all texture coordinates don't provide a w value.
     *     Always use the textureStride attribute in order to determine the
     *     stride length of the texture coordinates when rendering the element
     *     array.
     * @param {Boolean} options.calcTangentsAndBitangents - Calculate the tangents
     *     and bitangents when loading of the OBJ is completed. This adds two new
     *     attributes to the Mesh instance: `tangents` and `bitangents`.
     */
    constructor(objectData, options) {
        options = options || {};
        options.materials = options.materials || {};
        options.enableWTextureCoord = !!options.enableWTextureCoord;
        options.indicesPerMaterial = !!options.indicesPerMaterial;
        this.indicesPerMaterial = options.indicesPerMaterial ? options.indicesPerMaterial : false;
        let self = this;
        // the list of unique vertex, normal, texture, attributes
        self.vertices = [];
        self.vertexNormals = [];
        self.textures = [];
        // the indicies to draw the faces
        self.indices = [];
        self.textureStride = options.enableWTextureCoord ? 3 : 2;

        /*
        The OBJ file format does a sort of compression when saving a model in a
        program like Blender. There are at least 3 sections (4 including textures)
        within the file. Each line in a section begins with the same string:
          * 'v': indicates vertex section
          * 'vn': indicates vertex normal section
          * 'f': indicates the faces section
          * 'vt': indicates vertex texture section (if textures were used on the model)
        Each of the above sections (except for the faces section) is a list/set of
        unique vertices.

        Each line of the faces section contains a list of
        (vertex, [texture], normal) groups.

        **Note:** The following documentation will use a capital "V" Vertex to
        denote the above (vertex, [texture], normal) groups whereas a lowercase
        "v" vertex is used to denote an X, Y, Z coordinate.

        Some examples:
            // the texture index is optional, both formats are possible for models
            // without a texture applied
            f 1/25 18/46 12/31
            f 1//25 18//46 12//31

            // A 3 vertex face with texture indices
            f 16/92/11 14/101/22 1/69/1

            // A 4 vertex face
            f 16/92/11 40/109/40 38/114/38 14/101/22

        The first two lines are examples of a 3 vertex face without a texture applied.
        The second is an example of a 3 vertex face with a texture applied.
        The third is an example of a 4 vertex face. Note: a face can contain N
        number of vertices.

        Each number that appears in one of the groups is a 1-based index
        corresponding to an item from the other sections (meaning that indexing
        starts at one and *not* zero).

        For example:
            `f 16/92/11` is saying to
              - take the 16th element from the [v] vertex array
              - take the 92nd element from the [vt] texture array
              - take the 11th element from the [vn] normal array
            and together they make a unique vertex.
        Using all 3+ unique Vertices from the face line will produce a polygon.

        Now, you could just go through the OBJ file and create a new vertex for
        each face line and WebGL will draw what appears to be the same model.
        However, vertices will be overlapped and duplicated all over the place.

        Consider a cube in 3D space centered about the origin and each side is
        2 units long. The front face (with the positive Z-axis pointing towards
        you) would have a Top Right vertex (looking orthogonal to its normal)
        mapped at (1,1,1) The right face would have a Top Left vertex (looking
        orthogonal to its normal) at (1,1,1) and the top face would have a Bottom
        Right vertex (looking orthogonal to its normal) at (1,1,1). Each face
        has a vertex at the same coordinates, however, three distinct vertices
        will be drawn at the same spot.

        To solve the issue of duplicate Vertices (the `(vertex, [texture], normal)`
        groups), while iterating through the face lines, when a group is encountered
        the whole group string ('16/92/11') is checked to see if it exists in the
        packed.hashindices object, and if it doesn't, the indices it specifies
        are used to look up each attribute in the corresponding attribute arrays
        already created. The values are then copied to the corresponding unpacked
        array (flattened to play nice with WebGL's ELEMENT_ARRAY_BUFFER indexing),
        the group string is added to the hashindices set and the current unpacked
        index is used as this hashindices value so that the group of elements can
        be reused. The unpacked index is incremented. If the group string already
        exists in the hashindices object, its corresponding value is the index of
        that group and is appended to the unpacked indices array.
       */
        this.name = "";
        const verts = [];
        const vertNormals = [];
        const textures = [];
        const unpacked = {};
        const materialNamesByIndex = [];
        const materialIndicesByName = {};
        // keep track of what material we've seen last
        let currentMaterialIndex = -1;
        // keep track if pushing indices by materials - otherwise not used
        let currentObjectByMaterialIndex = 0;
        // unpacking stuff
        unpacked.verts = [];
        unpacked.norms = [];
        unpacked.textures = [];
        unpacked.hashindices = {};
        unpacked.indices = [[]];
        unpacked.materialIndices = [];
        unpacked.index = 0;

        const VERTEX_RE = /^v\s/;
        const NORMAL_RE = /^vn\s/;
        const TEXTURE_RE = /^vt\s/;
        const FACE_RE = /^f\s/;
        const WHITESPACE_RE = /\s+/;
        const USE_MATERIAL_RE = /^usemtl/;

        // array of lines separated by the newline
        const lines = objectData.split("\n");

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || line.startsWith("#")) {
                continue;
            }
            const elements = line.split(WHITESPACE_RE);
            elements.shift();

            if (VERTEX_RE.test(line)) {
                // if this is a vertex
                verts.push(...elements);
            } else if (NORMAL_RE.test(line)) {
                // if this is a vertex normal
                vertNormals.push(...elements);
            } else if (TEXTURE_RE.test(line)) {
                let coords = elements;
                // by default, the loader will only look at the U and V
                // coordinates of the vt declaration. So, this truncates the
                // elements to only those 2 values. If W texture coordinate
                // support is enabled, then the texture coordinate is
                // expected to have three values in it.
                if (elements.length > 2 && !options.enableWTextureCoord) {
                    coords = elements.slice(0, 2);
                } else if (elements.length === 2 && options.enableWTextureCoord) {
                    // If for some reason W texture coordinate support is enabled
                    // and only the U and V coordinates are given, then we supply
                    // the default value of 0 so that the stride length is correct
                    // when the textures are unpacked below.
                    coords.push(0);
                }
                textures.push(...coords);
            } else if (USE_MATERIAL_RE.test(line)) {
                const materialName = elements[0];

                // check to see if we've ever seen it before
                if (!(materialName in materialIndicesByName)) {
                    // new material we've never seen
                    materialNamesByIndex.push(materialName);
                    materialIndicesByName[materialName] = materialNamesByIndex.length - 1;
                    // push new array into indices
                    if (options.indicesPerMaterial) {
                        // already contains an array at index zero, don't add
                        if (materialIndicesByName[materialName] > 0) {
                            unpacked.indices.push([]);
                        }
                    }
                }
                // keep track of the current material index
                currentMaterialIndex = materialIndicesByName[materialName];
                // update current index array
                if (options.indicesPerMaterial) {
                    currentObjectByMaterialIndex = currentMaterialIndex;
                }
            } else if (FACE_RE.test(line)) {
                // if this is a face
                /*
                split this face into an array of Vertex groups
                for example:
                   f 16/92/11 14/101/22 1/69/1
                becomes:
                  ['16/92/11', '14/101/22', '1/69/1'];
                */

                const triangles = this.triangulate(elements);
                for (const triangle of triangles) {
                    let vertexs = [];
                    for (let j = 0, eleLen = triangle.length; j < eleLen; j++) {
                        const vertex = elements[j].split("/");
                        let x = +verts[(+vertex[0] - 1) * 3 + 0],
                            y = +verts[(+vertex[0] - 1) * 3 + 1],
                            z = +verts[(+vertex[0] - 1) * 3 + 2];
                        // const hash = triangle[j] + "," + currentMaterialIndex;
                        // if (hash in unpacked.hashindices) {
                        //     unpacked.indices[currentObjectByMaterialIndex].push(unpacked.hashindices[hash]);
                        //     vertexs.push([x, y, z]);
                        // } else {
                            /*
                        Each element of the face line array is a Vertex which has its
                        attributes delimited by a forward slash. This will separate
                        each attribute into another array:
                            '19/92/11'
                        becomes:
                            Vertex = ['19', '92', '11'];
                        where
                            Vertex[0] is the vertex index
                            Vertex[1] is the texture index
                            Vertex[2] is the normal index
                         Think of faces having Vertices which are comprised of the
                         attributes location (v), texture (vt), and normal (vn).
                         */
                            // const vertex = elements[j].split("/");
                            // it's possible for faces to only specify the vertex
                            // and the normal. In this case, vertex will only have
                            // a length of 2 and not 3 and the normal will be the
                            // second item in the list with an index of 1.
                            const normalIndex = vertex.length - 1;
                            /*
                             The verts, textures, and vertNormals arrays each contain a
                             flattend array of coordinates.

                             Because it gets confusing by referring to Vertex and then
                             vertex (both are different in my descriptions) I will explain
                             what's going on using the vertexNormals array:

                             vertex[2] will contain the one-based index of the vertexNormals
                             section (vn). One is subtracted from this index number to play
                             nice with javascript's zero-based array indexing.

                             Because vertexNormal is a flattened array of x, y, z values,
                             simple pointer arithmetic is used to skip to the start of the
                             vertexNormal, then the offset is added to get the correct
                             component: +0 is x, +1 is y, +2 is z.

                             This same process is repeated for verts and textures.
                             */
                            // Vertex position
                            unpacked.verts.push(x, y, z);
                            // unpacked.verts.push(+verts[(+vertex[0] - 1) * 3 + 0]);
                            // unpacked.verts.push(+verts[(+vertex[0] - 1) * 3 + 1]);
                            // unpacked.verts.push(+verts[(+vertex[0] - 1) * 3 + 2]);
                            // Vertex textures
                            if (textures.length) {
                                const stride = options.enableWTextureCoord ? 3 : 2;
                                unpacked.textures.push(+textures[(+vertex[1] - 1) * stride + 0]);
                                unpacked.textures.push(+textures[(+vertex[1] - 1) * stride + 1]);
                                if (options.enableWTextureCoord) {
                                    unpacked.textures.push(+textures[(+vertex[1] - 1) * stride + 2]);
                                }
                            }
                            // Vertex normals
                            if (isNaN(+vertNormals[(+vertex[normalIndex] - 1) * 3 + 0])) {
                                vertexs.push([x, y, z]);
                                if (j === eleLen - 1 && vertexs.length == 3) {
                                    let [nx, ny, nz] = this.createNormal(vertexs[0], vertexs[1], vertexs[2]);
                                    unpacked.norms.push(nx, ny, nz, nx, ny, nz, nx, ny, nz);
                                    vertexs = [];
                                }
                            }
                            else {
                                unpacked.norms.push(+vertNormals[(+vertex[normalIndex] - 1) * 3 + 0]);
                                unpacked.norms.push(+vertNormals[(+vertex[normalIndex] - 1) * 3 + 1]);
                                unpacked.norms.push(+vertNormals[(+vertex[normalIndex] - 1) * 3 + 2]);
                            }
                            // Vertex material indices
                            unpacked.materialIndices.push(currentMaterialIndex);
                            // add the newly created Vertex to the list of indices
                            // unpacked.hashindices[hash] = unpacked.index;
                            // unpacked.indices[currentObjectByMaterialIndex].push(unpacked.hashindices[hash]);
                            unpacked.indices[currentObjectByMaterialIndex].push(unpacked.verts.length / 3 - 1);
                            // increment the counter
                            unpacked.index += 1;
                        // }
                    }
                }
            }
            self.vertices = unpacked.verts;
            self.vertexNormals = unpacked.norms;
            self.textures = unpacked.textures;
            self.vertexMaterialIndices = unpacked.materialIndices;
            self.indices = options.indicesPerMaterial ? unpacked.indices : unpacked.indices[currentObjectByMaterialIndex];

            self.materialNames = materialNamesByIndex;
            self.materialIndices = materialIndicesByName;
            self.materialsByIndex = {};

            if (options.calcTangentsAndBitangents) {
                this.calculateTangentsAndBitangents();
            }
        }
    }

    /**
     * Calculates the tangents and bitangents of the mesh that forms an orthogonal basis together with the
     * normal in the direction of the texture coordinates. These are useful for setting up the TBN matrix
     * when distorting the normals through normal maps.
     * Method derived from: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/
     *
     * This method requires the normals and texture coordinates to be parsed and set up correctly.
     * Adds the tangents and bitangents as members of the class instance.
     */
    calculateTangentsAndBitangents() {
        console.assert(
            this.vertices &&
            this.vertices.length &&
            this.vertexNormals &&
            this.vertexNormals.length &&
            this.textures &&
            this.textures.length,
            "Missing attributes for calculating tangents and bitangents"
        );

        const unpacked = {};
        unpacked.tangents = [...new Array(this.vertices.length)].map(v => 0);
        unpacked.bitangents = [...new Array(this.vertices.length)].map(v => 0);

        // Loop through all faces in the whole mesh
        let indices;
        // If sorted by material
        if (Array.isArray(this.indices[0])) {
            indices = [].concat.apply([], this.indices);
        } else {
            indices = this.indices;
        }

        const vertices = this.vertices;
        const normals = this.vertexNormals;
        const uvs = this.textures;

        for (let i = 0; i < indices.length; i += 3) {
            const i0 = indices[i + 0];
            const i1 = indices[i + 1];
            const i2 = indices[i + 2];

            const x_v0 = vertices[i0 * 3 + 0];
            const y_v0 = vertices[i0 * 3 + 1];
            const z_v0 = vertices[i0 * 3 + 2];

            const x_uv0 = uvs[i0 * 2 + 0];
            const y_uv0 = uvs[i0 * 2 + 1];

            const x_v1 = vertices[i1 * 3 + 0];
            const y_v1 = vertices[i1 * 3 + 1];
            const z_v1 = vertices[i1 * 3 + 2];

            const x_uv1 = uvs[i1 * 2 + 0];
            const y_uv1 = uvs[i1 * 2 + 1];

            const x_v2 = vertices[i2 * 3 + 0];
            const y_v2 = vertices[i2 * 3 + 1];
            const z_v2 = vertices[i2 * 3 + 2];

            const x_uv2 = uvs[i2 * 2 + 0];
            const y_uv2 = uvs[i2 * 2 + 1];

            const x_deltaPos1 = x_v1 - x_v0;
            const y_deltaPos1 = y_v1 - y_v0;
            const z_deltaPos1 = z_v1 - z_v0;

            const x_deltaPos2 = x_v2 - x_v0;
            const y_deltaPos2 = y_v2 - y_v0;
            const z_deltaPos2 = z_v2 - z_v0;

            const x_uvDeltaPos1 = x_uv1 - x_uv0;
            const y_uvDeltaPos1 = y_uv1 - y_uv0;

            const x_uvDeltaPos2 = x_uv2 - x_uv0;
            const y_uvDeltaPos2 = y_uv2 - y_uv0;

            const rInv = x_uvDeltaPos1 * y_uvDeltaPos2 - y_uvDeltaPos1 * x_uvDeltaPos2;
            const r = 1.0 / (Math.abs(rInv < 0.0001) ? 1.0 : rInv);

            // Tangent
            const x_tangent = (x_deltaPos1 * y_uvDeltaPos2 - x_deltaPos2 * y_uvDeltaPos1) * r;
            const y_tangent = (y_deltaPos1 * y_uvDeltaPos2 - y_deltaPos2 * y_uvDeltaPos1) * r;
            const z_tangent = (z_deltaPos1 * y_uvDeltaPos2 - z_deltaPos2 * y_uvDeltaPos1) * r;

            // Bitangent
            const x_bitangent = (x_deltaPos2 * x_uvDeltaPos1 - x_deltaPos1 * x_uvDeltaPos2) * r;
            const y_bitangent = (y_deltaPos2 * x_uvDeltaPos1 - y_deltaPos1 * x_uvDeltaPos2) * r;
            const z_bitangent = (z_deltaPos2 * x_uvDeltaPos1 - z_deltaPos1 * x_uvDeltaPos2) * r;

            // Gram-Schmidt orthogonalize
            //t = glm::normalize(t - n * glm:: dot(n, t));
            const x_n0 = normals[i0 * 3 + 0];
            const y_n0 = normals[i0 * 3 + 1];
            const z_n0 = normals[i0 * 3 + 2];

            const x_n1 = normals[i1 * 3 + 0];
            const y_n1 = normals[i1 * 3 + 1];
            const z_n1 = normals[i1 * 3 + 2];

            const x_n2 = normals[i2 * 3 + 0];
            const y_n2 = normals[i2 * 3 + 1];
            const z_n2 = normals[i2 * 3 + 2];

            // Tangent
            const n0_dot_t = x_tangent * x_n0 + y_tangent * y_n0 + z_tangent * z_n0;
            const n1_dot_t = x_tangent * x_n1 + y_tangent * y_n1 + z_tangent * z_n1;
            const n2_dot_t = x_tangent * x_n2 + y_tangent * y_n2 + z_tangent * z_n2;

            const x_resTangent0 = x_tangent - x_n0 * n0_dot_t;
            const y_resTangent0 = y_tangent - y_n0 * n0_dot_t;
            const z_resTangent0 = z_tangent - z_n0 * n0_dot_t;

            const x_resTangent1 = x_tangent - x_n1 * n1_dot_t;
            const y_resTangent1 = y_tangent - y_n1 * n1_dot_t;
            const z_resTangent1 = z_tangent - z_n1 * n1_dot_t;

            const x_resTangent2 = x_tangent - x_n2 * n2_dot_t;
            const y_resTangent2 = y_tangent - y_n2 * n2_dot_t;
            const z_resTangent2 = z_tangent - z_n2 * n2_dot_t;

            const magTangent0 = Math.sqrt(
                x_resTangent0 * x_resTangent0 + y_resTangent0 * y_resTangent0 + z_resTangent0 * z_resTangent0
            );
            const magTangent1 = Math.sqrt(
                x_resTangent1 * x_resTangent1 + y_resTangent1 * y_resTangent1 + z_resTangent1 * z_resTangent1
            );
            const magTangent2 = Math.sqrt(
                x_resTangent2 * x_resTangent2 + y_resTangent2 * y_resTangent2 + z_resTangent2 * z_resTangent2
            );

            // Bitangent
            const n0_dot_bt = x_bitangent * x_n0 + y_bitangent * y_n0 + z_bitangent * z_n0;
            const n1_dot_bt = x_bitangent * x_n1 + y_bitangent * y_n1 + z_bitangent * z_n1;
            const n2_dot_bt = x_bitangent * x_n2 + y_bitangent * y_n2 + z_bitangent * z_n2;

            const x_resBitangent0 = x_bitangent - x_n0 * n0_dot_bt;
            const y_resBitangent0 = y_bitangent - y_n0 * n0_dot_bt;
            const z_resBitangent0 = z_bitangent - z_n0 * n0_dot_bt;

            const x_resBitangent1 = x_bitangent - x_n1 * n1_dot_bt;
            const y_resBitangent1 = y_bitangent - y_n1 * n1_dot_bt;
            const z_resBitangent1 = z_bitangent - z_n1 * n1_dot_bt;

            const x_resBitangent2 = x_bitangent - x_n2 * n2_dot_bt;
            const y_resBitangent2 = y_bitangent - y_n2 * n2_dot_bt;
            const z_resBitangent2 = z_bitangent - z_n2 * n2_dot_bt;

            const magBitangent0 = Math.sqrt(
                x_resBitangent0 * x_resBitangent0 +
                y_resBitangent0 * y_resBitangent0 +
                z_resBitangent0 * z_resBitangent0
            );
            const magBitangent1 = Math.sqrt(
                x_resBitangent1 * x_resBitangent1 +
                y_resBitangent1 * y_resBitangent1 +
                z_resBitangent1 * z_resBitangent1
            );
            const magBitangent2 = Math.sqrt(
                x_resBitangent2 * x_resBitangent2 +
                y_resBitangent2 * y_resBitangent2 +
                z_resBitangent2 * z_resBitangent2
            );

            unpacked.tangents[i0 * 3 + 0] += x_resTangent0 / magTangent0;
            unpacked.tangents[i0 * 3 + 1] += y_resTangent0 / magTangent0;
            unpacked.tangents[i0 * 3 + 2] += z_resTangent0 / magTangent0;

            unpacked.tangents[i1 * 3 + 0] += x_resTangent1 / magTangent1;
            unpacked.tangents[i1 * 3 + 1] += y_resTangent1 / magTangent1;
            unpacked.tangents[i1 * 3 + 2] += z_resTangent1 / magTangent1;

            unpacked.tangents[i2 * 3 + 0] += x_resTangent2 / magTangent2;
            unpacked.tangents[i2 * 3 + 1] += y_resTangent2 / magTangent2;
            unpacked.tangents[i2 * 3 + 2] += z_resTangent2 / magTangent2;

            unpacked.bitangents[i0 * 3 + 0] += x_resBitangent0 / magBitangent0;
            unpacked.bitangents[i0 * 3 + 1] += y_resBitangent0 / magBitangent0;
            unpacked.bitangents[i0 * 3 + 2] += z_resBitangent0 / magBitangent0;

            unpacked.bitangents[i1 * 3 + 0] += x_resBitangent1 / magBitangent1;
            unpacked.bitangents[i1 * 3 + 1] += y_resBitangent1 / magBitangent1;
            unpacked.bitangents[i1 * 3 + 2] += z_resBitangent1 / magBitangent1;

            unpacked.bitangents[i2 * 3 + 0] += x_resBitangent2 / magBitangent2;
            unpacked.bitangents[i2 * 3 + 1] += y_resBitangent2 / magBitangent2;
            unpacked.bitangents[i2 * 3 + 2] += z_resBitangent2 / magBitangent2;

            // TODO: check handedness
        }

        this.tangents = unpacked.tangents;
        this.bitangents = unpacked.bitangents;
    }

    /**
     * @param {hmap.format.obj.Layout} layout - A {@link Layout} object that describes the
     * desired memory layout of the generated buffer
     * @return {ArrayBuffer} The packed array in the ... TODO
     */
    makeBufferData(layout) {
        const numItems = this.vertices.length / 3;
        const buffer = new ArrayBuffer(layout.stride * numItems);
        buffer.numItems = numItems;
        const dataView = new DataView(buffer);
        for (let i = 0, vertexOffset = 0; i < numItems; i++) {
            vertexOffset = i * layout.stride;
            // copy in the vertex data in the order and format given by the
            // layout param
            for (const attribute of layout.attributes) {
                const offset = vertexOffset + layout[attribute.key].offset;
                switch (attribute.key) {
                    case hmap.format.obj.Layout.POSITION.key:
                        dataView.setFloat32(offset, this.vertices[i * 3], true);
                        dataView.setFloat32(offset + 4, this.vertices[i * 3 + 1], true);
                        dataView.setFloat32(offset + 8, this.vertices[i * 3 + 2], true);
                        break;
                    case hmap.format.obj.Layout.POSITION_LOW.key:
                        dataView.setFloat32(offset, this.verticesLow[i * 3], true);
                        dataView.setFloat32(offset + 4, this.verticesLow[i * 3 + 1], true);
                        dataView.setFloat32(offset + 8, this.verticesLow[i * 3 + 2], true);
                        break;
                    case hmap.format.obj.Layout.UV.key:
                        dataView.setFloat32(offset, this.textures[i * 2], true);
                        dataView.setFloat32(offset + 4, this.textures[i * 2 + 1], true);
                        break;
                    case hmap.format.obj.Layout.NORMAL.key:
                        dataView.setFloat32(offset, this.vertexNormals[i * 3], true);
                        dataView.setFloat32(offset + 4, this.vertexNormals[i * 3 + 1], true);
                        dataView.setFloat32(offset + 8, this.vertexNormals[i * 3 + 2], true);
                        break;
                    case hmap.format.obj.Layout.MATERIAL_INDEX.key:
                        dataView.setInt16(offset, this.vertexMaterialIndices[i], true);
                        break;
                    case hmap.format.obj.Layout.AMBIENT.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.ambient[0], true);
                        dataView.setFloat32(offset + 4, material.ambient[1], true);
                        dataView.setFloat32(offset + 8, material.ambient[2], true);
                        break;
                    }
                    case hmap.format.obj.Layout.DIFFUSE.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.diffuse[0], true);
                        dataView.setFloat32(offset + 4, material.diffuse[1], true);
                        dataView.setFloat32(offset + 8, material.diffuse[2], true);
                        break;
                    }
                    case hmap.format.obj.Layout.SPECULAR.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.specular[0], true);
                        dataView.setFloat32(offset + 4, material.specular[1], true);
                        dataView.setFloat32(offset + 8, material.specular[2], true);
                        break;
                    }
                    case hmap.format.obj.Layout.SPECULAR_EXPONENT.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.specularExponent, true);
                        break;
                    }
                    case hmap.format.obj.Layout.EMISSIVE.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.emissive[0], true);
                        dataView.setFloat32(offset + 4, material.emissive[1], true);
                        dataView.setFloat32(offset + 8, material.emissive[2], true);
                        break;
                    }
                    case hmap.format.obj.Layout.TRANSMISSION_FILTER.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.transmissionFilter[0], true);
                        dataView.setFloat32(offset + 4, material.transmissionFilter[1], true);
                        dataView.setFloat32(offset + 8, material.transmissionFilter[2], true);
                        break;
                    }
                    case hmap.format.obj.Layout.DISSOLVE.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.dissolve, true);
                        break;
                    }
                    case hmap.format.obj.Layout.ILLUMINATION.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setInt16(offset, material.illumination, true);
                        break;
                    }
                    case hmap.format.obj.Layout.REFRACTION_INDEX.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.refractionIndex, true);
                        break;
                    }
                    case hmap.format.obj.Layout.SHARPNESS.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setFloat32(offset, material.sharpness, true);
                        break;
                    }
                    case hmap.format.obj.Layout.ANTI_ALIASING.key: {
                        const materialIndex = this.vertexMaterialIndices[i];
                        const material = this.materialsByIndex[materialIndex];
                        if (!material) {
                            console.warn(
                                'Material "' +
                                this.materialNames[materialIndex] +
                                '" not found in mesh. Did you forget to call addMaterialLibrary(...)?"'
                            );
                            break;
                        }
                        dataView.setInt16(offset, material.antiAliasing, true);
                        break;
                    }
                }
            }
        }
        return buffer;
    }

    makeIndexBufferData() {
        // const buffer = new Uint16Array(this.indices);
        let indices = [];
        if (this.indicesPerMaterial) {
            indices = this.indices.reduce(function (a, b) {
                return a.concat(b)
            })
        } else {
            indices = this.indices;
        }
        const buffer = new Uint32Array(indices);
        buffer.numItems = indices.length;
        return buffer;
        // const buffer = new Uint32Array(this.indices);
        // buffer.numItems = this.indices.length;
        // return buffer;
    }

    addMaterialLibrary(mtl) {
        for (const name in mtl.materials) {
            if (!(name in this.materialIndices)) {
                // This material is not referenced by the mesh
                continue;
            }

            const material = mtl.materials[name];

            // Find the material index for this material
            const materialIndex = this.materialIndices[material.name];

            // Put the material into the materialsByIndex object at the right
            // spot as determined when the obj file was parsed
            this.materialsByIndex[materialIndex] = material;
        }
    }

    * triangulate(elements) {
        if (elements.length <= 3) {
            yield elements;
        } else if (elements.length === 4) {
            yield [elements[0], elements[1], elements[2]];
            yield [elements[2], elements[3], elements[0]];
        } else {
            for (let i = 1; i < elements.length - 1; i++) {
                yield [elements[0], elements[i], elements[i + 1]];
            }
        }
    }

    createNormal(xyz1, xyz2, xyz3) {
        let vec1 = new hmap.util.Vector3(xyz1[0], xyz1[1], xyz1[2]),
            vec2 = new hmap.util.Vector3(xyz2[0], xyz2[1], xyz2[2]),
            vec3 = new hmap.util.Vector3(xyz3[0], xyz3[1], xyz3[2]);
        vec2.substract(vec1);
        vec3.substract(vec1);
        vec2.cross(vec3);
        let [x, y, z] = vec2.getElements();
        let scalar = Math.sqrt(x * x + y * y + z * z);
        scalar = scalar === 0 ? 0.00001 : scalar;
        vec2.divideScalar(scalar);
        return vec2.getElements();
    }
}
;"use strict";
hmap.format = hmap.format || {};
hmap.format.obj = hmap.format.obj || {};
/**
 * The Material class.
 * @private
 */
hmap.format.obj.Material = class {
    /**
     * Constructor
     * @param {String} name the unique name of the material
     */
    constructor(name) {
        // the unique material ID.
        this.name = name;
        // The values for the following attibutes
        // are an array of R, G, B normalized values.
        // Ka - Ambient Reflectivity
        this.ambient = [0, 0, 0];
        // Kd - Defuse Reflectivity
        this.diffuse = [0, 0, 0];
        // Ks
        this.specular = [0, 0, 0];
        // Ke
        this.emissive = [0, 0, 0];
        // Tf
        this.transmissionFilter = [0, 0, 0];
        // d
        this.dissolve = 1;
        // valid range is between 0 and 1000
        this.specularExponent = 0;
        // either d or Tr; valid values are normalized
        this.transparency = 0;
        // illum - the enum of the illumination model to use
        this.illumination = 0;
        // Ni - Set to "normal" (air).
        this.refractionIndex = 1;
        // sharpness
        this.sharpness = 0;
        // map_Kd
        this.mapDiffuse = null;
        // map_Ka
        this.mapAmbient = null;
        // map_Ks
        this.mapSpecular = null;
        // map_Ns
        this.mapSpecularExponent = null;
        // map_d
        this.mapDissolve = null;
        // map_aat
        this.antiAliasing = false;
        // map_bump or bump
        this.mapBump = null;
        // disp
        this.mapDisplacement = null;
        // decal
        this.mapDecal = null;
        // map_Ke
        this.mapEmissive = null;
        // refl - when the reflection type is a cube, there will be multiple refl
        //        statements for each side of the cube. If it's a spherical
        //        reflection, there should only ever be one.
        this.mapReflections = [];
    }
}

/**
 * @private
 */
hmap.format.obj.MaterialLibrary = class{
    /**
     * Constructs the Material Parser
     * @param {String} mtlData the MTL file contents
     * @private
     */
    constructor(mtlData) {
        this.data = mtlData;
        this.currentMaterial = null;
        this.materials = {};

        this.parse();
    }

    /* eslint-disable camelcase */
    /* the function names here disobey camelCase conventions
     to make parsing/routing easier. see the parse function
     documentation for more information. */

    /**
     * Creates a new Material object and adds to the registry.
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_newmtl(tokens) {
        let name = tokens[0];

        this.currentMaterial = new hmap.format.obj.Material(name);
        this.materials[name] = this.currentMaterial;
    }

    /**
     * See the documenation for parse_Ka below for a better understanding.
     *
     * Given a list of possible color tokens, returns an array of R, G, and B
     * color values.
     *
     * @param {string[]} tokens the tokens associated with the directive
     * @return {*} a 3 element array containing the R, G, and B values
     * of the color.
     */
    parseColor(tokens) {
        if (tokens[0] == "spectral") {
            console.error(
                "The MTL parser does not support spectral curve files. You will " +
                "need to convert the MTL colors to either RGB or CIEXYZ."
            );
            return;
        }

        if (tokens[0] == "xyz") {
            console.warn("TODO: convert XYZ to RGB");
            return;
        }

        // from my understanding of the spec, RGB values at this point
        // will either be 3 floats or exactly 1 float, so that's the check
        // that i'm going to perform here
        if (tokens.length == 3) {
            return tokens.map(parseFloat);
        }

        // Since tokens at this point has a length of 3, we're going to assume
        // it's exactly 1, skipping the check for 2.
        let value = parseFloat(tokens[0]);
        // in this case, all values are equivalent
        return [value, value, value];
    }

    /**
     * Parse the ambient reflectivity
     *
     * A Ka directive can take one of three forms:
     *   - Ka r g b
     *   - Ka spectral file.rfl
     *   - Ka xyz x y z
     * These three forms are mutually exclusive in that only one
     * declaration can exist per material. It is considered a syntax
     * error otherwise.
     *
     * The "Ka" form specifies the ambient reflectivity using RGB values.
     * The "g" and "b" values are optional. If only the "r" value is
     * specified, then the "g" and "b" values are assigned the value of
     * "r". Values are normally in the range 0.0 to 1.0. Values outside
     * of this range increase or decrease the reflectivity accordingly.
     *
     * The "Ka spectral" form specifies the ambient reflectivity using a
     * spectral curve. "file.rfl" is the name of the ".rfl" file containing
     * the curve data. "factor" is an optional argument which is a multiplier
     * for the values in the .rfl file and defaults to 1.0 if not specified.
     *
     * The "Ka xyz" form specifies the ambient reflectivity using CIEXYZ values.
     * "x y z" are the values of the CIEXYZ color space. The "y" and "z" arguments
     * are optional and take on the value of the "x" component if only "x" is
     * specified. The "x y z" values are normally in the range of 0.0 to 1.0 and
     * increase or decrease ambient reflectivity accordingly outside of that
     * range.
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Ka(tokens) {
        this.currentMaterial.ambient = this.parseColor(tokens);
    }

    /**
     * Diffuse Reflectivity
     *
     * Similar to the Ka directive. Simply replace "Ka" with "Kd" and the rules
     * are the same
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Kd(tokens) {
        this.currentMaterial.diffuse = this.parseColor(tokens);
    }

    /**
     * Spectral Reflectivity
     *
     * Similar to the Ka directive. Simply replace "Ks" with "Kd" and the rules
     * are the same
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Ks(tokens) {
        this.currentMaterial.specular = this.parseColor(tokens);
    }

    /**
     * Emissive
     *
     * The amount and color of light emitted by the object.
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Ke(tokens) {
        this.currentMaterial.emissive = this.parseColor(tokens);
    }

    /**
     * Transmission Filter
     *
     * Any light passing through the object is filtered by the transmission
     * filter, which only allows specific colors to pass through. For example, Tf
     * 0 1 0 allows all of the green to pass through and filters out all of the
     * red and blue.
     *
     * Similar to the Ka directive. Simply replace "Ks" with "Tf" and the rules
     * are the same
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Tf(tokens) {
        this.currentMaterial.transmissionFilter = this.parseColor(tokens);
    }

    /**
     * Specifies the dissolve for the current material.
     *
     * Statement: d [-halo] `factor`
     *
     * Example: "d 0.5"
     *
     * The factor is the amount this material dissolves into the background. A
     * factor of 1.0 is fully opaque. This is the default when a new material is
     * created. A factor of 0.0 is fully dissolved (completely transparent).
     *
     * Unlike a real transparent material, the dissolve does not depend upon
     * material thickness nor does it have any spectral character. Dissolve works
     * on all illumination models.
     *
     * The dissolve statement allows for an optional "-halo" flag which indicates
     * that a dissolve is dependent on the surface orientation relative to the
     * viewer. For example, a sphere with the following dissolve, "d -halo 0.0",
     * will be fully dissolved at its center and will appear gradually more opaque
     * toward its edge.
     *
     * "factor" is the minimum amount of dissolve applied to the material. The
     * amount of dissolve will vary between 1.0 (fully opaque) and the specified
     * "factor". The formula is:
     *
     *    dissolve = 1.0 - (N*v)(1.0-factor)
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_d(tokens) {
        // this ignores the -halo option as I can't find any documentation on what
        // it's supposed to be.
        this.currentMaterial.dissolve = parseFloat(tokens.pop());
    }

    /**
     * The "illum" statement specifies the illumination model to use in the
     * material. Illumination models are mathematical equations that represent
     * various material lighting and shading effects.
     *
     * The illumination number can be a number from 0 to 10. The following are
     * the list of illumination enumerations and their summaries:
     * 0. Color on and Ambient off
     * 1. Color on and Ambient on
     * 2. Highlight on
     * 3. Reflection on and Ray trace on
     * 4. Transparency: Glass on, Reflection: Ray trace on
     * 5. Reflection: Fresnel on and Ray trace on
     * 6. Transparency: Refraction on, Reflection: Fresnel off and Ray trace on
     * 7. Transparency: Refraction on, Reflection: Fresnel on and Ray trace on
     * 8. Reflection on and Ray trace off
     * 9. Transparency: Glass on, Reflection: Ray trace off
     * 10. Casts shadows onto invisible surfaces
     *
     * Example: "illum 2" to specify the "Highlight on" model
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_illum(tokens) {
        this.currentMaterial.illumination = parseInt(tokens[0]);
    }

    /**
     * Optical Density (AKA Index of Refraction)
     *
     * Statement: Ni `index`
     *
     * Example: Ni 1.0
     *
     * Specifies the optical density for the surface. `index` is the value
     * for the optical density. The values can range from 0.001 to 10.  A value of
     * 1.0 means that light does not bend as it passes through an object.
     * Increasing the optical_density increases the amount of bending. Glass has
     * an index of refraction of about 1.5. Values of less than 1.0 produce
     * bizarre results and are not recommended
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Ni(tokens) {
        this.currentMaterial.refractionIndex = parseFloat(tokens[0]);
    }

    /**
     * Specifies the specular exponent for the current material. This defines the
     * focus of the specular highlight.
     *
     * Statement: Ns `exponent`
     *
     * Example: "Ns 250"
     *
     * `exponent` is the value for the specular exponent. A high exponent results
     * in a tight, concentrated highlight. Ns Values normally range from 0 to
     * 1000.
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_Ns(tokens) {
        this.currentMaterial.specularExponent = parseInt(tokens[0]);
    }

    /**
     * Specifies the sharpness of the reflections from the local reflection map.
     *
     * Statement: sharpness `value`
     *
     * Example: "sharpness 100"
     *
     * If a material does not have a local reflection map defined in its material
     * defintions, sharpness will apply to the global reflection map defined in
     * PreView.
     *
     * `value` can be a number from 0 to 1000. The default is 60. A high value
     * results in a clear reflection of objects in the reflection map.
     *
     * Tip: sharpness values greater than 100 introduce aliasing effects in
     * flat surfaces that are viewed at a sharp angle.
     *
     * @param {string[]} tokens the tokens associated with the directive
     */
    parse_sharpness(tokens) {
        this.currentMaterial.sharpness = parseInt(tokens[0]);
    }

    /**
     * Parses the -cc flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -cc flag
     * @param {Object} options the Object of all image options
     */
    parse_cc(values, options) {
        options.colorCorrection = values[0] == "on";
    }

    /**
     * Parses the -blendu flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -blendu flag
     * @param {Object} options the Object of all image options
     */
    parse_blendu(values, options) {
        options.horizontalBlending = values[0] == "on";
    }

    /**
     * Parses the -blendv flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -blendv flag
     * @param {Object} options the Object of all image options
     */
    parse_blendv(values, options) {
        options.verticalBlending = values[0] == "on";
    }

    /**
     * Parses the -boost flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -boost flag
     * @param {Object} options the Object of all image options
     */
    parse_boost(values, options) {
        options.boostMipMapSharpness = parseFloat(values[0]);
    }

    /**
     * Parses the -mm flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -mm flag
     * @param {Object} options the Object of all image options
     */
    parse_mm(values, options) {
        options.modifyTextureMap.brightness = parseFloat(values[0]);
        options.modifyTextureMap.contrast = parseFloat(values[1]);
    }

    /**
     * Parses and sets the -o, -s, and -t  u, v, and w values
     *
     * @param {string[]} values the values passed to the -o, -s, -t flag
     * @param {Object} option the Object of either the -o, -s, -t option
     * @param {Integer} defaultValue the Object of all image options
     */
    parse_ost(values, option, defaultValue) {
        while (values.length < 3) {
            values.push(defaultValue);
        }

        option.u = parseFloat(values[0]);
        option.v = parseFloat(values[1]);
        option.w = parseFloat(values[2]);
    }

    /**
     * Parses the -o flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -o flag
     * @param {Object} options the Object of all image options
     */
    parse_o(values, options) {
        this.parse_ost(values, options.offset, 0);
    }

    /**
     * Parses the -s flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -s flag
     * @param {Object} options the Object of all image options
     */
    parse_s(values, options) {
        this.parse_ost(values, options.scale, 1);
    }

    /**
     * Parses the -t flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -t flag
     * @param {Object} options the Object of all image options
     */
    parse_t(values, options) {
        this.parse_ost(values, options.turbulence, 0);
    }

    /**
     * Parses the -texres flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -texres flag
     * @param {Object} options the Object of all image options
     */
    parse_texres(values, options) {
        options.textureResolution = parseFloat(values[0]);
    }

    /**
     * Parses the -clamp flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -clamp flag
     * @param {Object} options the Object of all image options
     */
    parse_clamp(values, options) {
        options.clamp = values[0] == "on";
    }

    /**
     * Parses the -bm flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -bm flag
     * @param {Object} options the Object of all image options
     */
    parse_bm(values, options) {
        options.bumpMultiplier = parseFloat(values[0]);
    }

    /**
     * Parses the -imfchan flag and updates the options object with the values.
     *
     * @param {string[]} values the values passed to the -imfchan flag
     * @param {Object} options the Object of all image options
     */
    parse_imfchan(values, options) {
        options.imfChan = values[0];
    }

    /**
     * This only exists for relection maps and denotes the type of reflection.
     *
     * @param {string[]} values the values passed to the -type flag
     * @param {Object} options the Object of all image options
     */
    parse_type(values, options) {
        options.reflectionType = values[0];
    }

    /**
     * Parses the texture's options and returns an options object with the info
     *
     * @param {string[]} tokens all of the option tokens to pass to the texture
     * @return {Object} a complete object of objects to apply to the texture
     */
    parseOptions(tokens) {
        let options = {
            colorCorrection: false,
            horizontalBlending: true,
            verticalBlending: true,
            boostMipMapSharpness: 0,
            modifyTextureMap: {
                brightness: 0,
                contrast: 1
            },
            offset: { u: 0, v: 0, w: 0 },
            scale: { u: 1, v: 1, w: 1 },
            turbulence: { u: 0, v: 0, w: 0 },
            clamp: false,
            textureResolution: null,
            bumpMultiplier: 1,
            imfChan: null
        };

        let option;
        let values;
        let optionsToValues = {};

        tokens.reverse();

        while (tokens.length) {
            const token = tokens.pop();

            if (token.startsWith("-")) {
                option = token.substr(1);
                optionsToValues[option] = [];
            } else {
                optionsToValues[option].push(token);
            }
        }

        for (option in optionsToValues) {
            if (!optionsToValues.hasOwnProperty(option)) {
                continue;
            }
            values = optionsToValues[option];
            let optionMethod = this[`parse_${option}`];
            if (optionMethod) {
                optionMethod.bind(this)(values, options);
            }
        }

        return options;
    }

    /**
     * Parses the given texture map line.
     *
     * @param {string[]} tokens all of the tokens representing the texture
     * @return {Object} a complete object of objects to apply to the texture
     */
    parseMap(tokens) {
        // according to wikipedia:
        // (https://en.wikipedia.org/wiki/Wavefront_.obj_file#Vendor_specific_alterations)
        // there is at least one vendor that places the filename before the options
        // rather than after (which is to spec). All options start with a '-'
        // so if the first token doesn't start with a '-', we're going to assume
        // it's the name of the map file.
        let filename;
        let options;
        if (!tokens[0].startsWith("-")) {
            [filename, ...options] = tokens;
        } else {
            filename = tokens.pop();
            options = tokens;
        }

        options = this.parseOptions(options);
        options["filename"] = filename;
        return options;
    }

    /**
     * Parses the ambient map.
     *
     * @param {string[]} tokens list of tokens for the map_Ka direcive
     */
    parse_map_Ka(tokens) {
        this.currentMaterial.mapAmbient = this.parseMap(tokens);
    }

    /**
     * Parses the diffuse map.
     *
     * @param {string[]} tokens list of tokens for the map_Kd direcive
     */
    parse_map_Kd(tokens) {
        this.currentMaterial.mapDiffuse = this.parseMap(tokens);
    }

    /**
     * Parses the specular map.
     *
     * @param {string[]} tokens list of tokens for the map_Ks direcive
     */
    parse_map_Ks(tokens) {
        this.currentMaterial.mapSpecular = this.parseMap(tokens);
    }

    /**
     * Parses the emissive map.
     *
     * @param {string[]} tokens list of tokens for the map_Ke direcive
     */
    parse_map_Ke(tokens) {
        this.currentMaterial.mapEmissive = this.parseMap(tokens);
    }

    /**
     * Parses the specular exponent map.
     *
     * @param {string[]} tokens list of tokens for the map_Ns direcive
     */
    parse_map_Ns(tokens) {
        this.currentMaterial.mapSpecularExponent = this.parseMap(tokens);
    }

    /**
     * Parses the dissolve map.
     *
     * @param {string[]} tokens list of tokens for the map_d direcive
     */
    parse_map_d(tokens) {
        this.currentMaterial.mapDissolve = this.parseMap(tokens);
    }

    /**
     * Parses the anti-aliasing option.
     *
     * @param {string[]} tokens list of tokens for the map_aat direcive
     */
    parse_map_aat(tokens) {
        this.currentMaterial.antiAliasing = tokens[0] == "on";
    }

    /**
     * Parses the bump map.
     *
     * @param {string[]} tokens list of tokens for the map_bump direcive
     */
    parse_map_bump(tokens) {
        this.currentMaterial.mapBump = this.parseMap(tokens);
    }

    /**
     * Parses the bump map.
     *
     * @param {string[]} tokens list of tokens for the bump direcive
     */
    parse_bump(tokens) {
        this.parse_map_bump(tokens);
    }

    /**
     * Parses the disp map.
     *
     * @param {string[]} tokens list of tokens for the disp direcive
     */
    parse_disp(tokens) {
        this.currentMaterial.mapDisplacement = this.parseMap(tokens);
    }

    /**
     * Parses the decal map.
     *
     * @param {string[]} tokens list of tokens for the map_decal direcive
     */
    parse_decal(tokens) {
        this.currentMaterial.mapDecal = this.parseMap(tokens);
    }

    /**
     * Parses the refl map.
     *
     * @param {string[]} tokens list of tokens for the refl direcive
     */
    parse_refl(tokens) {
        this.currentMaterial.mapReflections.push(this.parseMap(tokens));
    }

    /**
     * Parses the MTL file.
     *
     * Iterates line by line parsing each MTL directive.
     *
     * This function expects the first token in the line
     * to be a valid MTL directive. That token is then used
     * to try and run a method on this class. parse_[directive]
     * E.g., the `newmtl` directive would try to call the method
     * parse_newmtl. Each parsing function takes in the remaining
     * list of tokens and updates the currentMaterial class with
     * the attributes provided.
     */
    parse() {
        let lines = this.data.split(/\r?\n/);
        for (let line of lines) {
            line = line.trim();
            if (!line || line.startsWith("#")) {
                continue;
            }

            let tokens = line.split(/\s/);
            let directive;
            [directive, ...tokens] = tokens;

            let parseMethod = this[`parse_${directive}`];

            if (!parseMethod) {
                console.warn(`Don't know how to parse the directive: "${directive}"`);
                continue;
            }

            // console.log(`Parsing "${directive}" with tokens: ${tokens}`);
            parseMethod.bind(this)(tokens);
        }

        // some cleanup. These don't need to be exposed as public data.
        delete this.data;
        this.currentMaterial = null;
    }

    /* eslint-enable camelcase*/
}
;"use strict";
hmap.format = hmap.format || {};
hmap.format.obj = hmap.format.obj || {};
/**
 * A class to represent the memory layout for a vertex attribute array. Used by
 * {@link hmap.format.obj.Mesh}'s TBD(...) method to generate a packed array from mesh data.
 * <p>
 * Layout can sort of be thought of as a C-style struct declaration.
 * {@link hmap.format.obj.Mesh}'s TBD(...) method will use the {@link Layout} instance to
 * pack an array in the given attribute order.
 * <p>
 * Layout also is very helpful when calling a WebGL context's
 * <code>vertexAttribPointer</code> method. If you've created a buffer using
 * a Layout instance, then the same Layout instance can be used to determine
 * the size, type, normalized, stride, and offset parameters for
 * <code>vertexAttribPointer</code>.
 * <p>
 * For example:
 * <pre><code>
 *
 * const index = glctx.getAttribLocation(shaderProgram, "pos");
 * glctx.vertexAttribPointer(
 *   layout.position.size,
 *   glctx[layout.position.type],
 *   layout.position.normalized,
 *   layout.position.stride,
 *   layout.position.offset);
 * </code></pre>
 * @see {@link hmap.format.obj.Mesh}
 * @private
 */
hmap.format.obj.Layout = class {
    /**
     * Create a Layout object. This constructor will throw if any duplicate
     * attributes are given.
     * @param {Array} ...attributes - An ordered list of attributes that
     *        describe the desired memory layout for each vertex attribute.
     *        <p>
     *
     * @see {@link hmap.format.obj.Mesh}
     */
    constructor(...attributes) {
        this.attributes = attributes;
        let offset = 0;
        let maxStrideMultiple = 0;
        for (const attribute of attributes) {
            if (this[attribute.key]) {
                throw new DuplicateAttributeException(attribute);
            }
            // Add padding to satisfy WebGL's requirement that all
            // vertexAttribPointer calls have an offset that is a multiple of
            // the type size.
            if (offset % attribute.sizeOfType !== 0) {
                offset += attribute.sizeOfType - offset % attribute.sizeOfType;
            }
            this[attribute.key] = {
                attribute: attribute,
                size: attribute.size,
                type: attribute.type,
                normalized: attribute.normalized,
                offset: offset
            };
            offset += attribute.sizeInBytes;
            maxStrideMultiple = Math.max(maxStrideMultiple, attribute.sizeOfType);
        }
        // Add padding to the end to satisfy WebGL's requirement that all
        // vertexAttribPointer calls have a stride that is a multiple of the
        // type size. Because we're putting differently sized attributes into
        // the same buffer, it must be padded to a multiple of the largest
        // type size.
        if (offset % maxStrideMultiple !== 0) {
            offset += maxStrideMultiple - offset % maxStrideMultiple;
        }
        this.stride = offset;
        for (const attribute of attributes) {
            this[attribute.key].stride = this.stride;
        }
    }
}

/**
 * An exception for when two or more of the same attributes are found in the
 * same layout.
 * @private
 */
hmap.format.obj.DuplicateAttributeException = class  {
    /**
     * Create a DuplicateAttributeException
     * @param {Attribute} attribute - The attribute that was found more than
     *        once in the {@link Layout}
     */
    constructor(attribute) {
        this.message = "found duplicate attribute: " + attribute.key;
    }
}

/**
 * Represents how a vertex attribute should be packed into an buffer.
 * @private
 */
hmap.format.obj.Attribute = class {
    /**
     * Create an attribute. Do not call this directly, use the predefined
     * constants.
     * @param {string} key - The name of this attribute as if it were a key in
     *        an Object. Use the camel case version of the upper snake case
     *        const name.
     * @param {number} size - The number of components per vertex attribute.
     *        Must be 1, 2, 3, or 4.
     * @param {string} type - The data type of each component for this
     *        attribute. Possible values:<br/>
     *        "BYTE": signed 8-bit integer, with values in [-128, 127]<br/>
     *        "SHORT": signed 16-bit integer, with values in
     *            [-32768, 32767]<br/>
     *        "UNSIGNED_BYTE": unsigned 8-bit integer, with values in
     *            [0, 255]<br/>
     *        "UNSIGNED_SHORT": unsigned 16-bit integer, with values in
     *            [0, 65535]<br/>
     *        "FLOAT": 32-bit floating point number
     * @param {Boolean} normalized - Whether integer data values should be
     *        normalized when being casted to a float.<br/>
     *        If true, signed integers are normalized to [-1, 1].<br/>
     *        If true, unsigned integers are normalized to [0, 1].<br/>
     *        For type "FLOAT", this parameter has no effect.
     */
    constructor(key, size, type, normalized = false) {
        this.key = key;
        this.size = size;
        this.type = type;
        this.normalized = false;
        this.sizeOfType = sizeInBytesOfType(type);
        this.sizeInBytes = this.sizeOfType * size;
    }
}

/**
 * @param {string} type - A type accepted by {@link Attribute}.
 * @return The size (in bytes) for a given type.
 * @see {@link hmap.format.obj.Attribute}
 * @private
 */
function sizeInBytesOfType(type) {
    switch (type) {
        case "BYTE":
        case "UNSIGNED_BYTE":
            return 1;
        case "SHORT":
        case "UNSIGNED_SHORT":
            return 2;
        case "FLOAT":
            return 4;
    }
}

// Geometry attributes
/**
 * Attribute layout to pack a vertex's x, y, & z as floats
 *
 * @see {@link Layout}
 */
hmap.format.obj.Layout.POSITION = new hmap.format.obj.Attribute("position", 3, "FLOAT");
hmap.format.obj.Layout.POSITION_LOW = new hmap.format.obj.Attribute("positionLow", 3, "FLOAT");

/**
 * Attribute layout to pack a vertex's normal's x, y, & z as floats
 *
 * @see {@link Layout}
 */
hmap.format.obj.Layout.NORMAL = new hmap.format.obj.Attribute("normal", 3, "FLOAT");

/**
 * Attribute layout to pack a vertex's normal's x, y, & z as floats.
 * <p>
 * This value will be computed on-the-fly based on the texture coordinates.
 * If no texture coordinates are available, the generated value will default to
 * 0, 0, 0.
 *
 * @see {@link Layout}
 */
hmap.format.obj.Layout.TANGENT = new hmap.format.obj.Attribute("tangent", 3, "FLOAT");

/**
 * Attribute layout to pack a vertex's normal's bitangent x, y, & z as floats.
 * <p>
 * This value will be computed on-the-fly based on the texture coordinates.
 * If no texture coordinates are available, the generated value will default to
 * 0, 0, 0.
 * @see {@link hmap.format.obj.Layout}
 */
hmap.format.obj.Layout.BITANGENT = new hmap.format.obj.Attribute("bitangent", 3, "FLOAT");

/**
 * Attribute layout to pack a vertex's texture coordinates' u & v as floats
 *
 * @see {@link hmap.format.obj.Layout}
 */
hmap.format.obj.Layout.UV = new hmap.format.obj.Attribute("uv", 2, "FLOAT");

// Material attributes

/**
 * Attribute layout to pack an unsigned short to be interpreted as a the index
 * into a {@link hmap.format.obj.Mesh}'s materials list.
 * <p>
 * The intention of this value is to send all of the {@link hmap.format.obj.Mesh}'s materials
 * into multiple shader uniforms and then reference the current one by this
 * vertex attribute.
 * <p>
 * example glsl code:
 *
 * <pre><code>
 *  // this is bound using MATERIAL_INDEX
 *  attribute int materialIndex;
 *
 *  struct Material {
 *    vec3 diffuse;
 *    vec3 specular;
 *    vec3 specularExponent;
 *  };
 *
 *  uniform Material materials[MAX_MATERIALS];
 *
 *  // ...
 *
 *  vec3 diffuse = materials[materialIndex];
 *
 * </code></pre>
 * TODO: More description & test to make sure subscripting by attributes even
 * works for webgl
 *
 * @see {@link hmap.format.obj.Layout}
 */
hmap.format.obj.Layout.MATERIAL_INDEX = new hmap.format.obj.Attribute("materialIndex", 1, "SHORT");
hmap.format.obj.Layout.MATERIAL_ENABLED = new hmap.format.obj.Attribute("materialEnabled", 1, "UNSIGNED_SHORT");
hmap.format.obj.Layout.AMBIENT = new hmap.format.obj.Attribute("ambient", 3, "FLOAT");
hmap.format.obj.Layout.DIFFUSE = new hmap.format.obj.Attribute("diffuse", 3, "FLOAT");
hmap.format.obj.Layout.SPECULAR = new hmap.format.obj.Attribute("specular", 3, "FLOAT");
hmap.format.obj.Layout.SPECULAR_EXPONENT = new hmap.format.obj.Attribute("specularExponent", 3, "FLOAT");
hmap.format.obj.Layout.EMISSIVE = new hmap.format.obj.Attribute("emissive", 3, "FLOAT");
hmap.format.obj.Layout.TRANSMISSION_FILTER = new hmap.format.obj.Attribute("transmissionFilter", 3, "FLOAT");
hmap.format.obj.Layout.DISSOLVE = new hmap.format.obj.Attribute("dissolve", 1, "FLOAT");
hmap.format.obj.Layout.ILLUMINATION = new hmap.format.obj.Attribute("illumination", 1, "UNSIGNED_SHORT");
hmap.format.obj.Layout.REFRACTION_INDEX = new hmap.format.obj.Attribute("refractionIndex", 1, "FLOAT");
hmap.format.obj.Layout.SHARPNESS = new hmap.format.obj.Attribute("sharpness", 1, "FLOAT");
hmap.format.obj.Layout.MAP_DIFFUSE = new hmap.format.obj.Attribute("mapDiffuse", 1, "SHORT");
hmap.format.obj.Layout.MAP_AMBIENT = new hmap.format.obj.Attribute("mapAmbient", 1, "SHORT");
hmap.format.obj.Layout.MAP_SPECULAR = new hmap.format.obj.Attribute("mapSpecular", 1, "SHORT");
hmap.format.obj.Layout.MAP_SPECULAR_EXPONENT = new hmap.format.obj.Attribute("mapSpecularExponent", 1, "SHORT");
hmap.format.obj.Layout.MAP_DISSOLVE = new hmap.format.obj.Attribute("mapDissolve", 1, "SHORT");
hmap.format.obj.Layout.ANTI_ALIASING = new hmap.format.obj.Attribute("antiAliasing", 1, "UNSIGNED_SHORT");
hmap.format.obj.Layout.MAP_BUMP = new hmap.format.obj.Attribute("mapBump", 1, "SHORT");
hmap.format.obj.Layout.MAP_DISPLACEMENT = new hmap.format.obj.Attribute("mapDisplacement", 1, "SHORT");
hmap.format.obj.Layout.MAP_DECAL = new hmap.format.obj.Attribute("mapDecal", 1, "SHORT");
hmap.format.obj.Layout.MAP_EMISSIVE = new hmap.format.obj.Attribute("mapEmissive", 1, "SHORT");
;"use strict";
hmap.geom=hmap.geom||{};
/**
 * 枚举类，涵盖了hmap支持的所有几何体类型
 * @type {{Point: string, MultiPoint: string, Line: string, MultiLine: string, LinearRing: string, Polygon: string, MultiPolygon: string, Collection: string, Circle: string, Rectangle: string, Triangle: string, Hexagon: string}}
 */
 hmap.geom.GeometryType={
     Point:'Point',
     MultiPoint:'MultiPoint',
     Line:'Line',
     MultiLine:'MultiLine',
     LinearRing:'LinearRing',
     Polygon:'Polygon',
     MultiPolygon:'MultiPolygon',
     Collection:'Collection',
     Circle:'Circle',
     Rectangle:'Rectangle',
     Triangle:'Triangle',
     Hexagon:'Hexagon',
     CircleExt:'CircleExt',
 };

/**
 *  拓展的几何类型
 *  @example
 *  线类型：
 *  POLYLINE.ARC        圆弧
 *  POLYLINE.FREELINE   自由线
 *  POLYLINE.BEZIER_CURVE2   二次贝塞尔曲线
 *  POLYLINE.BEZIER_CURVE3   三次贝塞尔曲线
 *  POLYLINE.BEZIER_CURVEN   N次贝塞尔曲线
 *  POLYLINE.CARDINAL_CURVE   Cardinal曲线
 *  面类型：
 *  CIRCLE   圆
 *  ELLIPSE   椭圆
 *  SECTOR   扇形
 *  LUNE   弓形
 *  POLYGON.RECTANGLE   矩形
 *  POLYGON.FREE_POLYGON   手绘面
 *  POLYGON.GATHERING_PLACE   聚集区
 *  POLYGON.ROUNDED_RECT   圆角矩形
 *  POLYGON.CLOSE_CURVE   闭合曲线
 *  旗标：
 *  FLAG.CURVE_FLAG   曲线旗标
 *  FLAG.RECT_FLAG   直角旗标
 *  FLAG.TRIANGLE_FLAG   三角旗标
 *  箭头面：
 *  ARROW.CLOSE_CURVE   直箭头
 *  ARROW.CLOSE_CURVE   斜箭头
 *  ARROW.CLOSE_CURVE   双箭头
 *  ARROW.CLOSE_CURVE   燕尾直箭头
 *  ARROW.CLOSE_CURVE   燕尾斜箭头
 *  箭头线：
 *  LARROW.POLYLINE_ARROW   折线箭头
 *  LARROW.PARALLEL_SEARCH   平行搜寻区
 *  LARROW.SECTOR_SEARCH   扇形搜寻区
 *  LARROW.BEZIER_CURVE_ARROW   贝塞尔曲线箭头
 *  LARROW.CARDINAL_CURVE_ARROW   Cardinal曲线箭头
 * */
hmap.geom.GeometryExtType =
    {
        POLYLINE:{
            ARC:"Arc",                            //圆弧
            FREELINE:"FreeLine",                //自由线
            BEZIER_CURVE2:"BezierCurve2",      //二次贝塞尔曲线
            BEZIER_CURVE3:"BezierCurve3",      //三次贝塞尔曲线
            BEZIER_CURVEN:"BezierCurveN",      //N次贝塞尔曲线
            CARDINAL_CURVE:"CardinalCurve"     //Cardinal曲线
        },
        POLYGON:{
            CIRCLE:"CircleExt",                      //圆
            ELLIPSE:"Ellipse",                    //椭圆
            SECTOR:"Sector",                            //扇形
            LUNE:"Lune",                                 //弓形
            RECTANGLE:"Rectangle",                     //矩形
            FREE_POLYGON:"FreePolygon",               //手绘面
            GATHERING_PLACE:"GatheringPlace",        //聚集区
            ROUNDED_RECT:"RoundedRect",               //圆角矩形
            CLOSE_CURVE:"CloseCurve"                  //闭合曲线
        },
        FLAG:{
            CURVE_FLAG:"CurveFlag",          //曲线旗标
            RECT_FLAG:"RectFlag",            //直角旗标
            TRIANGLE_FLAG:"TriangleFlag"    //三角旗标
        },
        ARROW:{
            STRAIGHT_ARROW:"StraightArrow",            //直箭头
            DIAGONAL_ARROW:"DiagonalArrow",            //斜箭头
            DOUBLE_ARROW:"DoubleArrow",                    //双箭头
            DOVETAIL_STRAIGHT_ARROW:"DoveTailStraightArrow",  //燕尾直箭头
            DOVETAIL_DIAGONAL_ARROW:"DoveTailDiagonalArrow"   //燕尾斜箭头
        },
        LARROW:{
            POLYLINE_ARROW:"PolylineArrow",            //折线箭头
            PARALLEL_SEARCH:"ParallelSearch",          //平行搜寻区
            SECTOR_SEARCH:"SectorSearch",              //扇形搜寻区
            BEZIER_CURVE_ARROW:"BezierCurveArrow",    //贝塞尔曲线箭头
            CARDINAL_CURVE_ARROW:"CardinalCurveArrow" //Cardinal曲线箭头
        }
    }

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 地理几何体基类。该类是抽象类，不能被直接实例化。其子类实例与非空间属性、样式等一起组成地理要素。
 * 地理几何体刻画了地表实体的轮廓形状、位置等信息。地理几何体是矢量图形，与空间分辨率没关，这意味着它们可以在显示屏幕上无损显示。
 * @type {hmap.geom.Geometry}
 */
hmap.geom.Geometry = class {
    /**
     * 构造函数。该类是抽象类，不能用构造函数直接实例化。
     */
    constructor() {
        if (new.target === hmap.geom.Geometry) {
            throw new TypeError("The Geometry is an abstract class,and can not be instanced!");
        }
        this.CLASS_NAME = "hmap.geom.Geometry";
    }
    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
    }
    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的计算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
    }
    /**
     * 复制一个几何体。复制后几何体是独立于原几何体的实例。
     * @returns {hmap.geom.Geometry} 新的几何体。
     */
    clone() {
    }
    /**
     * 复制当前几何体对象，将得到的几何体对象的地理范围中心变成传参的coordinate。不改变原来的geometry对象。
     * @param {hmap.basetype.Coordinate} coordinate 坐标
     * @returns {hmap.geom.Geometry} 新的geometry对象，geometry类型和调用该方法的对象的类型一致。
     */
    copyTo(coordinate){
        if(!(coordinate instanceof hmap.basetype.Coordinate)){
            return null;
        }
        const geo = this.clone();
        const centCoord = geo.getExtent().getCenter();
        const deltaX = coordinate.getOrdinate("X") - centCoord.getOrdinate("X");
        const deltaY = coordinate.getOrdinate("Y") - centCoord.getOrdinate("Y");
        const deltaZ = coordinate.getOrdinate("Z") - centCoord.getOrdinate("Z");
        geo.moveByDelta(deltaX,deltaY,deltaZ);
        return geo;
    }

    /**
     * 销毁几何体对象。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * point.destroy();
     */
    destroy() {
        for(const e in this){
            delete this[e];
        }
    }
    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示几何对象上最靠近目标几何对象的点；x1 和 y1 表示目标几何对象上最近的点。
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 计算一个几何图形到目标几何图形边缘的最近距离，默认为true
     * 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数，
     * 如果为false，两个几何图形相交情况下 计算距离为0。
     * @return {Number | Object} 返回的距离信息，根据options.details参数值给出不同的距离信息。但当options.details为false时，结果只返回一个距离值。
     */
    distanceTo(geometry, options) {
    }
    /**
     * 计算几何体的缓冲区。
     * @param {Number} dist 缓冲距离,地图单位，且是大于0的数字。
     * @returns {hmap.geom.Geometry} 缓冲区。
     * @private
     */
    getBuffer(dist){
    }
    /**
     * 质量中心简称质心，指物质系统上被认为质量集中于此的一个假想点,
     * 与重心不同的是，质心不一定要在有重力场的系统中。特别地，除非重力场是均匀的，否则同一物质系统的质心与重心通常不在同一假想点上。
     */
    // getCentroid() {
    // };

    /**
     * 从构成几何体的所有点中，获取离传入坐标最近的一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 几何体上的一个点。
     */
    getClosestPoint(coord) {
    }
    /**
     * 计算几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 几何体的地理范围。
     */
    getExtent() {
    }

    /**
     * 获取几何体类型。
     * @returns {String} 几何体类型。
     */
    getType() {
    }

    /**
     * 检测几何体与地理坐标是否相交。
     * @param {hmap.basetype.Coordinate} coordinate 地理坐标。
     * @return {Boolean} 为true时表示相交，为false时表示不相交。
     */
    intersectsCoordinate(coordinate) {
        const point=new hmap.geom.Point(coordinate);
        return point.intersectsGeometry(this);
    }
    /**
     * 检测几何体与地理范围是否相交。
     * @param  {hmap.basetype.Extent} extent 地理范围。
     * @return {Boolean} 为true时表示相交，为false时表示不相交。
     */
    intersectsExtent(extent) {
        const geo=extent.toPolygon();
        return geo.intersectsGeometry(this);
    }
    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
    }
    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线。
     * @param {Number} tolerance 拾取容差。
     * @return {Number} 射线上距离要素最近点到相机点的距离。
     * @private
     */
    intersectRay(ray,tolerance){
    }
    /**
     * 自相交判断。
     * @return {Boolean} 返回true表示相交；返回false表示不相交
     */
    isSelfIntersects() {
    }
    /**
     * 检测当前几何体是否有效。
     * @private
     * @returns {Boolean} 返回true表示有效；返回false表示无效。
     */
    isValid() {
    }
    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Geometry} 移动后的几何体。
     */
    moveByDelta(deltaX, deltaY, deltaZ) {
    }
    /**
     * 以某个坐标为中心，绕坐标轴旋转。绕轴旋转的本质如下： 绕Z轴旋转即是在XY平面内旋转；绕X轴旋转即是在YZ平面内旋转；绕Y轴旋转即是在XZ平面内旋转
     * @param {String} axis   坐标轴。可选值为"X","Y","Z"
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center  旋转（环绕中心），可选项。参数为空时，仅环绕坐标轴旋转
     * @throws {Error} 当axis不是'X'、’Y‘、’Z‘三者之一时，抛出异常
     * @throws {TypeError} 当angle不是数字，或者传入的center参数类型不是hmap.basetype.Coordinate时，抛出类型错误异常
     */
    rotate(axis,angle, center) {
    }
    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Geometry} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
    }
    /**
     * 简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。
     * 采用道格拉斯-普克算法，每条用于构成几何体的线中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * 注意：Triangle对象本身就是最简化的状态，所以不需要简化。
     * @private
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Geometry} 返回简化后的几何体。
     */
    simplify(tolerance) {
    }
    /**
     * (暂未实现)将一个几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 如果给定的坐标系未找到，则抛出异常。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * **考虑到实际转换时，数据量可能较大，故传入crs的SRID，而非crs实例，以减少crs实例数量，进而降低内存成本**
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Geometry} 坐标转换后的几何体。
     */
    transform(source, destination) {
    }

    /**
     * 计算几何体的三维包围盒
     */
    getBBox() {
    }
};
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 点，地理几何体的一种，从形态上讲，也称为点状几何体。由地理坐标构成，而不等同于地理坐标。
 * @type {hmap.geom.Point}
 * @extends hmap.geom.Geometry
 * @example
 * let coord = new hmap.basetype.Coordinate(120,30,0);
 * let point = new hmap.geom.Point(coord);
 */
hmap.geom.Point = class extends hmap.geom.Geometry {
    /**
     * 构造一个点几何体对象。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     */
    constructor(coord) {
        super();
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        this._coordinate = coord;
        this.CLASS_NAME = "hmap.geom.Point";
    }

    /**
     * 检测两个点几何体的坐标是否相等。
     * @param {hmap.geom.Point} point 一个点几何体对象。
     * @return {Boolean} 返回true表示相等；返回false表示不相等。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord);
     * let point2 = new hmap.geom.Point(coord);
     * let result = point1.equals(point2);
     */
    equals(point) {
        if (!point || !(point instanceof hmap.geom.Point)) {
            throw new Error("parameter does not meet the requirement!");
        }
        return this._coordinate.equals(point.getCoordinate());
    }

    /**
     * 获取构成点几何体对象的地理坐标。
     * @returns {hmap.basetype.Coordinate} 地理坐标。
     */
    getCoordinate() {
        return this._coordinate;
    }

    /**
     * 重新设置点几何体的坐标。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @throws {TypeError} 当入参coord不是一个地理坐标时，抛出对象类型异常。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let coord2 = new hmap.basetype.Coordinate(12.5,31.0,0);
     * point.setCoordinate(coord2);
     */
    setCoordinate(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new TypeError("parameter is not Coordinate!");
        }
        this._coordinate = coord;
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        this._coordinate = callback(this.getCoordinate());
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new TypeError("the parameter is not Coordinate!");
        }
        const extentP = this.getExtent();
        return extentP.containsCoord(coord);
    }

    /**
     * 复制一个点几何体对象。
     * @returns {hmap.geom.Point} 返回新的点对象。
     */
    clone() {
        return new hmap.geom.Point(this._coordinate.clone());
    }


    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true，一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let coord2 = new hmap.basetype.Coordinate(140,30,0);
     * let center = new hmap.geom.Point(coord2);
     * let circle = new hmap.geom.Circle(center,10);
     * let result = point1.distanceTo(circle);//result=10
     */
    distanceTo(geometry, options) {
        const edge = !(options && options.edge === false);          //边缘距离，默认true
        const details = options && options.details;         //默认为false
        let distance, x0, y0, x1, y1, result;
        if (geometry instanceof hmap.geom.Point) {
            x0 = this._coordinate.getOrdinate("X");
            y0 = this._coordinate.getOrdinate("Y");
            x1 = geometry.getCoordinate().getOrdinate("X");
            y1 = geometry.getCoordinate().getOrdinate("Y");
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
        } else if (geometry instanceof hmap.geom.Circle) {           //对圆进行处理
            x0 = this._coordinate.getOrdinate("X");
            y0 = this._coordinate.getOrdinate("Y");
            x1 = geometry.getCenter().getCoordinate().getOrdinate("X");
            y1 = geometry.getCenter().getCoordinate().getOrdinate("Y");
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));      //点到圆心的距离
            if (distance !== 0) {
                x1 = x1 - (x1 - x0) * geometry.getRadius() / distance, y1 = y1 - (y1 - y0) * geometry.getRadius() / distance;    //与边线的交点
            }
            let edgeDistance = distance - geometry.getRadius();
            if (!edge && edgeDistance <= 0) {          //不求边缘距离且距离小于0，直接返回0
                edgeDistance = 0;
            }
            result = !details ? edgeDistance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: edgeDistance};

        } else {
            result = geometry.distanceTo(this, options);
            if (details) {
                if (edge || (!edge && result.distance > 0)) {
                    result = {
                        distance: result.distance,
                        x0: result.x1, y0: result.y1,
                        x1: result.x0, y1: result.y0
                    };
                }
            }
        }
        // //如果两个几何体相交，则只有当edge、detials同时为true才返回详细信息，否则只返回距离。
        // if(((result instanceof Object)&&result.distance&&result.distance<=0)||result<=0){
        //     return (options&&!options.details)?result:0;
        // }
        return result;
    }

    /**
     * 计算点到线段的距离
     * @private
     * @param {Array<hmap.basetype.Coordinate>} segment 包含两个坐标对象的数组，表示一个线段。
     * @returns {Object} 距离信息,格式为:{"distance":xxx,"x":xxx,"y":xxx,"along":xxx}.distance:点到线段的最短距离;x和y:在线段上，距点几何体最近的点坐标；along:(x,y)点对应整个线段的比例因子，即:该点到起点长度/线段总长。
     */
    distanceToSegment(segment) {
        const result = this._distanceSquaredToSegment(segment);
        return result;
    }

    /**
     * 通常应使用distanceToSegment方法。该方法可以用于在距离的值不重要的情况下进行距离的比较。
     * @param {Array<hmap.basetype.Coordinate>} segment 包含两个坐标对象的数组，表示一个线段。
     * @returns {Object} 距离信息，包含属性distance、x、y和along。distance属性表示点到线段的最短距离，x和y表示线段上距离当前点最近的点，along表示线段上距离当前点最近的点到线段起始点的距离和线段长度的比值。
     * @private
     */
    _distanceSquaredToSegment(segment) {
        const x0 = this.getCoordinate().getOrdinate("X");
        const y0 = this.getCoordinate().getOrdinate("Y");
        const x1 = segment[0].getOrdinate("X");
        const y1 = segment[0].getOrdinate("Y");
        const x2 = segment[1].getOrdinate("X");
        const y2 = segment[1].getOrdinate("Y");
        const dx = x2 - x1;
        const dy = y2 - y1;
        const along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
            (Math.pow(dx, 2) + Math.pow(dy, 2));
        let x, y;
        if (along <= 0.0) {
            x = x1;
            y = y1;
        } else if (along >= 1.0) {
            x = x2;
            y = y2;
        } else {
            x = x1 + along * dx;
            y = y1 + along * dy;
        }
        return {
            distance: Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)),
            x: x, y: y,
            along: along
        };
    }

    /**
     * 计算点几何体的缓冲区域。即:以点为圆心，缓冲距离为半径构成的一个圆区域，作为点几何体的缓冲区域。
     * @param {Number} dist 缓冲距离,大于0。单位和地图单位相同
     * @returns {hmap.geom.Circle} 缓冲区域。
     * @example
     * point.getBuffer(0.01);
     */
    getBuffer(dist) {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero !");
        }
        return new hmap.geom.Circle(this, dist);
    }

    /**
     * 获取点对象的质心。
     * @returns {hmap.basetype.Coordinate} 质心地理坐标。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let result = point.getCentroid();
     */
    getCentroid() {
        return this.getCoordinate();
    }

    /**
     * (没有意义，不开放接口)获取离传入坐标最近的一个点。
     * @private
     */
    getClosestPoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        return this;
    }

    /**
     * 计算点几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 返回点几何体的地理范围。
     */
    getExtent() {
        const lAndR = this._coordinate.getOrdinate("X");
        const tAndB = this._coordinate.getOrdinate("Y");
        return new hmap.basetype.Extent(lAndR, tAndB, lAndR, tAndB);
    }

    /**
     * 获取几何体类型。
     * @returns {String} 返回几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.Point;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectPoint3D(this, geom);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.pointIntersectMultiPoint3D(this, geom);
            },
            'Line': () => {
                return hmap.strategy.Intersect.pointIntersectLine3D(this, geom);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.pointIntersectLine3D(this, geom);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.pointIntersectPolygon2D(this, geom.toPolygon());
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.pointIntersectMultiLine3D(this, geom);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.pointIntersectPolygon2D(this, geom.toPolygon());
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.pointIntersectPolygon2D(this, geom.toPolygon());
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.pointIntersectPolygon2D(this, geom);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.pointIntersectMultiPolygon2D(this, geom);
            },
            'Collection': () => {
                return geom.intersectsGeometry(this);
            }
        }[geom.getType()]();
    }

    /**
     * (暂未启用)自相交判断。
     * @return {Boolean} true表示相交，false表示不相交
     */
    isSelfIntersects() {
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid() {
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Point} 移动后的点几何体。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * let result = point.moveByDelta(2,3,0);//result=new hmap.geom.Point(new hmap.basetype.Coordinate(122,33,0))
     */
    moveByDelta(deltaX, deltaY, deltaZ) {
        if (!(Number.isFinite(deltaX)) || !(Number.isFinite(deltaY)) || !(Number.isFinite(deltaZ))) {
            throw new Error("parameter must be number!");
        }
        let coord = this._coordinate;
        coord.setOrdinate("X", coord.getOrdinate("X") + deltaX);
        coord.setOrdinate("Y", coord.getOrdinate("Y") + deltaY);
        coord.setOrdinate("Z", coord.getOrdinate("Z") + deltaZ);
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z"
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针为正，顺时针为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.Point} 返回旋转后的点。
     */
    rotate(axis, angle, center) {
        this._coordinate.rotate(axis, angle, center);
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Point} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        if (!Number.isFinite(xFactor) || !Number.isFinite(yFactor) || !Number.isFinite(zFactor)
            || xFactor <= 0 || yFactor <= 0 || zFactor <= 0) {
            throw new RangeError('Parameter "xFactor", "yFactor" and "zFactor" must be positive Number!');
        }
        if (origin && !(origin instanceof hmap.basetype.Coordinate)) {
            throw new TypeError('Parameter "origin" must be type of hmap.basetype.Coordinate');
        }
        if (!origin) {
            return this;
        }
        const x = origin.getOrdinate("X");
        const y = origin.getOrdinate("Y");
        const z = origin.getOrdinate("Z");
        this.moveByDelta(-x, -y, -z);
        this._coordinate.scale(xFactor, yFactor, zFactor);
        this.moveByDelta(x, y, z);
        return this;
    }

    /**
     * (单点简化无意义，接口不开放)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。采用道格拉斯-普克算法，每条用于构成几何体的线中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Point} 返回简化后的几何体。
     * @private
     */
    simplify(tolerance) {
        return this;
    }

    /**
     * 将点几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本**
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Point} 坐标转换后的几何体。
     */
    transform(source, destination) {
        this._coordinate = hmap.proj.Transformer.transform(this._coordinate, source, destination);
        return this;
    }

    /**
     * 销毁对象。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point = new hmap.geom.Point(coord);
     * point.destroy();
     * let result = point.CLASS_NAME;//result=undefined即point对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 计算点几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回点几何体的三维包围盒。
     */
    getBBox() {
        let lAndR = this._coordinate.getOrdinate("X");
        let tAndB = this._coordinate.getOrdinate("Y");
        let hAndB = this._coordinate.getOrdinate("Z");
        return new hmap.basetype.BBox(lAndR, tAndB, hAndB, lAndR, tAndB, hAndB);
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance 拾取容差
     * @param {Number|Array} offset 偏移
     * @return {Number} 最小距离
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        //待更新
        let result = hmap.strategy.Intersect3D.pointToSegment(this.getCoordinate(),
            ray._line.getVertices()[0].getCoordinate(), ray._line.getVertices()[1].getCoordinate(),offset);
        if(!result) return null;
        let minDistance = result.distance;//点到直线的距离
        if (minDistance < tolerance) {
            let pointToCamera =  ray.distanceSquare(result.point);//最近点到相机的距离
            return {
                distance: pointToCamera,
            }
        }
        return null;
    }
};
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 线状几何体，由两个或两个以上的点组成。
 * @type {hmap.geom.Line}
 * @extends hmap.geom.Geometry
 * @example
 * let coord = new hmap.basetype.Coordinate(120,30,0);
 * let point1 = new hmap.geom.Point(coord);
 * let point2 = new hmap.geom.Point(coord);
 * let line = new hmap.geom.Line([point1,point2]);
 */
hmap.geom.Line = class extends hmap.geom.Geometry {

    /**
     * 构造一条线，构成一条线需要至少两个{hmap.geom.Point}对象。
     * @param {Array<hmap.geom.Point>} points 点对象组成的数组。
     */
    constructor(points) {
        if (points.length < 2) {
            throw new Error("the array must be two coordinates at least!");
        }
        //所有元素均为point时，返回true
        let isPoints = points.every(function (item, index, array) {
            return item instanceof hmap.geom.Point;
        });
        if (!isPoints) {
            throw new Error("the elements in the array are all not Points!");
        }
        super();

        //在类内部维护一个名为pointArr的数组
        this._pointArr = points;
        //计算该类的范围
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this._extent = this._bbox.getExtent();

        this.CLASS_NAME = "hmap.geom.Line";
    }

    /**
     * 把传入的坐标追加到线的坐标数组中。
     * 1.如果index大于线的坐标数组长度，新坐标将被追加到线的坐标数组末尾；
     * 2.如果index小于0，新坐标将被添加到坐标数组的起始位置；
     * 3.如果index不传，则将新坐标自动追加到线的坐标数组末尾。
     * @param {hmap.basetype.Coordinate} coord 新的坐标，此坐标将被加入到线的坐标数组中
     * @param {Number} index 在坐标数组中的索引。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let coord = new hmap.basetype.Coordinate(122,32,0);
     * line.addCoord(coord,2);
     * let result = line.getCoordSeq();
     */
    addCoord(coord, index) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new TypeError("the first parameter must be a Coordinate!");
        }
        //判断是否有index值传入,没有则默认插入到末尾
        if (index === undefined) {
            index = this._pointArr.length;
        }
        if (!Number.isFinite(index)) {
            throw new TypeError("the index must be a number!");
        }
        //判断index值是否超出范围
        index = index > this._pointArr.length ? this._pointArr.length : index < 0 ? 0 : index;
        //clone要插入的对象
        //let coordinate=coord.clone()//验证添加坐标;
        //比较要插入的位置是否值相同
        if (index < this._pointArr.length) {
            const point = new hmap.geom.Point(coord);
            this._pointArr.splice(index, 0, point);
        } else { //直接添加到末尾
            this._pointArr.push(new hmap.geom.Point(coord));
        }
        //更新extent
        this._pointsChanged = true;
        this.getExtent();
    }

    /**
     * 遍历并处理当前线中的所有线段。线段（segment）是指两端都有端点，不可延伸的线，有别于直线、射线。
     * @private
     * @param {Function} callback 对线段进行的操作。参数为包含线段两个端点的{@link hmap.geom.Line}。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(123,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let line = new hmap.geom.Line([point1,point2,point3]);
     * let result = [];
     * line.forEachSegment(function(value){//返回构成线的每一条线段
     *      result.push(value);
     * });
     */
    forEachSegment(callback) {
        for (let i = 0, len = this._pointArr.length - 1; i < len; i++) {
            callback(new hmap.geom.Line(this._pointArr.slice(i, i + 2)));
        }
        this._pointsChanged = true;
        this.getExtent();
    }

    /**
     * 将一个坐标序列转化成线对象。
     * @param {hmap.basetype.CoordSeq} coordSeq 坐标序列。
     * @returns {hmap.geom.Line} 生成的线对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2]);
     * let result = hmap.geom.Line.fromCoordSeq(coordSeq);
     */
    static fromCoordSeq(coordSeq) {
        if (!coordSeq instanceof hmap.basetype.CoordSeq) {
            throw new Error('parameter "coordSeq" must be instance of hmap.basetype.CoordSeq')
        }
        let points = coordSeq.extractCoords().map(coord => {
            return new hmap.geom.Point(coord);
        });
        return new hmap.geom.Line(points);
    }

    /**
     * 从几何体开始的位置，按照比例因子匹配最接近索引的坐标。若比例因子对应的位置正好在两个点的中间，则返回后面的点。
     * @param {Number} fraction 比例因子，范围为0~1。0表示起点，1表示终点。
     * @returns {hmap.basetype.Coordinate} 匹配到的坐标。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getCoordinateAt(0.4);//result=new hmap.basetype.Coordinate(120,30,0)
     */
    getCoordinateAt(fraction) {
        if (Number.isFinite(fraction) && fraction >= 0 && fraction <= 1) {
            const pointCount = Math.round((this._pointArr.length - 1) * fraction);
            return this._pointArr[pointCount].getCoordinate();
        } else {
            throw new RangeError('Parameter "fraction" must be Number between 0 and 1!');
        }
    }

    /**
     * 提取线的坐标序列。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的Coordinate；
     * 3.如果startIndex与endIndex参数为空，返回所有Coordinate。
     * 4.当startIndex大于等于endIndex，返回空数组。
     * @param {Number} startIndex 起始索引。如果不传，默认是0。
     * @param {Number} endIndex 结束索引。如果不传，默认是坐标序列长度值。
     * @returns {hmap.basetype.CoordSeq} 坐标序列。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getCoordSeq(0,1);
     */
    getCoordSeq(startIndex = 0, endIndex = this._pointArr.length) {
        if (!Number.isFinite(startIndex) || !Number.isFinite(endIndex)) {
            throw new TypeError('Parameter "startIndex" and "endIndex" must be Number!');
        }
        //处理索引越界问题
        const len = this._pointArr.length;
        startIndex = startIndex <= 0 ? 0 : Number.parseInt(startIndex);
        endIndex = endIndex >= len ? len : Number.parseInt(endIndex);

        if (startIndex >= endIndex) {
            return [];
        }

        //获取指定位置的point
        let points = this._pointArr.slice(startIndex, endIndex);
        let coords = points.map(function (item, index, array) {
            return item.getCoordinate();
        });
        return new hmap.basetype.CoordSeq(coords);
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     * 获取当前几何体的所有节点。
     * @returns {Array<hmap.geom.Point>} 节点数组。
     */
    getVertices() {
        return this._pointArr;
    }

    /**
     * 从线中删除与指定坐标地理位置相同的点。注意：删除后，如果剩余的点数量为1，那么将把仅剩的点复制一次，与复制前的坐标一起组成线。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Number} 删除点的个数。传入参数异常则返回-1。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.removeCoord(coord1);
     */
    removeCoord(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            return -1;
        }

        const point = new hmap.geom.Point(coord);
        const oriLen = this._pointArr.length;
        for (let i = oriLen - 1; i >= 0; i--) {
            if (point.equals(this._pointArr[i])) {
                this._pointArr.splice(i, 1);
            }
        }

        //计算当前数组长度
        let curLen = this._pointArr.length;
        if (curLen < oriLen) {
            if (curLen === 1) {
                this._pointArr.push(this._pointArr[0]);
            }
        }

        //重新计算extent
        this._pointsChanged = true;
        this.getExtent();

        //返回删除的个数
        return oriLen - curLen;
    }

    /**
     * 用当前线切割目标几何体(暂未启用)。
     * @private
     * @param {hmap.geom.Geometry} targetGeometry 目标几何体。
     * @param {Object} options
     */
    split(targetGeometry, options) {
    }

    /**
     * 用指定几何体切割线(暂未启用)。
     * @param {hmap.geom.Geometry} geometry 用于切割线的几何体。
     * @param {Object} options
     * @private
     */
    splitWith(geometry, options) {
    }

    /**
     * 获取排序后的线段数组。
     * @private
     * @returns {Array} 线段对象数组。线段对象包含了x1, y1, x2, y2属性。起始点的坐标表示为x1和y1，终止点的坐标表示为x2和y2。起始点和终止点的排序依据为x1<x2。
     */
    _getSortedSegments() {
        const numSeg = this._pointArr.length - 1;
        let segments = new Array(numSeg),
            coord1, coord2;
        for (let i = 0; i < numSeg; ++i) {
            coord1 = this._pointArr[i].getCoordinate();
            coord2 = this._pointArr[i + 1].getCoordinate();
            if (coord1.getOrdinate("X") < coord2.getOrdinate("X")) {
                segments[i] = [coord1, coord2];
            } else {
                segments[i] = [coord2, coord1];
            }
        }

        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1[0].getOrdinate("X") - seg2[0].getOrdinate("X");
        }

        return segments.sort(byX1);
    }

    /**
     * 判定两条线段是否相交。通过选项可以设置是否返回相交点。该方法用于计算seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1的情况。在显然不相交的情况下，该方法不应被调用。
     * @param {Object} seg1 线段对象，包含了x1, y1, x2, y2属性。线段对象包含了x1, y1, x2, y2属性。起始点的坐标表示为x1和y1，终止点的坐标表示为x2和y2。起始点和终止点的排序依据为x1<x2。
     * @param {Object} seg2 线段对象，包含了x1, y1, x2, y2属性。线段对象包含了x1, y1, x2, y2属性。起始点的坐标表示为x1和y1，终止点的坐标表示为x2和y2。起始点和终止点的排序依据为x1<x2。
     * @param {Object} options 计算相交的选项。
     * @param {Boolean} options.point 是否返回相交点。如果设置为false，则不计算相交点。如果设置为true，则在线段相交的情况下将返回相交点，在线段不相交的情况下返回false，在线段重叠的情况下返回true。
     * @param {Number} options.tolerance 如果设置为非零值，则两线段在容差距离内也被判定为相交。此外，如果point选项设置为true，则交点在端点容差距离以内时，端点将作为交点返回。另外，如果交点在两条线段端点的容差距离以内，或者一条线段的端点在另一条线段端点的容差距离以内（没有计算出交点），则在返回第一条线段上的端点。
     * @returns {Boolean|hmap.geom.Point} 两条线段是否相交。如果point选项设置为true，则在相交时返回交点，不相交时返回false，重叠时返回true（交集为较短的线段）。
     * @private
     */
    static segmentsIntersect(seg1, seg2, options) {
        const point = options && options.point;
        const tolerance = options && options.tolerance;
        let intersection = false;
        const x11_21 = seg1[0].getOrdinate("X") - seg2[0].getOrdinate("X");
        const y11_21 = seg1[0].getOrdinate("Y") - seg2[0].getOrdinate("Y");
        const x12_11 = seg1[1].getOrdinate("X") - seg1[0].getOrdinate("X");
        const y12_11 = seg1[1].getOrdinate("Y") - seg1[0].getOrdinate("Y");
        const y22_21 = seg2[1].getOrdinate("Y") - seg2[0].getOrdinate("Y");
        const x22_21 = seg2[1].getOrdinate("X") - seg2[0].getOrdinate("X");
        const d = (y22_21 * x12_11) - (x22_21 * y12_11);
        const n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
        const n2 = (x12_11 * y11_21) - (y12_11 * x11_21);

        const x11_22 = seg1[0].getOrdinate("X") - seg2[1].getOrdinate("X");
        const y11_22 = seg1[0].getOrdinate("Y") - seg2[1].getOrdinate("Y");
        const x12_21 = seg1[1].getOrdinate("X") - seg2[0].getOrdinate("X");
        const y12_21 = seg1[1].getOrdinate("Y") - seg2[0].getOrdinate("Y");
        const x12_22 = seg1[1].getOrdinate("X") - seg2[1].getOrdinate("X");
        const y12_22 = seg1[1].getOrdinate("Y") - seg2[1].getOrdinate("Y");

        const x21_11 = seg2[0].getOrdinate("X") - seg1[0].getOrdinate("X");
        const y21_11 = seg2[0].getOrdinate("Y") - seg1[0].getOrdinate("Y");
        const x21_12 = seg2[0].getOrdinate("X") - seg1[1].getOrdinate("X");
        const y21_12 = seg2[0].getOrdinate("Y") - seg1[1].getOrdinate("Y");
        const x22_11 = seg2[1].getOrdinate("X") - seg1[0].getOrdinate("X");
        const y22_11 = seg2[1].getOrdinate("Y") - seg1[0].getOrdinate("Y");
        const x22_12 = seg2[1].getOrdinate("X") - seg1[1].getOrdinate("X");
        const y22_12 = seg2[1].getOrdinate("Y") - seg1[1].getOrdinate("Y");

        if (d === 0) {
            // parallel 平行
            if (n1 === 0 && n2 === 0) {
                // coincident 共线
                if (x11_21 * x11_22 < 0 || y11_21 * y11_22 < 0 || x12_21 * x12_22 < 0 || y12_21 * y12_22 < 0 || x21_11 * x21_12 < 0 || y21_11 * y21_12 < 0 || x22_11 * x22_12 < 0 || y22_11 * y22_12 < 0) {
                    //验证共线相交
                    if (!point) {
                        intersection = true;
                    } else {
                        intersection = new hmap.geom.Point(seg1[0]);
                    }
                } else {
                    intersection = false;
                }
            }
        } else {
            const along1 = n1 / d;
            const along2 = n2 / d;
            if (along1 >= 0 && along1 <= 1 && along2 >= 0 && along2 <= 1) {
                // intersect
                if (!point) {
                    intersection = true;
                } else {
                    // calculate the intersection point
                    const x = seg1[0].getOrdinate("X") + (along1 * x12_11);
                    const y = seg1[0].getOrdinate("Y") + (along1 * y12_11);
                    intersection = new hmap.geom.Point(new hmap.basetype.Coordinate(x, y));
                }
            }
        }
        if (tolerance) {
            let dist;
            if (intersection) {
                if (point) {
                    let segs = [seg1, seg2];
                    let seg, x, y;
                    // check segment endpoints for proximity to intersection
                    // set intersection to first endpoint within the tolerance
                    outer: for (var i = 0; i < 2; ++i) {
                        seg = segs[i];
                        for (let j = 0; j < 2; ++j) {
                            x = seg[j].getOrdinate("X");
                            y = seg[j].getOrdinate("Y");
                            dist = Math.sqrt(
                                Math.pow(x - intersection.x, 2) +
                                Math.pow(y - intersection.y, 2)
                            );
                            if (dist < tolerance) {
                                intersection.x = x;
                                intersection.y = y;
                                break outer;
                            }
                        }
                    }
                }
            } else {
                // no calculated intersection, but segments could be within
                // the tolerance of one another
                const segs = [seg1, seg2];
                let source, target, x, y, p, result;
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for (let i = 0; i < 2; ++i) {
                    source = segs[i];
                    target = segs[(i + 1) % 2];
                    for (let j = 0; j < 2; ++j) {
                        p = new hmap.geom.Point(new hmap.basetype.Coordinate(source[j].getOrdinate("X"), source[j].getOrdinate("Y")));
                        result = p.distanceToSegment(target);
                        if (result.distance < tolerance) {
                            if (point) {
                                intersection = new hmap.geom.Point(new hmap.basetype.Coordinate(p.x, p.y));
                            } else {
                                intersection = true;
                            }
                            break outer;
                        }
                    }
                }
            }
        }
        return intersection;
    }

    /**
     * 复制一个线对象。
     * @return {hmap.geom.Line} 新的线。
     */
    clone() {
        const ps = [];
        for (let i = 0, len = this._pointArr.length; i < len; i++) {
            ps.push(this._pointArr[i].clone());
        }
        return new hmap.geom.Line(ps);
    }

    /**
     * 销毁对象。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord);
     * let point2 = new hmap.geom.Point(coord);
     * let line = new hmap.geom.Line([point1,point2]);
     * line.destroy();
     * let result = line.CLASS_NAME;//result=undefined即line对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        for (let i = 0, len = this._pointArr.length; i < len; i++) {
            this._pointArr[i].applyTransform(callback);
        }
        this._pointsChanged = true;
        this.getExtent();
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if (coord instanceof hmap.basetype.Coordinate) {
            return this.getExtent().containsCoord(coord);
        } else {
            throw new TypeError("the parameter is not Coordinate!");
        }
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options = {}) {
        const edge = !(options && options.edge === false); //边缘距离，默认true
        const details = options && options.details; //默认为false
        let result, best = {};
        let min = Number.POSITIVE_INFINITY;
        if (geometry instanceof hmap.geom.Point) {
            const segs = this._getSortedSegments();
            // const x = geometry.getCoordinate().getOrdinate("X");
            // const y = geometry.getCoordinate().getOrdinate("Y");
            let seg;
            for (let i = 0, len = segs.length; i < len; ++i) {
                seg = segs[i];
                result = geometry.distanceToSegment(seg); //点到线段的距离
                if (result.distance < min) {
                    min = result.distance;
                    best = {
                        x0: result.x,
                        y0: result.y,
                        x1: geometry.getCoordinate().getOrdinate("X"),
                        y1: geometry.getCoordinate().getOrdinate("Y"),
                        distance: result.distance
                    };

                    if (!details) {
                        best = best.distance;
                    }
                    if (min === 0) {
                        break;
                    }
                }
                // else {
                //     // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                //     if (seg[1].getOrdinate("X") > x && ((y > seg[0].getOrdinate("Y") && y < seg[1].getOrdinate("Y")) ||
                //             (y < seg[0].getOrdinate("Y") && y > seg[1].getOrdinate("Y")))) {
                //         break;
                //     }
                // }
            }
        } else if (geometry instanceof hmap.geom.Line) {
            const segsSrc = this._getSortedSegments(); //源线段组
            const segsDes = geometry._getSortedSegments(); //目标线段组
            const interOptions = {
                point: true
            };
            outer: for (let i = 0, length1 = segsSrc.length; i < length1; ++i) {
                let segSrc = segsSrc[i];
                let x0 = segSrc[0].getOrdinate("X"),
                    y0 = segSrc[0].getOrdinate("Y");
                for (let j = 0, length2 = segsDes.length; j < length2; ++j) {
                    let segDes = segsDes[j];
                    let intersection = hmap.geom.Line.segmentsIntersect(segSrc, segDes, interOptions);
                    if (intersection) { //线段组相交
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.getCoordinate().getOrdinate("X"),
                            y0: intersection.getCoordinate().getOrdinate("Y"),
                            x1: intersection.getCoordinate().getOrdinate("X"),
                            y1: intersection.getCoordinate().getOrdinate("Y")
                        };
                        break outer;
                    } else { //不相交
                        let resultS = new hmap.geom.Point(new hmap.basetype.Coordinate(x0, y0)).distanceToSegment(segDes);
                        let resultE = new hmap.geom.Point(new hmap.basetype.Coordinate(segSrc[1].getOrdinate("X"), segSrc[1].getOrdinate("Y"))).distanceToSegment(segDes);
                        let result = resultS,
                            nearerPoint = [x0, y0];
                        if (resultE.distance < resultS.distance) {
                            result = resultE, nearerPoint = [segSrc[1].getOrdinate("X"), segSrc[1].getOrdinate("Y")];
                        }
                        if (result.distance < min) { //不相交的距离
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: nearerPoint[0],
                                y0: nearerPoint[1],
                                x1: result.x,
                                y1: result.y
                            };
                        }
                    }
                }
            }
            if (min !== 0) {
                let reverseBest = {},
                    reverseMin = Number.POSITIVE_INFINITY;
                outer: for (let i = 0, length1 = segsDes.length; i < length1; ++i) {
                    let segDes = segsDes[i];
                    let x0 = segDes[0].getOrdinate("X"),
                        y0 = segDes[0].getOrdinate("Y");
                    for (let j = 0, length2 = segsSrc.length; j < length2; ++j) {
                        let segSrc = segsSrc[j];
                        let intersection = hmap.geom.Line.segmentsIntersect(segDes, segSrc, interOptions); //线段组相交
                        if (intersection) {
                            reverseMin = 0;
                            reverseBest = {
                                distance: 0,
                                x0: intersection.getCoordinate().getOrdinate("X"),
                                y0: intersection.getCoordinate().getOrdinate("Y"),
                                x1: intersection.getCoordinate().getOrdinate("X"),
                                y1: intersection.getCoordinate().getOrdinate("Y")
                            };
                            break outer;
                        } else {
                            let resultS = new hmap.geom.Point(new hmap.basetype.Coordinate(x0, y0)).distanceToSegment(segSrc);
                            let resultE = new hmap.geom.Point(new hmap.basetype.Coordinate(segDes[1].getOrdinate("X"), segDes[1].getOrdinate("Y"))).distanceToSegment(segSrc);
                            let result = resultS,
                                nearerPoint = [x0, y0];
                            if (resultE.distance < resultS.distance) {
                                result = resultE, nearerPoint = [segDes[1].getOrdinate("X"), segDes[1].getOrdinate("Y")];
                            }
                            if (result.distance < reverseMin) {
                                reverseMin = result.distance;
                                reverseBest = {
                                    distance: reverseMin,
                                    x0: nearerPoint[0],
                                    y0: nearerPoint[1],
                                    x1: result.x,
                                    y1: result.y
                                };
                            }
                        }
                    }
                }
                if (reverseMin < min) {
                    min = reverseMin;
                    best = {
                        distance: reverseBest.distance,
                        x0: reverseBest.x1,
                        y0: reverseBest.y1,
                        x1: reverseBest.x0,
                        y1: reverseBest.y0
                    }
                }
            }
            if (!details) {
                best = best.distance;
            }
        } else if (geometry instanceof hmap.geom.Circle) { //对圆进行特殊处理
            let center = geometry.getCenter(),
                radius = geometry.getRadius();
            let result = this.distanceTo(center, options); //线和圆心的距离结果
            let distance = (result.distance || result.distance == 0) ? result.distance - radius : result - radius; //圆心到线的距离减去半径
            if (distance < 0) {
                let maxDist = Number.NEGATIVE_INFINITY,
                    maxCoord; //线要素中 组成点离圆心的最大距离
                let centerCoord = center.getCoordinate(),
                    centerX = centerCoord.getOrdinate("X"),
                    centerY = centerCoord.getOrdinate("Y");
                let points = this.getVertices();
                for (let point of points) {
                    let coordinate = point.getCoordinate(),
                        coordX = coordinate.getOrdinate("X"),
                        coordY = coordinate.getOrdinate("Y");
                    let length = Math.sqrt((coordX - centerX) * (coordX - centerX) + (coordY - centerY) * (coordY - centerY));
                    if (maxDist < length) {
                        maxDist = length;
                        maxCoord = coordinate;
                    }
                }
                if (result instanceof Object) {
                    result.distance = maxDist - radius;
                    result.x0 = maxCoord.getOrdinate("X");
                    result.y0 = maxCoord.getOrdinate("Y");
                } else {
                    result = maxDist - radius;
                }
            }
            if (!edge && distance <= 0) { //圆内
                best = 0;
            } else {
                if (result instanceof Object) {
                    result.x1 = result.x1 + (result.x0 - result.x1) * radius / (distance + radius);
                    result.y1 = result.y1 + (result.y0 - result.y1) * radius / (distance + radius);

                    best = {
                        distance: distance,
                        x0: result.x0,
                        y0: result.y0,
                        x1: result.x1,
                        y1: result.y1
                    };
                } else {
                    best = distance;
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            if (details) {
                if (edge || (!edge && best.distance > 0)) {
                    best = {
                        distance: best.distance,
                        x0: best.x1,
                        y0: best.y1,
                        x1: best.x0,
                        y1: best.y0
                    };
                }
            }
        }
        return best;
    }

    /**
     * 获取几何体的缓冲区。缓冲区限于X-Y平面内，非三维空间中的缓冲区，（注意：缓冲距离请控制在合理范围，否则有可能导致结果和预期不符合）
     * @param {Number} dist 缓冲距离，一个正数，单位和地图单位相同，注意，缓冲半径过大可能出现重叠或岛洞
     * @param {String} endCap 端点类型。"ROUND"：圆角."FLAT":平角。默认"ROUND"
     * @param {Number} sideSign 缓冲模式。1：左缓冲，-1：右缓冲，0：双向缓冲。默认为0
     * @returns {hmap.geom.Polygon} 返回一个面状几何体
     */
    getBuffer(dist, endCap = "ROUND", sideSign = 0) {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero !");
        }
        let lineBuffer = new hmap.strategy.LineBuffer(this, dist, endCap, sideSign);
        return lineBuffer.build();
    }

    /**
     * 获取线的质心坐标。
     * @returns {hmap.basetype.Coordinate} 线的质心坐标。
     * @example
     * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,2));
     * let line = new hmap.geom.Line([point1,point2]);
     * line.getCentroid();
     */
    getCentroid() {
        let sumX = 0,
            sumY = 0,
            sumZ = 0;
        for (let point of this._pointArr) {
            sumX = sumX + point.getCoordinate().getOrdinate('X');
            sumY = sumY + point.getCoordinate().getOrdinate('Y');
            sumZ = sumZ + point.getCoordinate().getOrdinate('Z');
        }
        const x = sumX / this._pointArr.length,
            y = sumY / this._pointArr.length,
            z = sumZ / this._pointArr.length;
        return new hmap.basetype.Coordinate(x, y, z);
    }

    /**
     * 从构成几何体的所有点中，获取离传入坐标最近的一个点。传入坐标到多点距离都相等时，返回几何体的第一个点。
     * @param {hmap.basetype.Coordinate} coord 地理坐标实例。
     * @returns {hmap.geom.Point} 几何体上的一个点。
     */
    getClosestPoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        let minD = this._pointArr[0].getCoordinate().get3Dist(coord);
        let point = this._pointArr[0];
        const length = this._pointArr.length;
        for (let i = 0; i < length; i++) {
            const value = this._pointArr[i];
            const dist = value.getCoordinate().get3Dist(coord);
            if (dist < minD) {
                minD = dist;
                point = value;
            }
        }
        return point;
    }

    /**
     * 计算几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 返回几何体的地理范围。
     * @example
     * let extent = line.getExtent();
     */
    getExtent() {
        this.getBBox();
        return this._extent;
    }

    /**
     * 计算几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回三维包围盒。
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._pointsChanged = false;
            this._extent = this._bbox.getExtent();
        }
        return this._bbox;
    }

    /**
     * 获取几何体类型。
     * @returns {String} 几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.Line;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectLine2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectLine2D(geom, this);
            },
            'Line': () => {
                return hmap.strategy.Intersect.lineIntersectLine2D(this, geom);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.lineIntersectLine2D(this, geom);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(this, geom.toPolygon());
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.lineIntersectMultiLine2D(this, geom);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(this, geom.toPolygon());
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(this, geom.toPolygon());
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(this, geom);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.lineIntersectMultiPolygon2D(this, geom);
            },
            'Collection': () => {
                return geom.intersectsGeometry(this);
            }
        } [geom.getType()]();
    }

    /**
     * 自相交判断。
     * @return {Boolean} true表示自相交，false表示不自相交
     */
    isSelfIntersects() {
        let points = this._pointArr;
        let ptCount = points.length;
        if (ptCount <= 3) {
            return false;
        }
        for (let i = 3; i < ptCount; i++) {
            let seg1 = [points[i - 3].getCoordinate(), points[i - 2].getCoordinate()];
            for (let j = i; j < ptCount; j++) {
                let seg2 = [points[j - 1].getCoordinate(), points[j].getCoordinate()];
                if (hmap.strategy.Intersect.segmentIntersectSegment2D(seg1, seg2)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 几何体自身的拓扑关系是否有效。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid() {
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Line} 移动后的几何体。
     */
    moveByDelta(deltaX = 0, deltaY = 0, deltaZ = 0) {
        if (!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)) {
            throw new Error("parameter must be number!");
        }

        let oriCoord;
        for (let i = 0, len = this._pointArr.length; i < len; i++) {
            oriCoord = this._pointArr[i].getCoordinate();
            oriCoord.setOrdinate("X", oriCoord.getOrdinate("X") + deltaX);
            oriCoord.setOrdinate("Y", oriCoord.getOrdinate("Y") + deltaY);
            oriCoord.setOrdinate("Z", oriCoord.getOrdinate("Z") + deltaZ);
        }
        this._pointsChanged = true;
        this.getExtent();
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认值为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.Line} 旋转后的几何体。
     */
    rotate(axis, angle, center) {
        for (let i = 0, len = this._pointArr.length; i < len; i++) {
            this._pointArr[i].rotate(axis, angle, center);
        }
        this._pointsChanged = true;
        this.getExtent();
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Line} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     *         {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        if (!origin) {
            origin = this.getExtent().getCenter();
        }
        for (let i = 0, len = this._pointArr.length; i < len; i++) {
            this._pointArr[i].scale(xFactor, yFactor, zFactor, origin);
        }
        this._pointsChanged = true;
        this.getExtent();
        return this;
    }

    /**
     * 简化线几何体。在尽可能不改变原几何体形状的情况下，减少构成几何体的坐标数量。采用道格拉斯-普克算法。
     * 如果待简化的线几何体中点个数小于3，则不做任何处理。
     * @param {Number} tolerance 道格拉斯算法中简化所用的容差值，即:简化的参考值。容差值越大,构成几何体的坐标数量越少。容差值大于等于0。
     * @returns {hmap.geom.Line} 返回简化后的几何体。
     */
    simplify(tolerance) {
        const simplifiedCoords = this.getCoordSeq().simplify(tolerance).extractCoords();
        const simplifiedPoints = [];
        for (let i = 0; i < simplifiedCoords.length; i++) {
            simplifiedPoints.push(new hmap.geom.Point(simplifiedCoords[i]));
        }
        this._pointArr = simplifiedPoints;
        this._pointsChanged = true;
        return this;
    }

    /**
     * 拐点平滑，在拐点处进行平滑处理，输出一条新的线
     * @param {Number} tolerance 平滑度，小于1的数字
     * @return {hmap.geom.Line}
     * @private
     */
    smooth(tolerance = 0.5) {
        if (!Number.isFinite(tolerance) || tolerance > 1) {
            throw new Error("parameter 'tolerance' should be a Number not great than 1")
        }
        let coords = this.getCoordSeq().extractCoords();

        function richCoords(b, a, r) {
            const vector = {x: b.getOrdinate("X") - a.getOrdinate("X"), y: b.getOrdinate("Y") - a.getOrdinate("Y")};
            const length = Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
            const unit = {x: vector.x / length, y: vector.y / length};
            const x = a.getOrdinate("X") + unit.x * r / 35,
                y = a.getOrdinate("Y") + unit.y * r / 35;
            return new hmap.basetype.Coordinate(x, y);
        }

        let newArr = coords.slice(1).reduce((acc, p, i, coords) => {
            let next = coords[i + 1];
            let prev = acc[acc.length - 1];
            if (next && !(hmap.strategy.Topology.checkCollinear(prev, next, p) === 0)) {
                const before = richCoords(prev, p, tolerance);
                const after = richCoords(next, p, tolerance);
                const bezier3 = new hmap.geomext.BezierCurve2([new hmap.geom.Point(before), new hmap.geom.Point(p), new hmap.geom.Point(after)]);
                return acc.concat(bezier3.getCoordSeq().extractCoords())
            } else {
                return acc.concat(p)
            }
        }, [coords[0]]);
        return hmap.geom.Line.fromCoordSeq(new hmap.basetype.CoordSeq(newArr));

    }

    /**
     * 将一个线状几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Line} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this._pointArr.length; i < l; i++) {
            this._pointArr[i].transform(source, destination);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} rayLine 射线。
     * @param {Number} tolerance 拾取容差。
     * @return {Number} 如果要素到射线的距离小于容差则返回到特定相机点的地图距离，否则返回空。
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        let results = hmap.strategy.Intersect3D.lineToLine(this, ray._line,offset);
        let minDistance = Number.POSITIVE_INFINITY;
        for (let i = 0, len = results.length; i < len; i++) {
            let result = results[i];
            if (result && result.distance < tolerance) {
                let distanceToCamera = ray.distanceSquare(result.point);
                if (distanceToCamera < minDistance) {
                    minDistance = distanceToCamera;
                }
            }
        }
        if (Number.isFinite(minDistance)) {
            return minDistance;
        }
        return null;
    }


    /*------------以下为私有方法-------------*/
    /**
     * 根据coord更新Line的extent
     * @param coord
     * @private
     */
    _extendExtent(coord) {
        const l = this._extent.getLeft() < coord.getOrdinate("X") ? this._extent.getLeft() : coord.getOrdinate("X");
        const r = this._extent.getRight() > coord.getOrdinate("X") ? this._extent.getRight() : coord.getOrdinate("X");
        const t = this._extent.getTop() > coord.getOrdinate("Y") ? this._extent.getTop() : coord.getOrdinate("Y");
        const b = this._extent.getBottom() < coord.getOrdinate("Y") ? this._extent.getBottom() : coord.getOrdinate("Y");

        this._extent.setLeft(l);
        this._extent.setRight(r);
        this._extent.setTop(t);
        this._extent.setBottom(b);
    }


    /**
     * 转换为Bezier曲线。
     * 控制点的个数是线的节点数。起止点为线的首末结点，如果线有N个结点，那么方法将返回一条Bezier二次曲线
     * @param {Number} density
     * @returns {hmap.geom.Line} Bezier曲线

     toBezierLine(density) {
        if (!density || !Number.isNaN(density)) {
            density = 100;
        }
        let coordSeq = this.getCoordSeq();
        //n次曲线
        const n = coordSeq.getCoordCount() - 1;
        //n的阶乘
        const njc = hmap.util.ArithMetic.del(n);

        //曲线上的总的点数
        let bPointArr = [];
        for (let t = 0; t < 1; t = t + 1 / density) {
            //计算第k个点的坐标
            for (let k = 0; k < n; k++) {
                //k与(n-k)的阶乘
                const kjc = hmap.util.ArithMetic.del(k);
                const nkjc = hmap.util.ArithMetic.del(n - k);
                //多项式系数
                const factor = njc / (kjc * nkjc);
                //曲线上的第N个点的系数
                const pfactor = factor * Math.pow(t, k) * Math.pow(1 - t, n - k);
                //第个点坐标
                let coordN = coordSeq.extractCoords(k, 1)[0];
                const xn = pfactor * coordN.getOrdinate("X"), yn = pfactor * coordN.getOrdinate("Y"),
                    zn = pfactor * coordN.getOrdinate("Z");
                coordN.setOrdinate("X", xn);
                coordN.setOrdinate("Y", yn);
                coordN.setOrdinate("Z", zn);
                const point = new hmap.geom.Point(coordN);
                bPointArr.push(point);
            }
        }
        //由点组线
        return new hmap.geom.Line(bPointArr);
    }*/

    /**
     * 计算多点几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回多点几何体的地理范围。
     * @private
     */
    _calculateBBox() {
        let length = this._pointArr.length;
        if (length === 0) {
            return new hmap.basetype.BBox(0, 0, 0, 0, 0, 0);
        }
        let coordinate = this._pointArr[0].getCoordinate();
        let left = coordinate.getOrdinate("X"),
            right = coordinate.getOrdinate("X"),
            back = coordinate.getOrdinate("Y"),
            front = coordinate.getOrdinate("Y"),
            up = coordinate.getOrdinate('Z'),
            bottom = coordinate.getOrdinate('Z');
        for (let i = 1; i < length; i++) {
            coordinate = this._pointArr[i].getCoordinate();
            let x = coordinate.getOrdinate("X"),
                y = coordinate.getOrdinate("Y"),
                z = coordinate.getOrdinate('Z');
            left = Math.min(left, x);
            right = Math.max(right, x);
            front = Math.min(front, y);
            back = Math.max(back, y);
            up = Math.max(up, z);
            bottom = Math.min(bottom, z);
        }
        return new hmap.basetype.BBox(left, front, bottom, right, back, up);
    }

    /**
     * 等分折线
     * 注意，原理是相似三角形的计算得到的等分点，投影坐标系直接计算，地理坐标系先投影在计算，最后再转为地理坐标
     * @param {Number} parts 等分份数,必须为正数
     * @param {Number} srid 线段的坐标系（地理坐标系还是投影坐标系）,默认为4326
     * @private
     * @returns {Array<hmap.geom.Line>} 返回等分之后的line数组。
     */
    divide(parts, srid = 4326) {
        if (parts === 1) {
            return [this];
        }
        const crs = hmap.proj.Transformer.CrsList['EPSG' + srid];
        const crsType = crs.getCrsType();
        let coordSeq = this.clone().getCoordSeq();
        const coordSeqClone = coordSeq.clone();
        const num = coordSeq.getCoordCount();
        let transformLine;
        //将地理坐标投影到3857坐标
        if (crsType === 'GeoCRS') {
            let coordArr = coordSeq.extractCoords(0, num);
            coordArr = coordArr.map(coor => {
                return hmap.proj.Transformer.transform(coor, srid, 3857);
            });
            let pointArr = coordArr.map(coor => {
                return new hmap.geom.Point(coor);
            })
            transformLine = new hmap.geom.Line(pointArr);
            coordSeq = new hmap.basetype.CoordSeq(coordArr);
        } else {
            transformLine = this;
        }
        const step = transformLine.getLength(3857) / parts;
        //定义临时变量记录结果点离上临时点的距离
        let cur_span = step;
        let tempLine;
        let startCoor = coordSeq.getCoordinate(0);
        let lineArr = [];
        let tempLoopCoorSeq = new hmap.basetype.CoordSeq([startCoor]);
        let isFinished = false;
        let ignoreTransformIndex = [0];
        for (let i = 1; i < num && !isFinished; i++) {
            const tempCoor = coordSeq.getCoordinate(i);
            const x2 = tempCoor.getOrdinate('X');
            const y2 = tempCoor.getOrdinate('Y');
            const z2 = tempCoor.getOrdinate('Z');
            while (true) {
                if (parts === 1) {
                    //最后一段直接把线上剩余的点都取到即可(从当前的i位开始到最后)
                    const count = coordSeqClone.getCoordCount();
                    for (let j = i; j < count; j++) {
                        ignoreTransformIndex.push(tempLoopCoorSeq.getCoordCount());
                        tempLoopCoorSeq.addCoord(coordSeqClone.getCoordinate(j));
                    }
                    lineArr.push(hmap.geom.Line.fromCoordSeq(this._transformCoorseq(tempLoopCoorSeq, 3857, srid, ignoreTransformIndex)));
                    isFinished = true;
                    break;
                }
                const p1 = new hmap.geom.Point(startCoor);
                const p2 = new hmap.geom.Point(tempCoor);
                tempLine = new hmap.geom.Line([p1, p2]);
                const cur_distance = tempLine.getLength(3857);

                //这里设置一个容差0.2米  如果距离在这个范围之后就认为是结果点
                if (Math.abs(cur_distance - cur_span) < 0.2) {
                    //tempCoor就是一个分割点
                    ignoreTransformIndex.push(tempLoopCoorSeq.getCoordCount());
                    tempLoopCoorSeq.addCoord(coordSeqClone.getCoordinate(i));
                    lineArr.push(hmap.geom.Line.fromCoordSeq(this._transformCoorseq(tempLoopCoorSeq.clone(), 3857, srid, ignoreTransformIndex)));
                    ignoreTransformIndex = [];
                    tempLoopCoorSeq.remove(0, tempLoopCoorSeq.getCoordCount() - 1);
                    parts--;
                    break;
                } else if (cur_distance > cur_span) {
                    const x1 = startCoor.getOrdinate('X');
                    const y1 = startCoor.getOrdinate('Y');
                    const z1 = startCoor.getOrdinate('Z');
                    const resX = (x2 - x1) * cur_span / cur_distance + x1;
                    const resY = (y2 - y1) * cur_span / cur_distance + y1;
                    const resZ = (z2 - z1) * cur_span / cur_distance + z1;
                    const resCoor = new hmap.basetype.Coordinate(resX, resY, resZ);
                    tempLoopCoorSeq.addCoord(resCoor);
                    lineArr.push(hmap.geom.Line.fromCoordSeq(this._transformCoorseq(tempLoopCoorSeq.clone(), 3857, srid, ignoreTransformIndex)));
                    ignoreTransformIndex = [];
                    tempLoopCoorSeq.remove(0, tempLoopCoorSeq.getCoordCount() - 1);
                    parts--;
                    startCoor = resCoor;
                    //找到结果点之后还原步长
                    cur_span = step
                } else {
                    //说明结果点没有落在startCoor 和 tempCoor 两点之间，跳出while循环，进入for循环从下一个段中找
                    startCoor = tempCoor;

                    ignoreTransformIndex.push(tempLoopCoorSeq.getCoordCount());
                    tempLoopCoorSeq.addCoord(coordSeqClone.getCoordinate(i));
                    cur_span = cur_span - cur_distance;
                    break;
                }
            }
        }
        //将第一条线的起点还原为原始line的起点
        lineArr[0].getCoordSeq().getCoordinate(0).setOrdinate('X', coordSeqClone.getCoordinate(0).getOrdinate('X'));
        lineArr[0].getCoordSeq().getCoordinate(0).setOrdinate('Y', coordSeqClone.getCoordinate(0).getOrdinate('Y'));
        lineArr[0].getCoordSeq().getCoordinate(0).setOrdinate('Z', coordSeqClone.getCoordinate(0).getOrdinate('Z'));
        return lineArr;
    }

    /**
     * 将一个坐标序列做整体的坐标转换
     * @param {hmap.basetype.CoordSeq} coordSeq 要转换的坐标
     * @param {String|Number} source 源坐标系
     * @param {String|Number} dest 目标坐标系
     * @param {Array<Number>} ignoreIndexs 要忽略的坐标的index
     * @returns {hmap.basetype.CoordSeq} 坐标系转换之后的坐标序列
     * @private
     */
    _transformCoorseq(coordSeq, source, dest, ignoreIndexs) {
        if (typeof source === "number" || typeof source === 'string') {
            const sourceCrs = hmap.proj.Transformer.CrsList['EPSG' + source];
            if (sourceCrs === undefined) {
                throw new Error(source + " is not in hmap.proj.Transformer.CrsList,please add first.");
            }
        }
        if (typeof dest === "number" || typeof dest === 'string') {
            const destCrs = hmap.proj.Transformer.CrsList['EPSG' + dest];
            if (destCrs === undefined) {
                throw new Error(dest + ' is not in hmap.proj.Transformer.CrsList,please add first.');
            }
        }
        var corrdCount = coordSeq.getCoordCount();
        let coordArr = coordSeq.extractCoords(0, corrdCount);
        coordArr = coordArr.map((coor, index) => {
            if (ignoreIndexs.indexOf(index) !== -1) {
                return coor;
            } else {
                return hmap.proj.Transformer.transform(coor, source, dest);
            }
        });
        return new hmap.basetype.CoordSeq(coordArr);
    }

    /**
     * 提取构成线的点。按照前闭后开的原则提取，从开始索引处提取点，到结束索引前一位
     * @param start {Number} 开始索引
     * @param end {Number} 结束索引
     * @private
     */
    getPoints(start=0, end=this._pointArr.length) {
        return this._pointArr.slice(start, end);
    }

    /**
     * 把传入的点根据指定索引位置追加到线的点数组中。
     * 1.如果index不传或者大于线的点数组长度，点将被追加到线的点数组末尾；
     * 2.如果index小于0，点将被添加到点数组的起始位置。
     * @param point {hmap.geom.Point}
     * @param index {Number}
     * @private
     */
    addPoints(points, index=this._pointArr.length) {
        if (index < 0) {
            this._pointArr.unshift(...points);
        }
        else if (index < this._pointArr.length) {
            this._pointArr.splice(index, 0, ...points);
        }
        else {
            this._pointArr.push(...points);
        }
    }
}
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 闭合线，也称线环。相对于普通线的特别之处在于，该对象是闭合的（首尾坐标相同）。
 * @type {hmap.geom.LinearRing}
 * @extends hmap.geom.Line
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let coord3 = new hmap.basetype.Coordinate(122,32,0);
 * let point1 = new hmap.geom.Point(coord1);
 * let point2 = new hmap.geom.Point(coord2);
 * let point3 = new hmap.geom.Point(coord3);
 * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
 */
hmap.geom.LinearRing = class extends hmap.geom.Line {
    /**
     * 构造一个线环。其参数坐标数组中如果首尾两点不同，则构造函数会获取第一个点，追加到数组末尾，以保证形成闭环。
     * 传入的数组长度如果少于三，会抛出异常。
     * 如果传入的数组长度为三，且第一个点的坐标和最后一个点的坐标相同，将构造一个拓扑错误的线环。
     * @param  {Array<hmap.geom.Point>} points 点数组
     */
    constructor(points) {
        if (!points) {
            return null;
        }
        const len = points.length;
        if (len < 3) {
            throw new Error("invalid LinearRing,the num of points less than 3");
        }
        const fp = points[0].getCoordinate();
        const lp = points[len-1].getCoordinate();
        if (!fp.equals(lp)){
            points.push(points[0].clone());
        }
        super(points);
        this.CLASS_NAME="hmap.geom.LinearRing";
        // this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 追加坐标到线环的坐标数组中。
     * 1.如果索引值大于线的坐标数据长度，那么新坐标将被追加到线的末尾；
     * 2.如果索引值小于0时，新坐标被添加到坐标数组的第一个位置之前。
     * 3.如果不传入索引值，则自动追加到线的末尾。
     * 4.如果新坐标加入到了线的末尾，该方法会自动再添加第一个点，以确保闭合。
     * @param {hmap.basetype.Coordinate} coord 添加的坐标。
     * @param {Number} index 指定的索引值。
     * @returns {Number} 增加的坐标个数。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let coord4 = new hmap.basetype.Coordinate(120,30,0);
     * let result = linearRing.addCoord(coord4, 2);//result=0
     */
    addCoord(coord, index) {
        const len = this._pointArr.length;
        if (index > len-1 || index === undefined) {
            index = len-1;
        }else if(index<0){
            index=0;
        }
        let newPoint = new hmap.geom.Point(coord);
        //坐标相同的话,不进行插入
        if(index===len-1){
            if(newPoint.equals(this._pointArr[index])){
                return 0;
            }
        }
        this._pointArr.splice(index,0,newPoint);
        let fp = this._pointArr[0].getCoordinate();
        let lp =this._pointArr[len-1].getCoordinate();
        if (!fp.equals(lp)){
            this._pointArr[len]=this._pointArr[0];
        }
        this._pointsChanged = true;
        return 1;
    }

    /**
     * 复制一个线环对象。
     * @returns {hmap.geom.LinearRing} 新的线环对象。
     * @example
     * let newLinearRing = linearRing.clone();
     */
    clone() {
        const newPoints = [...this._pointArr].map(point=>point.clone());
        return new hmap.geom.LinearRing(newPoints);
    }

    /**
     * 判断当前线环围成的区域内是否包含了给定地理坐标。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @return {Boolean} true表示包含，false表示不包含。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let coord4 = new hmap.basetype.Coordinate(120,30,0);
     * let result = linearRing.containsCoord(coord4);//result=true
     */
    containsCoord(coord){
        const polygon = new hmap.geom.Polygon([this]);
        return hmap.strategy.Intersect.pointIntersectPolygon2D(new hmap.geom.Point(coord),polygon);
    }

    /**
     * 从坐标序列构建一个线环,如果坐标序列参数中的坐标若首尾坐标不同，则会将第一个点添加到坐标序列末尾以构成闭环
     * @param {hmap.basetype.CoordSeq} coordSeq 坐标序列。
     * @return {hmap.geom.LinearRing} 由坐标序列构建的线环。
     * @throws {TypeError} 当坐标序列的坐标少于3，会抛出异常。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2,coord3]);
     * let result = hmap.geom.LinearRing.fromCoordSeq(coordSeq);
     */
    static fromCoordSeq(coordSeq){
        if(!coordSeq instanceof hmap.basetype.CoordSeq){
            throw new Error('parameter "coordSeq" must be instance of hmap.basetype.CoordSeq')
        }
        let points=coordSeq.extractCoords().map(coord=>{
            return new hmap.geom.Point(coord);
        });
        return new hmap.geom.LinearRing(points);
    }

    /**
     * 从几何体开始的位置，按照比例因子匹配最接近索引的坐标。若比例因子对应的位置正好在两个点的中间，则返回后面的点。
     * @param {Number} fraction 比例因子，范围为0~1。0表示起点，1表示终点。
     * @returns {hmap.basetype.Coordinate} 匹配到的坐标。
     * @example
     * let result = linearRing.getCoordinateAt(0.4);
     */
    getCoordinateAt(fraction) {
        return super.getCoordinateAt(fraction);
    }

    /**
     * 计算线环的三维长度。每个线段长度的计算：根据每截线段在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。默认4326（坐标系为WGS84）。
     * @returns {Number} 线环的三维长度，单位是米。
     * @example
     * let result = linearRing.getLength(4326);
     */
    getLength(srid = 4326) {
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     * 计算线环所围成区域的面积。线环的面积代表的是多边形的面积，该多边形以该线环为多边形外环。
     * @return {Number} 线环围成的面积。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let result = linearRing.getArea();//result=1
     */
    getArea() {
        return hmap.strategy.EarCut.polygonArea([this.getCoordSeq()]);
    }

    /**
     * 提取几何体的坐标序列。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的Coordinate；
     * 3.如果startIndex与endIndex参数为空，返回所有Coordinate。
     * 4.当startIndex大于等于endIndex，返回空数组。
     * @param {Number} startIndex 起始索引。如果不传，默认是0。
     * @param {Number} endIndex 结束索引。如果不传，默认是坐标序列长度值。
     * @returns {hmap.basetype.CoordSeq} 坐标序列。
     * @example
     * let result = linearRing.getCoordSeq(0,1);
     */
    getCoordSeq(startIndex = 0, endIndex = this._pointArr.length) {
        return super.getCoordSeq(startIndex,endIndex);
    }

    /**
     * 计算线环的质心。线环的质心代表的是多边形的质心，该多边形以该线环为多边形外环。
     * @returns {hmap.basetype.Coordinate} 质心地理坐标。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let result = linearRing.getCentroid();//result=new hmap.basetype.Coordinate(121,30.333333,0)
     */
    getCentroid(){
        return new hmap.basetype.Coordinate(...hmap.strategy.EarCut.polygonCentroid([this.getCoordSeq()]));
    }

    /**
     * 删除线环几何体上的一个坐标。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @return {Number} 删除个数。因构成线环的点数不能少于3，即删除后线环点数小于3，则删除失败，删除个数为0。
     * @throws {TypeError} 当入参coord不是一个地理坐标时，抛出对象类型异常。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let coord4 = new hmap.basetype.Coordinate(120,30,0);
     * let result = linearRing.removeCoord(coord4);//result=0
     */
    removeCoord(coord){
        let removeCount=0;
        if(!(coord instanceof hmap.basetype.Coordinate)){
            throw new TypeError("parameter is not a Coordinate!");
        }
        let points=[...this._pointArr];
        let oriLen=this._pointArr.length;
        let point = new hmap.geom.Point(coord);
        for(let i=oriLen-1;i>=0;i--){
            if(point.equals(this._pointArr[i])){
                //如果删除的是闭合点
                if(i===oriLen-1){
                    this._pointArr.splice(0,1,this._pointArr[i-1]);
                    this._pointArr.pop();
                    removeCount++;
                }else{
                    this._pointArr.splice(i,1);
                    removeCount++;
                }
            }
        }
        this._pointsChanged = true;
        if(this._pointArr.length<3){
            this._pointArr=[...points];
            return 0;
        }
        return removeCount;
    }

    /**
     * 获取几何体类型。
     * @returns {String} 几何体类型。
     * @example
     * let type = linearRing.getType();
     */
    getType(){
        return hmap.geom.GeometryType.LinearRing;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid(){
    }

    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * linearRing.destroy();
     * let result = linearRing.CLASS_NAME;//result=undefined即linearRing对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options = {}) {
        let best = super.distanceTo(geometry, options);
        //删除说明，线环应作为线进行处理，不存在包含其他几何体这个说法
        return best;
    }

    /**
     * 将线环转化为多边形。
     * @returns {hmap.geom.Polygon} 多边形。
     */
    toPolygon() {
        return new hmap.geom.Polygon([this]);
    }

    /**
     * 简化线环。在尽可能不改变原几何体形状的情况下，减少构成线环的坐标数量。采用道格拉斯-普克算法。
     * 线环中应至少包含三个点，若点个数小于3，则不做任何处理。
     * @param {Number} tolerance 道格拉斯算法中简化所用的容差值，即:简化的参考值。容差值越大,构成几何体的坐标数量越少。容差值大于等于0。
     * @returns {hmap.geom.LinearRing} 返回简化后的线环。
     */
    simplify(tolerance) {
        const simplifiedCoords = this.getCoordSeq().simplify(tolerance, true).extractCoords();
        const simplifiedPoints = [];
        for (let i = 0; i < simplifiedCoords.length; i++) {
            simplifiedPoints.push(new hmap.geom.Point(simplifiedCoords[i]));
        }
        this._pointArr = simplifiedPoints;
        this._pointsChanged = true;
        return this;
    }

    /**
     * 射线拾取
     * @param {hmap.stragey.Raycaster} rayLine 射线。
     * @param {Number} tolerance 拾取容差。
     * @return {Number} 返回到特定相机点的地图距离。
     * @private
     */
    intersectRay(ray, tolerance) {
        let results = hmap.strategy.Intersect3D.lineToLine(this, ray._line);
        let minDistance = Number.POSITIVE_INFINITY;
        for (let i = 0, len = results.length; i < len; i++) {
            let result = results[i];
            if (result && result.distance < tolerance) {
                let distanceToCamera = ray.distanceSquare(result.point);
                if (distanceToCamera < minDistance) {
                    minDistance = distanceToCamera;
                }
            }
        }
        if (Number.isFinite(minDistance)) {
            return minDistance;
        }
        return null;
    }
    /**
     * 获取线环的缓冲区。缓冲区限于X-Y平面内，非三维空间中的缓冲区。（注意：缓冲距离请控制在合理范围，否则有可能导致结果和预期不符合）
     * @param {Number} dist 缓冲距离，一个正数，单位和地图单位相同。注意，缓冲半径过大可能出现重叠或岛洞
     * @param {String} sideSign 缓冲模式。1：左缓冲，-1：右缓冲，0：双向缓冲。默认为0
     * @returns {hmap.geom.Polygon} 返回一个面状几何体
     */
    getBuffer(dist,sideSign = 0) {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero!");
        }
        let lineBuffer = new hmap.strategy.LineBuffer(this, dist, "ROUND", sideSign);
        return lineBuffer.build();
    }

    /**
     * 计算线环的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 返回线环的地理范围。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point2 = new hmap.geom.Point(coord2);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let extent = linearRing.getExtent();
     */
    getExtent() {
        return super.getExtent();
    }

    /**
     * 遍历并处理当前线环中的所有线段。线段（segment）是指两端都有端点，不可延伸的线，有别于直线、射线。
     * @param {Function} callback 对线段进行的操作。参数为包含线段两个端点的{@link hmap.geom.Line}。
     * @private
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(123,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let result = [];
     * linearRing.forEachSegment(function(value){//返回构成线环的每一条线段
     *      result.push(value);
     * });
     */
    forEachSegment(callback){
        super.forEachSegment(callback);
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.LinearRing} 移动后的线环几何体。
     */
    moveByDelta(deltaX = 0, deltaY = 0, deltaZ = 0) {
        return super.moveByDelta(deltaX,deltaY,deltaZ);
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认值为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.LinearRing} 旋转后的几何体。
     */
    rotate(axis, angle, center) {
        return super.rotate(axis, angle, center);
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.LinearRing} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        return  super.scale(xFactor, yFactor, zFactor, origin);
    }

    /**
     * 自相交判断。
     * @return {Boolean} true表示自相交，false表示不自相交
     */
    isSelfIntersects() {
        let points = [],
            ptCount = this._pointArr.length - 1;
        if (ptCount <= 3) {
            return false;
        }
        for (let i = 0; i < ptCount; i++) {
            points.push(this._pointArr[i])
        }
        for (let i = 3; i < ptCount; i++) {
            let seg1 = [points[i - 3].getCoordinate(), points[i - 2].getCoordinate()];
            for (let j = i; j < ptCount; j++) {
                let seg2 = [points[j - 1].getCoordinate(), points[j].getCoordinate()];
                if (hmap.strategy.Intersect.segmentIntersectSegment2D(seg1, seg2)) {
                    return true;
                }
            }
        }
        return false;
    }
};

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 多边形即面状几何体。即:由线环围成的区域。
 * 当多边形由多个线环构成时，第一个线环默认是外边界，其他线环默认是内边界。
 * 当在第一个线环围成的区域内，包含其他线环时，面状几何体表现为环状的几何体，即岛洞。
 * 1.多边形包含一个区域(称为其内部)，该区域总是有一个可测量的面积。
 * 2.构成多边形的线段只在它们的顶点处相交。即:恰好两条边在每个顶点相交。
 * 3.边的数量总是等于顶点的数量。
 * @type {hmap.geom.Polygon}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let coord3 = new hmap.basetype.Coordinate(122,32,0);
 * let coord4 = new hmap.basetype.Coordinate(123,33,0);
 * let p1 =  new hmap.geom.Point(coord1);
 * let p2 =  new hmap.geom.Point(coord2);
 * let p3 =  new hmap.geom.Point(coord3);
 * let p4 =  new hmap.geom.Point(coord4);
 * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
 * let polygon = new hmap.geom.Polygon([linearRing]);
 */
hmap.geom.Polygon = class extends hmap.geom.Geometry {
    /**
     * 构造一个面状几何体。
     * @param {Array<hmap.geom.LinearRing>} linearRings 线环数组。
     */
    constructor(linearRings) {
        let flag = linearRings instanceof Array && linearRings.length > 0;
        if (!flag) {
            throw new TypeError('Parameter "linearRing" is not an Array or contains no LinearRing!');
        } else {
            super();
            this.lineRingArr = linearRings;//级成多边形的线环
        }

        this.CLASS_NAME = "hmap.geom.Polygon";
    }

    /**
     * 把一个线环追加到面状几何体的线环数组中。
     * @param {hmap.geom.LinearRing} linearRing 线环。
     * @returns {Boolean} true表示添加成功，false表示添加失败。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing1 = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let linearRing2 = new hmap.geom.LinearRing([p2,p1,p4,p3]);
     * let polygon = new hmap.geom.Polygon([linearRing1]);
     * let result = polygon.appendLinearRing(linearRing2);//result=true
     */
    appendLinearRing(linearRing) {
        let flag = linearRing instanceof hmap.geom.LinearRing;
        if (flag) {
            this.lineRingArr.push(linearRing);
        }
        return flag;
    }

    /**
     * 创建规则的多边形。
     * 该方法可以创建出正三角形、正方形、正五边形、正六边形、正N边形；
     * 一般地，当边数达到20以上时，所创建的多边形可以近似地表示一个圆。
     * @param {hmap.basetype.Coordinate} origin 多边形的中心点的地理坐标。
     * @param {Number} radius 半径，地图单位。点与中心点连线为半径
     * @param {Number} sides 边数。边数可以确定多边形的形态。例如正方形，四条边，六边形。20条边可以近似表示一个圆。
     * @param {Number} rotation 多边形的起始顶点与中心点的连线和x轴正方向形成的夹角（origin即为坐标原点），夹角逆时针方向为正，
     * 单位是角度。如果是0度，默认是x轴正方向开始创建多边形。
     * @returns {hmap.geom.Polygon} 一个多边形对象。当边数小于3时返回null。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let result = hmap.geom.Polygon.createRegularPolygon(coord,30,4,20);
     */
    static createRegularPolygon(origin, radius, sides, rotation) {
        if (!Number.isFinite(radius) || !Number.isFinite(sides) || !Number.isFinite(rotation)) {
            throw 'Parameter "radius", "side" and "rotation" must be type of Number!';
        }
        if (!(origin instanceof hmap.basetype.Coordinate)) {
            throw 'Parameter "origin" must be type of hmap.basetype.Coordinate!';
        }

        if (sides < 3) {
            return null;
        }
        const centerAngle = 2.0 * Math.PI / sides; //两个相邻顶点与中心点连接所形成的夹角
        const points = [];
        const originX = origin.getOrdinate("X");
        const originY = origin.getOrdinate("Y");
        for (let i = 0; i < sides; i++) {
            const nthAngle = centerAngle * i + rotation * Math.PI / 180;
            const x = radius * Math.cos(nthAngle) + originX;
            const y = radius * Math.sin(nthAngle) + originY;
            points[i] = new hmap.geom.Point(new hmap.basetype.Coordinate(x, y));
        }
        points.push(points[0]);
        const linearRing = new hmap.geom.LinearRing(points);
        return new hmap.geom.Polygon([linearRing]);
    }

    /**
     * 从一个圆形几何体生成一个多边形几何体对象。
     * @param {hmap.geom.Circle} circle 圆几何体对象
     * @returns {hmap.geom.Polygon|Null} 若生成成功，返回一个多边形对象；若生成失败，则返回null。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = hmap.geom.Polygon.fromCircle(circle);
     */
    static fromCircle(circle) {
        let flag = circle instanceof hmap.geom.Circle;
        return flag ? circle.toPolygon() : null;
    }

    /**
     * 从一个范围对象生成一个多边形。
     * @param {hmap.basetype.Extent} ext 范围。
     * @returns {hmap.geom.Polygon} 多边形对象，若生成失败则返回null。
     * @example
     * let extent = new hmap.basetype.Extent(120.1,30.07,120.7,30.3);
     * let result = hmap.geom.Polygon.fromExtent(extent);
     */
    static fromExtent(ext) {
        let flag = ext instanceof hmap.basetype.Extent;
        return flag ? new hmap.geom.Polygon([ext.toLinearRing()]) : null;
    }

    /**
     * （暂不启用）从一个矩形几何体创建一个多边形。
     * @param {hmap.geom.Rectangle} rect 一个矩形几何体。
     * @returns {hmap.geom.Polygon} 多边形对象，若生成失败则返回null。
     * @private
     */
    static fromRectangle(rect) {
        let flag = rect instanceof hmap.geom.Rectangle;
        return flag ? rect.toLinearRing() : null;
    }

    /**
     * 检查当前多边形的凸凹形。当前版本仅检测外环的凸凹形，对具有岛洞的多边形无效。
     * @returns {Boolean} 返回true表示多边形为凸形；返回false表示多边形为凹形。
     * @private
     */
    isConvexity() {
        let flag = true;
        //取第一个坐标序列
        const coordSeq = this.getCoordSeqs(0, 1);
        const count = coordSeq.getCoordCount();
        for (let i = 0; i < count - 3; i++) {
            const coordThird = coordSeq.getCoordinate(i + 2);
            const coordSecond = coordSeq.getCoordinate(i + 1);
            const coordFirst = coordSeq.getCoordinate(i);
            //前面的向量
            const x1 = coordSecond.getOrdinate("X") - coordFirst.getOrdinate("X");
            const y1 = coordSecond.getOrdinate("Y") - coordFirst.getOrdinate("Y");
            const z1 = coordSecond.getOrdinate("Z") - coordFirst.getOrdinate("Z");
            const firstVec = new hmap.util.Vector3(x1, y1, z1);

            //后面的向量
            const x2 = coordThird.getOrdinate("X") - coordSecond.getOrdinate("X");
            const y2 = coordThird.getOrdinate("Y") - coordSecond.getOrdinate("Y");
            const z2 = coordThird.getOrdinate("Z") - coordSecond.getOrdinate("Z");
            const secondVec = new hmap.util.Vector3(x2, y2, z2);
            //求两个向量的夹角，如果大于180，则一定是凹多边形
            const angle = firstVec.rotateAngle(secondVec);
            if (angle > 180) {
                return false;
            }
        }
        return flag;
    }

    /**
     * 把当前多边形转换成凸多边形。当前版本仅对外环所构成的多边形进行转换，对具有岛洞的多边形无效。
     * @returns {Array<hmap.geom.Polygon>} 凸多边形数组。
     * @private
     */
    toConvexPolys() {
        let convexPolyArr = [];  //凸多边形构成的数组
        //首先判断当前多边形的凸性,如果是凸包，则直接返回，否则进行拆解
        const flag = this.isConvexity();
        if (flag === true) {
            convexPolyArr.push(this);
        } else {
            let arr = this._splitConcave();
            for (let i = 0; i < arr.length; i++) {
                convexPolyArr.push(...arr[i].toConvexPolys());
            }
        }
        return convexPolyArr;
    }

    /**
     * 把凹多边形拆解成凸多边形。仅拆最外环。把一个凹多边形拆解为凸多形数组。
     * 如果当前多边形是凸性的，那么返回的数组中只有它自己。
     * @private
     */
    _splitConcave() {
        let polyArr = [];  //凸多边形构成的数组
        //取第一个线环
        const outerRing = this.getLinearRing(0);
        //对第一个线环去重
        let coordSeq = outerRing.getCoordSeq().removeRepeat();
        //线环中的坐标按X分量，从小到大排序
        let sortedSeq = coordSeq.sort('X', 'ASC');


        //最左边的一个点与前后两个点构成一个三角形
        const coordMidIndex = coordSeq.containsCoord(sortedSeq.getCoordinate(0));  //最左边的点的索引
        const firstIndex = coordMidIndex - 1, secondIndex = coordMidIndex + 1;   //前后两个点的索引
        const midCoord = coordSeq.getCoordinate(coordMidIndex);
        const firstCoord = coordSeq.getCoordinate(firstIndex);
        const secondCoord = coordSeq.getCoordinate(secondIndex);
        const triangleCoords = [firstCoord, midCoord, secondCoord];
        const triangleRing = hmap.basetype.CoordSeq.fromCoords(triangleCoords);

        //检测除以上三个点之外，剩余的坐标有没有跟三角开相交。首先找出最左边的坐标
        let lastCoord = sortedSeq.getCoordinate(1);
        if (firstCoord.equals(sortedSeq[1]) || secondCoord.equals(lastCoord)) {
            lastCoord = sortedSeq.getCoordinate(2);
        }
        //相交检测
        const flag = triangleRing.containsCoord(lastCoord);
        if (flag) {
            //如果相交，说明本次拆分仍有凹多边形，最左边的点与交点相连，将原多边形划分为两个多边形。

            //分割后的多边形索引分界
            const beginIndex = coordMidIndex, endIndex = coordSeq.containsCoord(lastCoord);
            const frontCoords = coordSeq.extractCoords(beginIndex, endIndex - beginIndex);
            //第一个多边形
            const frontRing = hmap.geom.LinearRing.fromCoords(frontCoords);
            const fpoly = new hmap.geom.Polygon([frontRing]);
            polyArr.push(fpoly);
            //剩下的点组成一个多边形
            const otherCoords = [];
            for (let i = endIndex; i < coordSeq.getCoordCount(); i++) {
                otherCoords.push(coordSeq.getCoordinate(i));
            }
            for (let m = 0; m < begin; m++) {
                otherCoords.push(coordSeq.getCoordinate(m));
            }
            const otrherRing = hmap.geom.LinearRing.fromCoords(otherCoords);
            const spoly = new hmap.geom.Polygon([otrherRing]);
            polyArr.push(spoly);
        } else {
            //如果不相交，则本次分割是成功的，首先把割好的三角形加入的凸多形中。然后再拆分出两个多边形
            const trianglePoly = new hmap.geom.Polygon([triangleRing]);
            polyArr.push(trianglePoly);
            //剩下的点组成一个多边形
            coordSeq = coordSeq.remove(coordMidIndex, 1);
            const otherRing = hmap.geom.LinearRing.fromCoordSeq(coordSeq);
            const otherPoly = new hmap.geom.Polygon([otherRing]);
            polyArr.push(otherPoly);
        }
        return polyArr;
    }

    /**
     * 计算面状几何体的面积。
     * @returns {Number} 几何体的面积，面积单位是地图单位的平方。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * let result = polygon.getArea();//result=3
     */
    getArea() {
        return hmap.strategy.EarCut.polygonArea(this.getCoordSeqs());
    }

    /**
     * 提取多边形的坐标序列数组。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标序列。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的CoordSeq；
     * 3.如果startIndex与endIndex参数为空，返回所有CoordSeq。
     * 4.当startIndex大于等于endIndex，返回空数组。
     * @param {Number} startIndex 起始索引。如果不传，默认是0。
     * @param {Number} endIndex 结束索引。如果不传，默认是坐标序列数组长度。
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * let result = polygon.getCoordSeqs();
     */
    getCoordSeqs(startIndex = 0, endIndex = this.lineRingArr.length) {
        if (!Number.isFinite(startIndex) || !Number.isFinite(endIndex)) {
            throw new Error("the parameters is not a number");
        }
        const len = this.lineRingArr.length;
        startIndex = (startIndex <= 0) ? 0 : Number.parseInt(startIndex);
        endIndex = (endIndex >= len) ? len : Number.parseInt(endIndex);

        if (startIndex >= endIndex) {
            return [];
        }

        let arr = [];
        for (let i = startIndex; i < endIndex; i++) {
            arr.push(this.lineRingArr[i].getCoordSeq());
        }
        return arr;
    }

    /**
     * 获取第n个线环。
     * @param {Number} n 线环的索引,一个整数数值。当索引越界时，返回null。
     * @returns {hmap.geom.LinearRing} 获取的线环。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     *
     *
     * let linearRing=null;
     * for(let n=0;n<getLinearRings().length;n++){
     * 	   linearRing=polygon.getLinearRing(n);//线环不为空
     *	}
     *
     * linearRing=polygon.getLinearRing(-2);//线环为空 linearRing=null;
     * linearRing=polygon.getLinearRing(10);//线环为空 linearRing=null;
     *
     */
    getLinearRing(n = 0) {
        if (Number.isInteger(n)) {
            return (n >= 0 && n < this.lineRingArr.length) ? this.lineRingArr[n] : null;
        } else {
            throw new Error("the parameter must be a Integer");
        }
    }

    /**
     * 获取线环数量。
     * @returns {Number} 线环数量。
     */
    getLinearRingCount() {
        return this.lineRingArr.length;
    }

    /**
     * 获取所有线环。
     * @returns {Array<hmap.geom.LinearRing>} 包含所有线环的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * let result = polygon.getLinearRings();
     */
    getLinearRings() {
        return this.lineRingArr;
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        for (let i = 0; i < this.lineRingArr.length; i++) {
            this.lineRingArr[i].applyTransform(callback);
        }
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if (coord instanceof hmap.basetype.Coordinate) {
            return this.getExtent().containsCoord(coord, true);
        } else {
            throw new TypeError("the parameter is not Coordinate!");
        }
    }

    /**
     * 获取几何体的缓冲区。缓冲区限于X-Y平面内，非三维空间中的缓冲区。
     * @param {Number} dist 缓冲距离，一个正数，单位同地图单位。注意，缓冲半径过大可能出现重叠或岛洞
     * @param {String} sideType 面缓冲类型，"FULL"：包含原几何体，"OUTSIDE"：不包含原有几何体。
     * @returns {hmap.geom.Polygon} 返回一个面状几何体
     */
    getBuffer(dist,sideType ="FULL") {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero !");
        }
        const polygonBuffer = new hmap.strategy.PolygonBuffer(this, dist, sideType);
        return polygonBuffer.build();
    }

    /**
     * 复制一个多边形几何体对象。
     * @return {hmap.geom.Polygon} 返回新的多边形。
     */
    clone() {
        const lineArr = [...this.lineRingArr].map(linearRing => linearRing.clone());//级成多边形的线环
        return new hmap.geom.Polygon(lineArr);
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options = {}) {
        const edge = !(options && options.edge === false);          //边缘距离，默认true
        const details = options && options.details;
        if (!edge && this.intersectsGeometry(geometry)) {            //相交的情况
            if (!details)
                return 0;
            else {
                return {distance: 0};
            }
        } else {
            let result, best, distance;
            let min = Number.POSITIVE_INFINITY;
            for (let i = 0, len = this.lineRingArr.length; i < len; ++i) {
                result = this.lineRingArr[i].distanceTo(geometry, options);
                distance = (result.distance || result.distance == 0) ? result.distance : result;
                if (Math.abs(distance) < Math.abs(min)) {   //这里比较的是距离所以要绝对值
                    min = distance;
                    best = result;
                }
            }
            //包含的情况求距离
            if (edge && this.intersectsGeometry(geometry)) {
                if (min != 0) min = -min;
                if (best && (best.distance || best.distance == 0)) {
                    best.distance = min;
                } else {
                    best = min;
                }
            }
            return best;
        }
    }

    /**
     * 计算多边形的质心。
     * @returns {hmap.basetype.Coordinate} 多边形质心的地理坐标。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * let result = polygon.getCentroid();//result=new hmap.basetype.Coordinate(121.666667, 30.666667, 0)
     */
    getCentroid() {
        return new hmap.basetype.Coordinate(...hmap.strategy.EarCut.polygonCentroid(this.getCoordSeqs()));
    }

    /**
     * (暂未启用)从构成多边形几何体的所有点中，获取离传入坐标最近的一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 多边形几何体上的一个点。
     */
    getClosestPoint(coord) {
        let point,minDistance=Number.POSITIVE_INFINITY;
        for(let i=0,len=this.lineRingArr.length;i<len;i++) {
            let points = this.lineRingArr[i].getVertices();
            for (let k = 0, lenk = points.length; k < lenk; k++) {
                const value = points[i];
                const dist = value.getCoordinate().get3Dist(coord);
                if (dist < minDistance) {
                    minDistance = dist;
                    point = value;
                }
            }
        }
        return point;
    }

    /**
     * 计算多边形几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * 带有“岛洞”的多边形，其地理范围取决于最外面的环。
     * @returns {hmap.basetype.Extent} 返回多边形几何体的地理范围。
     * @example
     * let result = polygon.getExtent();
     */
    getExtent() {
        return this.getLinearRing(0).getExtent();
    }

    /**
     * 计算周长。
     * @param {Number} linearRingIndex 线环索引。如果linearRingIndex非空，则计算对应线环的长度，否则计算所有线环长度之和。
     * @param {String} srid  空间参考系的id
     * @returns {Number} 周长
     */
    getPerimeter(linearRingIndex, srid = 4326) {
        if (linearRingIndex == undefined) {
            let totalLength = 0;
            for (let i = 0; i < this.lineRingArr.length; i++) {
                totalLength += this.lineRingArr[i].getLength(srid);
            }
            return totalLength;
        } else {
            if (!Number.isFinite(linearRingIndex)) {
                throw "linearRingIndex must be a Number!";
            }
            if (linearRingIndex < 0 || linearRingIndex >= this.lineRingArr.length) {
                throw "linearRingIndex out of range!";
            }
            return this.lineRingArr[linearRingIndex].getLength(srid);
        }
    }

    /**
     * 获取几何体类型。
     * @returns {String} 返回几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.Polygon;
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Polygon} 移动后的多边形几何体。
     */
    moveByDelta(deltaX, deltaY, deltaZ) {
        for (let i = 0; i < this.lineRingArr.length; i++) {
            this.lineRingArr[i].moveByDelta(deltaX, deltaY, deltaZ);
        }
        return this;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectPolygon2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectPolygon2D(geom, this);
            },
            'Line': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(geom, this);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.lineIntersectPolygon2D(geom, this);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.polygonIntersectPolygon2D(this, geom.toPolygon());
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.multiLineIntersectPolygon2D(geom, this);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.polygonIntersectPolygon2D(this, geom.toPolygon());
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.polygonIntersectPolygon2D(this, geom.toPolygon());
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.polygonIntersectPolygon2D(this, geom);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.polygonIntersectMultiPolygon2D(this, geom);
            },
            'Collection': () => {
                return geom.intersectsGeometry(this);
            }
        }[geom.getType()]();
    }

    /**
     * 自相交判断。
     * @return {Boolean} 返回true表示相交；返回false表示不相交
     */
    isSelfIntersects() {
        let lineRings = this.getLinearRings();
        let lineCount = lineRings.length;
        for (let i = 0; i < lineCount; i++) {
            let lineRing = lineRings[i];
            if (lineRing.isSelfIntersects()) {
                return true;
            }
            for (let j = i + 1; j < lineCount; j++) {
                let lineRing2 = lineRings[j];
                if (hmap.strategy.Intersect.lineIntersectLine2D(lineRing, lineRing2)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} 返回true表示有效；返回false表示无效。
     */
    isValid() {
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认值为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针为正，顺时针为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.Polygon} 返回旋转后的面状几何体。
     */
    rotate(axis, angle, center) {
        for (let i = 0; i < this.lineRingArr.length; i++) {
            this.lineRingArr[i].rotate(axis, angle, center);
        }
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Polygon} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        if (!origin) {
            origin = this.getExtent().getCenter();
        }
        for (let i = 0; i < this.lineRingArr.length; i++) {
            this.lineRingArr[i].scale(xFactor, yFactor, zFactor, origin);
        }
        return this;
    }

    /**
     * 简化多边形几何体。在尽可能不改变原几何体形状的情况下，减少构成几何体的坐标数量。采用道格拉斯-普克算法。
     * 简化后，构成多边形几何体的每条线环中应至少包含三个点。
     * @param {Number} tolerance 道格拉斯算法中简化所用的容差值，即:简化的参考值。容差值越大,构成几何体的坐标数量越少。容差值大于等于0。
     * @returns {hmap.geom.Polygon} 返回简化后的几何体。
     */
    simplify(tolerance) {
        for (let i = 0; i < this.lineRingArr.length; i++) {
            this.lineRingArr[i].simplify(tolerance);
        }
        return this;
    }

    /**
     * 将一个多边形几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Polygon} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this.lineRingArr.length; i < l; i++) {
            this.lineRingArr[i].transform(source, destination);
        }
        return this;
    }

    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * polygon.destroy();
     * let result = polygon.CLASS_NAME;//result=undefined即polygon对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 计算多边形几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回该多边形的三维包围盒。
     */
    getBBox() {
        let bbox = this.getLinearRing(0).getBBox();
        for (let i = 1, l = this.getLinearRingCount(); i < l; i++) {
            bbox.extendBBox(this.getLinearRing(i).getBBox());
        }
        return bbox;
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster}ray 射线
     * @param {Number}tolerance 拾取容差
     * @return {Number}
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        let result = hmap.strategy.Intersect3D.rayIntersectPolygon(ray.origin, ray.direction, this,offset);
        let minDistance = Number.POSITIVE_INFINITY;
        if (result && result.length > 0) {
            for (let i = 0, len = result.length; i < len; i++) {
                let pointToCamera = ray.distanceSquare(result[i]);
                if (pointToCamera < minDistance) {
                    minDistance = pointToCamera;
                }
            }
        }
        return Number.isFinite(minDistance) ? minDistance : null;
    }


};

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 圆是一个特殊的正多边形，正多边形的边数越多，越逼近圆，同时渲染时需要消耗的计算机资源就越多。
 * @type {hmap.geom.Circle}
 * @extends hmap.geom.Geometry
 * @example
 * let center = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let circle = new hmap.geom.Circle(center,20);
 */
hmap.geom.Circle = class extends hmap.geom.Geometry {
    /**
     * 圆的构造函数。
     * @param {hmap.geom.Point} center 圆的中心点。
     * @param {Number} radius 圆的半径，单位与地图坐标系的单位一致。
     * @param {Number} pointNum 可选项，构成圆的边的数量，最少是8，默认是50，建议不要超过100；水平向右为0度角，逆时针方向为正方向进行分段。边数越多，需要渲染的数据量越大，渲染时需要消耗的计算机资源就越多，耗时因此会增加。
     * @throws 当参数center不是点几何对象或者参数radius不是大于0的数字时，抛出异常。
     */
    constructor(center, radius, pointNum = 50) {
        if (!(center instanceof hmap.geom.Point)) {
            throw new TypeError('Parameter "center" must be instance of hmap.geom.Point!');
        }
        if (!Number.isFinite(radius) || radius <= 0) {
            throw new TypeError('Parameter "radius" must be Number and greater than zero');
        }
        if (!(Math.floor(pointNum) === pointNum) || pointNum <= 7) {
            throw new TypeError('Parameter "pointNum" must be Integer and no less than 8');
        }
        super();
        this._center = center;
        this._radius = radius;
        this._pointNum = pointNum;

        // 维护圆上的点
        const centerCoord = this._center.getCoordinate();
        const centerX = centerCoord.getOrdinate('X');
        const centerY = centerCoord.getOrdinate('Y');
        const centerZ = centerCoord.getOrdinate('Z');
        const circlePoints = [];
        let radian;
        for (let i = 0; i < this._pointNum; i++) {
            radian = 2 * Math.PI / this._pointNum * i;
            circlePoints.push(
                new hmap.geom.Point(
                    new hmap.basetype.Coordinate(
                        centerX + this._radius * Math.cos(radian),
                        centerY + this._radius * Math.sin(radian),
                        centerZ
                    )
                )
            );
        }
        this._circlePoints = circlePoints;
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this.CLASS_NAME = "hmap.geom.Circle";
    }

    /**
     * 计算圆的面积。
     * @returns {Number} 圆的面积，地图单位。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getArea();
     */
    getArea() {
        return Math.PI * this._radius * this._radius;
    }

    /**
     * 获取圆的中心点。
     * @returns {hmap.geom.Point} 中心点。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getCenter();
     */
    getCenter() {
        return this._center;
    }

    /**
     * 提取圆的坐标序列。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标序列。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的Coordinate；
     * 3.如果startIndex与endIndex参数为空，返回所有Coordinate。
     * @param {Number} startIndex 起始索引。如果不传，默认是0。
     * @param {Number} endIndex 结束索引。如果不传，默认是坐标序列长度值。
     * @returns {hmap.basetype.CoordSeq} 坐标序列。坐标序列规律，一个圆是360度，若是有100个点组成，其均匀的分布在圆上，每相邻两点的角度是3.6度， 圆上第一个点的坐标是以平行y轴正方向取点的，按逆时针方向后面有第2个，第3个点,以此类推剩下的其他点。
     * @throws 当参数startIndex和endIndex都不是数字或者参数startIndex大于等于参数endIndex时，抛出异常。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getCoordSeq(0,1);
     */
    getCoordSeq(startIndex = 0, endIndex = this._pointNum) {
        if (Number.isFinite(startIndex) && Number.isFinite(endIndex)) {
            const len = this._pointNum;
            startIndex = startIndex <= 0 ? 0 : Number.parseInt(startIndex);
            endIndex = endIndex > len ? len : Number.parseInt(endIndex);

            if (startIndex >= endIndex) {
                throw new RangeError("endIndex must greater than startIndex!");
            }

            const circleCoordArr = [];
            const circlePoints = this.getPoints();
            for (let point of circlePoints) {
                circleCoordArr.push(point.getCoordinate());
            }
            const circleCoordSeq = new hmap.basetype.CoordSeq(circleCoordArr);
            return new hmap.basetype.CoordSeq(circleCoordSeq.extractCoords(startIndex, endIndex - startIndex));
        } else {
            throw new TypeError("the parameter " + startIndex + "&" + endIndex + "must be number!");
        }
    }

    /**
     * 提取圆的坐标序列数组
     * @return {Array<hmap.basetype.CoordSeq>}
     */
    getCoordSeqs() {
        return [this.getCoordSeq()];
    }

    /**
     * 计算圆的周长
     * @returns {Number} 周长，单位与地图单位相同。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getLength();//result=125.66370614359172
     */
    getLength() {
        return 2 * Math.PI * this.getRadius();
    }

    /**
     * 获取组成圆的所有点。
     * @returns {Array<hmap.geom.Point>} 点数组。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getPoints();
     */
    getPoints() {
        return this._circlePoints;
    }

    /**
     * 计算圆所含的点数量。
     * @returns {Number} 一个整数值，表示点的总数。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getPointNum();//result=100
     */
    getPointNum() {
        return this._pointNum;
    }

    /**
     * 获取圆的半径。
     * @returns {Number} 圆的半径。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getRadius();//result=20
     */
    getRadius() {
        return this._radius;
    }

    /**
     * 重设圆的中心点。
     * @param {hmap.geom.Point} center 圆的中心点。
     * @returns {Object} 返回Circle 对象
     * @throws 当参数center不是一个点几何对象时，抛出异常。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let coord2 = new hmap.basetype.Coordinate(123,33,0);
     * let center2 = new hmap.geom.Point(coord2);
     * let result = circle.setCenter(center2);//result=true
     */
    setCenter(center) {
        if (!(center instanceof hmap.geom.Point)) {
            throw new Error("the center is not a Point");
        }

        // 根据偏移量，重新设置圆的中心点
        const newCenterCoord = center.getCoordinate();
        const centerCoord = this._center.getCoordinate();
        const offsetX = newCenterCoord.getOrdinate('X') - centerCoord.getOrdinate('X');
        const offsetY = newCenterCoord.getOrdinate('Y') - centerCoord.getOrdinate('Y');
        const offsetZ = newCenterCoord.getOrdinate('Z') - centerCoord.getOrdinate('Z');
        this.moveByDelta(offsetX, offsetY, offsetZ);
        return this;
    }

    /**
     * 重设圆的半径。
     * @param {Number} radius 半径。
     * @returns {Boolean} true表示设置成功，false表示设置失败。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.setRadius(30);//result=true
     */
    setRadius(radius) {
        if (!Number.isFinite(radius) || radius <= 0) {
            return false;
        }

        // 根据偏移量，重新设置圆的点
        const offsetN = radius / this._radius;
        const centerCoord = this._center.getCoordinate();
        const centerX = centerCoord.getOrdinate('X');
        const centerY = centerCoord.getOrdinate('Y');
        const centerZ = centerCoord.getOrdinate('Z');
        const circlePoints = [];
        for (let coord of this.getCoordSeq().extractCoords()) {
            coord.setOrdinate("X", (coord.getOrdinate("X") - centerX) * offsetN + centerX);
            coord.setOrdinate("Y", (coord.getOrdinate("Y") - centerY) * offsetN + centerY);
            coord.setOrdinate("Z", (coord.getOrdinate("Z") - centerZ) * offsetN + centerZ);
            circlePoints.push(new hmap.geom.Point(coord));
        }
        this._circlePoints = circlePoints;
        this._radius = radius;
        this._pointsChanged = true;
        return true;
    }

    /**
     * 将圆转化为多边形。
     * @returns {hmap.geom.Polygon} 多边形。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.toPolygon();
     */
    toPolygon() {
        const lastPoint = this.getPoints()[0];
        let points = this.getPoints();
        points.push(lastPoint);
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(points)]);
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     * @example
     * circle.applyTransform(function(coordinate){
     *      coordinate.setOrdinate("X", coordinate.getOrdinate("X")+1);
     *      return coordinate;
     * });
     */
    applyTransform(callback) {
        let coord;
        for (let i = 0, len = this._circlePoints.length; i < len; i++) {
            coord = callback(this._circlePoints[i].getCoordinate());
            this._circlePoints[i] = new hmap.geom.Point(coord);
        }
        this._pointsChanged = true;
        // 更新center坐标值
        let extent = this.getExtent();
        const x = (extent.getLeft() + extent.getRight()) / 2;
        const y = (extent.getTop() + extent.getBottom()) / 2;

        const circleCoords = this.getPoints();
        const firstCoord = circleCoords[0].getCoordinate();
        let zfront, zback, pointZ;
        zfront = zback = firstCoord.getOrdinate("Z");
        for (let coord of circleCoords) {
            pointZ = coord.getCoordinate().getOrdinate("Z");
            zfront = zfront < pointZ ? pointZ : zfront;
            zback = zback > pointZ ? pointZ : zback;
        }
        const z = (zfront + zback) / 2;
        const centerCoord = this._center.getCoordinate();
        centerCoord.setOrdinate("X", x);
        centerCoord.setOrdinate("Y", y);
        centerCoord.setOrdinate("Z", z);
        // 更新半径
        const onePointCoord = this._circlePoints[0].getCoordinate();
        this._radius = Math.sqrt(Math.pow(onePointCoord.getOrdinate("X"), 2) + Math.pow(onePointCoord.getOrdinate("Y"), 2) + Math.pow(onePointCoord.getOrdinate("Z"), 2));
    }

    /**
     * 检测一个坐标是否在圆的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在圆内，可能会在圆的边缘以外附近。
     * 边界盒：即圆的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} true表示在圆的边界盒范围以内，false表示不在圆的边界盒范围以内。
     * @throws 当参数coord不是一个地理坐标对象时，抛出异常。
     */
    atApproximatePoint(coord) {
        if (coord instanceof hmap.basetype.Coordinate) {
            return this.getExtent().containsCoord(coord);
        } else {
            throw new TypeError("the parameter is not Coordinate!");
        }
    }

    /**
     * 复制一个圆。
     * @returns {hmap.geom.Circle} 新的圆。
     */
    clone() {
        return new hmap.geom.Circle(this._center.clone(), this._radius, this._pointNum);
    }

    /**
     * 计算圆几何和一个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     * @example
     * let options = {details:true,edge:false};
     * let geom = new hmap.geom.Point(new hmap.basetype.Coordinate(112.0,26.0));
     * circle.distanceTo(geom,options);
     */
    //TODO 圆和圆的距离和交点
    distanceTo(geometry, options) {
        return this.toPolygon().distanceTo(geometry, options);
        // let best = geometry.distanceTo(this,options);
        // if(best instanceof Object){
        //     best = {
        //         distance: best.distance,
        //         x0: best.x1, y0: best.y1,
        //         x1: best.x0, y1: best.y0
        //     };
        // }
        // return best;
    }

    /**
     * 获取圆对象的缓冲区
     * @param {Number} dist 缓冲距离，一个正数，单位同地图单位。
     * @param {String} sideType 面缓冲类型，"FULL"：包含原几何体，"OUTSIDE"：不包含原有几何体。
     * @returns {hmap.geom.Circle} 缓冲区。
     * @example
     * circle.getBuffer(0.001)
     */
    getBuffer(dist,sideType ="FULL") {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number larger than zero !");
        }
        const newCircle = new hmap.geom.Circle(this._center.clone(), this._radius + dist);
        if (sideType === "OUTSIDE") {
            const ring1 = newCircle.toPolygon().getLinearRing(0);
            const ring2 = this.toPolygon().getLinearRing(0);
            return new hmap.geom.Polygon([ring1, ring2]);
        }
        return newCircle;
    }

    /**
     * 计算圆的质心。
     * @returns {hmap.basetype.Coordinate} 质心坐标。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getCentroid();
     */
    getCentroid() {
        return this._center.getCoordinate();
    }

    /**
     * 从构成圆几何体的所有点中，获取离传入坐标最近的一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 圆几何体上的一个点。
     * @throws 当参数coord不是一个地理坐标对象时，抛出异常。
     */
    getClosestPoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is illegal!");
        }
        const center = this._center, radius = this._radius;
        let x0 = center.getCoordinate().getOrdinate("X"), y0 = center.getCoordinate().getOrdinate("Y"),
            x1 = coord.getOrdinate("X"), y1 = coord.getOrdinate("Y");
        let distanceToCenter = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
        let closestPoint;
        if (distanceToCenter != 0) {
            const coordX = x0 + (x1 - x0) * radius / distanceToCenter;
            const coordY = y0 + (y1 - y0) * radius / distanceToCenter;
            closestPoint = new hmap.geom.Point(new hmap.basetype.Coordinate(coordX, coordY, 0));
        }
        return closestPoint;
    }

    /**
     * 获取圆的地理范围（即边界盒）。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 地理范围。
     */
    getExtent() {
        return this.getBBox().getExtent();
    }

    /**
     * 获取圆的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回圆的三维包围盒
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._pointsChanged = false;
        }
        return this._bbox
    }

    /**
     * 计算圆的三维包围盒
     * @returns {hmap.basetype.BBox|*}
     * @private
     */
    _calculateBBox() {
        let length = this._circlePoints.length;
        if (length === 0) {
            return new hmap.basetype.BBox(0, 0, 0, 0, 0, 0);
        }
        let coordinate = this._circlePoints[0].getCoordinate();
        let left = coordinate.getOrdinate("X"),
            right = coordinate.getOrdinate("X"),
            back = coordinate.getOrdinate("Y"),
            front = coordinate.getOrdinate("Y"),
            up = coordinate.getOrdinate('Z'),
            bottom = coordinate.getOrdinate('Z');
        for (let i = 1; i < length; i++) {
            coordinate = this._circlePoints[i].getCoordinate();
            let x = coordinate.getOrdinate("X"),
                y = coordinate.getOrdinate("Y"),
                z = coordinate.getOrdinate('Z');
            left = Math.min(left, x);
            right = Math.max(right, x);
            front = Math.min(front, y);
            back = Math.max(back, y);
            up = Math.max(up, z);
            bottom = Math.min(bottom, z);
        }
        return new hmap.basetype.BBox(left, front, bottom, right, back, up);
    }

    /**
     * 获取圆的几何体类型。
     * @returns {String} hmap所支持的几何类型枚举值，参见{@link hmap.geom.GeometryType}
     */
    getType() {
        return hmap.geom.GeometryType.Circle;
    }

    /**
     * 检测圆与入参几何体是否相交。
     * @param {hmap.geom.Geometry} geom 几何体。
     * @returns {Boolean} 返回true表示相交；返回false表示不相交。
     * @example
     * const pt1 = new hmap.geom.Point(new hmap.basetype.Coordinate(119.0,30.0));
     * const pt2 = new hmap.geom.Point(new hmap.basetype.Cooridinate(120.0,30.2));
     * let geom = new hmap.geom.Line([pt1,pt2]);
     * circle.intersectsGeometry(geom);
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectCircle2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectCircle2D(geom, this);
            },
            'Line': () => {
                return hmap.strategy.Intersect.lineIntersectCircle2D(geom, this);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.lineIntersectCircle2D(geom, this);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom.toPolygon(), this);
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.multiLineIntersectCircle2D(geom, this);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.circle2DIntersectCircle2D(this, geom);
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom.toPolygon(), this);
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom, this);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.multiPolygonIntersectCircle2D(geom, this);
            },
            'Collection': () => {
                for (let geometry of geom.getGeoms()) {
                    if (this.intersectsGeometry(geometry)) {
                        return true;
                    }
                }
                return false;
            }
        }[geom.getType()]();
    }

    /**
     * 自相交判断。
     * @returns {Boolean} 只能为false，表示圆不会自相交。
     */
    isSelfIntersects() {
        return false;
    }

    /**
     * (暂不启用)检测当前几何体是否有效。
     * 有效判断的的检查项：
     * 1、坐标值是否有效，在坐标系已知的情况下。
     * 2、几何体自身的拓扑关系。线的自相交、面的八字形状判断。
     * @returns true表示有效，false表示无效。
     */
    isValid() {
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Circle} 移动后的圆几何体。
     * @throws 当三个参数有一个不是数值类型时，抛出异常。
     * @example
     * circle.moveByDelta(0.001,0,0);
     */
    moveByDelta(deltaX, deltaY, deltaZ) {
        if (!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)) {
            throw new Error("parameter must be number!");
        }
        // 根据偏移量，重新设置圆的点
        const circlePoints = [];
        let coords = this.getCoordSeq().extractCoords();
        for (let coord of coords) {
            coord.setOrdinate("X", coord.getOrdinate("X") + deltaX);
            coord.setOrdinate("Y", coord.getOrdinate("Y") + deltaY);
            coord.setOrdinate("Z", coord.getOrdinate("Z") + deltaZ);
            circlePoints.push(new hmap.geom.Point(coord));
        }
        this._circlePoints = circlePoints;
        const centerCoord = this._center.getCoordinate();
        centerCoord.setOrdinate("X", centerCoord.getOrdinate("X") + deltaX);
        centerCoord.setOrdinate("Y", centerCoord.getOrdinate("Y") + deltaY);
        centerCoord.setOrdinate("Z", centerCoord.getOrdinate("Z") + deltaZ);
        this._pointsChanged = true;
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * 该方法不会改变圆的形状，但可能会改变圆的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z"
     * @param {number} angle 旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @throws 当axis不是'X'、'Y'、'Z'三者之一，或者参数类型不对时，抛出异常。
     * @example
     * circle.rotate("Y",30,new hmap.basetype.Coordinate(119.0,30.5,0));
     */
    rotate(axis, angle, center) {
        // if (!center) {
        //     center = this.getExtent().getCenter();
        // }
        this._center.rotate(axis, angle, center);
        for (let i = 0; i < this._circlePoints.length; i++) {
            this._circlePoints[i].rotate(axis, angle, center);
        }
        this._pointsChanged = true;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放圆。
     * 该方法可能会改变圆的形状与位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xyzFactor XYZ方向上的缩放因子一样,必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，表示以缩放原点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Circle} 返回缩放后的圆几何体。
     * @throws 当参数xyzFactor<=0 或者 参数origin不是一个地理坐标对象时，抛出异常
     * @example
     * circle.scale(1.2);//将圆放大1.2倍
     */
    scale(xyzFactor, origin) {
        if (!Number.isFinite(xyzFactor) || xyzFactor <= 0) {
            throw new RangeError('Parameter "xyzFactor" must be positive Number!');
        }
        if (origin && !(origin instanceof hmap.basetype.Coordinate)) {
            throw new TypeError('Parameter "origin" must be type of hmap.basetype.Coordinate');
        }
        if (!origin) {
            origin = this._center.getCoordinate();
        }
        this._center.scale(xyzFactor, xyzFactor, xyzFactor, origin);
        for (let point of this._circlePoints) {       //组成点缩放
            point.scale(xyzFactor, xyzFactor, xyzFactor, origin);
        }
        this._radius = xyzFactor * this._radius;
        this.setRadius(this._radius);
        this._pointsChanged = true;
        return this;
    }

    /**
     * (道格拉斯-普克算法)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。
     * 采用道格拉斯-普克算法，每条用于构成几何体的线中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * 圆形的简化返回原对象
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Circle} 返回简化后的几何体。
     */
    simplify(tolerance) {
        return this;
    }

    /**
     * 把圆几何体中坐标从源坐标系转换到目标坐标系。 返回坐标转换后的圆。
     * 转换后，原始几何体的坐标值将会被修改。请使用clone方法备份。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例,以减少CRS实例数量，进而降低内存成本。
     * @param {hmap.proj.Crs} source 源坐标系。
     * @param {hmap.proj.Crs} destination 目标坐标系。
     * @returns {hmap.geom.Circle} 坐标转换后的几何体。
     */
    transform(source, destination) {
        this._center.transform(source, destination);
        for (let i = 0; i < this._pointNum; i++) {
            this._circlePoints[i].transform(source, destination);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 销毁对象。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * circle.destroy();
     */
    destroy() {
        super.destroy();
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance 拾取容差
     * @return {Object} 最小距离{distance: Number}
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        let centerPoint = this.getCenter();
        let result = hmap.strategy.Intersect3D.pointToSegment(centerPoint.getCoordinate(),
            ray._line.getVertices()[0].getCoordinate(), ray._line.getVertices()[1].getCoordinate(),offset);
        let minDistance = result.distance - this.getRadius();//点到直线的距离
        if (minDistance < tolerance) {
            let pointToCamera = ray.distanceSquare(result.point);//最近点到相机的距离
            return {
                distance: pointToCamera,
            }
        }
    }
};
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 集合体。地理几何体的一种形态，由多种简单的几何体组合而成。
 * @type {hmap.geom.Collection}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(120.1,30.1,0);
 * let point1 = new hmap.geom.Point(coord1);
 * let point2 = new hmap.geom.Point(coord2);
 * let line = new hmap.geom.Line([point1,point2]);
 * let collection = new hmap.geom.Collection([point1,point2,line]);
 */
hmap.geom.Collection=class extends hmap.geom.Geometry{
    /**
     * 构造集合体。
     * @param {Array<hmap.geom.Geometry>} geometrys 几何体数组。
     */
    constructor(geometrys){
        super();
        if(geometrys instanceof Array){
            const len=geometrys.length;
            if(len<1){
                throw new Error("It does not have enough geometry object.");
            }
            for(let i=0;i<len;i++){
                const geometry=geometrys[i];
                if(!this._validType(geometry)){
                    throw new TypeError("This geometrys contains invalid geometry.");
                }
            }
            this._geometrys = geometrys;
        }else{
            throw new TypeError("params must be Array");
        }
        this.CLASS_NAME = "hmap.geom.Collection";
    }

    /**
     * 判断几何类型是否被支持，支持的类型有：Point、MultiPoint、Line、MultiLine、LinearRing、Polygon、MultiPolygon、Triangle、Rectangle、Circle
     * @private
     * @param {hmap.geom.Geometry} geometry 几何对象
     * @returns {Boolean} 几何类型被支持时，返回true；不支持或参数不存在时，返回false。
     */
    _validType(geometry){
        if(geometry===null || geometry===undefined){
            return false;
        }
        if(geometry instanceof hmap.geom.Point || geometry instanceof hmap.geom.MultiPoint
            || geometry instanceof hmap.geom.Line  || geometry instanceof hmap.geom.MultiLine
            || geometry instanceof hmap.geom.LinearRing || geometry instanceof hmap.geom.Polygon
            || geometry instanceof hmap.geom.MultiPolygon || geometry instanceof hmap.geom.Triangle
            || geometry instanceof hmap.geom.Rectangle || geometry instanceof hmap.geom.Circle){
            return true;
        }else{
            return false;
        }
    }

    /**
     * 向集合体添加一个几何体。
     * @param {hmap.geom.Geometry} geometry 要添加的几何体，该参数不合法时，返回原集合体。
     * @param {Number} index 几何体索引，0或正整数。表示新加入的几何体的索引位置。当索引小于0时，添加到几何体数组的起始位置；当索引大于几何体的数量或为空时，添加到几何体数组的末尾。
     * @returns {hmap.geom.Collection} 返回修改后的集合体对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120.1,30.1,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let collection = new hmap.geom.Collection([point1,point2,line]);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let point3 = new hmap.geom.Point(coord3);
     * let result = collection.addGeometry(point3,2);
     */
    addGeometry(geometry,index){
        if(!this._validType(geometry)){
            return this;
        }
        if(index<0){
            index=0;
        }else if(index === undefined || index>this._geometrys.length){
            index=this._geometrys.length;
        }
        this._geometrys.splice(index,0,geometry);
        return this;
    }

    /**
     * 计算面积，非面状几何体不会被统计。
     * @returns {Number} 面积。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let linearRing = new hmap.geom.LinearRing([point1,point2,point3]);
     * let polygon = new hmap.geom.Polygon([linearRing]);
     * let collection = new hmap.geom.Collection([point1,point2,polygon]);
     * let result = collection.getArea();
     */
    getArea(){
        let area=0;
        this._geometrys.forEach(geom=>{
            if(geom instanceof hmap.geom.Point || geom instanceof hmap.geom.MultiPoint
                || geom instanceof hmap.geom.Line  || geom instanceof hmap.geom.MultiLine){
                //不做任何面积添加
            }else{
                area+=geom.getArea();
            }
        });
        return area;
    }

    /**
     * 获取几何体数量。
     * @returns {Number} 几何体数量。
     */
    getCount(){
        return this._geometrys.length;
    }

    /**
     * 获取所有的几何体。
     * @returns {Array<hmap.geom.Geometry>} 几何体数组。
     */
    getGeoms(){
        return this._geometrys;
    }

    /**
     * 获取组成集合体的所有几何体类型。
     * @returns {Array<string>} 所有几何体类型的数组，该数组的每个元素表示在{@link hmap.geom.Collection#getGeoms}返回的几何体数组中同一位置的几何体类型。
     */
    getGeometryTypes(){
        return this._geometrys.map(
            function(geometry){
                return geometry.getType();
            });
    }

    /**
     * 计算长度,不会统计“非线几何体”的长度
     * @param {Number} srid 坐标系，默认是4326。
     * @returns {Number} 长度值，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let collection = new hmap.geom.Collection([point1,point2,line]);
     * let result = collection.getLength(4326);//result=146775.88397588348
     */
    getLength(srid = 4326){
        let length=0;
        this._geometrys.forEach(geom=>{
            if(geom instanceof hmap.geom.Line){
                length+=geom.getLength(srid);
            }else if(geom instanceof hmap.geom.MultiLine){
                let lines = geom.getLines();
                for(let line of lines){
                    length+=line.getLength(srid);
                }
            }else{
                //其他类型没有长度
            }
        });
        return length;
    }

    /**
     * 从集合体中删除一个几何体。
     * @param {hmap.geom.Geometry} geom 要删除的几何体。
     * @returns {Number} 删除几何体个数。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120.1,30.1,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let collection = new hmap.geom.Collection([point1,point2,line]);
     * let result = collection.removeGeom(point1);//result=1
     */

    removeGeom(geom){
        let count=0;
        const len=this._geometrys.length;
        for(let i=0;i<len;i++){
            if(this._geometrys[i-count]===geom){
                this._geometrys.splice(i,1);
                count++;
            }
        }
        return count;
    }

    /**
     * 获取集合体的质心。
     * @returns {hmap.basetype.Coordinate} 质心地理坐标，返回-1表示没有质心。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120.1,30.1,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let collection = new hmap.geom.Collection([point1,point2,line]);
     * let result = collection.getCentroid();
     * //result=new hmap.basetype.Coordinate(120.05,30.05,0);
     */
    getCentroid(){
        let x=0,y=0,z=0;
        const len=this._geometrys.length;
        for(let i=0;i<len;i++){
            if(this._geometrys[i].getCentroid){
                const geomCentroid = this._geometrys[i].getCentroid();
                x+=geomCentroid.getOrdinate("X");
                y+=geomCentroid.getOrdinate("Y");
                z+=geomCentroid.getOrdinate("Z");
            }
        }
        return (!x&&!y&&!z)?(-1):new hmap.basetype.Coordinate(x/len,y/len,z/len);
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord){
        let flag=false;
        this._geometrys.forEach(geometry=>{
            if(geometry.atApproximatePoint(coord)){
                flag=true;
            }
        });
        return flag;
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback){
        this._geometrys.forEach(geometry=>{
            geometry.applyTransform(callback);
        });
    }

    /**
     * 复制一个集合体。复制后的集合体是独立于原集合体的实例。
     * @returns {hmap.geom.Geometry} 新的集合体。
     */
    clone(){
        const newGeoms = [...this._geometrys].map(geom => geom.clone());
        return new hmap.basetype.Collection(newGeoms);
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry,options){
        const edge = !(options && options.edge === false);
        const details = edge && options && options.details;
        let result, best, distance;
        let min = Number.POSITIVE_INFINITY;
        for(let i=0, len=this._geometrys.length; i<len; ++i) {
            result = this._geometrys[i].distanceTo(geometry, options);
            distance = (result.distance || result.distance==0) ? result.distance : result;
            if(distance < min) {
                min = distance;
                best = result;
                if(min === 0) {
                    break;
                }
            }
        }
        return best;
    }

    /**
     * 计算集合体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 集合体的地理范围。
     */
    getExtent(){
        let left,bottom,right,top;
        if(this._geometrys.length < 1){
            return false;
        }else{
            let e = this._geometrys[0].getExtent();
            left=e.getLeft();
            bottom=e.getBottom();
            right=e.getRight();
            top=e.getTop();
        }
        this._geometrys.forEach(geometry=>{
            const e=geometry.getExtent();
            left=e.getLeft()<left?e.getLeft():left;
            bottom=e.getBottom()<bottom?e.getBottom():bottom;
            right=e.getRight()>right?e.getRight():right;
            top=e.getTop()>top?e.getTop():top;
        });
        return new hmap.basetype.Extent(left,bottom,right,top);
    }

    distanceToSegment(coordsegment){}
    getLastCoordinate(){}
    getClosesPoint(coord){}
    getCoordSeq(startIndex, endIndex) {}

    /**
     * 获取几何体类型。
     * @returns {String} 几何体类型。
     */
    getType(){
        return hmap.geom.GeometryType.Collection;
    }

    /**
     * 检测集合体与地理范围是否相交。
     * @param extent 地理范围。
     * @return {Boolean} 为true时表示相交，为false时表示不相交。
     */
    intersectsExtent(extent){
        const thisExtent=this.getExtent();
        const flag1=thisExtent.getLeft()>=extent.getLeft() && thisExtent.getBottom()>=extent.getBottom() && thisExtent.getLeft()<=extent.getRight() && thisExtent.getBottom()<=extent.getTop();
        const flag2=thisExtent.getRight()>=extent.getLeft() && thisExtent.getTop()>=extent.getBottom() && thisExtent.getRight()<=extent.getRight() && thisExtent.getTop()<=extent.getTop();
        return (flag1 ||flag2);
    }

    /**
     * 检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid(){
        let flag=true;
        this._geometrys.forEach(geometry=>{
            if(!geometry.isValid()){
                flag=false;
            }
        });
        return flag;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom){
        for(let i=0,len=this._geometrys.length;i<len;i++){
            if(this._geometrys[i].intersectsGeometry(geom)){
                return true;
            }
        }
        return false;
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.Collection} 移动后的几何体。
     */
    moveByDelta(deltaX, deltaY, deltaZ){
        this._geometrys.forEach(geometry=>{
            geometry.moveByDelta(deltaX,deltaY,deltaZ);
        });
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z"
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @throws {TypeError} 当axis不是'X'、’Y‘、’Z‘三者之一，或者参数类型不对时，抛出异常
     */
    rotate(axis, angle, center){
        this._geometrys.forEach(geometry=>{
            geometry.rotate(axis, angle, center);
        });
    }

    /**
     * (不是所有几何体都有简化接口)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。采用道格拉斯-普克算法，每条用于构成几何体的线中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Collection} 返回简化后的几何体。
     */
    simplify(tolerance){
        this._geometrys.forEach(geometry=>{
            geometry.simplify(tolerance);
        });
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.Collection} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin){
        if(!origin){
            origin = this.getExtent().getCenter();
        }
        this._geometrys.forEach(geometry=>{
            geometry.scale(xFactor, yFactor, zFactor, origin);
        });
        return this;
    }

    /**
     * (暂未启用)将一个几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 如果给定的坐标系未找到，则抛出异常。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * **考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本**
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @param {function} transformer 自定义的坐标系转换方法。 如果提供，则默认使用此方法进行坐标转换。
     * @returns {hmap.geom.Geometry} 坐标转换后的几何体。
     */
    transform(source,destination, transformer){

    }

    /**
     * 检测几何体与地理坐标坐标是否相交。
     * @param {hmap.basetype.Coordinate} coordinate 地理坐标。
     * @return {Boolean} 为true时表示相交，为false时表示不相交。
     */
    intersectsCoordinate(coordinate){
        this._geometrys.forEach(geometry=>{
            if(geometry.intersectsCoordinate(coordinate)){
                return true;
            }
        });
        return false;
    }

    /**
     * 自相交判断。
     * @return {Boolean} true表示相交，false表示不相交
     */
    isSelfIntersects(){
        let flag=false;
        this._geometrys.forEach(geometry=>{
            if(geometry.isSelfIntersects()){
                flag=true;
            }
        });
        return flag;
    }

    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120.1,30.1,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let collection = new hmap.geom.Collection([point1,point2,line]);
     * collection.destroy();
     */
    destroy() {
        super.destroy();
    }
};

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 多线几何体。多线几何体是由简单的线状几何体组合而成的。
 * @type {hmap.geom.MultiLine}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let coord3 = new hmap.basetype.Coordinate(122,32,0);
 * let coord4 = new hmap.basetype.Coordinate(123,33,0);
 * let point1 = new hmap.geom.Point(coord1);
 * let point2 = new hmap.geom.Point(coord2);
 * let point3 = new hmap.geom.Point(coord3);
 * let point4 = new hmap.geom.Point(coord4);
 * let line1 = new hmap.geom.Line([point1,point2]);
 * let line2 = new hmap.geom.Line([point3,point4]);
 * let multiLine = new hmap.geom.MultiLine([line1,line2]);
 */
hmap.geom.MultiLine = class extends hmap.geom.Geometry{
    /**
     * 构造一个多线。
     * @param {Array<hmap.geom.Line>} lines 由线对象组成的数组。
     */
    constructor(lines){
        //判断数组中是否全是line对象
        let isLines=lines.every(function(item,index,array){
            return item instanceof hmap.geom.Line;
        });
        if(!isLines){
            throw new Error('Not every elements in parameter "lines" is hmap.geom.Line!');
        }

        super();
        this._lines= lines;
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this._extent = this._bbox.getExtent();

        this.CLASS_NAME="hmap.geom.MultiLine";
        // this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }
    /**
     * 在多线几何体中添加新的线对象。
     * @param {hmap.geom.Line} line 要增添的线对象。
     * @returns {hmap.geom.MultiLine} 添加线对象后的多线几何体。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let line3 = new hmap.geom.Line([point2,point3]);
     * let result = multiLine.addLine(line3);
     */
    addLine(line){
        if(line instanceof hmap.geom.Line){
            this._lines.push(line);
            //更新BBox和extent
            this._extendBBox(line);
            return this;
        }else{
            throw new TypeError("the type of parameter must be Line!");
        }
    }

    /**
     * 从一个坐标序列数组创建一个多线。
     * @param {Array<hmap.basetype.CoordSeq>} coordSeqs 坐标序列组成的数组。
     * @returns {hmap.geom.MultiLine} 创建的多线对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coordSeq1 = new hmap.basetype.CoordSeq([coord1,coord2]);
     * let coordSeq2 = new hmap.basetype.CoordSeq([coord2,coord3]);
     * let result = hmap.geom.MultiLine.fromCoordSeqs([coordSeq1,coordSeq2]);
     */
    static fromCoordSeqs(coordSeqs=[]){
        if(Array.isArray(coordSeqs) || Object.prototype.toString.call(coordSeqs)==='[Object Array]'){
            let isCS=coordSeqs.every(function(item,index,array){
                return item instanceof hmap.basetype.CoordSeq;
            });
            if(!isCS){
                throw new Error("there is no CoordSeq in your Array!");
            }

            let fLines=coordSeqs.map(function(item,index,array){
                return hmap.geom.Line.fromCoordSeq(item);
            });
            return new  hmap.geom.MultiLine(fLines);
        }else{
            throw new TypeError("the parameter you passed must be Array!");
        }
    }

    /**
     * 提取多线的坐标序列数组。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标序列。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的CoordSeq；
     * 3.如果startIndex与endIndex参数为空，返回所有CoordSeq。
     * 4.当startIndex大于等于endIndex，返回空数组。
     * @param {Number} startIndex 起始索引。如果不传，默认是0。
     * @param {Number} endIndex 结束索引。如果不传，默认是坐标序列数组长度值。
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getCoordSeqs();
     */
    getCoordSeqs(startIndex=0, endIndex=this._lines.length) {
        if(Number.isFinite(startIndex) && Number.isFinite(endIndex)){
            //处理索引越界问题
            const len = this._lines.length;
            startIndex = startIndex <= 0 ? 0 : Number.parseInt(startIndex);
            endIndex = endIndex > len ? len : Number.parseInt(endIndex);

            if (startIndex >= endIndex) {
                return [];
            }

            let arr=[];
            for(let i=startIndex,l=endIndex;i<l;i++){
                arr.push(this._lines[i].getCoordSeq());
            }
            return arr;
        }else{
            throw new Error("the parameters must be numbers!");
        }
    }

    /**
     * 获取多线中指定索引处的{@link hmap.geom.Line}对象。
     * @param {Number} index 要获取的线在多线中的索引。
     * @returns {hmap.geom.Line} 线对象。
     * @example
     * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,32,0));
     * let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(123,33,0));
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * multiLine.getLine(1);
     */
    getLine(index=0){
        if(!Number.isFinite(index)){
            throw new TypeError("the type of parameter must be number!");
        }

        if(index<0 || index>=this._lines.length){
            throw new RangeError("the index value is out of Bounds!");
        }

        //return this._lines[index].clone();
        return this._lines[index];
    }

    getLineCount(){
        return this._lines.length;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
       // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }


    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        for(let i=0,len=this._lines.length;i<len;i++){
            this._lines[i].applyTransform(callback);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if(coord instanceof hmap.basetype.Coordinate){
            return this.getExtent().containsCoord(coord);
        }else{
            throw new TypeError("the parameter is not Coordinate!");
        }
    }

    /**
     * 复制一个多线对象。
     * @returns {hmap.geom.MultiLine} 新的多线对象。
     */
    clone() {
        const linesClone=[];
        for(let i=0,len=this._lines.length;i<len;i++){
            linesClone.push(this._lines[i].clone());
        }
        return new hmap.geom.MultiLine(linesClone);
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry,options) {
        let result, best, distance;
        let min = Number.POSITIVE_INFINITY;
        for(let i=0, len=this._lines.length; i<len; ++i) {
            result = this._lines[i].distanceTo(geometry, options);
            distance = (result.distance || result.distance==0) ? result.distance : result;
            if((min < 0 && distance > min && distance < 0)||(min > 0 && distance < min)){
                min = distance;
                best = result;
                if(min === 0) {
                    break;
                }
            }
        }
        return best;
    }

    /**
     * 计算几何体的缓冲区。
     * @param {Number} dist 缓冲距离,地图单位，且是大于0的数字。注意，缓冲半径过大可能出现重叠或岛洞
     * @param {String} endCap 端点类型。"ROUND"：圆角."FLAT":平角。默认"ROUND"
     * @param {Number} sideSign 缓冲模式。1：左缓冲，-1：右缓冲，0：双向缓冲。默认为0
     * @returns {hmap.geom.Polygon|hmap.geom.MultiPolygon} 缓冲区。
     */
    getBuffer(dist, endCap = "ROUND", sideSign = 0) {
        const arrBuffer = [];
        const toolGeoJSON = new hmap.format.GeoJSON();
        for (let i = 0, len = this.getLineCount(); i < len; i++) {
            // arrBuffer.push(this.getPoint(i).getBuffer(dist).toPolygon());
            arrBuffer.push(toolGeoJSON.writeGeometry(this.getLine(i).getBuffer(dist, endCap, sideSign)));
        }
        let topo = new hmap.strategy.TopologyBoolean();
        const buffer = topo.unionPolygons(arrBuffer);
        topo = null;
        return toolGeoJSON.readGeometry(buffer, null);
    }


    /**
     * 从构成多线几何体的所有点中，获取离传入坐标最近的一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 多线几何体上的一个点。
     */
    getClosestPoint(coord) {
        let point,minDistance=Number.POSITIVE_INFINITY;
        for (let i = 0, len = this._lines.length; i < len; ++i) {
            let points = this._lines[i].getVertices();
            for (let k = 0, lenk = points.length; k < lenk; k++) {
                const value = points[k];
                const dist = value.getCoordinate().get3Dist(coord);
                if (dist < minDistance) {
                    minDistance = dist;
                    point = value;
                }
            }
        }
        return point;
    }

    /**
     * 计算多线几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 返回多线几何体的地理范围。
     */
    getExtent() {
        this.getBBox();
        return this._extent;
    }

    /**
     * 计算多线几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回多线几何体的三维包围盒。
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._pointsChanged = false;
            this._extent = this._bbox.getExtent();
        }
        return this._bbox;
    }

    /**
     * 获取几何体类型。
     * @returns {String} 几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.MultiLine;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if(!geom.getType){
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': ()=>{return hmap.strategy.Intersect.pointIntersectMultiLine2D(geom,this);},
            'MultiPoint': ()=>{return hmap.strategy.Intersect.multiPointIntersectMultiLine2D(geom,this);},
            'Line': ()=>{return hmap.strategy.Intersect.lineIntersectMultiLine2D(geom,this);},
            'LinearRing':()=>{return hmap.strategy.Intersect.lineIntersectMultiLine2D(geom,this);},
            'Triangle':()=>{return hmap.strategy.Intersect.multiLineIntersectPolygon2D(this,geom.toPolygon());},
            'MultiLine': ()=>{return hmap.strategy.Intersect.multiLineIntersectMultiLine2D(this,geom);},
            'Circle':()=>{return hmap.strategy.Intersect.multiLineIntersectPolygon2D(this,geom.toPolygon());},
            'Rectangle':()=>{return hmap.strategy.Intersect.multiLineIntersectPolygon2D(this,geom.toPolygon());},
            'Polygon': ()=>{return hmap.strategy.Intersect.multiLineIntersectPolygon2D(this,geom);},
            'MultiPolygon': ()=>{return hmap.strategy.Intersect.multiLineIntersectMultiPolygon2D(this,geom);},
            'Collection': ()=>{return geom.intersectsGeometry(this);}
        }[geom.getType()]();
    }

    /**
     * 自相交判断。
     * @return {Boolean} true表示自相交，false表示不自相交
     */
    isSelfIntersects() {
        for(let i = 0, len = this.getLineCount(); i < len; i++){
            let line = this.getLine(i);

            //如果有一条线是自相交的，则多线是自相交的。
            if(line.isSelfIntersects()){
                return true;
            }
            //判断当前线跟其他线是否相交
            for (let j = i + 1; j < len; j++) {
                let line2 = this.getLine(j);
                if (hmap.strategy.Intersect.lineIntersectLine2D(line, line2)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid() {

    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.MultiLine} 移动后的多线几何体。
     */
    moveByDelta(deltaX=0, deltaY=0, deltaZ=0) {
        if(!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)){
            throw new Error("parameter must be number!");
        }
        for(let i=0,len=this._lines.length;i<len;i++){
            this._lines[i].moveByDelta(deltaX,deltaY,deltaZ);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     */
    rotate(axis,angle,center) {
        for(let i=0,len=this._lines.length;i<len;i++){
            this._lines[i].rotate(axis,angle,center);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.MultiLine} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor,origin) {
        if(!origin){
            origin = this.getExtent().getCenter();
        }
        for(let i=0,len=this._lines.length;i<len;i++){
            this._lines[i].scale(xFactor, yFactor, zFactor,origin);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 简化多线几何体。在尽可能不改变原几何体形状的情况下，减少构成几何体的坐标数量。采用道格拉斯-普克算法。
     * 构成多线几何体的每条线中应至少包含三个点，若点个数小于3，则不做任何处理。
     * @param {Number} tolerance 道格拉斯算法中简化所用的容差值，即:简化的参考值。容差值越大,构成几何体的坐标数量越少。容差值大于等于0。
     * @returns {hmap.geom.MultiLine} 返回简化后的几何体。
     */
    simplify(tolerance) {
        for(let i =0;i<this._lines.length;i++){
            this._lines[i].simplify(tolerance);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance 拾取容差
     * @return {Number} 射线上距离要素最近的点到相机的距离
     * @private
     */
    intersectRay(ray, tolerance) {
        let minDistance = Number.POSITIVE_INFINITY;
        for(let n=0,length=this.getLineCount();n<length;n++){
            let line=this.getLine(n);
            let results = hmap.strategy.Intersect3D.lineToLine(line, ray._line);
            for (let i = 0, len = results.length; i < len; i++) {
                let result = results[i];
                if (result && result.distance < tolerance) {
                    let distanceToCamera =  ray.distanceSquare(result.point);
                    if (distanceToCamera < minDistance) {
                        minDistance = distanceToCamera;
                    }
                }
            }
        }
        if (Number.isFinite(minDistance)) {
            return minDistance;
        }
        return null;
    }

    /**
     * 将一个多线几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.MultiLine} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this._lines.length; i < l; i++) {
            this._lines[i].transform(source, destination);
        }
        this._pointsChanged = true;
        return this;
    }

    /*---------以下为私有方法--------------*/

    /**
     * 计算多线几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回多线几何体的地理范围。
     * @private
     */
    _calculateBBox() {
        let l = this._lines.length;
        if(l === 0){
            return null;
        }
        this._bbox = this._lines[0].getBBox();
        for (let i = 1; i < l; i++) {
            this._bbox.extendBBox(this._lines[i].getBBox());
        }

        return this._bbox;
    }

    /**
     * 根据line更新MultiLine的extent
     * @param line
     * @private
     */
    _extendExtent(line) {
        this._extent=this._extent.extendExtent(line.getExtent());
    }

    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * multiLine.destroy();
     * let result = multiLine.CLASS_NAME;
     */
    destroy() {
        super.destroy();
    }

    /**
     * 根据line更新MultiLine的bbox
     * @param line
     * @private
     */
    _extendBBox(line) {
        this._bbox.extendBBox(line.getBBox());
        this._extent = this._bbox.getExtent();
    }
};
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 多点几何体。由多个点组成的几何体。
 * @type {hmap.geom.MultiPoint}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let point1 = new hmap.geom.Point(coord1);
 * let point2 = new hmap.geom.Point(coord2);
 * let multiPoint = new hmap.geom.MultiPoint([point1,point2]);
 */
hmap.geom.MultiPoint = class extends hmap.geom.Geometry {

    /**
     * 构造一个多点几何体。
     * @param {Array<hmap.geom.Point>} points 点状几何体数组。
     */
    constructor(points) {
        super();
        if (!(points instanceof Array)) {
            throw new Error("parameter is not an array of Points!");
        }
        let flags = points.every(function (value) {
            return value instanceof hmap.geom.Point;
        });
        if (!flags) {
            throw new Error("parameter is not an array of all Point!");
        }
        this._points = points;
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this.CLASS_NAME = "hmap.geom.MultiPoint";
    }

    /**
     * 追加点状几何体到多点几何体中。
     * @param {hmap.geom.Point} point 点状几何体。
     * @param {Number} index 点的索引位置。在多点几何体中，点的顺序不影响几何位置、形状。因此该参数不是必需的。
     * @return {hmap.geom.MultiPoint} 添加点状几何体后的多点几何体。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let multiPoint = new hmap.geom.MultiPoint([point1,point2]);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let point3 = new hmap.geom.Point(coord3);
     * let result = multiPoint.addPoint(point3,1);
     */
    addPoint(point, index = 0) {
        if (!(Number.isFinite(index))) {
            throw new Error("parameter is not available!");
        }
        if (!(point instanceof hmap.geom.Point)) {
            throw new Error("parameter is not Point!");
        }
        let i = index;
        if (i < 0) {
            i = 0;
        }
        this._points.splice(i, 0, point);
        this._pointsChanged = true;
        return this;
    }

    /**
     * 删除一个点。
     * @param {hmap.geom.Point} point 要删除的点对象。
     * @return {Number} 删除点的个数，删除失败则返回-1。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let multiPoint = new hmap.geom.MultiPoint([point1,point2]);
     * let result = multiPoint.removePoint(point2);//result=1
     */
    removePoint(point) {
        let newArray = [];
        let removeN = 0;
        const lengthP = this._points.length;
        if (!(point instanceof hmap.geom.Point)) {
            removeN = -1;
            return removeN;
        }
        for (let i = 0; i < lengthP; i++) {
            if (!(point.equals(this._points[i]))) {
                newArray.push(this._points[i]);
            }
        }
        removeN = lengthP - newArray.length;
        this._points = newArray;
        this._pointsChanged = true;
        return removeN;
    }

    /**
     * 提取多点几何体的坐标数组。
     * @returns {Array<hmap.basetype.Coordinate>} 坐标数组
     */
    getCoordinates() {
        let arrayC = [];
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            const value = this._points[i];
            arrayC.push(value.getCoordinate());
        }
        return arrayC;
    }

    /**
     * 获取多点几何体中指定索引处的点几何体。
     * @param {Number} index 点几何体在多点几何体中的索引。
     * @returns {hmap.geom.Point} 一个点几何体。
     */
    getPoint(index) {
        const length = this._points.length;
        if (!(Number.isFinite(index)) || index < 0 || index >= length) {
            throw new Error("parameter is not available!");
        }
        return this._points[index];
    }

    /**
     * 多点几何体中包含的点几何体的数量。
     * @returns {Number} 点几何体数量。
     */
    getPointCount() {
        return this._points.length;
    }

    /**
     * 多点几何体包含的所有点几何体。
     * @returns {Array<hmap.geom.Point>} 返回所有点几何体的数组。
     */
    getPoints() {
        return this._points;
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        for (let i = 0; i < this._points.length; i++) {
            this._points[i].applyTransform(callback);
        }
        this._pointsChanged = true;
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        const extent = this.getExtent();
        return extent.containsCoord(coord);
    }

    /**
     * 复制一个多点几何体对象。
     * @returns {hmap.geom.MultiPoint} 返回新的多点几何体。
     */
    clone() {
        const newPoints = [...this._points].map(point => point.clone());
        return new hmap.geom.MultiPoint(newPoints);
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false。
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options) {
        let result, best, distance;
        let min = Number.POSITIVE_INFINITY;
        for (let i = 0, len = this._points.length; i < len; ++i) {
            result = this._points[i].distanceTo(geometry, options);
            distance = (result.distance || result.distance == 0) ? result.distance : result; //distance可能为负数,因此要分开处理
            if (Math.abs(distance) < Math.abs(min)) { //最小距离
                min = distance;
                best = result;
            }
        }
        return best;
    }

    /**
     * 计算几何体的缓冲区。
     * @param {Number} dist 缓冲距离,,地图单位，且是大于0的数字。
     * @returns {hmap.geom.Polygon|hmap.geom.MultiPolygon} 缓冲区。
     */
    getBuffer(dist) {
        const arrBuffer=[];
        const toolGeoJSON = new hmap.format.GeoJSON();
        for (let i = 0, len = this.getPointCount(); i < len; i++) {
            // arrBuffer.push(this.getPoint(i).getBuffer(dist).toPolygon());
            arrBuffer.push(toolGeoJSON.writeGeometry(this.getPoint(i).getBuffer(dist).toPolygon()));
        }
        let topo = new hmap.strategy.TopologyBoolean();
        const buffer = topo.unionPolygons(arrBuffer);
        topo = null;
        return toolGeoJSON.readGeometry(buffer, null);

    }

    /**
     * 获取多点几何体对象的质心。
     * @return {hmap.basetype.Coordinate} 质心的地理坐标。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let multiPoint = new hmap.geom.MultiPoint([point1,point2]);
     * let result = multiPoint.getCentroid();
     * //result=new hmap.basetype.Coordinate(120.5, 30.5, 0)
     */
    getCentroid() {
        let sumX = 0;
        let sumY = 0;
        let sumZ = 0;
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            const value = this._points[i];
            sumX += value.getCoordinate().getOrdinate("X");
            sumY += value.getCoordinate().getOrdinate("Y");
            sumZ += value.getCoordinate().getOrdinate("Z");
        }
        sumX = sumX / length;
        sumY = sumY / length;
        sumZ = sumZ / length;
        return new hmap.basetype.Coordinate(sumX, sumY, sumZ);
    }

    /**
     * 从构成多点几何体的所有点中，获取离传入坐标最近的一个点。传入坐标到多点距离都相等时，返回多点几何体的第一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 多点几何体上的一个点。
     */
    getClosestPoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        let minD = this._points[0].getCoordinate().get3Dist(coord);
        let point = this._points[0];
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            const value = this._points[i];
            const dist = value.getCoordinate().get3Dist(coord);
            if (dist < minD) {
                minD = dist;
                point = value;
            }
        }
        return point;
    }

    /**
     * 计算多点几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @returns {hmap.basetype.Extent} 返回多点几何体的地理范围。
     */
    getExtent() {
        this.getBBox();
        return this._bbox.getExtent();
    }

    /**
     * 获取几何体类型。
     * @returns {String} 返回几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.MultiPoint;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectMultiPoint2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectMultiPoint2D(this, geom);
            },
            'Line': () => {
                return hmap.strategy.Intersect.multiPointIntersectLine2D(this, geom);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.multiPointIntersectLine2D(this, geom);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.multiPointIntersectPolygon2D(this, geom.toPolygon());
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.multiPointIntersectMultiLine2D(this, geom);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.multiPointIntersectPolygon2D(this, geom.toPolygon());
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.multiPointIntersectPolygon2D(this, geom.toPolygon());
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.multiPointIntersectPolygon2D(this, geom);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.multiPointIntersectMultiPolygon2D(this, geom);
            },
            'Collection': () => {
                return geom.intersectsGeometry(this);
            }
        } [geom.getType()]();
    }

    /**
     * (暂未启用)自相交判断。
     * @return {Boolean} 返回true表示相交；返回false表示不相交
     */
    isSelfIntersects() {
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} 返回true表示有效；返回false表示无效。
     */
    isValid() {}

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.MultiPoint} 移动后的多点几何体。
     */
    moveByDelta(deltaX, deltaY, deltaZ) {
        if (!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)) {
            throw new Error("parameter must be number!");
        }
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            this._points[i].moveByDelta(deltaX, deltaY, deltaZ);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认值为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针旋转为正，顺时针旋转为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.MultiPoint} 返回旋转后的多点。
     */
    rotate(axis, angle, center) {
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            this._points[i].rotate(axis, angle, center);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.MultiPoint} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        if (!origin) {
            origin = this.getExtent().getCenter();
        }
        const length = this._points.length;
        for (let i = 0; i < length; i++) {
            this._points[i].scale(xFactor, yFactor, zFactor, origin);
        }
        this._pointsChanged = true;
    }

    /**
     * (多点简化无意义，接口不开放)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。采用道格拉斯-普克算法，每条用于构成几何体的线中应至少包含三个坐标，若坐标个数小于3，则不做任何处理。
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.MultiPoint} 返回简化后的几何体。
     * @private
     */
    simplify(tolerance) {
        return this;
    }

    /**
     * 将一个多点几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.MultiPoint} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this._points.length; i < l; i++) {
            this._points[i].transform(source, destination);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let multiPoint = new hmap.geom.MultiPoint([point1,point2]);
     * multiPoint.destroy();
     * let result = multiPoint.CLASS_NAME;//result=undefined即multiPoint对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 计算多点几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回该多点几何体的三维包围盒。
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._pointsChanged = false;
        }
        return this._bbox;
    }

    /**
     * 计算多点几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回多点几何体的地理范围。
     * @private
     */
    _calculateBBox() {
        let length = this._points.length;
        if (length === 0) {
            return new hmap.basetype.BBox(0, 0, 0, 0, 0, 0);
        }
        let coordinate = this._points[0].getCoordinate();
        let left = coordinate.getOrdinate("X"),
            right = coordinate.getOrdinate("X"),
            back = coordinate.getOrdinate("Y"),
            front = coordinate.getOrdinate("Y"),
            up = coordinate.getOrdinate('Z'),
            bottom = coordinate.getOrdinate('Z');
        for (let i = 1; i < length; i++) {
            coordinate = this._points[i].getCoordinate();
            let x = coordinate.getOrdinate("X"),
                y = coordinate.getOrdinate("Y"),
                z = coordinate.getOrdinate('Z');
            left = Math.min(left, x);
            right = Math.max(right, x);
            front = Math.min(front, y);
            back = Math.max(back, y);
            up = Math.max(up, z);
            bottom = Math.min(bottom, z);
        }
        return new hmap.basetype.BBox(left, front, bottom, right, back, up);
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray  射线
     * @param {Number}tolerance 拾取容差
     * @return {Number} 射线上距离要素最近的点到相机的距离
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        let minDistanceToCamera = Number.POSITIVE_INFINITY;
        for (let i = 0, len = this._points.length; i < len; i++) {
            let result = hmap.strategy.Intersect3D.pointToSegment(this._points[i].getCoordinate(),
                ray._line.getVertices()[0].getCoordinate(), ray._line.getVertices()[1].getCoordinate(),offset);
            if(!result) continue;
            let minDistance = result.distance; //点到直线的距离
            if (minDistance < tolerance) {
                let pointToCamera = ray.distanceSquare(result.point); //最近点到相机的距离
                if (pointToCamera < minDistanceToCamera) {
                    minDistanceToCamera = pointToCamera;
                }
            }
        }
        if (Number.isFinite(minDistanceToCamera)) {
            return minDistanceToCamera;
        }
        return null;
    }
};
;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 多面几何体。由多个简单多边形组成的复杂几何体，至少包含一个简单多边形。
 * 至少由一个简单面状几何体组成的数组。
 * @type {hmap.geom.MultiPolygon}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(120,30,0);
 * let coord3 = new hmap.basetype.Coordinate(120,30,0);
 * let coord4 = new hmap.basetype.Coordinate(120,30,0);
 * let p1 =  new hmap.geom.Point(coord1);
 * let p2 =  new hmap.geom.Point(coord2);
 * let p3 =  new hmap.geom.Point(coord3);
 * let p4 =  new hmap.geom.Point(coord4);
 * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
 * let polygon1 = new hmap.geom.Polygon([linearRing]);
 * let polygon2 = polygon1.clone();
 * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
 */
hmap.geom.MultiPolygon = class extends hmap.geom.Geometry {
    /**
     * 构造一个多面几何体。
     * @param {Array<hmap.geom.Polygon>} polygons 面状几何体数组。
     */
    constructor(polygons) {
        const flag = polygons instanceof Array && polygons.length > 0;
        if (!flag) {
            throw 'Parameter "polygons" is not an Array or contains no polygon!';
        }
        super();
        this.polygons = new Array();
        for (let p of polygons) {
            if (p instanceof hmap.geom.Polygon) {
                this.polygons.push(p);
            } else {
                throw 'All elements in "polygons" must be type of hmap.geom.Polygon!';
            }
        }
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this._extent = this._bbox.getExtent();
        this.CLASS_NAME = "hmap.geom.MultiPolygon";
    }

    /**
     * 追加一个面状几何体到当前几何体中。
     * @param {hmap.geom.Polygon} polygon 面状几何体。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,30,0);
     * let coord3 = new hmap.basetype.Coordinate(120,31,0);
     * let coord4 = new hmap.basetype.Coordinate(122,32,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon1 = new hmap.geom.Polygon([linearRing]);
     * let polygon2 = polygon1.clone();
     * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
     * let extent = new hmap.basetype.Extent(120.1,30.07,120.7,30.3);
     * let polygon3 = hmap.geom.Polygon.fromExtent(extent);
     * multiPolygon.addPolygon(polygon3);
     */
    addPolygon(polygon) {
        if (polygon instanceof hmap.geom.Polygon) {
            this.polygons.push(polygon);
            this._bbox.extendBBox(polygon.getBBox());
            this._extent = this._bbox.getExtent();
        }
    }

    /**
     * 计算多面几何体的面积。计算结果为每个面状几何体的面积的累加值。
     * @returns {Number} 面积。
     * @example
     * let extent1 = new hmap.basetype.Extent(120.1,30.07,120.7,30.3);
     * let extent2 = new hmap.basetype.Extent(120.2,30.08,120.8,30.4);
     * let polygon1 = hmap.geom.Polygon.fromExtent(extent1);
     * let polygon2 = hmap.geom.Polygon.fromExtent(extent2);
     * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
     * let result = multiPolygon.getArea();//result=0.660000000000001
     */
    getArea() {
        //计算每一个多边形的面积
        let sumArea = 0;
        for (let p of this.polygons) {
            sumArea = sumArea + p.getArea();
        }
        return sumArea;
    }

    /**
     * 提取多面中每个面的坐标序列数组，返回值为每个面构成的二维数组。从起始索引开始提取，取到结束索引的前一位，即按“前闭后开”的原则进行提取坐标序列。
     * 1.当startIndex小于0时则取0，当endIndex大于坐标序列长度时取坐标序列长度；
     * 2.当endIndex未传入时，返回startIndex以后的Array<CoordSeq>；
     * 3.如果startIndex与endIndex参数为空，返回所有Array<CoordSeq>。
     * 4.当startIndex大于等于endIndex，返回空数组。
     * @param startIndex 起始索引。如果不传，默认是0。
     * @param endIndex 结束索引。如果不传，默认是坐标序列数组长度值。
     * @returns {Array<Array<hmap.basetype.CoordSeq>>} 返回的坐标序列二维数组，一个面的坐标序列为二维数组中的一个元素
     * @example
     * let extent1 = new hmap.basetype.Extent(120.1,30.07,120.7,30.3);
     * let extent2 = new hmap.basetype.Extent(120.2,30.08,120.8,30.4);
     * let polygon1 = hmap.geom.Polygon.fromExtent(extent1);
     * let polygon2 = hmap.geom.Polygon.fromExtent(extent2);
     * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
     * let result = multiPolygon.getCoordSeqs();
     * // result = [
     * //          [hmap.basetype.CoordSeq([new hmap.basetype.Coordinate(120.1,30.07),new hmap.basetype.Coordinate(120.1,30.3),……]),
     * //          [hmap.basetype.CoordSeq([new hmap.basetype.Coordinate(120.2,30.08),new hmap.basetype.Coordinate(120.2,30.04),……]
     * //          ]
     */
    getCoordSeqs(startIndex = 0, endIndex = this.polygons.length) {
        if (!Number.isFinite(startIndex) || !Number.isFinite(endIndex)) {
            throw "the parameters must be number!";
        }
        const len = this.polygons.length;
        startIndex = (startIndex <= 0) ? 0 : Number.parseInt(startIndex);
        endIndex = (endIndex >= len) ? len : Number.parseInt(endIndex);

        if (startIndex >= endIndex) {
            return [];
        }

        let arr = [];
        for (let i = startIndex; i < endIndex; i++) {
            arr.push(this.polygons[i].getCoordSeqs(0, this.polygons[i].getLinearRingCount()));
        }
        return arr;
    }

    /**
     * 获取指定索引处的面状几何体。
     * @param {Number} index>=0 面状几何体在多面几何体中的索引。如果索引超出MultiPolygon中的面的个数，则返回undefined
     * @returns {hmap.geom.Polygon} 指定索引处的面状几何体。
     */
    getPolygon(index) {
        return this.polygons[index];
    }

    /**
     * 返回多面几何体的所有几何体的数量。
     * @returns {Number} 所有几何体的数量。
     */
    getPolygonCount() {
        return this.polygons.length;
    }

    /**
     * 获取所有面状几何体。
     * @returns {Array<hmap.geom.Polygon>} 面状几何体数组。
     */
    getPolygons() {
        return this.polygons;
    }


    //================继承自Gemoetry的方法======================

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Function} callback 用于处理坐标值的回调函数，回调函数的参数为坐标对象，该回调函数会作用在几何体的每个坐标上。
     */
    applyTransform(callback) {
        for (let i = 0; i < this.polygons.length; i++) {
            this.polygons[i].applyTransform(callback);
        }
        this._pointsChanged = true;
        this.getExtent();
    }

    /**
     * 检测一个坐标是否在几何体的边界范围以内。 本计算基于边界盒与坐标的相交运算，不包含高程方向的运算，一般用于近似相交判断。注意：与边界盒相交的坐标不一定在几何体内，可能会在几何体的边缘以外附近。
     * 边界盒：即几何体的地理范围构成的多边形区域。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。
     * @returns {Boolean} 返回true表示在几何体的边界盒范围以内；返回false表示不在几何体的边界盒范围以内。
     */
    atApproximatePoint(coord) {
        if (coord instanceof hmap.basetype.Coordinate) {
            return this.getExtent().containsCoord(coord);
        } else {
            throw new TypeError("the parameter is not Coordinate!");
        }
    }

    /**
     * 复制一个多面。
     * @return {hmap.geom.MultiPolygon} 新的多面。
     */
    clone() {
        const newPolygons = [...this.polygons].map(polygon => polygon.clone());
        return new hmap.geom.MultiPolygon(newPolygons);
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options) {
        let result, best, distance;
        let min = Number.POSITIVE_INFINITY;
        //遍历获取多面几何体距离一个几何体的距离
        for (let i = 0, len = this.polygons.length; i < len; ++i) {
            result = this.polygons[i].distanceTo(geometry, options);
            distance = (result.distance || result.distance == 0) ? result.distance : result;
            if ((min < 0 && distance > min && distance < 0) || (min > 0 && distance < min)) {
                min = distance;
                best = result;
                if (min === 0) {
                    break;
                }
            }
        }
        return best;
    }

    /**
     * 计算多面的缓冲区。
     * @param {Number} dist 缓冲距离,地图单位，且是大于0的数字。注意，缓冲半径过大可能出现重叠或岛洞
     * @param {String} sideType 面缓冲类型，"FULL"：包含原几何体，"OUTSIDE"：不包含原有几何体。
     * @returns {hmap.geom.Polygon|hmap.geom.MultiPolygon} 缓冲区。
     */
    getBuffer(dist, sideType = "FULL") {
        const arrBuffer = [];
        const arrGeoms = [];
        const toolGeo = new hmap.format.GeoJSON();
        for (let i = 0, len = this.getPolygonCount(); i < len; i++) {
            arrGeoms.push(toolGeo.writeGeometry(this.getPolygon(i)));
            arrBuffer.push(toolGeo.writeGeometry(this.getPolygon(i).getBuffer(dist, "FULL")));
        }
        const topo = new hmap.strategy.TopologyBoolean();
        const buffer = topo.unionPolygons(arrBuffer);
        if (sideType.toUpperCase() === "OUTSIDE") {
            const geom = topo.unionPolygons(arrGeoms);
            return toolGeo.readGeometry(topo.difference(buffer, geom), null);
        }
        return toolGeo.readGeometry(buffer, null);
    }

    /**
     * 计算多面的质心。
     * @return {hmap.basetype.Coordinate} 质心的地理坐标。
     * @example
     * let extent1 = new hmap.basetype.Extent(120.1,30.07,120.7,30.3);
     * let extent2 = new hmap.basetype.Extent(120.2,30.08,120.8,30.4);
     * let polygon1 = hmap.geom.Polygon.fromExtent(extent1);
     * let polygon2 = hmap.geom.Polygon.fromExtent(extent2);
     * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
     * let result = multiPolygon.getCentroid();
     */
    getCentroid() {
        let totalX = 0, totalY = 0, totalZ = 0, totalArea = 0;
        let polygonCentroid, polygonArea;
        for (let i = 0; i < this.polygons.length; i++) {
            polygonCentroid = this.polygons[i].getCentroid();
            polygonArea = this.polygons[i].getArea();
            totalX += polygonArea * polygonCentroid.getOrdinate("X");
            totalY += polygonArea * polygonCentroid.getOrdinate("Y");
            totalZ += polygonArea * polygonCentroid.getOrdinate("Z");
            totalArea += polygonArea;
        }
        return new hmap.basetype.Coordinate(totalX / totalArea, totalY / totalArea, totalZ / totalArea);
    }

    /**
     * (暂未启用)从构成多面几何体的所有点中，获取离传入坐标最近的一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 多面几何体上的一个点。
     */
    getClosestPoint(coord) {
        let point, minDistance = Number.POSITIVE_INFINITY;
        for (let i = 0, len = this.getPolygonCount(); i < len; i++) {
            let lineRingArr = this.getPolygon(i).lineRingArr;
            for (let m = 0, len2 = lineRingArr.length; m < len2; m++) {
                let points = lineRingArr[m].getVertices();
                for (let k = 0, len3 = points.length - 1; k < len3; k++) {
                    const value = points[k];
                    const dist = value.getCoordinate().get3Dist(coord);
                    if (dist < minDistance) {
                        minDistance = dist;
                        point = value;
                    }
                }
            }
        }
        return point;
    }

    /**
     * 计算多面几何体的地理范围。该地理范围界定了X-Y平面的边界，不含高程信息。
     * @return {hmap.basetype.Extent} 返回多面几何体的地理范围。
     */
    getExtent() {
        this.getBBox();
        return this._extent;
    }

    /**
     * 计算多面几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回多面几何体的三维包围盒。
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._extent = this._bbox.getExtent();
            this._pointsChanged = false;
        }
        return this._bbox;
    }

    /**
     * 计算周长。如果polygonIndex和linearRingIndex都未设置，则返回所有多边形中所有线环的长度和；如果参数linearRingIndex未设置，
     * 则返回指定多边形中所有线环的长度和；如果polygonIndex未设置，返回每个多边形中指定线环的长度和。
     * @param {Number} polygonIndex  面几何体索引。
     * @param {Number} linearRingIndex  线环索引。
     * @param {String} srid  坐标系id，支持4326和3857。
     * @return {Number} 返回指定多边形中的指定线环的长度。
     * @throws polygonIndex和linearRingIndex不是数字，或者超出索引范围时，抛出异常。
     */
    getPerimeter(polygonIndex, linearRingIndex, srid = 4326) {
        if (polygonIndex == undefined) {
            let totalLength = 0;
            if (linearRingIndex == undefined) {
                for (let i = 0; i < this.polygons.length; i++) {
                    totalLength += this.polygons[i].getPerimeter(null, srid);
                }
            } else {
                if (!Number.isFinite(linearRingIndex)) {
                    throw "linearRingIndex must be a Number!";
                }
                for (let i = 0; i < this.polygons.length; i++) {
                    if (linearRingIndex < 0 || linearRingIndex >= this.polygons[i].getLinearRingCount()) {
                        throw "linearRingIndex out of range!";
                    }
                    totalLength += this.polygons[i].getLinearRing(linearRingIndex).getLength(srid);
                }
            }
            return totalLength;
        } else {
            if (typeof (polygonIndex) !== 'number') {
                throw "polygonIndex must be a Number!";
            }
            if (polygonIndex < 0 || polygonIndex >= this.getPolygonCount()) {
                throw "polygonIndex out of range!";
            }
            if (linearRingIndex == undefined) {
                return this.polygons[polygonIndex].getPerimeter(null, srid);
            } else {
                if (!Number.isFinite(linearRingIndex)) {
                    throw "linearRingIndex must be a Number!";
                }
                if (linearRingIndex < 0 || linearRingIndex >= this.polygons[polygonIndex].getLinearRingCount()) {
                    throw "linearRingIndex out of range!";
                }
                return this.polygons[polygonIndex].getLinearRing(linearRingIndex).getLength(srid);
            }
        }
    }

    /**
     * 获取几何体类型。
     * @returns {String} 返回几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.MultiPolygon;
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectMultiPolygon2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectMultiPolygon2D(geom, this);
            },
            'Line': () => {
                return hmap.strategy.Intersect.lineIntersectMultiPolygon2D(geom, this);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.lineIntersectMultiPolygon2D(geom, this);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.polygonIntersectMultiPolygon2D(geom.toPolygon(), this);
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.multiLineIntersectMultiPolygon2D(geom, this);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.polygonIntersectMultiPolygon2D(geom.toPolygon(), this);
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.polygonIntersectMultiPolygon2D(geom.toPolygon(), this);
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.polygonIntersectMultiPolygon2D(geom, this);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.multiPolygonIntersectMultiPolygon2D(this, geom);
            },
            'Collection': () => {
                return geom.intersectsGeometry(this);
            }
        }[geom.getType()]();
    }

    /**
     * 自相交判断。
     * @return {Boolean} true表示自相交，false表示不自相交
     */
    isSelfIntersects() {
        for (let i = 0, len = this.getPolygons().length; i < len; i++) {
            let polygon = this.getPolygon(i);
            if (polygon.isSelfIntersects()) {
                return true;
            }
            for (let j = i + 1; j < len; j++) {
                let polygon1 = this.getPolygon(j)
                if (hmap.strategy.Intersect.polygonIntersectPolygon2D(polygon, polygon1)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * (暂未启用)检测当前几何体是否有效。
     * 有效判断的标准为：1、在坐标系已知的情况下，坐标值是否有效；2、几何体自身的拓扑关系是否有效。线的自相交、面的八字形状判断。
     * @private
     * @returns {Boolean} true表示有效，false表示无效。
     */
    isValid() {
    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。如果参数为负，则向坐标轴负向偏移。
     * 该方法不会改变几何体的形状，但可能改变原几何体的位置，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} deltaX X坐标轴方向的平移量。
     * @param {Number} deltaY Y坐标轴方向的平移量。
     * @param {Number} deltaZ Z坐标轴方向的平移量。
     * @returns {hmap.geom.MultiPolygon} 移动后的多面几何体。
     */
    moveByDelta(deltaX = 0, deltaY = 0, deltaZ = 0) {
        if (!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)) {
            throw new Error("parameter must be number!");
        }

        for (let i = 0; i < this.polygons.length; i++) {
            this.polygons[i] = this.polygons[i].moveByDelta(deltaX, deltaY, deltaZ);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 以某个坐标为中心，绕坐标轴旋转。绕轴旋转的本质如下： 绕Z轴旋转即是在XY平面内旋转；绕X轴旋转即是在YZ平面内旋转；绕Y轴旋转即是在XZ平面内旋转
     * @param {String} axis   坐标轴。可选值为"X","Y","Z"
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针为正，顺时针为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     */
    rotate(axis, angle, center) {
        for (let i = 0, len = this.polygons.length; i < len; i++) {
            this.polygons[i].rotate(axis, angle, center);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 按各坐标轴的缩放比例和指定的缩放原点进行缩放几何体。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param {Number} xFactor X坐标值缩放比例，必须大于0。
     * @param {Number} yFactor Y坐标值缩放比例，必须大于0。
     * @param {Number} zFactor Z坐标值缩放比例，必须大于0。
     * @param {hmap.basetype.Coordinate} origin 缩放原点，以该点为参考点进行缩放。默认以几何体地理范围的中心点进行缩放。
     * @returns {hmap.geom.MultiPolygon} 返回缩放后的几何体。
     * @throws {RangeError} 当xFactor, yFactor, zFactor的值不为正时。
     * @throws {TypeError} origin类型错误时。
     */
    scale(xFactor, yFactor, zFactor, origin) {
        if (!origin) {
            origin = this.getExtent().getCenter();
        }
        for (let i = 0, len = this.polygons.length; i < len; i++) {
            this.polygons[i].scale(xFactor, yFactor, zFactor, origin);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 简化多面几何体。在尽可能不改变原几何体形状的情况下，减少构成几何体的坐标数量。采用道格拉斯-普克算法。
     * 简化后，构成多面几何体的每个面的每条线环中应至少包含三个点。
     * @param {Number} tolerance 道格拉斯算法中简化所用的容差值，即:简化的参考值。容差值越大,构成几何体的坐标数量越少。容差值大于等于0。
     * @returns {hmap.geom.MultiPolygon} 返回简化后的几何体。
     */
    simplify(tolerance) {
        for (let i = 0; i < this.polygons.length; i++) {
            this.polygons[i].simplify(tolerance);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 将一个多面几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.MultiPolygon} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this.polygons.length; i < l; i++) {
            this.polygons[i].transform(source, destination);
        }
        this._pointsChanged = true;
        this._extent = this.getExtent();
        return this;
    }

    /**
     * 计算多面三维包围盒。
     * @returns {hmap.basetype.BBox}
     * @private
     */
    _calculateBBox() {
        let l = this.polygons.length;
        if (l == 0) {
            return null;
        }
        this._bbox = this.polygons[0].getBBox();
        for (let i = 1; i < l; i++) {
            this._bbox.extendBBox(this.polygons[i].getBBox());
        }
        return this._bbox;
    }


    /**
     * 销毁对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(120,30,0);
     * let coord3 = new hmap.basetype.Coordinate(120,30,0);
     * let coord4 = new hmap.basetype.Coordinate(120,30,0);
     * let p1 =  new hmap.geom.Point(coord1);
     * let p2 =  new hmap.geom.Point(coord2);
     * let p3 =  new hmap.geom.Point(coord3);
     * let p4 =  new hmap.geom.Point(coord4);
     * let linearRing = new hmap.geom.LinearRing([p1,p2,p3,p4]);
     * let polygon1 = new hmap.geom.Polygon([linearRing]);
     * let polygon2 = polygon1.clone();
     * let multiPolygon = new hmap.geom.MultiPolygon([polygon1,polygon2]);
     * multiPolygon.destroy();
     * let result = multiPolygon.CLASS_NAME;//result=undefined即multiPolygon对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance 拾取容差
     * @return {Number} 到相机的距离
     * @private
     */
    intersectRay(ray, tolerance,offset) {
        let minDistanceToCamera = Number.POSITIVE_INFINITY;
        let result = hmap.strategy.Intersect3D.rayIntersectMultiPolygon(ray.origin, ray.direction, this,offset);
        if (result && result.length > 0) {
            for (let i = 0, len = result.length; i < len; i++) {
                let pointToCamera = ray.distanceSquare(result[i]);
                if (pointToCamera < minDistanceToCamera) {
                    minDistanceToCamera = pointToCamera;
                }
            }
        }
        return (Number.isFinite(minDistanceToCamera)) ? minDistanceToCamera : null;
    }
};

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 三角形。由三个点构造。 如果三点共线，则构造失败，抛出异常。
 * @type {hmap.geom.Triangle}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let coord3 = new hmap.basetype.Coordinate(122,32,0);
 * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
 */
hmap.geom.Triangle=class extends hmap.geom.Geometry{
    /**
     * 三角形构造函数
     * @param {hmap.basetype.Coordinate} a  第一个点的坐标
     * @param {hmap.basetype.Coordinate} b  第二个点的坐标
     * @param {hmap.basetype.Coordinate} c  第三个点的坐标
     */
    constructor(a,b,c){
        super();
        if(!(a instanceof hmap.basetype.Coordinate)||!(b instanceof hmap.basetype.Coordinate)||!(c instanceof hmap.basetype.Coordinate)){
            throw new TypeError("parameter is not Coordinate!");
        }
        //向量a-->b和向量a-->c
        let vecA=[b.getOrdinate("X")-a.getOrdinate("X"),b.getOrdinate("Y")-a.getOrdinate("Y"),b.getOrdinate("Z")-a.getOrdinate("Z")];
        let vecB=[c.getOrdinate("X")-a.getOrdinate("X"),c.getOrdinate("Y")-a.getOrdinate("Y"),c.getOrdinate("Z")-a.getOrdinate("Z")];
        //向量vecA X vecB
        let vecX=[(vecA[1]*vecB[2]-vecB[1]*vecA[2]),(vecA[2]*vecB[0]-vecA[0]*vecB[2]),(vecA[0]*vecB[1]-vecA[1]*vecB[0])];
        //计算叉乘向量的模值平方，为0则三点共线
        let modelValue=Math.pow(vecX[0],2)+Math.pow(vecX[1],2)+Math.pow(vecX[2],2);
        if(!modelValue){
            throw new Error("three Coordinates are in same line!");
        }
        this._aCoord=a.clone();
        this._bCoord=b.clone();
        this._cCoord=c.clone();
        this._bbox = this._calculateBBox();
        this._pointsChanged = false;
        this.CLASS_NAME = "hmap.geom.Triangle";
    }

    /**
     * 计算面积
     * @return {Number} 返回面积值,单位是坐标单位的平方
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * let result = triangle.getArea();//result=1
     */
    getArea(){
        let arrayVector=this._getVAndN();
        let vecX=arrayVector[3];
        //计算叉乘向量的模值平方，为0则三点共线
        let modelValue=Math.pow(vecX[0],2)+Math.pow(vecX[1],2)+Math.pow(vecX[2],2);
        return Math.sqrt(modelValue)/2;
    }

    /**
     * 提取几何体坐标序列
     * @return {Array<hmap.basetype.CoordSeq>} 返回坐标序列数组，鉴于Triangle坐标序列数组只有一个，可以通过getCoordSeq 直接返回该坐标序列对象。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * let result = triangle.getCoordSeqs();
     */
    getCoordSeqs(){
        return [this.getCoordSeq()];
    }
    getCoordSeq(){
        return new hmap.basetype.CoordSeq([this._aCoord,this._bCoord,this._cCoord]);
    }
    getCircumCenter(){

    }

    /**
     * 获取三角形内切圆圆心，即三角形内心的坐标。
     * @returns {hmap.basetype.Coordinate} 返回三角形内心的坐标。
     */
    getInCenter(){
        let xa = this._aCoord.getOrdinate('X'),
            ya = this._aCoord.getOrdinate('Y'),
            za = this._aCoord.getOrdinate('Z'),
            xb = this._bCoord.getOrdinate('X'),
            yb = this._bCoord.getOrdinate('Y'),
            zb = this._bCoord.getOrdinate('Z'),
            xc = this._cCoord.getOrdinate('X'),
            yc = this._cCoord.getOrdinate('Y'),
            zc = this._cCoord.getOrdinate('Z'),
            va = new hmap.util.Vector3(xa, ya, za),
            vb = new hmap.util.Vector3(xb, yb, zb),
            vc = new hmap.util.Vector3(xc, yc, zc),
            la = vb.substract(vc).length(),
            lb = va.substract(vc).length();
        vb.set(xb, yb, zb);
        va.set(xa, ya, za);
        let lc = va.substract(vb).length(),
            sum = la + lb + lc;
        let x = (la * xa + lb * xb + lc * xc) / sum,
            y = (la * ya + lb * yb + lc * yc) / sum,
            z = (la * za + lb * zb + lc * zc) / sum;
        return new hmap.basetype.Coordinate(x, y, z);
    }

    /**
     * 计算最长边的长度
     * @return {Number} 返回长度值
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * let result = triangle.getLongestSideLength();//result=2
     */
    getLongestSideLength(){
        let arrayVector=this._getVAndN();
        let vecAB=arrayVector[0];
        let vecAC=arrayVector[1];
        let vecBC=arrayVector[2];
        let lengthAB2=Math.pow(vecAB[0],2)+Math.pow(vecAB[1],2)+Math.pow(vecAB[2],2);
        let lengthAC2=Math.pow(vecAC[0],2)+Math.pow(vecAC[1],2)+Math.pow(vecAC[2],2);
        let lengthBC2=Math.pow(vecBC[0],2)+Math.pow(vecBC[1],2)+Math.pow(vecBC[2],2);
        return Math.sqrt(Math.max(lengthAB2,lengthAC2,lengthBC2));
    }
    /**
     * 判断当前三角形是否是锐角三角形
     * @return {Boolean} 锐角三角形返回true;不是锐角三角形返回false
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * let result = triangle.isAcute();//result=false
     */
    isAcute(){
        //利用锐角三角形的判定定理：边a<b<c，a的平方+b的平方>c的平方-->a的平方+b的平方+c的平方>c的平方*2
        let arrayVector=this._getVAndN();
        let vecAB=arrayVector[0];
        let vecAC=arrayVector[1];
        let vecBC=arrayVector[2];
        let lengthAB2=Math.pow(vecAB[0],2)+Math.pow(vecAB[1],2)+Math.pow(vecAB[2],2);
        let lengthAC2=Math.pow(vecAC[0],2)+Math.pow(vecAC[1],2)+Math.pow(vecAC[2],2);
        let lengthBC2=Math.pow(vecBC[0],2)+Math.pow(vecBC[1],2)+Math.pow(vecBC[2],2);
        let flags=lengthAB2+lengthAC2+lengthBC2-2*Math.max(lengthAB2,lengthAC2,lengthBC2);
        if(flags<=0){
            return false;
        }else{
            return true;
        }
    }
    /**
     * 转换成多边形几何体，其中组成多边形的点的顺序是构造三角形时传入的点的顺序。
     * @returns {hmap.geom.Polygon}
     */
    toPolygon(){
       const arrayP=[new hmap.geom.Point(this._aCoord),new hmap.geom.Point(this._bCoord),new hmap.geom.Point(this._cCoord)];
       const lineRing=new hmap.geom.LinearRing(arrayP);
       return new hmap.geom.Polygon([lineRing]);
    }
    /*-----父类方法-----*/
    applyTransform(callback){
        this._aCoord = callback(this._aCoord);
        this._bCoord = callback(this._bCoord);
        this._cCoord = callback(this._cCoord);
        this._pointsChanged = true;
    }

    /**
     * 检测一个坐标是否在该三角形的边界范围以内。
     * @param {hmap.basetype.Coordinate} coord 坐标
     * @returns {Boolean} 范围内返回true;范围外返回false。
     */
    atApproximatePoint(coord){
        if(!(coord instanceof hmap.basetype.Coordinate)){
            throw new TypeError("The coord parameter is not an object of Coordinate!");
        }
        const extent=this.getExtent();
        const flags=extent.containsCoord(coord);
        return flags;
    }

    /**
     * 复制一个几何体
     * @returns {hmap.geom.Triangle}
     */
    clone(){
        return new hmap.geom.Triangle(this._aCoord,this._bCoord,this._cCoord);
    }
    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。
     * 其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。
     * 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options){
        return this.toPolygon().distanceTo(geometry, options);
    }
    /**
     * 获取几何体的缓冲区。缓冲区限于X-Y平面内，非三维空间中的缓冲区
     * @param {Number} dist 缓冲距离，一个正数，单位同地图单位。
     * @param {String} sideType 面缓冲类型，"FULL"：包含原几何体，"OUTSIDE"：不包含原有几何体。
     * @returns {hmap.geom.Polygon} 返回缓冲区几何体
     */
    getBuffer(dist,sideType ="FULL") {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero !");
        }
        const polygonBuffer = new hmap.strategy.PolygonBuffer(this.toPolygon(), dist, sideType);
        return polygonBuffer.build();
    }

    /**
     * 计算三角形的质心
     * @return {hmap.basetype.Coordinate} 返回质心坐标
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * let result = triangle.getCentroid();//result=new hmap.basetype.Coordinate(121,30.333333,0)
     */
    getCentroid(){
        const array=[this._aCoord,this._bCoord,this._cCoord];
        let sumX=0;
        let sumY=0;
        let sumZ=0;
        for(let i=0;i<3;i++){
            const value=array[i];
            sumX+=value.getOrdinate("X");
            sumY+=value.getOrdinate("Y");
            sumZ+=value.getOrdinate("Z");
        }
        return new hmap.basetype.Coordinate(sumX/3,sumY/3,sumZ/3);
    }

    /**
     * 在构成几何体的所有结点中，计算与传入坐标最近的一个节点。如果几何体的节点与传入坐标距离均相同，则返回几何体的第一个节点。
     * @param {hmap.basetype.Coordinate} coord 坐标
     * @returns {hmap.geom.Point} 三角形上的一个点。
     */
    getClosestPoint(coord){
        let array=[this._aCoord,this._bCoord,this._cCoord];
        let coordinate=this._aCoord;
        let distMin=array[0].get3Dist(coord);
        for(let i=1;i<3;i++){
            const value=array[i];
            const dist=value.get3Dist(coord);
            if(dist<distMin){
                coordinate=value;
                distMin=dist;
            }
        }
        return new hmap.geom.Point(coordinate);
    }

    /**
     * 获取几何体地理范围
     * @returns {hmap.basetype.Extent}
     */
    getExtent(){
        return this.getBBox().getExtent();
    }

    /**
     * 获取三角形几何体的三维包围盒。
     * @returns {hmap.basetype.BBox} 三角形几何体三维包围盒
     */
    getBBox() {
        if (this._pointsChanged) {
            this._bbox = this._calculateBBox();
            this._pointsChanged = false;
        }
        return this._bbox;
    }

    _calculateBBox() {
        let coordArr = [this._aCoord, this._bCoord, this._cCoord];
        let coordinate = coordArr[0];
        let left = coordinate.getOrdinate("X"),
            right= coordinate.getOrdinate("X"),
            back= coordinate.getOrdinate("Y"),
            front= coordinate.getOrdinate("Y"),
            up = coordinate.getOrdinate('Z'),
            bottom = coordinate.getOrdinate('Z');
        for(let i=1; i < 3; i++){
            coordinate = coordArr[i];
            let x=coordinate.getOrdinate("X"),
                y=coordinate.getOrdinate("Y"),
                z = coordinate.getOrdinate('Z');
            left = Math.min(left,x);
            right = Math.max(right,x);
            front = Math.min(front,y);
            back = Math.max(back,y);
            up = Math.max(up, z);
            bottom = Math.min(bottom, z);
        }
        return new hmap.basetype.BBox(left, front, bottom, right, back, up);
    }

    /**
     * 获取当前几何体类型
     * @returns {string}
     */
    getType(){
        return hmap.geom.GeometryType.Triangle;
    }

    intersectsGeometry(geom){
        return this.toPolygon().intersectsGeometry(geom);
    }

    /**
     * 是否自相交
     * @returns {Boolean} false，三角形不会自相交。
     */
    isSelfIntersects(){
        return false;
    }

    /**
     * @private
     */
    isValid(){

    }

    /**
     * 沿坐标轴正方向，将几何体的所有坐标按给定的参数偏移。
     * @param {Number} deltaX X轴偏移量
     * @param {Number} deltaY Y轴偏移量
     * @param {Number} deltaZ Z轴偏移量
     * @returns {hmap.geom.Triangle} 偏移之后的三角形对象
     */
    moveByDelta(deltaX,deltaY,deltaZ){
        if(!Number.isFinite(deltaX) || !Number.isFinite(deltaY) || !Number.isFinite(deltaZ)){
            throw new Error("parameter must be number!");
        }
        let array=[this._aCoord,this._bCoord,this._cCoord];
        for(let i=0;i<3;i++){
            const value=array[i];
            value.setOrdinate("X",value.getOrdinate("X")+deltaX);
            value.setOrdinate("Y",value.getOrdinate("Y")+deltaY);
            value.setOrdinate("Z",value.getOrdinate("Z")+deltaZ);
        }
        this._pointsChanged = true;
        return this;
    }

    /**
     * 旋转坐标。旋转后，坐标值可能发生变化
     * @param {String} axis 坐标轴，X、Y、Z之一
     * @param {Number} angle 旋转角度
     * @param {hmap.basetype.Coordinate} center 围绕该中心点旋转三角形。该参数不传时，绕传入的坐标轴旋转。
     * @returns {hmap.geom.Triangle} 旋转后的三角形。
     */
    rotate(axis='Z',angle=0,center){
        this._aCoord.rotate(axis,angle,center);
        this._bCoord.rotate(axis,angle,center);
        this._cCoord.rotate(axis,angle,center);
        this._pointsChanged = true;
        return this;
    }

    /**
     * 坐标缩放
     * @param {Number} scaleX 在X轴方向的缩放，>0的数值。
     * @param {Number} scaleY 在Y轴方向的缩放，>0的数值。
     * @param {Number} scaleZ 在Z轴方向的缩放，>0的数值。
     * @param {hmap.basetype.Coordinate} coordinate 锚点的坐标值,如果不传，以三角形的外接矩形中心点作为缩放中心点
     * @returns {hmap.geom.Triangle} 返回缩放后的三角形。
     * @throws {TypeError} 当coordinate传入但类型错误时，抛出类型错误异常。
     */
    scale(scaleX,scaleY,scaleZ,coordinate){
        if (coordinate != undefined && !(coordinate instanceof hmap.basetype.Coordinate)) {
            throw new TypeError('Parameter "coordinate" must be type of hmap.basetype.Coordinate');
        }
        if(!coordinate){
            coordinate = this.getExtent().getCenter();
        }
        const x=coordinate.getOrdinate("X");
        const y=coordinate.getOrdinate("Y");
        const z=coordinate.getOrdinate("Z");
        this.moveByDelta(-x,-y,-z);
        this._aCoord.scale(scaleX,scaleY,scaleZ);
        this._bCoord.scale(scaleX,scaleY,scaleZ);
        this._cCoord.scale(scaleX,scaleY,scaleZ);
        this.moveByDelta(x,y,z);
        return this;
    }

    /**
     * 将一个三角形几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Triangle} 坐标转换后的几何体。
     */
    transform(source,destination){
        this._aCoord = hmap.proj.Transformer.transform(this._aCoord, source, destination);
        this._bCoord = hmap.proj.Transformer.transform(this._bCoord, source, destination);
        this._cCoord = hmap.proj.Transformer.transform(this._cCoord, source, destination);
        this._pointsChanged = true;
        return this;
    }

    /**
     * 内部方法，返回各边的向量以及平面的法向量
     * @returns {*}
     * @private
     */
    _getVAndN(){
        //向量a-->b和向量a-->c
        let vecA=[this._bCoord.getOrdinate("X")-this._aCoord.getOrdinate("X"),this._bCoord.getOrdinate("Y")-this._aCoord.getOrdinate("Y"),this._bCoord.getOrdinate("Z")-this._aCoord.getOrdinate("Z")];
        let vecB=[this._cCoord.getOrdinate("X")-this._aCoord.getOrdinate("X"),this._cCoord.getOrdinate("Y")-this._aCoord.getOrdinate("Y"),this._cCoord.getOrdinate("Z")-this._aCoord.getOrdinate("Z")];
        //向量vecA X vecB（叉乘）
        let vecX=[(vecA[1]*vecB[2]-vecB[1]*vecA[2]),(vecA[2]*vecB[0]-vecA[0]*vecB[2]),(vecA[0]*vecB[1]-vecA[1]*vecB[0])];
        //向量b-->c的向量
        let vecC=[this._cCoord.getOrdinate("X")-this._bCoord.getOrdinate("X"),this._cCoord.getOrdinate("Y")-this._bCoord.getOrdinate("Y"),this._cCoord.getOrdinate("Z")-this._bCoord.getOrdinate("Z")];
        return [vecA,vecB,vecC,vecX];
    }

    /**
     * 销毁对象中的全部属性
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,30,0);
     * let triangle = new hmap.geom.Triangle(coord1,coord2,coord3);
     * triangle.destroy();
     * let result = triangle.CLASS_NAME;//result=undefined即triangle对象中属性被销毁
     */
    destroy() {
        super.destroy();
    }
    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number}tolerance 容差
     * @return {Number} 到相机的距离
     * @private
     */
    intersectRay(ray, tolerance,offset=[0,0,0]) {
        let vertics = [
            new hmap.util.Vector3(this._aCoord._x + offset[0], this._aCoord._y + offset[1], this._aCoord._z + offset[2]) ,
            new hmap.util.Vector3(this._bCoord._x + offset[0], this._bCoord._y + offset[1], this._bCoord._z + offset[2]) ,
            new hmap.util.Vector3(this._cCoord._x + offset[0], this._cCoord._y + offset[1], this._cCoord._z + offset[2])
        ];
        let coord = hmap.strategy.Intersect3D.rayIntersectTriangle(ray.origin, ray.direction, vertics);
        if (coord) {
            let pointToCamera = ray.distanceSquare(coord);
            return pointToCamera;
        }
    }

    /**
     * (道格拉斯-普克算法)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。
     * 三角形的简化返回原对象
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Triangle} 返回简化后的几何体。
     */
    simplify(tolerance) {
        if (!Number.isFinite(tolerance) || tolerance < 0) {
            throw new Error("parameter 'tolerance' should be positive number")
        }
        return this;
    }
}

;"use strict";
hmap.geom = hmap.geom || {};
/**
 * 根据2个对角顶点组成的数组构造二维外接矩形
 * @type {hmap.geom.Rectangle}
 * @extends hmap.geom.Geometry
 * @example
 * let coord1 = new hmap.basetype.Coordinate(120,30,0);
 * let pnt1 = new hmap.geom.Point(coord1);
 * let coord2 = new hmap.basetype.Coordinate(121,31,0);
 * let pnt2 = new hmap.geom.Point(coord2);
 * let rectangle = new hmap.geom.Rectangle([pnt1,pnt2]);
 */
hmap.geom.Rectangle = class extends hmap.geom.Geometry {
    /**
     * 点数组的最小地理范围[minX,minY,maxX,maxY]的左下角的点、右下角的点、右上角的点、左上角的点四个点构成了点数组的外接矩形。
     * @param {Array<hmap.geom.Point>} points 点的数组,点的数量大于1（不可平行于坐标轴，多于两个的取前两个）
     */
    constructor(points) {
        super();
        if (points.length < 2) {
            throw new Error("At least two points are required!");
        }
        if (!points[0] instanceof hmap.geom.Point || !points[1] instanceof hmap.geom.Point) {
            throw new Error("member of points must be instance of hmap.geom.Point");
        }
        this._pointArr = [];//存储矩形的四个顶点，顺序为左下、右下、右上、左上。
        this.CLASS_NAME = "hmap.geom.Rectangle";
        this._generatePoints(points);          //根据关键点计算图形的点几何
    }

    /**
     * 复制一个线对象。
     * @return {hmap.geom.Rectangle} 矩形。
     */
    clone() {
        const ps = [];
        //这里传入对角点就可以
        ps.push(this._pointArr[0].clone());
        ps.push(this._pointArr[1].clone());
        ps.push(this._pointArr[2].clone());
        ps.push(this._pointArr[3].clone());
        let newRect = new hmap.geom.Rectangle([
            new hmap.geom.Point(new hmap.basetype.Coordinate(0, 1, 0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(1, 0, 0))
        ]);
        newRect._pointArr = ps;
        newRect._generateBBox()
        return newRect;
    }

    /**
     * 计算两个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     *  若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     */
    distanceTo(geometry, options = {}) {
        return this.toPolygon().distanceTo(geometry, options)
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return this.toPolygon().intersectsGeometry(geom);
    }

    /**
     * 绕着指定直线（旋转轴）旋转，所指定的直线穿过给定点且平行于坐标轴。旋转后的坐标可能发生变化。绕轴旋转的本质如下： 绕平行于Z轴的直线旋转即是在XY平面内旋转；绕平行于X轴的直线旋转即是在YZ平面内旋转；绕平行于Y轴的直线旋转即是在XZ平面内旋转
     * @param {String} axis 坐标轴，旋转轴平行于该坐标轴并与坐标轴同向。可选值为"X","Y","Z",默认值为Z。
     * @param {Number} angle  旋转的角度，超过360度时，取angle/360的余数。逆时针为正，顺时针为负
     * @param {hmap.basetype.Coordinate} center 旋转轴所穿过的点，可选项。该参数为空时，绕坐标轴旋转
     * @returns {hmap.geom.Rectangle} 返回旋转后的矩形。
     */
    rotate(axis, angle, center) {
        for (let point of this._pointArr) {
            point.rotate(axis, angle, center);
        }
        return this;
    }

    /**
     * 对象移动
     * @param {Number} deltaX 在x轴方向的移动，单位同地图单位
     * @param {Number} deltaY 在y轴方向的移动，单位同地图单位
     * @param {Number} deltaZ 在z轴方向的移动，单位同地图单位
     * @returns {hmap.geom.Rectangle} 返回移动后的矩形。
     */
    moveByDelta(deltaX = 0, deltaY = 0, deltaZ = 0) {
        for (let point of this._pointArr) {
            point.moveByDelta(deltaX, deltaY, deltaZ);
        }
        this._generateBBox();
        return this;
    }

    /**
     *  根据坐标数组的坐标范围，计算外接矩形的四个顶点，以及坐标组的三维包围盒。
     *  @private
     * */
    _generatePoints(points) {
        if (!points || points.length < 1) {
            points = [];
            points.push(this._pointArr[0]);
            points.push(this._pointArr[2])
        }
        const _cz = 0.000000001;
        let minX, maxX, minY, maxY, minZ, maxZ;
        const x1 = points[0].getCoordinate().getOrdinate("X");
        const y1 = points[0].getCoordinate().getOrdinate("Y");
        const z1 = points[0].getCoordinate().getOrdinate("Z");

        const x2 = points[1].getCoordinate().getOrdinate("X");
        const y2 = points[1].getCoordinate().getOrdinate("Y");
        const z2 = points[1].getCoordinate().getOrdinate("Z");

        if (Math.abs(x1 - x2) < _cz || Math.abs(y1 - y2) < _cz) {
            throw new Error("the line consisting of two points cannot be parallel to the axis")
        }

        if (x1 > x2) {
            minX = x2;
            maxX = x1;
        } else {
            minX = x1;
            maxX = x2;
        }

        if (y1 > y2) {
            minY = y2;
            maxY = y1;
        } else {
            minY = y1;
            maxY = y2;
        }

        if (z1 > z2) {
            minZ = z2;
            maxZ = z1;
        } else {
            minZ = z1;
            maxZ = z2;
        }
        this._pointArr.length = 0;
        if (Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY)) {
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX, minY, 0)));        //left bottom
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(maxX, minY, 0)));        //right bottom
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(maxX, maxY, 0)));        //right top
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX, maxY, 0)));        //left top
        }
        this._bbox = new hmap.basetype.BBox(minX, minY, minZ, maxX, maxY, maxZ);
    }

    /**
     * 重新生成包围盒
     * @private
     */
    _generateBBox() {
        let minX, maxX, minY, maxY, minZ, maxZ;
        minX = maxX = this._pointArr[0].getCoordinate().getOrdinate("X");
        minY = maxY = this._pointArr[0].getCoordinate().getOrdinate("Y");
        minZ = maxZ = this._pointArr[0].getCoordinate().getOrdinate("Z");
        for (let point of this._pointArr) {
            const px = point.getCoordinate().getOrdinate("X");
            const py = point.getCoordinate().getOrdinate("Y");
            const pz = point.getCoordinate().getOrdinate("Z");
            if (minX > px) {
                minX = px;
            } else if (maxX < px) {
                maxX = px;
            }
            if (minY > py) {
                minY = py;
            } else if (maxY < py) {
                maxY = py;
            }

            if (minZ > pz) {
                minZ = pz;
            } else if (maxZ < pz) {
                maxZ = pz;
            }
        }
        this._bbox = new hmap.basetype.BBox(minX, minY, minZ, maxX, maxY, maxZ);
    }

    /**
     * 从构成矩形的所有点中，获取离传入坐标最近的一个点。传入坐标到矩形各个点距离都相等时，返回矩形的第一个点。
     * @param {hmap.basetype.Coordinate} coord 一个地理坐标。
     * @returns {hmap.geom.Point} 矩形几何体上的一个点。
     */
    getClosestPoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new Error("parameter is not Coordinate!");
        }
        let minD = this._pointArr[0].getCoordinate().get3Dist(coord);
        let point = this._pointArr[0];
        const length = this._pointArr.length;
        for (let i = 0; i < length; i++) {
            const value = this._pointArr[i];
            const dist = value.getCoordinate().get3Dist(coord);
            if (dist < minD) {
                minD = dist;
                point = value;
            }
        }
        return point;
    }

    /**
     * (道格拉斯-普克算法)简化几何体。使用较少的坐标数量表示与原几何体近似的几何体，该方法可简化线以及由线构成的几何体（即线、多线、面、多面和圆）。
     * 矩形的简化返回原对象
     * @param {Number} tolerance 简化所用容差值，大于等于0。(不表示两个坐标点之间的距离)。
     * @returns {hmap.geom.Rectangle} 返回简化后的几何体。
     */
    simplify(tolerance) {
        if (!Number.isFinite(tolerance) || tolerance < 0) {
            throw new Error("parameter 'tolerance' should be positive number")
        }
        return this;
    }

    /**
     * 获取二维包围盒
     * @returns {hmap.basetype.Extent} 在XY平面的最大地理范围。
     */
    getExtent() {
        return new hmap.basetype.Extent(this._bbox._minX, this._bbox._minY, this._bbox._maxX, this._bbox._maxY);
    }

    /**
     * 获取几何体类型。
     * @returns {String} 返回几何体类型。
     */
    getType() {
        return hmap.geom.GeometryType.Rectangle;
    }

    /**
     * 获取构成矩形的四个顶点
     * @return {Array<hmap.basetype.CoordSeq>} 顶点坐标序列,，鉴于Rectangle坐标序列数组只有一个，可以通过getCoordSeq 直接返回该坐标序列对象。
     */
    getCoordSeqs() {
        return [this.getCoordSeq()];
    }
    getCoordSeq(){
        const coordArr = [];
        if (this._pointArr.length != 0) {
            for (let i = 0, length = this._pointArr.length; i < length; i++) {
                coordArr.push(this._pointArr[i].getCoordinate());
            }
        }
        //return coordArr;
        return new hmap.basetype.CoordSeq(coordArr);
    }

    /**
     * 将矩形转化为多边形。
     * @returns {hmap.geom.Polygon} 多边形。
     * @example
     * let rectangle = new hmap.geom.Rectangle([point1,point2]);
     * let polygon = rectangle.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 将矩形转化为线几何。
     * @returns {hmap.geom.Line} 线几何。
     * @example
     * let rectangle = new hmap.geom.Rectangle([point1,point2]);
     * let polygon = rectangle.toLine();
     */
    toLine() {
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取几何体的缓冲区。缓冲区限于X-Y平面内，非三维空间中的缓冲区
     * @param {Number} dist 缓冲距离，一个正数，单位同地图单位。
     * @param {String} sideType 面缓冲类型，"FULL"：包含原几何体，"OUTSIDE"：不包含原有几何体。
     * @returns {hmap.geom.Polygon} 返回一个面状几何体
     */
    getBuffer(dist, sideType = "FULL") {
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error("parameter 'dist' must be a number that larger than zero !");
        }
        const polygonBuffer = new hmap.strategy.PolygonBuffer(this.toPolygon(), dist, sideType);
        return polygonBuffer.build();
    }

    /**
     * 获取矩形的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回矩形的三维包围盒。
     */
    getBBox() {
        return this._bbox;
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster}ray 射线
     * @param {Number}tolerance 拾取容差
     * @return {Number}
     * @private
     */
    intersectRay(ray, tolerance) {
       return this.toPolygon().intersectRay(ray, tolerance);
    }

    /**
     * 是否自相交
     * @returns {Boolean} false，矩形不会自相交。
     */
    isSelfIntersects() {
        return false;
    }

    /**
     * 销毁对象的全部属性
     */
    destroy() {
        super.destroy();
    }

    /**
     * 将一个矩形几何体中点所对应的地理坐标从源坐标系转换到目标坐标系。
     * 该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * 考虑到实际转换时，数据量可能较大，故传入CRS的SRID，而非CRS实例，以减少CRS实例数量，进而降低内存成本。
     * @param {Number} source 源坐标系。
     * @param {Number} destination 目标坐标系。
     * @returns {hmap.geom.Rectangle} 坐标转换后的几何体。
     */
    transform(source, destination) {
        for (let i = 0, l = this._pointArr.length; i < l; i++) {
            this._pointArr[i].transform(source, destination);
        }
        this._generateBBox();
        return this;
    }

    /**
     * 给定一个函数，用来修改几何体的坐标值。该方法可能改变原几何体的坐标值，如果需要保留原几何体，需要事先使用clone方法复制原几何体作为副本。
     * @param callback  用于处理几何体点对象的回调函数，回调函数的参数为点对象，该回调函数会作用在几何体的每个点对象上。
     */
    applyTransform(callback) {
        const pointArr = this._pointArr;
        pointArr[0].applyTransform(callback);
        pointArr[1].applyTransform(callback);
        pointArr[2].applyTransform(callback);
        pointArr[3].applyTransform(callback);
        this._generateBBox();
    }

    /**
     * 坐标缩放
     * @param {Number} scaleX 在X轴方向的缩放
     * @param {Number} scaleY 在Y轴方向的缩放
     * @param {Number} scaleZ 在Z轴方向的缩放
     * @param {hmap.basetype.Coordinate} coordinate 锚点的坐标值,如果不传，以矩形中心点作为缩放中心点
     * @returns {hmap.geom.Rectangle} 返回缩放后的矩形。
     * @throws {TypeError} 当coordinate传入但类型错误时，抛出类型错误异常。
     */
    scale(scaleX, scaleY, scaleZ, coordinate) {
        if (coordinate !== undefined && !(coordinate instanceof hmap.basetype.Coordinate)) {
            throw new TypeError('parameter "coordinate" must be type of hmap.basetype.Coordinate');
        }
        if (!coordinate) {
            coordinate = this.getExtent().getCenter();
        }
        for (let i = 0, l = this._pointArr.length; i < l; i++) {
            this._pointArr[i].scale(scaleX, scaleY, scaleZ, coordinate);
        }
        this._generateBBox();
        return this;
    }

    /**
     * 判断一个坐标是否在当前矩形内，不包含高程方向的运算。
     * @param {hmap.basetype.Coordinate} coord 坐标对象
     * @returns {Boolean} 在矩形范围内返回true;在矩形范围外返回false。
     */
    atApproximatePoint(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw new TypeError("The coord parameter is not an object of Coordinate!");
        }
        const extent = this.getExtent();
        return extent.containsCoord(coord);
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 地理几何体拓展类。该类是抽象类，不能被直接实例化
 * 一个地理要素由地理几何体、属性以及样式组成
 * @type {hmap.geomext.GeometryExt}
 * @private
 */
hmap.geomext.GeometryExt = class extends hmap.geom.Geometry {
    constructor(){
        if (new.target === hmap.geomext.GeometryExt) {
            throw new TypeError("The GeometryExt is an abstract class,and can not be instanced!");
        }
        super();
        this.CLASS_NAME = "hmap.geomext.GeometryExt";
    }

    /**
     *  计算和基准向量v夹角为a、长度为d的目标向量（理论上有两个，一左一右）
     *  @param {Object} v 基准向量 {x:xVal,y:yVal}
     *  @param {Number} aa 目标向量和基准向量的夹角，默认为90度，这里的单位使用弧度
     *  @param {Number} da 目标向量的长度，即模，默认为1，即单位向量
     *  @returns {Array<Object>} 目标向量数组（就两个向量，一左一右）[{x:xVal,y:yVal}]
     *  @private
     */
    calculateVector(v, aa, da){
        let aAngle = aa ? aa:Math.PI / 2;
        let desAngle = da ? da :1;

        //定义目标向量的头部   x 坐标
        let x_1,x_2;
        //定义目标向量的头部   y 坐标
        let y_1,y_2;
        //定义目标向量，一左一右
        let v_l,v_r;

        //计算基准向量v的模
        let d_v = Math.sqrt(v.x * v.x + v.y * v.y);

        //基准向量的斜率为0时，y值不能作为除数，所以需要特别处理
        if (v.y == 0) {
            //计算x,会有两个值
            x_1 = x_2 = d_v * desAngle * Math.cos(aAngle) / v.x;
            //根据v.x的正负判断目标向量的左右之分
            if (v.x > 0) {
                //计算y
                y_1 = Math.sqrt(desAngle * desAngle - x_1 * x_1);
                y_2 = -y_1;
            }
            else if (v.x < 0) {
                //计算y
                y_2 = Math.sqrt(desAngle * desAngle - x_1 * x_1);
                y_1 = -y_2;
            }
            v_l = {x:x_1,y:y_1};
            v_r = {x:x_2,y:y_2};
        }
        //此为大多数情况
        else {
            //转换为y=nx+m形式
            let n = -v.x / v.y;
            let m = desAngle * d_v * Math.cos(aAngle) / v.y;
            //
            //x*x + y*y = d*d
            //转换为a*x*x + b*x + c = 0
            let a = 1 + n * n;
            let b = 2 * n * m;
            let c = m * m - desAngle * desAngle;
            //计算x,会有两个值
            x_1 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            x_2 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            //计算y
            y_1 = n * x_1 + m;
            y_2 = n * x_2 + m;
            //当向量向上时
            if (v.y >= 0) {
                v_l = {x:x_1,y:y_1};
                v_r = {x:x_2,y:y_2};
            }
            //当向量向下时
            else if (v.y < 0) {
                v_l = {x:x_2,y:y_2};
                v_r = {x:x_1,y:y_1};
            }
        }
        return [v_l, v_r];
    }

    /**
     * 计算两条直线的交点
     * 通过向量的思想进行计算，需要提供两个向量以及两条直线上各自一个点
     * @param {Object} v_1 直线1的向量 {x:xVal,y:yVal}
     * @param {Object} v_2 直线2的向量 {x:xVal,y:yVal}
     * @param {Object} points1 直线1上的任意一点 {x:xVal,y:yVal}
     * @param {Object} points2 直线2上的任意一点 {x:xVal,y:yVal}
     * @returns {Object} 返回交点 {x:xVal,y:yVal}
     * @private
     */
    calculateIntersection(v_1, v_2, point1, point2) {
        //定义交点的坐标
        let x;
        let y;
        //如果向量v_1和v_2平行
        if (v_1.y * v_2.x - v_1.x * v_2.y == 0) {
            //平行也有两种情况
            //同向
            if (v_1.x * v_2.x > 0 || v_1.y * v_2.y > 0) {
                //同向直接取两个点的中点
                x = (point1.x + point2.x) / 2;
                y = (point1.y + point2.y) / 2;
            }
            //反向
            else {
                //如果反向直接返回后面的点位置
                x = point2.x;
                y = point2.y;
            }
        }
        else {
            //
            x = (v_1.x * v_2.x * (point2.y - point1.y) + point1.x * v_1.y * v_2.x - point2.x * v_2.y * v_1.x) / (v_1.y * v_2.x - v_1.x * v_2.y);
            if (v_1.x != 0) {
                y = (x - point1.x) * v_1.y / v_1.x + point1.y;
            }
            //不可能v_1.x和v_2.x同时为0
            else {
                y = (x - point2.x) * v_2.y / v_2.x + point2.y;
            }
        }
        return {x:x,y:y};
    }

    /**
     *  计算当前点所在的直径线与X轴的夹角，结果以弧度
     *  @param {Object} xy形式的边界坐标 {x:xVal,y:yVal}
     *  @param {Object} xy形式的圆心坐标 {x:xVal,y:yVal}
     *  @returns {Number} 弧度
     *  @private
     */
    calculateAngle(pointA, centerPoint) {
        let angle=Math.atan2((pointA.y-centerPoint.y),(pointA.x-centerPoint.x));
        if(angle<0){angle+=2*Math.PI;}
        return angle;
    }

    /**
     *  计算两点的中间点
     *  @param {Object} pointA xy形式的坐标 {x:xVal,y:yVal}
     *  @param {Object} pointB xy形式的坐标 {x:xVal,y:yVal}
     *  @returns {Object} xy形式的坐标
     *  @private
     */
    calculateMidpoint(pointA, pointB) {
        let midPoint = {x:(pointA.x + pointB.x) / 2, y:(pointA.y + pointB.y) / 2};
        return midPoint;
    }

    /**
     *  计算两点的距离
     *  @param {Object} pointA xy形式的坐标 {x:xVal,y:yVal}
     *  @param {Object} pointB xy形式的坐标 {x:xVal,y:yVal}
     *  @returns {Number} 坐标距离
     *  @private
     */
    calculateDistance(pointA, pointB) {
        let distance =Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
        return distance;
    }

    /**
     *  获取贝塞尔曲线的点几何数组
     *  @param {Array<hmap.geom.Point>} 贝塞尔曲线关键点数组
     *  @param {Number} density 点密度，默认100
     *  @returns {Array<hmap.geom.Point>} 贝塞尔曲线点数组
     *  @private
     */
    getBezierPoints(points,density=100){
        const result = [];
        const n = points.length - 1;
        for (let t=0; t <= 1; t+=1/density){
            let x=0,y=0;
            for (let index=0; index <= n; index++){
                let factor=getBinomialFactor(n, index);
                let a=Math.pow(t, index);
                let b=Math.pow((1 - t), (n - index));
                x+=factor * a * b * points[index].getCoordinate().getOrdinate("X");
                y+=factor * a * b * points[index].getCoordinate().getOrdinate("Y");
            }
            result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(x,y,0)));
        }
        result.push(points[n]);

        function getBinomialFactor(n, index){
            return getFactorial(n) / (getFactorial(index) * getFactorial(n - index));
        }
        /**
         *  求阶乘
         */
        function getFactorial(n){
            if (n <= 1)
                return 1;
            if (n == 2)
                return 2;
            if (n == 3)
                return 6;
            if (n == 4)
                return 24;
            if (n == 5)
                return 120;
            let result=1;
            for (let i=1; i <= n; i++)
                result*=i;
            return result;
        }

        return result;
    }

    /**
     *  根据关键点，构造Cardinal曲线点,最后两个控制点不能相同
     *  @param {Array<hmap.geom.Point>} 点几何数组
     *  @returns {Array<hmap.geom.Point>} Cardinal曲线点几何数组
     *  @private
     */
    calculateCardinalPoints(points){
        if(points==null||points.length<3) return points;
        let pnts = points
        const j = [];
        const p = 0.4;
        const H = 0.5;
        const D = 0.005;
        const pLength = pnts.length - 1;
        for(let y=0;y<=pLength+1-3;y++)
        {
            let g=pnts[y];
            let f=pnts[y+1];
            let d=pnts[y+2];
            let m=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
            let h=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
            let F={x:f.getCoordinate().getOrdinate("X")-g.getCoordinate().getOrdinate("X"),y:f.getCoordinate().getOrdinate("Y")-g.getCoordinate().getOrdinate("Y")};
            let a={x:d.getCoordinate().getOrdinate("X")-f.getCoordinate().getOrdinate("X"),y:d.getCoordinate().getOrdinate("Y")-f.getCoordinate().getOrdinate("Y")};
            let u=Math.sqrt(F.x*F.x+F.y*F.y);
            let I=Math.sqrt(a.x*a.x+a.y*a.y);
            let s={x:F.x/u,y:F.y/u};
            let l={x:a.x/I,y:a.y/I};
            let G=  {x:s.x+l.x,y:s.y+l.y};
            let c=Math.sqrt(G.x*G.x+G.y*G.y);
            let r= {x:G.x/c,y:G.y/c};
            let o=(s.x*l.x+s.y*l.y)/1;
            if(Math.abs(1-o)<D)
            {
                m.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")-l.x*u*p);
                m.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")-l.y*u*p);
                h.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")+s.x*I*p);
                h.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")+s.y*I*p);
            }else
            {
                m.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")-r.x*u*p);
                m.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")-r.y*u*p);
                h.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")+r.x*I*p);
                h.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")+r.y*I*p);
            }
            j[y*3+2+0]=m;
            j[y*3+2+1]=f;
            j[y*3+2+2]=h;
            if(y==0){
                let E=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
                let x={x:m.getCoordinate().getOrdinate("X")-g.getCoordinate().getOrdinate("X"),y:m.getCoordinate().getOrdinate("Y")-g.getCoordinate().getOrdinate("Y")};
                let C=Math.sqrt(x.x*x.x+x.y*x.y);
                let i={x:x.x/C,y:x.y/C};
                E.getCoordinate().setOrdinate("X",g.getCoordinate().getOrdinate("X")+i.x*u*p*H);
                E.getCoordinate().setOrdinate("Y",g.getCoordinate().getOrdinate("Y")+i.y*u*p*H);
                j[y*3+0]=g;
                j[y*3+1]=E
            }
            if(y==pLength+1-3)
            {
                let w=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
                let J={x:h.getCoordinate().getOrdinate("X")-d.getCoordinate().getOrdinate("X"),y:h.getCoordinate().getOrdinate("Y")-d.getCoordinate().getOrdinate("Y")};
                let B=Math.sqrt(J.x*J.x+J.y*J.y);
                let q={x:J.x/B,y:J.y/B};
                w.getCoordinate().setOrdinate("X",d.getCoordinate().getOrdinate("X")+q.x*I*p*H);
                w.getCoordinate().setOrdinate("Y",d.getCoordinate().getOrdinate("Y")+q.y*I*p*H);
                j[y*3+2+3]=w;
                j[y*3+2+4]=d
            }
        }
        return j
    }

    /**
     *  根据关键点，构造闭合的Cardinal曲线点
     *  @param {Array<hmap.geom.Point>} 点几何数组
     *  @returns {Array<hmap.geom.Point>} 闭合Cardinal曲线点几何数组
     *  @private
     */
    calculateCloseCardinal(points){
        if(points==null||points.length<3)
        {
            return points
        }
        const curvePoints = [];
        for(let i=0;i<points.length;i++){
            curvePoints.push(points[i]);
        }
        curvePoints.push(points[0])
        let pnts=curvePoints;        //pnts x
        let result=[];
        let p=0.4;
        let B=0.5;
        let y=0.005;
        let u=pnts.length-1;
        for(let v=0;v<=u-1;v++)
        {
            let g,f,d;
            if(v==u-1){
                g={x:pnts[u-1].getCoordinate().getOrdinate("X"),y:pnts[u-1].getCoordinate().getOrdinate("Y")};
                f=pnts[0];          //1
                d={x:pnts[1].getCoordinate().getOrdinate("X"),y:pnts[1].getCoordinate().getOrdinate("Y")};
            }else{
                g={x:pnts[v].getCoordinate().getOrdinate("X"),y:pnts[v].getCoordinate().getOrdinate("Y")};
                f=pnts[v+1];
                d={x:pnts[v+2].getCoordinate().getOrdinate("X"),y:pnts[v+2].getCoordinate().getOrdinate("Y")};
            }
            let l=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
            let h=new hmap.geom.Point(new hmap.basetype.Coordinate(0,0,0));
            let z={x:f.getCoordinate().getOrdinate("X")-g.x,y:f.getCoordinate().getOrdinate("Y")-g.y};
            let a={x:d.x-f.getCoordinate().getOrdinate("X"),y:d.y-f.getCoordinate().getOrdinate("Y")};
            let s=Math.sqrt(z.x*z.x+z.y*z.y);
            let C=Math.sqrt(a.x*a.x+a.y*a.y);
            let r={x:z.x/s,y:z.y/s};
            let j={x:a.x/C,y:a.y/C};
            let A={x:r.x+j.x,y:r.y+j.y};
            let c=Math.sqrt(A.x*A.x+A.y*A.y);
            let q={x:A.x/c,y:A.y/c};
            let m=(r.x*j.x+r.y*j.y)/1;
            if(Math.abs(1-m)<y)
            {
                l.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")-j.x*s*p);
                l.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")-j.y*s*p);
                h.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")+r.x*C*p);
                h.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")+r.y*C*p);
            }
            else
            {
                l.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")-q.x*s*p);
                l.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")-q.y*s*p);
                h.getCoordinate().setOrdinate("X",f.getCoordinate().getOrdinate("X")+q.x*C*p);
                h.getCoordinate().setOrdinate("Y",f.getCoordinate().getOrdinate("Y")+q.y*C*p);
            }
            if(v==u-1)
            {
                result[0]=f;
                result[1]=h;
                result[(u-2)*3+2+3]=l;
                result[(u-2)*3+2+4]=pnts[u]
            }
            else
            {
                result[v*3+2+0]=l;
                result[v*3+2+1]=f;
                result[v*3+2+2]=h
            }
        }
        return result
    }

    /**
     * 计算两个向量的角平分线向量
     * @param {Object} v1 向量1 {x:x,y:y}
     * @param {Object} v2 向量2 {x:x,y:y}
     * @returns {Object} 角平分线向量 {x:x,y:y}
     * @private
     */
    calculateAngularBisector(v1, v2) {
        //计算角平分线的思想是取两个向量的单位向量，然后相加
        let d1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        let d2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        return {x:v1.x / d1 + v2.x / d2, y:v1.y / d1 + v2.y / d2};
    }

    /**
     * 根据圆心、半径，与X轴的起点角和终点角计算圆弧。
     * Parameters:
     * @param {Object} center 圆心坐标 {x:x,y:y}
     * @param {Number} radius 半径
     * @param {Number} startAngle 起点角,范围为0到2π。
     * @param {Number} endAngle 终点角,范围为0到2π。
     * @param {Number} direction 从起点到终点的方向，其值为1：逆时针，其值为-1：顺时针。默认为1，即逆时针。
     * @param {Number} sides 圆弧所在圆的点数，默认为360个，即每1°一个点。
     * @returns {Array<hmap.geom.Point>} 圆弧上的点数组
     * @private
     */
    calculateArc(center,radius, startAngle,endAngle,direction,sides){
        if(!direction ||(direction!=1 && direction!=-1)) direction=-1;
        if(!sides) sides=360;
        let step=Math.PI*2/sides;
        let stepDir= step*direction;
        let length=Math.abs(endAngle-startAngle);
        let points=[];
        for(let radians =startAngle,i = 0; i <length;i+=step)
        {
            let circlePoint = new hmap.geom.Point(new hmap.basetype.Coordinate(Math.cos(radians) * radius + center.x, Math.sin(radians) * radius + center.y,0));
            points.push(circlePoint);
            radians+=stepDir;
            radians=radians<0?(radians+2*Math.PI):radians;
            radians=radians> 2*Math.PI?(radians-2*Math.PI):radians;
        }
        return points;
    }

    /**
     *  获取控制点的几何数组
     *  @returns {Array<hmap.geom.Point>} 点几何数组
     *  @example
     *  let points = geomext.getCtrlPoints();
     */
    getCtrlPoints() {
        return this._ctrlPoints;
    }

    /**
     * 射线法拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance 容差
     * @return {Number} 到相机距离
     * @private
     */
    intersectRay(ray,tolerance,offset) {
        switch (this.getType()) {
            case hmap.geom.GeometryExtType.POLYLINE.ARC:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE2:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE3:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVEN:
            case hmap.geom.GeometryExtType.POLYLINE.CARDINAL_CURVE:
                return this.toLine().intersectRay(ray,tolerance,offset);
                break;
            case hmap.geom.GeometryExtType.LARROW.BEZIER_CURVE_ARROW:
            case hmap.geom.GeometryExtType.LARROW.CARDINAL_CURVE_ARROW:
            case hmap.geom.GeometryExtType.LARROW.PARALLEL_SEARCH:
            case hmap.geom.GeometryExtType.LARROW.SECTOR_SEARCH:
            case hmap.geom.GeometryExtType.LARROW.POLYLINE_ARROW:
                return this.toMultiLine().intersectRay(ray,tolerance,offset);
                break;
            //POLYGON
            case hmap.geom.GeometryExtType.POLYGON.CIRCLE:
            case hmap.geom.GeometryExtType.POLYGON.ELLIPSE:
            case hmap.geom.GeometryExtType.POLYGON.SECTOR:
            case hmap.geom.GeometryExtType.POLYGON.CLOSE_CURVE:
            case hmap.geom.GeometryExtType.POLYGON.LUNE:
            case hmap.geom.GeometryExtType.POLYGON.GATHERING_PLACE:
            case hmap.geom.GeometryExtType.POLYGON.RECTANGLE:
            case hmap.geom.GeometryExtType.POLYGON.ROUNDED_RECT:
            //ARROW
            case hmap.geom.GeometryExtType.ARROW.STRAIGHT_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DIAGONAL_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOUBLE_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOVETAIL_DIAGONAL_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOVETAIL_STRAIGHT_ARROW:
            //FLAG
            case hmap.geom.GeometryExtType.FLAG.TRIANGLE_FLAG:
            case hmap.geom.GeometryExtType.FLAG.RECT_FLAG:
            case hmap.geom.GeometryExtType.FLAG.CURVE_FLAG:
                return this.toPolygon().intersectRay(ray,tolerance,offset);
                break;
            default:
                return null;
                break;
        }
    }
};"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 矩形
 * @type {hmap.geomext.Rectangle}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let rectangleGeom = new hmap.geomext.Rectangle([point1,point2]);
 */
hmap.geomext.Rectangle = class extends hmap.geomext.GeometryExt{
    /**
     * 根据两个控制点作为对角点构造矩形，坐标组中几何点数量至少为2，若几何点数量大于2，则构造控制点的外接矩形
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.Rectangle";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  根据全部的坐标点，计算外接矩形的组成点坐标
     *  @private
     */
    _generatePoints(){
        let minX,minY,maxX,maxY;
        for(let point of this._ctrlPoints){
            if(!(point instanceof hmap.geom.Point)){
                continue;
            }
            const px = point.getCoordinate().getOrdinate("X");
            const py = point.getCoordinate().getOrdinate("Y");
            if(!minX || (minX > px)){
                minX = px;
            }
            if(!minY || (minY > py)){
                minY = py;
            }
            if(!maxX || (maxX < px)){
                maxX = px;
            }
            if(!maxY || (maxY < py)){
                maxY = py;
            }
        }
        if(minX && minY && maxX && maxY){
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX,minY,0)));        //left bottom
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(maxX,minY,0)));        //right bottom
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(maxX,maxY,0)));        //right top
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX,maxY,0)));        //left top
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX,minY,0)));        //left top
        }
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = rectangleGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.RECTANGLE;
    }

    /**
     * 提取矩形的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = rectangleGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将矩形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = rectangleGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 将矩形转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = rectangleGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常点几何数组
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  rectangleGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }

    /**
     * 检测与另一个几何体是否相交。
     * @param {hmap.geom.Geometry} geom 另一个几何体。
     * @return {Boolean} 返回true表示相交；返回false表示不相交。
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return this.toPolygon().intersectsGeometry(geom);
    }

};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 圆角矩形
 * @type {hmap.geomext.RoundedRect}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let rrGeom = new hmap.geomext.RoundedRect([point1,point2]);
 */
hmap.geomext.RoundedRect = class extends hmap.geomext.GeometryExt{
    /**
     * 根据两个控制点作为对角顶点构造圆角矩形，控制点数量为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.RoundedRect";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算圆角矩形的组成点坐标
     *  @private
     */
    _generatePoints(){
        let minX,minY,maxX,maxY;
        for(let point of this._ctrlPoints){
            if(!(point instanceof hmap.geom.Point)){
                continue;
            }
            const px = point.getCoordinate().getOrdinate("X");
            const py = point.getCoordinate().getOrdinate("Y");
            if(!minX || (minX > px)){
                minX = px;
            }
            if(!minY || (minY > py)){
                minY = py;
            }
            if(!maxX || (maxX < px)){
                maxX = px;
            }
            if(!maxY || (maxY < py)){
                maxY = py;
            }
        }
        if(minX && minY && maxX && maxY){
            let radius = (maxX - minX)<(maxY - minY) ? (maxX - minX)*0.1:(maxY - minY)*0.1;
            let centerPoint0={x:minX+radius,y:minY+radius};
            let centerPoint1={x:minX+radius,y:maxY-radius};
            let centerPoint2={x:maxX-radius,y:maxY-radius};
            let centerPoint3={x:maxX-radius,y:minY+radius};

            //圆角矩形的圆弧依次为矩形的左上、右上、右下、左下
            let arc0=this.calculateArc(centerPoint0,radius,Math.PI*3/2,Math.PI,-1,180);
            let arc1=this.calculateArc(centerPoint1,radius,Math.PI,Math.PI/2,-1,180);
            let arc2=this.calculateArc(centerPoint2,radius,Math.PI/2,0,-1,180);
            let arc3=this.calculateArc(centerPoint3,radius,2*Math.PI,Math.PI*3/2,-1,180);
            this._pointArr  = arc0.concat(arc1,arc2,arc3);
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(minX+radius, minY,0)));
        }
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = rrGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.ROUNDED_RECT;
    }

    /**
     * 提取圆角矩形的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = rrGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将圆角矩形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = rrGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 将圆角矩形转化为线几何。
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = rrGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  rrGeom.setCtrlPoint([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 圆
 * @type {hmap.geomext.Circle}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let pnt1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let pnt2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let circleGeom = new hmap.geomext.Circle(pnt1,pnt2,20);
 */
hmap.geomext.Circle = class extends hmap.geomext.GeometryExt {
    /**
     * 根据圆心和边线上一点构造一个圆
     * @param {hmap.geom.Point} point1 控制点1，即圆心
     * @param {hmap.geom.Point} point2 控制点2，即圆边线上一个点
     * @param {Number} pointNum 构成圆的边的数量，默认是100，可选项。边数越多，需要渲染的数据量越大，渲染时需要消耗的计算机资源就越多，耗时因此会增加
     * @throws 参数中，圆心和边点必须是hmap.geom.Point的实例，否则抛出异常
     */
    constructor(point1, point2, pointNum = 100) {
        if (!(point1 instanceof hmap.geom.Point) || !(point2 instanceof hmap.geom.Point)) {
            throw new TypeError('points parameter must be instance of hmap.geom.Point!');
        }
        super();
        this._pointNum = pointNum;
        this._ctrlPoints = [point1, point2];
        this._pointArr = [];
        this._center = point1;

        this.CLASS_NAME = "hmap.geomext.Circle";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成

        this._generatePoints(); //根据关键点计算图形的点几何
    }

    /**
     *  计算圆的图形组成点
     *  @private
     */
    _generatePoints() {
        // 维护圆上的点
        const pnt1 = this._ctrlPoints[0],
            pnt2 = this._ctrlPoints[1];
        const radius = pnt1.distanceTo(pnt2);
        this._radius = radius;
        const centerCoord = pnt1.getCoordinate();
        const centerX = centerCoord.getOrdinate('X');
        const centerY = centerCoord.getOrdinate('Y');
        const centerZ = centerCoord.getOrdinate('Z');
        const circlePoints = [];
        let radian;
        for (let i = 0; i < this._pointNum; i++) {
            radian = 2 * Math.PI / this._pointNum * i;
            circlePoints.push(
                new hmap.geom.Point(
                    new hmap.basetype.Coordinate(
                        centerX + radius * Math.cos(radian),
                        centerY + radius * Math.sin(radian),
                        centerZ
                    )
                )
            );
        }
        circlePoints.push(new hmap.geom.Point(
            new hmap.basetype.Coordinate(
                centerX + radius, centerY, centerZ
            )
        ));
        this._pointArr = circlePoints;
    }

    /**
     * 提取圆的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>}
     * @example
     * let coordSeqs = circleGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if (this._pointArr.length != 0) {
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将圆转化为普通多边形
     * @returns {hmap.geom.Polygon} 普通多边形
     * @example
     * let polygon = circleGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取当前几何体的类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = circleGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.CIRCLE;
    }

    /**
     * 重新设置圆控制点
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度为2，否则抛出构造异常
     * @throws 数组长度不等于2或非数组类型，则抛出构造异常
     * @example
     * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     * circleGeom.setCtrlPoints([point1,point2])
     */
    setCtrlPoints(points) {
        if (!(points instanceof Array)) {
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if (points.length != 2) {
            throw new RangeError("only two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }

    /**
     * 检测圆与入参几何体是否相交。
     * @param {hmap.geom.Geometry} geom 几何体。
     * @returns {Boolean} 返回true表示相交；返回false表示不相交。
     * @example
     * const pt1 = new hmap.geom.Point(new hmap.basetype.Coordinate(119.0,30.0));
     * const pt2 = new hmap.geom.Point(new hmap.basetype.Cooridinate(120.0,30.2));
     * let geom = new hmap.geom.Line([pt1,pt2]);
     * circle.intersectsGeometry(geom);
     */
    intersectsGeometry(geom) {
        if (!geom.getType) {
            throw new TypeError("parameter is illegal!");
        }
        return {
            'Point': () => {
                return hmap.strategy.Intersect.pointIntersectCircle2D(geom, this);
            },
            'MultiPoint': () => {
                return hmap.strategy.Intersect.multiPointIntersectCircle2D(geom, this);
            },
            'Line': () => {
                return hmap.strategy.Intersect.lineIntersectCircle2D(geom, this);
            },
            'LinearRing': () => {
                return hmap.strategy.Intersect.lineIntersectCircle2D(geom, this);
            },
            'Triangle': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom.toPolygon(), this);
            },
            'MultiLine': () => {
                return hmap.strategy.Intersect.multiLineIntersectCircle2D(geom, this);
            },
            'Circle': () => {
                return hmap.strategy.Intersect.circle2DIntersectCircle2D(this, geom);
            },
            'Rectangle': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom.toPolygon(), this);
            },
            'Polygon': () => {
                return hmap.strategy.Intersect.polygonIntersectCircle2D(geom, this);
            },
            'MultiPolygon': () => {
                return hmap.strategy.Intersect.multiPolygonIntersectCircle2D(geom, this);
            },
            'Collection': () => {
                for (let geometry of geom.getGeoms()) {
                    if (this.intersectsGeometry(geometry)) {
                        return true;
                    }
                }
                return false;
            }
        } [geom.getType()]();
    }

    /**
     * 计算圆几何和一个地理几何体之间的距离（X-Y平面内）。
     * @param {hmap.geom.Geometry} geometry 地理几何体，继承{@link hmap.geom.Geometry}的任意几何体实例。
     * @param {Object} options 距离计算时的可选配置项。
     * @param {Boolean} options.details 指定返回结果的格式，默认为false
     * 若为true，则返回一个对象:{"distance":xxx,"x0":xxx,"y0":xxx,"x1":xxx,"y1":xxx}。其中 distance 表示几何对象到目标几何对象的距离；x0 和 y0 属性表示当前几何体上最靠近目标几何对象的坐标；x1 和 y1 表示目标几何上最靠近当前几何体的坐标。
     * 但当edge为false且两个几何体相交，则计算距离的详细交点信息的：x0,y0,x1,y1 无参考意义！
     * 若为false，则返回几何对象到目标几何对象的距离值，距离的单位与几何体的坐标相同。
     * @param {Boolean} options.edge 是否计算一个几何图形到目标几何图形边缘的最近距离，默认为true。 如果为true， 一个几何图形完全包含在目标几何图形中时，计算距离为负数；如果为false，两个几何图形相交情况下 计算距离为0。
     * @returns {Number | Object} 两个几何之间的距离。detials为true 返回Object 否则返回 Number
     * @example
     * let options = {details:true,edge:false};
     * let geom = new hmap.geom.Point(new hmap.basetype.Coordinate(112.0,26.0));
     * circle.distanceTo(geom,options);
     */
    //TODO 圆和圆的距离和交点
    distanceTo(geometry, options) {
        return this.toPolygon().distanceTo(geometry, options);
    }

    /**
     * 获取圆的半径。
     * @returns {Number} 圆的半径。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getRadius();//result=20
     */
    getRadius() {
        return this._radius;
    }

        /**
     * 获取圆的中心点。
     * @returns {hmap.geom.Point} 中心点。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let center = new hmap.geom.Point(coord);
     * let circle = new hmap.geom.Circle(center,20);
     * let result = circle.getCenter();
     */
    getCenter() {
        return this._center;
    }
};;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 椭圆
 * @type {hmap.geomext.Ellipse}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let ellipseGeom = new hmap.geomext.Ellipse([point1,point2]);
 */
hmap.geomext.Ellipse = class extends hmap.geomext.GeometryExt {
    /**
     *  构造椭圆
     *  @param {Array<hmap.geom.Point>} points 包含两个点状几何体数组。数组长度小于2或非数组类型，则抛出构造异常；当数组长度大于2时，取前2个控制点
     *  @throws 当数组长度小于2或非数组类型，抛出异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length <2){
            throw  new RangeError("At least two points are required!");
        }else{
            points=points.slice(0,2);
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];

        this.CLASS_NAME = "hmap.geomext.Ellipse";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的组成点
    }

    /**
     *  根据控制点计算椭圆的组成点坐标
     *  @private
     *  @throws 当控制点数组的长度小于2时会抛出异常
     */
    _generatePoints(){
        const pnt1 = this._ctrlPoints[0],pnt2 = this._ctrlPoints[1];
        let pnt1Coord = pnt1.getCoordinate(),pnt2Coord = pnt2.getCoordinate();      //第1、2个点坐标
        const points = [];
        //计算椭圆的半径
        let radius = Math.sqrt(2) * Math.abs(pnt2Coord.getOrdinate("Y") - pnt1Coord.getOrdinate("Y")) / 2;
        let rotatedAngle, x, y,ratio;
        let angle = Math.PI * ((1/360) - (1/2));
        let dx = pnt2Coord.getOrdinate("X") - pnt1Coord.getOrdinate("X");
        let dy = pnt2Coord.getOrdinate("Y") - pnt1Coord.getOrdinate("Y");

        if(dy == 0) {
            if(radius != 0){
                ratio = dx / (radius * Math.sqrt(2));
            }else{
                ratio = 0;
            }
        } else {
            ratio = dx / dy;
        }
        //计算圆的边缘所有点
        for(let i=0; i<360; ++i) {
            rotatedAngle = angle + (i * 2 * Math.PI / 360);
            x = pnt1Coord.getOrdinate("X") +  ratio * (radius * Math.cos(rotatedAngle))+ dx/2;
            y = pnt1Coord.getOrdinate("Y") + (radius * Math.sin(rotatedAngle))+dy/2;
            points[i]=new hmap.geom.Point(new hmap.basetype.Coordinate(x,y,0));
            if(i==359){
                points.push(points[0]);
            }
        }
        this._pointArr = points;
    }

    /**
     * 提取椭圆的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = ellipseGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将椭圆转化为普通多边形
     * @returns {hmap.geom.Polygon} 普通多边形
     * @example
     * let polygon = ellipseGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} 几何体类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = ellipseGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.ELLIPSE;
    }

    /**
     *  重置控制点
     *  @param {Array<hmap.geom.Point>} points 包含两个点状几何体数组。数组长度小于2或非数组类型，则抛出构造异常；当数组长度大于2时，取前2个控制点。
     *  @throws 当数组长度小于2或非数组类型，抛出异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  ellipseGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length <2){
            throw  new RangeError("At least two points are required!");
        }else{
            points=points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 扇形
 * @type {hmap.geomext.Sector}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let sectorGeom = new hmap.geomext.Sector([point1,point2,point3]);
 */
hmap.geomext.Sector = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造扇形，控制点数量为3
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前3个点几何
     * @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];
        this.direction = -1;
        this.CLASS_NAME = "hmap.geomext.Sector";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算扇形的组成点坐标
     *  @private
     */
    _generatePoints(){
        //取第一个点为圆心
        const centerPoint = this._ctrlPoints[0];
        const centerPoint_XY = {x:centerPoint.getCoordinate().getOrdinate("X"),y:centerPoint.getCoordinate().getOrdinate("Y")};
        //第二个点确定半径，为圆上一点
        const pointR = this._ctrlPoints[1];
        const pointR_XY = {x:pointR.getCoordinate().getOrdinate("X"),y:pointR.getCoordinate().getOrdinate("Y")};
        //最后一个点为圆上一点
        const pointC = this._ctrlPoints[2];
        const pointC_XY = {x:pointC.getCoordinate().getOrdinate("X"),y:pointC.getCoordinate().getOrdinate("Y")};
        //计算圆弧的半径
        let radius = this.calculateDistance(centerPoint_XY, pointR_XY);
        //分别计算圆上的两点所在的直径线与X轴的夹角
        let angleR=this.calculateAngle(pointR_XY,centerPoint_XY);
        let angleC=this.calculateAngle(pointC_XY,centerPoint_XY);
        if(angleR == angleC){
            let points = [centerPoint,pointR,pointR,centerPoint];
            this._pointArr = points;
            return;
        }
        //逆时针绘制
        if(this.direction==1&&angleC<angleR)   angleC=2*Math.PI+angleC;
        //顺时针绘制
        if(this.direction==-1&&angleC>angleR)   angleC=-(2*Math.PI-angleC);
        let points = [];
        points.push(centerPoint);
        let arcPoints=this.calculateArc(centerPoint_XY,radius,angleR,angleC,this.direction);
        points = points.concat(arcPoints);
        points.push(centerPoint);

        this._pointArr = points;
    }

    /**
     * 提取扇形的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = sectorGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将扇形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = sectorGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = sectorGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.SECTOR;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前3个点几何
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  sectorGeom.setCtrlPoints([point1,point2,point3]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 直角旗标
 * @type {hmap.geomext.RectFlag}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let rectFlagGeom = new hmap.geomext.RectFlag([point1,point2]);
 */
hmap.geomext.RectFlag = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造一个直角旗标，控制点数量为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.RectFlag";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  计算直角旗标图形的组成点坐标
     *  @private
     */
    _generatePoints(){
        // 维护圆上的点
        const pnt1 = this._ctrlPoints[0],pnt2 = this._ctrlPoints[1];
        const coord1 = pnt1.getCoordinate();
        const coord2 = pnt2.getCoordinate();
        const flagPoints = [];
        flagPoints.push(pnt1);
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord2.getOrdinate("X"),coord1.getOrdinate("Y"),0)));
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord2.getOrdinate("X"),0.5*(coord1.getOrdinate("Y")+coord2.getOrdinate("Y")),0)));
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord1.getOrdinate("X"),0.5*(coord1.getOrdinate("Y")+coord2.getOrdinate("Y")),0)));
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord1.getOrdinate("X"),coord2.getOrdinate("Y"),0)));
        flagPoints.push(pnt1);
        this._pointArr = flagPoints;
    }

    /**
     * 提取直角旗标的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = rectFlagGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将直角旗标图形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = rectFlagGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = rectFlagGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.FLAG.RECT_FLAG;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  rectFlagGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 三角旗标
 * @type {hmap.geomext.TriangleFlag}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let tFlagGeom = new hmap.geomext.TriangleFlag([point1,point2]);
 */
hmap.geomext.TriangleFlag = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造一个三角旗标，控制点数量为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;      //控制点数组
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.TriangleFlag";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算三角旗标的组成点坐标
     *  @private
     */
    _generatePoints(){
        const pnt1 = this._ctrlPoints[0],pnt2 = this._ctrlPoints[1];
        const coord1 = pnt1.getCoordinate();
        const coord2 = pnt2.getCoordinate();
        const flagPoints = [];
        flagPoints.push(pnt1);
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord2.getOrdinate("X"),0.5*(coord1.getOrdinate("Y")+coord2.getOrdinate("Y")),0)));
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord1.getOrdinate("X"),0.5*(coord1.getOrdinate("Y")+coord2.getOrdinate("Y")),0)));
        flagPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coord1.getOrdinate("X"),coord2.getOrdinate("Y"),0)));
        flagPoints.push(pnt1);
        this._pointArr = flagPoints;
    }

    /**
     * 提取三角旗标的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = tFlagGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将三角旗标图形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = tFlagGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = tFlagGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.FLAG.TRIANGLE_FLAG;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  tFlagGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 曲线旗标
 * @type {hmap.geomext.CurveFlag}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let curveFlagGeom = new hmap.geomext.CurveFlag([point1,point2]);
 */
hmap.geomext.CurveFlag = class extends hmap.geomext.GeometryExt{
    /**
     * 根据关键点，构造一个曲线旗标，关键点个数为2个
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     * @throws 数组长度小于2或非数组类型时，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;                //生成图形的关键点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.CurveFlag";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  计算曲线旗标的组成点
     *  @private
     */
    _generatePoints(){
        const startPoint = this._ctrlPoints[0],endPoint = this._ctrlPoints[1];
        const startCoord = startPoint.getCoordinate();
        const endCoord = endPoint.getCoordinate();
        //上曲线起始点
        let point1 = startPoint;
        //上曲线第一控制点
        let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate((startCoord.getOrdinate("X")-startCoord.getOrdinate("X"))/4+startCoord.getOrdinate("X"),(endCoord.getOrdinate("Y")-startCoord.getOrdinate("Y"))/8+startCoord.getOrdinate("Y"),0));
        //上曲线第二个点
        let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate((startCoord.getOrdinate("X")+endCoord.getOrdinate("X"))/2,startCoord.getOrdinate("Y"),0));
        //上曲线第二控制点
        let point4 =new hmap.geom.Point(new hmap.basetype.Coordinate((endCoord.getOrdinate("X")-startCoord.getOrdinate("X"))*3/4+startCoord.getOrdinate("X"),-(endCoord.getOrdinate("Y")-startCoord.getOrdinate("Y"))/8+startCoord.getOrdinate("Y"),0));
        //上曲线结束点
        let point5 = new hmap.geom.Point(new hmap.basetype.Coordinate(endCoord.getOrdinate("X"),startCoord.getOrdinate("Y"),0));

        //下曲线结束点
        let point6 = new hmap.geom.Point(new hmap.basetype.Coordinate(endCoord.getOrdinate("X"),(startCoord.getOrdinate("Y")+endCoord.getOrdinate("Y"))/2,0));
        //下曲线第二控制点
        let point7 = new hmap.geom.Point(new hmap.basetype.Coordinate((endCoord.getOrdinate("X")-startCoord.getOrdinate("X"))*3/4+startCoord.getOrdinate("X"),(endCoord.getOrdinate("Y")-startCoord.getOrdinate("Y"))*3/8+startCoord.getOrdinate("Y"),0));
        //下曲线第二个点
        let point8 = new hmap.geom.Point(new hmap.basetype.Coordinate((startCoord.getOrdinate("X")+endCoord.getOrdinate("X"))/2,(startCoord.getOrdinate("Y")+endCoord.getOrdinate("Y"))/2,0));
        //下曲线第一控制点
        let point9 = new hmap.geom.Point(new hmap.basetype.Coordinate((endCoord.getOrdinate("X")-startCoord.getOrdinate("X"))/4+startCoord.getOrdinate("X"),(endCoord.getOrdinate("Y")-startCoord.getOrdinate("Y"))*5/8+startCoord.getOrdinate("Y"),0));
        //下曲线起始点
        let point10 = new hmap.geom.Point(new hmap.basetype.Coordinate(startCoord.getOrdinate("X"),(startCoord.getOrdinate("Y")+endCoord.getOrdinate("Y"))/2,0));
        //旗杆底部点
        let point11 = new hmap.geom.Point(new hmap.basetype.Coordinate(startCoord.getOrdinate("X"),endCoord.getOrdinate("Y"),0));
        //计算上曲线
        let curve1 = this.getBezierPoints([point1,point2,point3,point4,point5]);
        //计算下曲线
        let curve2 = this.getBezierPoints([point6,point7,point8,point9,point10]);
        //合并
        let points = curve1.concat(curve2);
        points.push(point11);
        points.push(point1);        //连接开始点

        this._pointArr = points;
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = curveFlagGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.FLAG.CURVE_FLAG;
    }

    /**
     * 提取曲线旗标的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = curveFlagGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将曲线旗标转化为面几何
     * @returns {hmap.geom.Polygon} 线几何
     * @example
     * let polygon = curveFlagGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 将曲线旗标转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = curveFlagGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     *  重新设置控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型时，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,32,0));
     *  curveFlagGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 三点圆弧
 * @type {hmap.geomext.Arc}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let arcGeom = new hmap.geomext.Arc([point1,point2,point3]);
 */
hmap.geomext.Arc = class extends hmap.geomext.GeometryExt {
    /**
     * 根据三个控制点构造圆弧
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前三个点几何
     * @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.Arc";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  根据控制点计算圆弧的组成点
     *  @private
     */
    _generatePoints(){
        const pointA = {x:this._ctrlPoints[0].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[0].getCoordinate().getOrdinate("Y")};//this._ctrlPoints[0]
        const pointB = {x:this._ctrlPoints[1].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[1].getCoordinate().getOrdinate("Y")};//this._ctrlPoints[1];
        const pointC = {x:this._ctrlPoints[2].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[2].getCoordinate().getOrdinate("Y")};//this._ctrlPoints[2];
        //以第一个点A、第二个点B为圆弧的端点，C为圆弧上的一点
        //计算A点和B点的中点
        let midPointAB = this.calculateMidpoint(pointA, pointB);
        //计算B点和C点的中点
        let midPointBC = this.calculateMidpoint(pointB, pointC);
        //计算向量AB
        let vectorAB = {x:pointB.x - pointA.x, y:pointB.y - pointA.y};
        //计算向量BC
        let vectorBC = {x:pointC.x - pointB.x, y:pointC.y - pointB.y};
        //判断三点是否共线，若共线，返回三点（直线）
        if(Math.abs(vectorAB.x*vectorBC.y-vectorBC.x*vectorAB.y)<0.00000001)
        {
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointA.x,pointA.y,0)));
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointB.x,pointB.y,0)));
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointC.x,pointC.y,0)));
            return;
        }
        //计算过AB中点且与向量AB垂直的向量（AB的中垂线向量）
        let vector_center_midPointAB = this.calculateVector(vectorAB)[1];
        //计算过BC中点且与向量BC垂直的向量（BC的中垂线向量）
        let vector_center_midPointBC = this.calculateVector(vectorBC)[1];
        //计算圆弧的圆心
        let centerPoint = this.calculateIntersection(vector_center_midPointAB, vector_center_midPointBC, midPointAB, midPointBC);
        //计算圆弧的半径
        let radius = this.calculateDistance(centerPoint, pointA);
        //分别计算三点所在的直径线与X轴的夹角
        let angleA=this.calculateAngle(pointA,centerPoint);
        let angleB=this.calculateAngle(pointB,centerPoint);
        let angleC=this.calculateAngle(pointC,centerPoint);
        let PI=Math.PI;

        let  direction= 1,startAngle=angleA,endAngle=angleB,startP,endP;
        if(angleA>angleB)
        {
            startAngle=angleB;
            endAngle=angleA;
            startP=pointB;
            endP=pointA;
        }
        else
        {
            startP=pointA;
            endP=pointB;
        }
        let length=endAngle-startAngle;
        if((angleC<angleB &&angleC <angleA)||(angleC>angleB &&angleC >angleA))
        {
            direction=-1;
            length=startAngle+(2*PI-endAngle);
        }

        //计算圆弧上点，默认每隔1°绘制2个点
        let step=Math.PI*2/360;
        let stepDir= step*direction;

        this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(startP.x,startP.y,0)))
        for(let radians =startAngle,i = 0; i <length-step;i+=step)
        {
            radians+=stepDir;
            radians=radians<0?(radians+2*Math.PI):radians;
            radians=radians> 2*Math.PI?(radians-2*Math.PI):radians;
            let circlePoint = {x:Math.cos(radians) * radius + centerPoint.x, y:Math.sin(radians) * radius + centerPoint.y};
            this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(circlePoint.x,circlePoint.y,0)));
        }
        this._pointArr.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
    }

    /**
     * 提取圆弧的坐标序列
     * @example
     * let coordSeq = arcGeom.getCoordSeq();
     */
    getCoordSeq() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return new hmap.basetype.CoordSeq(circleCoordArr);
    }

    /**
     * 将圆弧曲线转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = arcGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toLine().getBBox();
    }

    /**
     * 获取几何体类型。
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = arcGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYLINE.ARC;
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前三个点几何
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(123,31,0));
     *  arcGeom.setCtrlPoints([point1,point2,point3])
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 贝塞尔三次曲线
 * @type {hmap.geomext.BezierCurve2}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let bezier2Geom = new hmap.geomext.BezierCurve2([point1,point2,point3]);
 */
hmap.geomext.BezierCurve2 = class extends hmap.geomext.GeometryExt {
    /**
     * 根据三个不重复的控制点，构造一个二次贝塞尔曲线
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前3个点几何
     * @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points,density=50) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this.density = density;
        this._ctrlPoints = points;
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.BezierCurve2";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  计算二次贝塞尔曲线的组成点
     *  @private
     */
    _generatePoints(){
        const point1 = this._ctrlPoints[0];
        const point2 = this._ctrlPoints[1];
        const point3 = this._ctrlPoints[2];
        const bezierPoints = this.getBezierPoints([point1,point2,point3],this.density);
        this._pointArr = bezierPoints;
    }

    /**
     * 提取二次贝塞尔曲线的坐标序列
     * @returns {hmap.basetype.CoordSeq} 坐标序列
     * @example
     * let coordSeq = bezier2Geom.getCoordSeq();
     */
    getCoordSeq() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return new hmap.basetype.CoordSeq(circleCoordArr);
    }

    /**
     * 将二次贝塞尔曲线转化为线几何。
     * @returns {hmap.geom.Line} 线几何。
     * @example
     * let polyline = bezier2Geom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = bezier2Geom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE2;
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前3个点几何
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(123,31,0));
     *  bezier2Geom.setCtrlPoints([point1,point2,point3])
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 贝塞尔三次曲线
 * @type {hmap.geomext.BezierCurve3}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,33,0));
 * let bezier3Geom = new hmap.geomext.BezierCurve3([point1,point2,point3,point4]);
 */
hmap.geomext.BezierCurve3 = class extends hmap.geomext.GeometryExt {
    /**
     * 根据四个不重复的控制点，构造一个三次贝塞尔曲线
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于4或非数组类型时，则抛出构造异常；当数组长度大于4时，取前4个点几何
     * @throws 数组长度小于4或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 4){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,4);
        }

        this._ctrlPoints = points;
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.BezierCurve3";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  计算三次贝塞尔曲线的组成点
     *  @private
     */
    _generatePoints(){
        const point1 = this._ctrlPoints[0];
        const point2 = this._ctrlPoints[1];
        const point3 = this._ctrlPoints[2];
        const point4 = this._ctrlPoints[3];
        const bezierPoints = this.getBezierPoints([point1,point2,point3,point4],50);
        this._pointArr = bezierPoints;
    }

    /**
     * 提取三次贝塞尔曲线的坐标序列
     * @returns {hmap.basetype.CoordSeq} 坐标序列
     * @example
     * let coordSeq = bezier3Geom.getCoordSeq();
     */
    getCoordSeq() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return new hmap.basetype.CoordSeq(circleCoordArr);
    }

    /**
     * 将曲线转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = bezier3Geom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = bezier3Geom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE3;
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于4或非数组类型时，则抛出构造异常；当数组长度大于4时，取前4个点几何
     *  @throws 数组长度小于4或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(123,31,0));
     *  let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(123,32,0));
     *  bezier3Geom.setCtrlPoints([point1,point2,point3,point4])
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 4){
            throw  new RangeError("At least three points are required!");
        }else{
            points = points.slice(0,4);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 贝塞尔N次曲线
 * @type {hmap.geomext.BezierCurveN}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,33,0));
 * let bezierNGeom = new hmap.geomext.BezierCurveN([point1,point2,point3,point4]);
 */
hmap.geomext.BezierCurveN = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点的个数构造贝塞尔曲线，至少需要两个不重复的点
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points, density=50) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this.density = density;
        this._ctrlPoints = points;
        this._pointArr = [];

        this.CLASS_NAME = "hmap.geomext.BezierCurveN";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算贝塞尔曲线的组成点
     *  @private
     */
    _generatePoints(){
        const bezierPoints = this.getBezierPoints(this._ctrlPoints,this.density);
        this._pointArr = bezierPoints;
    }

    /**
     * 提取贝塞尔曲线的坐标序列
     * @returns {hmap.basetype.CoordSeq} 坐标序列
     * @example
     * let coordSeq = bezierNGeom.getCoordSeq();
     */
    getCoordSeq() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return new hmap.basetype.CoordSeq(circleCoordArr);
    }

    /**
     * 将曲线转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = bezierNGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = bezierNGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVEN;
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,33,0));
     *  bezierNGeom.setCtrlPoints([point1,point2,point3,point4]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * Cardinal曲线
 * @type {hmap.geomext.CardinalCurve}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let cardinalGeom = new hmap.geomext.CardinalCurve([point1,point2,point3]);
 */
hmap.geomext.CardinalCurve = class extends hmap.geomext.GeometryExt{
    /**
     * 根据控制点，构造一个Cardinal曲线，控制点个数至少为3
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型，则抛出构造异常
     * @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }
        this._ctrlPoints = points;                //生成图形的关键点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.CardinalCurve";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算Cardinal曲线的组成点
     *  @private
     */
    _generatePoints(){
        const cardinalPoints = this.calculateCardinalPoints(this._ctrlPoints);     //获取Cardinal控制点
        this._pointArr = this.getBezierPoints(cardinalPoints,50);                   //根据Cardinal点获取贝塞尔曲线
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = cardinalGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYLINE.CARDINAL_CURVE;
    }

    /**
     * 提取Cardinal曲线的坐标序列
     * @returns {hmap.basetype.CoordSeq} 坐标序列
     * @example
     * let coordSeq = cardinalGeom.getCoordSeq();
     */
    getCoordSeq() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return new hmap.basetype.CoordSeq(circleCoordArr);
    }

    /**
     *  将Cardinal曲线转化为线几何
     *  @returns {hmap.geom.Line} 线几何
     *  @example
     *  let line = cardinalGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toLine().getBBox();
    }

    /**
     * 计算线段的三维长度。每个线段长度的计算：根据线在球面上投影的长度和两端点高差平方和，对其取开平方。
     * @param {Number} srid 坐标系类型。
     * @returns {Number} 线段的三维长度，单位是米。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,2);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let line = new hmap.geom.Line([point1,point2]);
     * let result = line.getLength(4326);
     */
    getLength(srid) {
        if(!srid){
            srid = hmap._srid;
        }
        let totalLength = 0;
        for (let i = 1, len = this._pointArr.length; i < len; i++) {
            const fromCoord = this._pointArr[i - 1].getCoordinate();
            const toCoord = this._pointArr[i].getCoordinate();
            const length2D = fromCoord.get2Dist(toCoord, srid);
            const elevationDiff = toCoord.getOrdinate("Z") - fromCoord.getOrdinate("Z");
            totalLength += Math.sqrt(length2D * length2D + elevationDiff * elevationDiff);
        }
        return totalLength;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型，则抛出构造异常
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,32,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,32,0));
     *  cardinalGeom.setCtrlPoints([point1,point2,point3]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 闭合曲线
 * @type {hmap.geomext.CloseCurve}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let closeCurveGeom = new hmap.geomext.CloseCurve([point1,point2,point3]);
 */
hmap.geomext.CloseCurve = class extends hmap.geomext.GeometryExt{
    /**
     * 根据关键点构造闭合曲线，至少需要3个不重复的关键点
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常
     * @throws 数组长度小于3或非数组类型时，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }

        this._ctrlPoints = points;                //生成图形的关键点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.CloseCurve";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  根据关键点计算闭合曲线的组成点，至少需要3个不重复的关键点
     *  @private
     */
    _generatePoints(){
        const cardinalPoints = this.calculateCloseCardinal(this._ctrlPoints);
        this._pointArr = this.getBezierPoints(cardinalPoints,50);         //根据Cardinal点获取贝塞尔曲线
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = closeCurveGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.CLOSE_CURVE;
    }

    /**
     * 提取闭合曲线的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = closeCurveGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将闭合曲线转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = closeCurveGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 将闭合曲线转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = closeCurveGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  重新设置关键点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于3或非数组类型时，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,32,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,32,0));
     *  closeCurveGeom.setCtrlPoints([point1,point2,point3]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 聚集区
 * @type {hmap.geomext.GatheringPlace}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let gatherPlaceGeom = new hmap.geomext.GatheringPlace([point1,point2]);
 */
hmap.geomext.GatheringPlace = class extends hmap.geomext.GeometryExt{
    /**
     *  根据控制点构造聚集区图形，坐标组中几何点数量为2
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个控制点
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.GatheringPlace";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算聚集区图形的组成点坐标
     *  @private
     * */
    _generatePoints(){
        //取第一个点作为第一控制点
        let originP = this._ctrlPoints[0];
        //取最后一个作为第二控制点
        let lastP = this._ctrlPoints[this._ctrlPoints.length-1];

        let points=[];
        // 向量originP_lastP
        let vectorOL= {x:lastP.getCoordinate().getOrdinate("X")-originP.getCoordinate().getOrdinate("X"),y:lastP.getCoordinate().getOrdinate("Y")-originP.getCoordinate().getOrdinate("Y")};
        // 向量originP_lastP的模
        let dOL=Math.sqrt(vectorOL.x * vectorOL.x+vectorOL.y * vectorOL.y);

        //计算第一个插值控制点
        //向量originP_P1以originP为起点，与向量originP_lastP的夹角设为30，模为√3/12*dOL，
        let v_O_P1_lr=this.calculateVector(vectorOL,Math.PI/3,Math.sqrt(3)/12*dOL);
        //取左边的向量作为向量originP_P1
        let originP_P1=v_O_P1_lr[0];
        let p1=new hmap.geom.Point(new hmap.basetype.Coordinate(originP_P1.x+originP.getCoordinate().getOrdinate("X"),originP_P1.y+originP.getCoordinate().getOrdinate("Y"),0));

        //计算第二个插值控制点，取第一控制点和第二控制点的中点为第二个插值控制点
        let p2=new hmap.geom.Point(new hmap.basetype.Coordinate((originP.getCoordinate().getOrdinate("X")+lastP.getCoordinate().getOrdinate("X"))/2,(originP.getCoordinate().getOrdinate("Y")+lastP.getCoordinate().getOrdinate("Y"))/2,0));

        //计算第三个插值控制点
        //向量originP_P3以lastP为起点，与向量originP_lastP的夹角设为150°，模为√3/12*dOL，
        let v_L_P3_lr=this.calculateVector(vectorOL,Math.PI*2/3,Math.sqrt(3)/12*dOL);
        //取左边的向量作为向量originP_P1
        let lastP_P3=v_L_P3_lr[0];
        let p3=new hmap.geom.Point(new hmap.basetype.Coordinate(lastP_P3.x+lastP.getCoordinate().getOrdinate("X"),lastP_P3.y+lastP.getCoordinate().getOrdinate("Y"),0));

        //计算第四个插值控制点
        //向量originP_P4以向量originP_lastP中点为起点，与向量originP_lastP的夹角设为90°，模为1/2*dOL，
        let v_O_P5_lr=this.calculateVector(vectorOL,Math.PI/2,1/2*dOL);
        //取左边的向量作为向量originP_P1
        let v_O_P5=v_O_P5_lr[1];
        let p5=new hmap.geom.Point(new hmap.basetype.Coordinate(v_O_P5.x+p2.getCoordinate().getOrdinate("X"),v_O_P5.y+p2.getCoordinate().getOrdinate("Y"),0));

        points.push(originP,p1,p2,p3,lastP,p5);

        const cardinalPoints = this.calculateCloseCardinal(points);     //获取Cardinal关键点
        this._pointArr = this.getBezierPoints(cardinalPoints,50);                  //根据Cardinal点获取贝塞尔曲线
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = gatherPlaceGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.GATHERING_PLACE;
    }

    /**
     *  提取聚集区图形的坐标序列
     *  @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     *  @example
     *  let coordSeqs = gatherPlaceGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     *  将聚集区图形转化为面几何
     *  @returns {hmap.geom.Polygon} 面几何
     *  @example
     *  let polygon = gatherPlaceGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  将聚集区图形转化为线几何。
     *  @returns {hmap.geom.Line} 线几何
     *  @example
     *  let line = gatherPlaceGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  gatherPlaceGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this.generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 弓形
 * @type {hmap.geomext.Lune}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let luneGeom = new hmap.geomext.Lune([point1,point2,point3]);
 */
hmap.geomext.Lune = class extends hmap.geomext.GeometryExt{
    /**
     * 根据控制点构造一个弓形，坐标组中几何点数量为3
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常；当数组长度大于3时，取前3个点几何
     * @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else if(points.length == 2){
            points = points;
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;                //生成图形的控制点
        this._pointArr = [];
        this.CLASS_NAME = "hmap.geomext.Lune";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算弓形的组成点坐标
     *  @private
     */
    _generatePoints(){
        //两个点时绘制半圆
        if (this._ctrlPoints.length ==2) {
            this._drawHalfCircle();
        }
        //至少需要三个控制点
        if (this._ctrlPoints.length > 2) {
            const pointA = {x:this._ctrlPoints[0].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[0].getCoordinate().getOrdinate("Y")};
            const pointB = {x:this._ctrlPoints[1].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[1].getCoordinate().getOrdinate("Y")};
            const pointC = {x:this._ctrlPoints[2].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[2].getCoordinate().getOrdinate("Y")};
            let points=[];
            //以第一个点A、第二个点B为圆弧的端点，C为圆弧上的一点
            //计算A点和B点的中点
            let midPointAB = this.calculateMidpoint(pointA, pointB);
            //计算B点和C点的中点
            let midPointBC = this.calculateMidpoint(pointB, pointC);
            //计算向量AB
            let vectorAB ={x:pointB.x - pointA.x,y:pointB.y - pointA.y};
            //计算向量BC
            let vectorBC = {x:pointC.x - pointB.x, y:pointC.y - pointB.y};
//                判断三点是否共线，若共线，返回三点（直线）
            if(Math.abs(vectorAB.x*vectorBC.y-vectorBC.x*vectorAB.y)<0.00001)
            {
                this._drawHalfCircle();
                return;
            }
            //计算过AB中点且与向量AB垂直的向量（AB的中垂线向量）
            let vector_center_midPointAB = this.calculateVector(vectorAB)[1];
            //计算过BC中点且与向量BC垂直的向量（BC的中垂线向量）
            let vector_center_midPointBC = this.calculateVector(vectorBC)[1];
            //计算圆弧的圆心
            let centerPoint = this.calculateIntersection(vector_center_midPointAB, vector_center_midPointBC, midPointAB, midPointBC);
            //计算圆弧的半径
            let radius = this.calculateDistance(centerPoint, pointA);
            //分别计算三点所在的直径线与X轴的夹角
            let angleA=this.calculateAngle(pointA,centerPoint);
            let angleB=this.calculateAngle(pointB,centerPoint);
            let angleC=this.calculateAngle(pointC,centerPoint);
            let PI=Math.PI;

            /*圆弧绘制思路为：
            angleA、angleB中最小的角对应的点为起点，最大的角对应的点为终点，若angleC不同时小于或不同时大于angleA与angleB，
            则从起点开始逆时针（direction=1）绘制点，直至终点；否则，从起点开始顺时针（direction=-1）绘制点，直至终点。
            */
            let  direction= 1,startAngle=angleA,endAngle=angleB,startP,endP;
            if(angleA>angleB)
            {
                startAngle=angleB;
                endAngle=angleA;
                startP=pointB;
                endP=pointA;
            }
            else
            {
                startP=pointA;
                endP=pointB;
            }
            let length=endAngle-startAngle;
            if((angleC<angleB &&angleC <angleA)||(angleC>angleB &&angleC >angleA))
            {
                direction=-1;
                length=startAngle+(2*PI-endAngle);
            }

            //计算圆弧上点，默认每隔1°绘制2个点
            let step=PI/720/2;
            let stepDir= step*direction;
            points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(startP.x,startP.y,0)));
            for(let radians =startAngle,i = 0; i <length-step;i+=step)
            {
                radians+=stepDir;
                radians=radians<0?(radians+2*PI):radians;
                radians=radians> 2*PI?(radians-2*PI):radians;
                let circlePoint = {x:Math.cos(radians) * radius + centerPoint.x,y:Math.sin(radians) * radius + centerPoint.y};
                points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(circlePoint.x,circlePoint.y,0)));
            }
            points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
            points.push(this._ctrlPoints[0]);
            this._pointArr = points;
        }
    }

    /**
     *  绘制半圆
     *  @private
     */
    _drawHalfCircle(){
        const pointA = {x:this._ctrlPoints[0].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[0].getCoordinate().getOrdinate("Y")};
        const pointB = {x:this._ctrlPoints[1].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[1].getCoordinate().getOrdinate("Y")};
        let centerP = this.calculateMidpoint(pointA,pointB);
        let radius = this.calculateDistance(pointA,pointB)/2;
        let angleS = this.calculateAngle(pointA,centerP);
        let points = this.calculateArc(centerP,radius,angleS,angleS+Math.PI,-1);
        points.push(this._ctrlPoints[0]);
        this._pointArr = points;
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = luneGeom.getType()
     */
    getType() {
        return hmap.geom.GeometryExtType.POLYGON.LUNE;
    }

    /**
     *  提取弓形的坐标序列
     *  @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     *  @example
     *  let coordSeqs = luneGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将弓形转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = luneGeom.toPolygon();
     */
    toPolygon(){
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 将弓形转化为线几何
     * @returns {hmap.geom.Line} 线几何
     * @example
     * let line = luneGeom.toLine();
     */
    toLine(){
        return new hmap.geom.Line(this._pointArr);
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  luneGeom.setCtrlPoints([point1,point2,point3]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else if(points.length == 2){
            points = points;
        }else{
            points = points.slice(0,3);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 直箭头
 * @type {hmap.geomext.StraightArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let sArrowGeom = new hmap.geomext.StraightArrow([point1,point2]);
 */
hmap.geomext.StraightArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造直箭头，控制点个数至少为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //控制点不重复
        this._pointArr = [];
        this._ratio = 6,            //箭头长度与宽度的比值，箭头三角形需要占用总长度的1/_ratio
        this._tailRatio = 5,        //箭头起始两个节点长度与箭头尾巴的比值
        this.CLASS_NAME = "hmap.geomext.StraightArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算直箭头的组成点坐标
     *  @private
     * */
    _generatePoints(){
        //计算只有两个点时，即直的直箭头
        if(this._ctrlPoints.length == 2)
        {
            this._calculateTwoPoints();
        }
        //计算有三个或三个以上的点时，即弯曲的直箭头
        else
        {
            this._calculateMorePoints();
        }
    }

    /**
     * 计算两个控制点时燕尾直箭头的所有绘制点
     * 两个控制点的燕尾直箭头绘制点只需要7个就可以构成
     * @private
     */
    _calculateTwoPoints(){
        let controlPois = this._ctrlPoints;

        //取出第一和第二两个点
        let pointS = {x:controlPois[0].getCoordinate().getOrdinate("X"),y:controlPois[0].getCoordinate().getOrdinate("Y")};    //controlPois[0];
        let pointE = {x:controlPois[1].getCoordinate().getOrdinate("X"),y:controlPois[1].getCoordinate().getOrdinate("Y")};    //controlPois[1];
        //计算箭头总长度，即两个控制点的距离
        let l = Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
        //计算燕尾直箭头的宽
        let w = l/this._ratio;

        //计算三角形的底边中心点坐标
        let x_ = pointS.x + (pointE.x - pointS.x)*(this._ratio-1)/this._ratio;
        let y_ = pointS.y + (pointE.y - pointS.y)*(this._ratio-1)/this._ratio;
        //计算与基本向量夹角90度的，长度为w/2的向量数组
        let v_lr = this.calculateVector({x:pointE.x-pointS.x,y:pointE.y-pointS.y},Math.PI/2,w/2);
        //获取左右向量
        let v_l = v_lr[0];
        let v_r = v_lr[1];
        //左1点
        let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointS.x+v_l.x,pointS.y+v_l.y,0));
        //左2点
        let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(x_+point1.getCoordinate().getOrdinate("X")-pointS.x,y_+point1.getCoordinate().getOrdinate("Y")-pointS.y,0));
        //左3点
        let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(2*point2.getCoordinate().getOrdinate("X")-x_,2*point2.getCoordinate().getOrdinate("Y")-y_,0));
        //顶点
        let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointE.x,pointE.y,0));
        //右3点
        let point7 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointS.x+v_r.x,pointS.y+v_r.y,0));
        //右2点
        let point6 = new hmap.geom.Point(new hmap.basetype.Coordinate(x_+point7.getCoordinate().getOrdinate("X")-pointS.x,y_+point7.getCoordinate().getOrdinate("Y")-pointS.y,0));
        //右1点
        let point5 = new hmap.geom.Point(new hmap.basetype.Coordinate(2*point6.getCoordinate().getOrdinate("X")-x_,2*point6.getCoordinate().getOrdinate("Y")-y_,0));

        this._pointArr.push(point1,point2,point3,point4,point5,point6,point7,point1);
    }

    /**
     * 计算三个或三个以上的控制点时的所有绘制点
     * 由于中间的控制点之间会进行差值，产生曲线效果，所以所需绘制点会很多
     * 这里使用的思想是将所有用户控制点连接起来形成一条折线段，
     * 然后在拐角进行曲线化处理（二次贝塞尔曲线差值），就形成了效果比较好的箭头
     * @private
     */
    _calculateMorePoints(){
        let controlPois = this._ctrlPoints;

        //计算箭头总长度
        let l = 0;
        //计算燕尾直箭头的宽
        let w = 0;
        //在尾部两个中间插入一个点，是pointS往pointE平移的一个点，为了制作尾巴的效果
        let point_tail;
        for(let i = 0;i<controlPois.length-1;i++)
        {
            //取出首尾两个点
            let pointS = {x:controlPois[i].getCoordinate().getOrdinate("X"),y:controlPois[i].getCoordinate().getOrdinate("Y")};//controlPois[i];
            let pointE = {x:controlPois[i+1].getCoordinate().getOrdinate("X"),y:controlPois[i+1].getCoordinate().getOrdinate("Y")};//controlPois[i+1];
            l += Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
            if(i==0)
            {
                point_tail = {x:(pointE.x-pointS.x)/this._tailRatio+pointS.x,y:(pointE.y-pointS.y)/this._tailRatio+pointS.y};
            }
        }
        w = l/this._ratio;
        //定义左右控制点集合
        let points_C_l = [];
        let points_C_r = [];
        //定义尾部左右的起始点
        let point_t_l={x:0,y:0};
        let point_t_r={x:0,y:0};
        //计算中间的所有交点
        for(let j = 0;j<controlPois.length-2;j++)
        {
            let pointU_1 = {x:controlPois[j].getCoordinate().getOrdinate("X"),y:controlPois[j].getCoordinate().getOrdinate("Y")};//controlPois[j];//第一个用户传入的点
            let pointU_2 = {x:controlPois[j+1].getCoordinate().getOrdinate("X"),y:controlPois[j+1].getCoordinate().getOrdinate("Y")};//controlPois[j+1];//第二个用户传入的点
            let pointU_3 = {x:controlPois[j+2].getCoordinate().getOrdinate("X"),y:controlPois[j+2].getCoordinate().getOrdinate("Y")};//controlPois[j+2];//第三个用户传入的点

            //计算向量
            let v_U_1_2 = {x:pointU_2.x-pointU_1.x,y:pointU_2.y-pointU_1.y};
            let v_U_2_3 = {x:pointU_3.x-pointU_2.x,y:pointU_3.y-pointU_2.y};

            let v_lr_1_2 = this.calculateVector(v_U_1_2,Math.PI/2,w/2);
            let v_l_1_2 = v_lr_1_2[0];
            let v_r_1_2 = v_lr_1_2[1];
            let v_lr_2_3 = this.calculateVector(v_U_2_3,Math.PI/2,w/2);
            let v_l_2_3 = v_lr_2_3[0];
            let v_r_2_3 = v_lr_2_3[1];
            //获取左右
            let point_l_1 = {x:pointU_1.x+v_l_1_2.x,y:pointU_1.y+v_l_1_2.y};
            let point_r_1 = {x:pointU_1.x+v_r_1_2.x,y:pointU_1.y+v_r_1_2.y};
            let point_l_2 = {x:pointU_2.x+v_l_2_3.x,y:pointU_2.y+v_l_2_3.y};
            let point_r_2 = {x:pointU_2.x+v_r_2_3.x,y:pointU_2.y+v_r_2_3.y};
            //向量v_U_1_2和向量v-point_l_1和point_r_1是平行的
            //如果向量a=(x1，y1)，b=(x2，y2)，则a//b等价于x1y2－x2y1=0
            //得到(x-point_l_1.x)*v_U_1_2.y=v_U_1_2.x*(y-point_l_1.y)
            //得到(point_l_2.x-x)*v_U_2_3.y=v_U_2_3.x*(point_l_2.y-y)
            //可以求出坐边的交点(x,y)，即控制点
            let point_C_l = this.calculateIntersection(v_U_1_2,v_U_2_3,point_l_1,point_l_2);
            let point_C_r = this.calculateIntersection(v_U_1_2,v_U_2_3,point_r_1,point_r_2);
            //定义中间的控制点
            let point_C_l_c;
            let point_C_r_c;
            if(j == 0)
            {
                //记录下箭头尾部的左右两个端点
                point_t_l = point_l_1;
                point_t_r = point_r_1;
                //计算第一个曲线控制点
                point_C_l_c = {x:(point_t_l.x+point_C_l.x)/2,y:(point_t_l.y+point_C_l.y)/2};
                point_C_r_c = {x:(point_t_r.x+point_C_r.x)/2,y:(point_t_r.y+point_C_r.y)/2};
                //添加两个拐角控制点中间的中间控制点
                points_C_l.push(point_C_l_c);
                points_C_r.push(point_C_r_c);
            }
            else
            {
                //获取前一个拐角控制点
                let point_C_l_q = points_C_l[points_C_l.length-1];
                let point_C_r_q = points_C_r[points_C_r.length-1];
                //计算两个拐角之间的中心控制点
                point_C_l_c = {x:(point_C_l_q.x+point_C_l.x)/2,y:(point_C_l_q.y+point_C_l.y)/2};
                point_C_r_c = {x:(point_C_r_q.x+point_C_r.x)/2,y:(point_C_r_q.y+point_C_r.y)/2};
                //添加两个拐角控制点中间的中间控制点
                points_C_l.push(point_C_l_c);
                points_C_r.push(point_C_r_c);
            }
            //添加后面的拐角控制点
            points_C_l.push(point_C_l);
            points_C_r.push(point_C_r);
        }
        //计算

        //进入计算头部
        //计算一下头部的长度
        let pointU_E2 = {x:controlPois[controlPois.length-2].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-2].getCoordinate().getOrdinate("Y")};//controlPois[controlPois.length-2];//倒数第二个用户点
        let pointU_E1 = {x:controlPois[controlPois.length-1].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-1].getCoordinate().getOrdinate("Y")};//controlPois[controlPois.length-1];//最后一个用户点
        //
        let v_U_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
        let head_d = Math.sqrt(v_U_E2_E1.x*v_U_E2_E1.x + v_U_E2_E1.y*v_U_E2_E1.y);
        //定义头部的左右两结束点
        let point_h_l;
        let point_h_r;

        //头部左右两向量数组
        let v_lr_h = [];
        let v_l_h;
        let v_r_h;
        //定义曲线最后一个控制点，也就是头部结束点和最后一个拐角点的中点
        let point_C_l_e;
        let point_C_r_e;
        //定义三角形的左右两个点
        let point_triangle_l;
        let point_triangle_r;

        //获取当前的最后的控制点，也就是之前计算的拐角点
        let point_C_l_eq = points_C_l[points_C_l.length-1];
        let point_C_r_eq = points_C_r[points_C_r.length-1];

        //三角的高度都不够
        if(head_d <= w)
        {
            v_lr_h = this.calculateVector(v_U_E2_E1,Math.PI/2,w/2);
            v_l_h = v_lr_h[0];
            v_r_h = v_lr_h[1];
            //获取头部的左右两结束点
            point_h_l = {x:pointU_E2.x+v_l_h.x,y:pointU_E2.y+v_l_h.y};
            point_h_r = {x:pointU_E2.x+v_r_h.x,y:pointU_E2.y+v_r_h.y};


            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);


            //计算三角形的左右两点
            point_triangle_l = {x:2*point_h_l.x-pointU_E2.x,y:2*point_h_l.y-pointU_E2.y};
            point_triangle_r = {x:2*point_h_r.x-pointU_E2.x,y:2*point_h_r.y-pointU_E2.y};
        }
        //足够三角的高度
        else
        {
            //由于够了三角的高度，所以首先去掉三角的高度

            //计算向量
            let v_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
            //取模
            let v_E2_E1_d = Math.sqrt(v_E2_E1.x*v_E2_E1.x+v_E2_E1.y*v_E2_E1.y);
            //首先需要计算三角形的底部中心点
            let point_c = {x:pointU_E1.x-v_E2_E1.x*w/v_E2_E1_d,y:pointU_E1.y-v_E2_E1.y*w/v_E2_E1_d};
            //计算出在三角形上底边上头部结束点

            v_lr_h = this.calculateVector(v_U_E2_E1,Math.PI/2,w/2);
            v_l_h = v_lr_h[0];
            v_r_h = v_lr_h[1];
            //获取头部的左右两结束点
            point_h_l = {x:point_c.x+v_l_h.x,y:point_c.y+v_l_h.y};
            point_h_r = {x:point_c.x+v_r_h.x,y:point_c.y+v_r_h.y};

            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);

            //计算三角形的左右点
            point_triangle_l = {x:2*point_h_l.x-point_c.x,y:2*point_h_l.y-point_c.y};
            point_triangle_r = {x:2*point_h_r.x-point_c.x,y:2*point_h_r.y-point_c.y};
        }

        const leftPoints = [];
        const rightPoints = [];
        for(let i=0;i<points_C_l.length;i++){
            leftPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_l[i].x,points_C_l[i].y,0)));
        }
        for(let i=0;i<points_C_r.length;i++){
            rightPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_r[i].x,points_C_r[i].y,0)));
        }

        //计算贝塞尔的控制点
        let points_BC_l = this.getBezierPoints(leftPoints);
        let points_BC_r = this.getBezierPoints(rightPoints);
        //左边尾部起始点
        let pointsR = [new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0))];         //[point_t_l];
        //首先连接左边的差值曲线
        pointsR = pointsR.concat(points_BC_l);
        //添加左边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.x,point_h_l.y,0)));        //point_h_l
        //添加三角形左边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_l.x,point_triangle_l.y,0)));     //point_triangle_l
        //添加三角形顶点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_E1.x,pointU_E1.y,0)));        //pointU_E1
        //添加三角形右边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_r.x,point_triangle_r.y,0)));         //point_triangle_r
        //添加右边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.x,point_h_r.y,0)));        //point_h_r
        //合并右边的所有点（先把右边的点倒序）
        pointsR = pointsR.concat(points_BC_r.reverse());
        //添加右边尾部起始点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_r.x,point_t_r.y,0)));        //point_t_r
        //左边尾部起始点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0)));       //point_tail

        this._pointArr = pointsR;
    }

    /**
     * 提取直箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let result = sArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将直箭头转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = sArrowGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = sArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.ARROW.STRAIGHT_ARROW;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  sArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 斜箭头
 * @type {hmap.geomext.DiagonalArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let dArrowGeom = new hmap.geomext.DiagonalArrow([point1,point2]);
 */
hmap.geomext.DiagonalArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造斜箭头，控制点个数至少为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     * @throws 数组长度小于2或非数组类型时，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //关键点不重复
        this._pointArr = [];

        this._ratio = 6,            //箭头长度与宽度的比值，箭头三角形需要占用总长度的1/_ratio
        this._tailRatio = 5,        //箭头起始两个节点长度与箭头尾巴的比值

        this.CLASS_NAME = "hmap.geomext.DiagonalArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算斜箭头的组成点坐标
     *  @private
     */
    _generatePoints(){
        //计算只有两个点时，即直的斜箭头
        if(this._ctrlPoints.length == 2)
        {
            this._calculateTwoPoints();
        }
        //计算有三个或三个以上的点时，即弯曲的斜箭头
        else
        {
            this._calculateMorePoints();
        }
    }

    /**
     *  计算两个控制点时斜箭头的所有绘制点
     *  两个控制点的斜箭头绘制点只需要7个就可以构成
     *  @private
     */
    _calculateTwoPoints(){
        let controlPois = this._ctrlPoints;

        //取出第一和第二两个点
        let pointS = {x:controlPois[0].getCoordinate().getOrdinate("X"),y:controlPois[0].getCoordinate().getOrdinate("Y")};    //controlPois[0];
        let pointE = {x:controlPois[1].getCoordinate().getOrdinate("X"),y:controlPois[1].getCoordinate().getOrdinate("Y")};    //controlPois[1];
        //计算箭头总长度，即两个控制点的距离
        let l = Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
        //计算燕尾直箭头的宽
        let w = l/this._ratio;

        //计算三角形的底边中心点坐标
        let x_ = pointS.x + (pointE.x - pointS.x)*(this._ratio-1)/this._ratio;
        let y_ = pointS.y + (pointE.y - pointS.y)*(this._ratio-1)/this._ratio;
        //计算与基本向量夹角90度的，长度为w/2的向量数组
        let v_lr = this.calculateVector({x:pointE.x-pointS.x,y:pointE.y-pointS.y},Math.PI/2,w/2);
        //获取左右向量
        let v_l_ = v_lr[0];
        let v_r_ = v_lr[1];

        //获取左边尾部点
        let point_l = new hmap.geom.Point(new hmap.basetype.Coordinate(v_l_.x+pointS.x,v_l_.y+pointS.y,0));
        //获取右边尾部点
        let point_r = new hmap.geom.Point(new hmap.basetype.Coordinate(v_r_.x+pointS.x,v_r_.y+pointS.y,0));

        let point_h_l = new hmap.geom.Point(new hmap.basetype.Coordinate(v_l_.x/this._ratio+x_,v_l_.y/this._ratio+y_,0));
        let point_h_r = new hmap.geom.Point(new hmap.basetype.Coordinate(v_r_.x/this._ratio+x_,v_r_.y/this._ratio+y_,0));

        //计算三角形左边点
        let point_a_l = new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.getCoordinate().getOrdinate("X")*2-point_h_r.getCoordinate().getOrdinate("X"),point_h_l.getCoordinate().getOrdinate("Y")*2-point_h_r.getCoordinate().getOrdinate("Y"),0));
        //计算三角形右边点
        let point_a_r = new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.getCoordinate().getOrdinate("X")*2-point_h_l.getCoordinate().getOrdinate("X"),point_h_r.getCoordinate().getOrdinate("Y")*2-point_h_l.getCoordinate().getOrdinate("Y"),0));

        let point_end = new hmap.geom.Point(new hmap.basetype.Coordinate(pointE.x,pointE.y,0));

        this._pointArr.push(point_l,point_h_l,point_a_l,point_end,point_a_r,point_h_r,point_r,point_l);
    }

    /**
     *  计算三个或三个以上的控制点时的所有绘制点
     *  由于中间的控制点之间会进行差值，产生曲线效果，所以所需绘制点会很多
     *  这里使用的思想是将所有用户控制点连接起来形成一条折线段，
     *  然后在拐角进行曲线化处理（二次贝塞尔曲线差值），就形成了效果比较好的箭头
     *  @private
     */
    _calculateMorePoints(){
        let controlPois = this._ctrlPoints;
        //计算箭头总长度
        let l = 0;
        //计算直箭头的宽
        let w = 0;

        for(let i = 0; i < controlPois.length - 1; i++)
        {
            //取出首尾两个点
            let pointS = {x:controlPois[i].getCoordinate().getOrdinate("X"),y:controlPois[i].getCoordinate().getOrdinate("Y")};
            let pointE = {x:controlPois[i+1].getCoordinate().getOrdinate("X"),y:controlPois[i+1].getCoordinate().getOrdinate("Y")};
            l += Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
        }
        w = l/this._ratio;

        let a = Math.atan(w/(2*l));

        //定义左右控制点集合
        let points_C_l = [];
        let points_C_r = [];
        //定义尾部左右的起始点
        let point_t_l={x:0,y:0};
        let point_t_r={x:0,y:0};


        //计算中间的所有交点
        for(let j = 0; j < controlPois.length-2; j++)
        {
            let pointU_1 = {x:controlPois[j].getCoordinate().getOrdinate("X"),y:controlPois[j].getCoordinate().getOrdinate("Y")};
            let pointU_2 = {x:controlPois[j+1].getCoordinate().getOrdinate("X"),y:controlPois[j+1].getCoordinate().getOrdinate("Y")};
            let pointU_3 = {x:controlPois[j+2].getCoordinate().getOrdinate("X"),y:controlPois[j+2].getCoordinate().getOrdinate("Y")};

            //计算向量
            let v_U_1_2 = {x:pointU_2.x-pointU_1.x,y:pointU_2.y-pointU_1.y};
            let v_U_2_3 = {x:pointU_3.x-pointU_2.x,y:pointU_3.y-pointU_2.y};

            //定义左边第一个控制点
            let point_l_1 = {x:0,y:0};
            //定义右边第一个控制点
            let point_r_1 = {x:0,y:0};
            //如果j=0时，左右第一个控制点需要计算
            if(j == 0)
            {
                let v_lr_ = this.calculateVector(v_U_1_2,Math.PI/2,w/2);
                //获取左边尾部点
                let v_l_ = v_lr_[0];
                //获取右边尾部点
                let v_r_ = v_lr_[1];
                //获取左边尾部点
                point_t_l = point_l_1 = {x:v_l_.x+pointU_1.x,y:v_l_.y+pointU_1.y};
                //获取右边尾部点
                point_t_r = point_r_1 = {x:v_r_.x+pointU_1.x,y:v_r_.y+pointU_1.y};
            }
            //否则获取上一次的记录
            else
            {
                point_l_1 = points_C_l[points_C_l.length-1];
                point_r_1 = points_C_r[points_C_r.length-1];
            }
            let v_lr = this.calculateVector(v_U_1_2,a,1);
            //这里的向量需要反过来
            //获取左边向量
            let v_l = v_lr[1];
            //获取右边向量
            let v_r = v_lr[0];
            //定义角平分线向量
            let v_angularBisector = this.calculateAngularBisector({x:-v_U_1_2.x,y:-v_U_1_2.y},v_U_2_3);
            //求交点
            //计算左边第二个控制点
            let point_l_2 = this.calculateIntersection(v_l,v_angularBisector,point_l_1,pointU_2);
            let point_r_2 = this.calculateIntersection(v_r,v_angularBisector,point_r_1,pointU_2);


            //添加后面的拐角控制点
            points_C_l.push({x:(point_l_1.x+point_l_2.x)/2,y:(point_l_1.y+point_l_2.y)/2});
            points_C_l.push(point_l_2);
            points_C_r.push({x:(point_r_1.x+point_r_2.x)/2,y:(point_r_1.y+point_r_2.y)/2});
            points_C_r.push(point_r_2);
        }

        //进入计算头部
        //计算一下头部的长度
        let pointU_E2 = {x:controlPois[controlPois.length-2].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-2].getCoordinate().getOrdinate("Y")};        //倒数第二个用户点
        let pointU_E1 = {x:controlPois[controlPois.length-1].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-1].getCoordinate().getOrdinate("Y")};        //最后一个用户点
        let head_d = Math.sqrt((pointU_E2.x-pointU_E1.x)*(pointU_E2.x-pointU_E1.x) + (pointU_E2.y-pointU_E1.y)*(pointU_E2.y-pointU_E1.y));
        //定义头部的左右两结束点
        let point_h_l = {x:0,y:0};
        let point_h_r = {x:0,y:0};
        //三角形左右两点数组
        let point_lr_t = [];
        //定义曲线最后一个控制点，也就是头部结束点和最后一个拐角点的中点
        let point_C_l_e = {x:0,y:0};
        let point_C_r_e = {x:0,y:0};
        //定义三角形的左右两个点
        let point_triangle_l = {x:0,y:0};
        let point_triangle_r = {x:0,y:0};

        //获取当前的最后的控制点，也就是之前计算的拐角点
        let point_C_l_eq = points_C_l[points_C_l.length-1];
        let point_C_r_eq = points_C_r[points_C_r.length-1];
        //申明三角形的两边向量
        let v_l_t = {x:0,y:0};
        let v_r_t = {x:0,y:0};
        //三角的高度都不够
        if(head_d <= w)
        {
            point_lr_t = this.calculateVector({x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y},Math.PI/2,w/2);
            //获取三角形左右两个向量
            v_l_t = point_lr_t[0];
            v_r_t = point_lr_t[1];

            point_h_l = {x:v_l_t.x/this._ratio+pointU_E2.x,y:v_l_t.y/this._ratio+pointU_E2.y};
            point_h_r = {x:v_r_t.x/this._ratio+pointU_E2.x,y:v_r_t.y/this._ratio+pointU_E2.y};
            //计算三角形的左右两点
            point_triangle_l = {x:point_h_l.x*2-point_h_r.x,y:point_h_l.y*2-point_h_r.y};
            point_triangle_r = {x:point_h_r.x*2-point_h_l.x,y:point_h_r.y*2-point_h_l.y};


            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);
        }
        //足够三角的高度
        else
        {
            //由于够了三角的高度，所以首先去掉三角的高度
            //计算向量
            let v_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
            //取模
            let v_E2_E1_d = Math.sqrt(v_E2_E1.x*v_E2_E1.x+v_E2_E1.y*v_E2_E1.y);
            //首先需要计算三角形的底部中心点
            let point_c = {x:pointU_E1.x-v_E2_E1.x*w/v_E2_E1_d,y:pointU_E1.y-v_E2_E1.y*w/v_E2_E1_d};

            //计算出在三角形上底边上头部结束点
            point_lr_t = this.calculateVector({x:pointU_E1.x-point_c.x,y:pointU_E1.y-point_c.y},Math.PI/2,w/2);
            //获取三角形左右两个向量
            v_l_t = point_lr_t[0];
            v_r_t = point_lr_t[1];

            point_h_l = {x:v_l_t.x/this._ratio+point_c.x,y:v_l_t.y/this._ratio+point_c.y};
            point_h_r = {x:v_r_t.x/this._ratio+point_c.x,y:v_r_t.y/this._ratio+point_c.y};
            //计算三角形的左右两点
            point_triangle_l = {x:point_h_l.x*2-point_h_r.x,y:point_h_l.y*2-point_h_r.y};
            point_triangle_r = {x:point_h_r.x*2-point_h_l.x,y:point_h_r.y*2-point_h_l.y};

            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);
        }
        const leftPoints = [];
        const rightPoints = [];
        for(let i=0;i<points_C_l.length;i++){
            leftPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_l[i].x,points_C_l[i].y,0)));
        }
        for(let i=0;i<points_C_r.length;i++){
            rightPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_r[i].x,points_C_r[i].y,0)));
        }
        //计算贝塞尔的控制点
        let points_BC_l = this.getBezierPoints(leftPoints);
        let points_BC_r = this.getBezierPoints(rightPoints);
        //组合左右点集和三角形三个点
        let pointsR = [new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0))];
        //首先连接左边的差值曲线
        pointsR = pointsR.concat(points_BC_l);
        //添加左边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.x,point_h_l.y,0)));
        //添加三角形左边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_l.x,point_triangle_l.y,0)));
        //添加三角形顶点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_E1.x,pointU_E1.y,0)));
        //添加三角形右边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_r.x,point_triangle_r.y,0)));
        //添加右边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.x,point_h_r.y,0)));
        //合并右边的所有点
        for(let k = points_BC_r.length-1; k>=0; k--)
        {
            pointsR.push(points_BC_r[k]);
        }
        //添加右边尾部起始点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_r.x,point_t_r.y,0)));
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0)));
        this._pointArr = pointsR;
    }

    /**
     *  提取斜箭头的坐标序列
     *  @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     *  @example
     *  let coordSeqs = dArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将斜箭头转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = dArrowGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = dArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.ARROW.DIAGONAL_ARROW;
    }

    /**
     *  重新设置控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型时，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,32,0));
     *  dArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 燕尾直箭头
 * @type {hmap.geomext.DoveTailStraightArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let dtdArrowGeom = new hmap.geomext.DoveTailStraightArrow([point1,point2]);
 */
hmap.geomext.DoveTailStraightArrow = class extends hmap.geomext.GeometryExt {
    /**
     *  根据控制点构造燕尾直箭头，控制点个数至少为2
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //关键点不重复
        this._pointArr = [];

        this._ratio = 6,            //箭头长度与宽度的比值，箭头三角形需要占用总长度的1/_ratio
        this._tailRatio = 5,        //箭头起始两个节点长度与箭头尾巴的比值

        this.CLASS_NAME = "hmap.geomext.DoveTailStraightArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算燕尾直箭头的组成点坐标
     *  @private
     * */
    _generatePoints(){
        //计算只有两个点时，即直的直箭头
        if(this._ctrlPoints.length == 2)
        {
            this._calculateTwoPoints();
        }
        //计算有三个或三个以上的点时，即弯曲的直箭头
        else
        {
            this._calculateMorePoints();
        }
    }

    /**
     * 计算两个控制点时燕尾直箭头的所有绘制点
     * 两个控制点的燕尾直箭头绘制点只需要7个就可以构成
     * @private
     */
    _calculateTwoPoints(){
        let controlPois = this._ctrlPoints;

        //取出第一和第二两个点
        let pointS = {x:controlPois[0].getCoordinate().getOrdinate("X"),y:controlPois[0].getCoordinate().getOrdinate("Y")};    //controlPois[0];
        let pointE = {x:controlPois[1].getCoordinate().getOrdinate("X"),y:controlPois[1].getCoordinate().getOrdinate("Y")};    //controlPois[1];
        //计算箭头总长度，即两个控制点的距离
        let l = Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
        //计算燕尾直箭头的宽
        let w = l/this._ratio;

        //计算三角形的底边中心点坐标
        let x_ = pointS.x + (pointE.x - pointS.x)*(this._ratio-1)/this._ratio;
        let y_ = pointS.y + (pointE.y - pointS.y)*(this._ratio-1)/this._ratio;
        //计算与基本向量夹角90度的，长度为w/2的向量数组
        let v_lr = this.calculateVector({x:pointE.x-pointS.x,y:pointE.y-pointS.y},Math.PI/2,w/2);
        //获取左右向量
        let v_l = v_lr[0];
        let v_r = v_lr[1];
        //左1点
        let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointS.x+v_l.x,pointS.y+v_l.y,0));
        //左2点
        let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(x_+point1.getCoordinate().getOrdinate("X")-pointS.x,y_+point1.getCoordinate().getOrdinate("Y")-pointS.y,0));
        //左3点
        let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(2*point2.getCoordinate().getOrdinate("X")-x_,2*point2.getCoordinate().getOrdinate("Y")-y_,0));
        //顶点
        let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointE.x,pointE.y,0));
        //右3点
        let point7 = new hmap.geom.Point(new hmap.basetype.Coordinate(pointS.x+v_r.x,pointS.y+v_r.y,0));
        //右2点
        let point6 = new hmap.geom.Point(new hmap.basetype.Coordinate(x_+point7.getCoordinate().getOrdinate("X")-pointS.x,y_+point7.getCoordinate().getOrdinate("Y")-pointS.y,0));
        //右1点
        let point5 = new hmap.geom.Point(new hmap.basetype.Coordinate(2*point6.getCoordinate().getOrdinate("X")-x_,2*point6.getCoordinate().getOrdinate("Y")-y_,0));
        //在尾部两个中间插入一个点，是pointS往pointE平移的一个点，为了制作尾巴的效果
        let point_tail = new hmap.geom.Point(new hmap.basetype.Coordinate((pointE.x-pointS.x)/this._tailRatio+pointS.x,(pointE.y-pointS.y)/this._tailRatio+pointS.y,0));

        this._pointArr.push(point_tail,point1,point2,point3,point4,point5,point6,point7,point_tail);
    }

    /**
     * 计算三个或三个以上的控制点时的所有绘制点
     * 由于中间的控制点之间会进行差值，产生曲线效果，所以所需绘制点会很多
     * 这里使用的思想是将所有用户控制点连接起来形成一条折线段，
     * 然后在拐角进行曲线化处理（二次贝塞尔曲线差值），就形成了效果比较好的箭头
     * @private
     */
    _calculateMorePoints(){
        let controlPois = this._ctrlPoints;

        //计算箭头总长度
        let l = 0;
        //计算燕尾直箭头的宽
        let w = 0;
        //在尾部两个中间插入一个点，是pointS往pointE平移的一个点，为了制作尾巴的效果
        let point_tail;
        for(let i = 0;i<controlPois.length-1;i++)
        {
            //取出首尾两个点
            let pointS = {x:controlPois[i].getCoordinate().getOrdinate("X"),y:controlPois[i].getCoordinate().getOrdinate("Y")};//controlPois[i];
            let pointE = {x:controlPois[i+1].getCoordinate().getOrdinate("X"),y:controlPois[i+1].getCoordinate().getOrdinate("Y")};//controlPois[i+1];
            l += Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
            if(i==0)
            {
                point_tail = {x:(pointE.x-pointS.x)/this._tailRatio+pointS.x,y:(pointE.y-pointS.y)/this._tailRatio+pointS.y};
            }
        }
        w = l/this._ratio;
        //定义左右控制点集合
        let points_C_l = [];
        let points_C_r = [];
        //定义尾部左右的起始点
        let point_t_l;
        let point_t_r;
        //计算中间的所有交点
        for(let j = 0;j<controlPois.length-2;j++)
        {
            let pointU_1 = {x:controlPois[j].getCoordinate().getOrdinate("X"),y:controlPois[j].getCoordinate().getOrdinate("Y")};//controlPois[j];//第一个用户传入的点
            let pointU_2 = {x:controlPois[j+1].getCoordinate().getOrdinate("X"),y:controlPois[j+1].getCoordinate().getOrdinate("Y")};//controlPois[j+1];//第二个用户传入的点
            let pointU_3 = {x:controlPois[j+2].getCoordinate().getOrdinate("X"),y:controlPois[j+2].getCoordinate().getOrdinate("Y")};//controlPois[j+2];//第三个用户传入的点

            //计算向量
            let v_U_1_2 = {x:pointU_2.x-pointU_1.x,y:pointU_2.y-pointU_1.y};
            let v_U_2_3 = {x:pointU_3.x-pointU_2.x,y:pointU_3.y-pointU_2.y};

            let v_lr_1_2 = this.calculateVector(v_U_1_2,Math.PI/2,w/2);
            let v_l_1_2 = v_lr_1_2[0];
            let v_r_1_2 = v_lr_1_2[1];
            let v_lr_2_3 = this.calculateVector(v_U_2_3,Math.PI/2,w/2);
            let v_l_2_3 = v_lr_2_3[0];
            let v_r_2_3 = v_lr_2_3[1];
            //获取左右
            let point_l_1 = {x:pointU_1.x+v_l_1_2.x,y:pointU_1.y+v_l_1_2.y};
            let point_r_1 = {x:pointU_1.x+v_r_1_2.x,y:pointU_1.y+v_r_1_2.y};
            let point_l_2 = {x:pointU_2.x+v_l_2_3.x,y:pointU_2.y+v_l_2_3.y};
            let point_r_2 = {x:pointU_2.x+v_r_2_3.x,y:pointU_2.y+v_r_2_3.y};
            //向量v_U_1_2和向量v-point_l_1和point_r_1是平行的
            //如果向量a=(x1，y1)，b=(x2，y2)，则a//b等价于x1y2－x2y1=0
            //得到(x-point_l_1.x)*v_U_1_2.y=v_U_1_2.x*(y-point_l_1.y)
            //得到(point_l_2.x-x)*v_U_2_3.y=v_U_2_3.x*(point_l_2.y-y)
            //可以求出坐边的交点(x,y)，即控制点
            let point_C_l = this.calculateIntersection(v_U_1_2,v_U_2_3,point_l_1,point_l_2);
            let point_C_r = this.calculateIntersection(v_U_1_2,v_U_2_3,point_r_1,point_r_2);
            //定义中间的控制点
            let point_C_l_c;
            let point_C_r_c;
            if(j == 0)
            {
                //记录下箭头尾部的左右两个端点
                point_t_l = point_l_1;
                point_t_r = point_r_1;
                //计算第一个曲线控制点
                point_C_l_c = {x:(point_t_l.x+point_C_l.x)/2,y:(point_t_l.y+point_C_l.y)/2};
                point_C_r_c = {x:(point_t_r.x+point_C_r.x)/2,y:(point_t_r.y+point_C_r.y)/2};
                //添加两个拐角控制点中间的中间控制点
                points_C_l.push(point_C_l_c);
                points_C_r.push(point_C_r_c);
            }
            else
            {
                //获取前一个拐角控制点
                let point_C_l_q = points_C_l[points_C_l.length-1];
                let point_C_r_q = points_C_r[points_C_r.length-1];
                //计算两个拐角之间的中心控制点
                point_C_l_c = {x:(point_C_l_q.x+point_C_l.x)/2,y:(point_C_l_q.y+point_C_l.y)/2};
                point_C_r_c = {x:(point_C_r_q.x+point_C_r.x)/2,y:(point_C_r_q.y+point_C_r.y)/2};
                //添加两个拐角控制点中间的中间控制点
                points_C_l.push(point_C_l_c);
                points_C_r.push(point_C_r_c);
            }
            //添加后面的拐角控制点
            points_C_l.push(point_C_l);
            points_C_r.push(point_C_r);
        }
        //计算

        //进入计算头部
        //计算一下头部的长度
        let pointU_E2 = {x:controlPois[controlPois.length-2].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-2].getCoordinate().getOrdinate("Y")};//controlPois[controlPois.length-2];//倒数第二个用户点
        let pointU_E1 = {x:controlPois[controlPois.length-1].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-1].getCoordinate().getOrdinate("Y")};//controlPois[controlPois.length-1];//最后一个用户点
        //
        let v_U_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
        let head_d = Math.sqrt(v_U_E2_E1.x*v_U_E2_E1.x + v_U_E2_E1.y*v_U_E2_E1.y);
        //定义头部的左右两结束点
        let point_h_l;
        let point_h_r;

        //头部左右两向量数组
        let v_lr_h = [];
        let v_l_h;
        let v_r_h;
        //定义曲线最后一个控制点，也就是头部结束点和最后一个拐角点的中点
        let point_C_l_e;
        let point_C_r_e;
        //定义三角形的左右两个点
        let point_triangle_l;
        let point_triangle_r;

        //获取当前的最后的控制点，也就是之前计算的拐角点
        let point_C_l_eq = points_C_l[points_C_l.length-1];
        let point_C_r_eq = points_C_r[points_C_r.length-1];

        //三角的高度都不够
        if(head_d <= w)
        {
            v_lr_h = this.calculateVector(v_U_E2_E1,Math.PI/2,w/2);
            v_l_h = v_lr_h[0];
            v_r_h = v_lr_h[1];
            //获取头部的左右两结束点
            point_h_l = {x:pointU_E2.x+v_l_h.x,y:pointU_E2.y+v_l_h.y};
            point_h_r = {x:pointU_E2.x+v_r_h.x,y:pointU_E2.y+v_r_h.y};


            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);


            //计算三角形的左右两点
            point_triangle_l = {x:2*point_h_l.x-pointU_E2.x,y:2*point_h_l.y-pointU_E2.y};
            point_triangle_r = {x:2*point_h_r.x-pointU_E2.x,y:2*point_h_r.y-pointU_E2.y};
        }
        //足够三角的高度
        else
        {
            //由于够了三角的高度，所以首先去掉三角的高度

            //计算向量
            let v_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
            //取模
            let v_E2_E1_d = Math.sqrt(v_E2_E1.x*v_E2_E1.x+v_E2_E1.y*v_E2_E1.y);
            //首先需要计算三角形的底部中心点
            let point_c = {x:pointU_E1.x-v_E2_E1.x*w/v_E2_E1_d,y:pointU_E1.y-v_E2_E1.y*w/v_E2_E1_d};
            //计算出在三角形上底边上头部结束点

            v_lr_h = this.calculateVector(v_U_E2_E1,Math.PI/2,w/2);
            v_l_h = v_lr_h[0];
            v_r_h = v_lr_h[1];
            //获取头部的左右两结束点
            point_h_l = {x:point_c.x+v_l_h.x,y:point_c.y+v_l_h.y};
            point_h_r = {x:point_c.x+v_r_h.x,y:point_c.y+v_r_h.y};

            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);

            //计算三角形的左右点
            point_triangle_l = {x:2*point_h_l.x-point_c.x,y:2*point_h_l.y-point_c.y};
            point_triangle_r = {x:2*point_h_r.x-point_c.x,y:2*point_h_r.y-point_c.y};
        }
        const leftPoints = [];
        const rightPoints = [];
        for(let i=0;i<points_C_l.length;i++){
            leftPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_l[i].x,points_C_l[i].y,0)));
        }
        for(let i=0;i<points_C_r.length;i++){
            rightPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_r[i].x,points_C_r[i].y,0)));
        }

        //计算贝塞尔的控制点
        let points_BC_l = this.getBezierPoints(leftPoints);
        let points_BC_r = this.getBezierPoints(rightPoints);
        //尾巴中间点
        let pointsR = [new hmap.geom.Point(new hmap.basetype.Coordinate(point_tail.x,point_tail.y,0))];       //point_tail
        //组合左右点集和三角形三个点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0)));         //[point_t_l];
        //首先连接左边的差值曲线
        pointsR = pointsR.concat(points_BC_l);
        //添加左边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.x,point_h_l.y,0)));        //point_h_l
        //添加三角形左边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_l.x,point_triangle_l.y,0)));     //point_triangle_l
        //添加三角形顶点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_E1.x,pointU_E1.y,0)));        //pointU_E1
        //添加三角形右边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_r.x,point_triangle_r.y,0)));         //point_triangle_r
        //添加右边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.x,point_h_r.y,0)));        //point_h_r
        //合并右边的所有点（先把右边的点倒序）
        pointsR = pointsR.concat(points_BC_r.reverse());

        //添加右边尾部起始点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_r.x,point_t_r.y,0)));        //point_t_r
        //添加尾巴点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_tail.x,point_tail.y,0)));       //point_tail

        this._pointArr = pointsR;
    }

    /**
     * 提取燕尾直箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = dtdArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     *  将燕尾直箭头转化为面几何
     *  @returns {hmap.geom.Polygon} 面几何
     *  @example
     *  let polygon = dtdArrowGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = dtdArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.ARROW.DOVETAIL_STRAIGHT_ARROW;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  dtdArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 燕尾斜箭头
 * @type {hmap.geomext.DoveTailDiagonalArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let dtdArrowGeom = new hmap.geomext.DoveTailDiagonalArrow([point1,point2]);
 */
hmap.geomext.DoveTailDiagonalArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造燕尾斜箭头，控制点个数至少为2
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //关键点不重复
        this._pointArr = [];

        this._ratio = 6,            //箭头长度与宽度的比值，箭头三角形需要占用总长度的1/_ratio
        this._tailRatio = 5,        //箭头起始两个节点长度与箭头尾巴的比值

        this.CLASS_NAME = "hmap.geomext.DoveTailDiagonalArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算燕尾斜箭头的组成点坐标
     *  @private
     * */
    _generatePoints(){
        //计算只有两个点时，即直的斜箭头
        if(this._ctrlPoints.length == 2)
        {
            this._calculateTwoPoints();
        }
        //计算有三个或三个以上的点时，即弯曲的斜箭头
        else
        {
            this._calculateMorePoints();
        }
    }

    /**
     * 计算两个控制点时斜箭头的所有绘制点
     * 两个控制点的斜箭头绘制点只需要7个就可以构成
     * @private
     */
    _calculateTwoPoints(){
        let controlPois = this._ctrlPoints;

        //取出第一和第二两个点
        let pointS = {x:controlPois[0].getCoordinate().getOrdinate("X"),y:controlPois[0].getCoordinate().getOrdinate("Y")};    //controlPois[0];
        let pointE = {x:controlPois[1].getCoordinate().getOrdinate("X"),y:controlPois[1].getCoordinate().getOrdinate("Y")};    //controlPois[1];
        //计算箭头总长度，即两个控制点的距离
        let l = Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
        //计算燕尾直箭头的宽
        let w = l/this._ratio;

        //计算三角形的底边中心点坐标
        let x_ = pointS.x + (pointE.x - pointS.x)*(this._ratio-1)/this._ratio;
        let y_ = pointS.y + (pointE.y - pointS.y)*(this._ratio-1)/this._ratio;
        //计算与基本向量夹角90度的，长度为w/2的向量数组
        let v_lr = this.calculateVector({x:pointE.x-pointS.x,y:pointE.y-pointS.y},Math.PI/2,w/2);
        //获取左右向量
        let v_l_ = v_lr[0];
        let v_r_ = v_lr[1];

        //获取左边尾部点
        let point_l = new hmap.geom.Point(new hmap.basetype.Coordinate(v_l_.x+pointS.x,v_l_.y+pointS.y,0));
        //获取右边尾部点
        let point_r = new hmap.geom.Point(new hmap.basetype.Coordinate(v_r_.x+pointS.x,v_r_.y+pointS.y,0));

        let point_h_l = new hmap.geom.Point(new hmap.basetype.Coordinate(v_l_.x/this._ratio+x_,v_l_.y/this._ratio+y_,0));
        let point_h_r = new hmap.geom.Point(new hmap.basetype.Coordinate(v_r_.x/this._ratio+x_,v_r_.y/this._ratio+y_,0));

        //计算三角形左边点
        let point_a_l = new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.getCoordinate().getOrdinate("X")*2-point_h_r.getCoordinate().getOrdinate("X"),point_h_l.getCoordinate().getOrdinate("Y")*2-point_h_r.getCoordinate().getOrdinate("Y"),0));
        //计算三角形右边点
        let point_a_r = new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.getCoordinate().getOrdinate("X")*2-point_h_l.getCoordinate().getOrdinate("X"),point_h_r.getCoordinate().getOrdinate("Y")*2-point_h_l.getCoordinate().getOrdinate("Y"),0));

        let point_end = new hmap.geom.Point(new hmap.basetype.Coordinate(pointE.x,pointE.y,0));

        let point_tail = new hmap.geom.Point(new hmap.basetype.Coordinate((pointE.x-pointS.x)/this._tailRatio+pointS.x,(pointE.y-pointS.y)/this._tailRatio+pointS.y,0));

        this._pointArr.push(point_tail,point_l,point_h_l,point_a_l,point_end,point_a_r,point_h_r,point_r,point_tail);
    }

    /**
     * 计算三个或三个以上的控制点时的所有绘制点
     * 由于中间的控制点之间会进行差值，产生曲线效果，所以所需绘制点会很多
     * 这里使用的思想是将所有用户控制点连接起来形成一条折线段，
     * 然后在拐角进行曲线化处理（二次贝塞尔曲线差值），就形成了效果比较好的箭头
     * @private
     */
    _calculateMorePoints(){
        let controlPois = this._ctrlPoints;
        //计算箭头总长度
        let l = 0;
        //计算直箭头的宽
        let w = 0;
        //在尾部两个中间插入一个点，是pointS往pointE平移的一个点，为了制作尾巴的效果
        let point_tail;
        for(let i = 0; i < controlPois.length - 1; i++)
        {
            //取出首尾两个点
            let pointS = {x:controlPois[i].getCoordinate().getOrdinate("X"),y:controlPois[i].getCoordinate().getOrdinate("Y")};
            let pointE = {x:controlPois[i+1].getCoordinate().getOrdinate("X"),y:controlPois[i+1].getCoordinate().getOrdinate("Y")};
            l += Math.sqrt((pointE.y-pointS.y)*(pointE.y-pointS.y)+(pointE.x-pointS.x)*(pointE.x-pointS.x));
            if(i==0)
            {
                point_tail = {x:(pointE.x-pointS.x)/this._tailRatio+pointS.x,y:(pointE.y-pointS.y)/this._tailRatio+pointS.y};
            }
        }
        w = l/this._ratio;

        let a = Math.atan(w/(2*l));

        //定义左右控制点集合
        let points_C_l = [];
        let points_C_r = [];
        //定义尾部左右的起始点
        let point_t_l={x:0,y:0};
        let point_t_r={x:0,y:0};


        //计算中间的所有交点
        for(let j = 0; j < controlPois.length-2; j++)
        {
            let pointU_1 = {x:controlPois[j].getCoordinate().getOrdinate("X"),y:controlPois[j].getCoordinate().getOrdinate("Y")};
            let pointU_2 = {x:controlPois[j+1].getCoordinate().getOrdinate("X"),y:controlPois[j+1].getCoordinate().getOrdinate("Y")};
            let pointU_3 = {x:controlPois[j+2].getCoordinate().getOrdinate("X"),y:controlPois[j+2].getCoordinate().getOrdinate("Y")};

            //计算向量
            let v_U_1_2 = {x:pointU_2.x-pointU_1.x,y:pointU_2.y-pointU_1.y};
            let v_U_2_3 = {x:pointU_3.x-pointU_2.x,y:pointU_3.y-pointU_2.y};

            //定义左边第一个控制点
            let point_l_1 = {x:0,y:0};
            //定义右边第一个控制点
            let point_r_1 = {x:0,y:0};
            //如果j=0时，左右第一个控制点需要计算
            if(j == 0)
            {
                let v_lr_ = this.calculateVector(v_U_1_2,Math.PI/2,w/2);
                //获取左边尾部点
                let v_l_ = v_lr_[0];
                //获取右边尾部点
                let v_r_ = v_lr_[1];
                //获取左边尾部点
                point_t_l = point_l_1 = {x:v_l_.x+pointU_1.x,y:v_l_.y+pointU_1.y};
                //获取右边尾部点
                point_t_r = point_r_1 = {x:v_r_.x+pointU_1.x,y:v_r_.y+pointU_1.y};
            }
            //否则获取上一次的记录
            else
            {
                point_l_1 = points_C_l[points_C_l.length-1];
                point_r_1 = points_C_r[points_C_r.length-1];
            }
            let v_lr = this.calculateVector(v_U_1_2,a,1);
            //这里的向量需要反过来
            //获取左边向量
            let v_l = v_lr[1];
            //获取右边向量
            let v_r = v_lr[0];
            //定义角平分线向量
            let v_angularBisector = this.calculateAngularBisector({x:-v_U_1_2.x,y:-v_U_1_2.y},v_U_2_3);
            //求交点
            //计算左边第二个控制点
            let point_l_2 = this.calculateIntersection(v_l,v_angularBisector,point_l_1,pointU_2);
            let point_r_2 = this.calculateIntersection(v_r,v_angularBisector,point_r_1,pointU_2);


            //添加后面的拐角控制点
            points_C_l.push({x:(point_l_1.x+point_l_2.x)/2,y:(point_l_1.y+point_l_2.y)/2});
            points_C_l.push(point_l_2);
            points_C_r.push({x:(point_r_1.x+point_r_2.x)/2,y:(point_r_1.y+point_r_2.y)/2});
            points_C_r.push(point_r_2);
        }

        //进入计算头部
        //计算一下头部的长度
        let pointU_E2 = {x:controlPois[controlPois.length-2].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-2].getCoordinate().getOrdinate("Y")};        //倒数第二个用户点
        let pointU_E1 = {x:controlPois[controlPois.length-1].getCoordinate().getOrdinate("X"),y:controlPois[controlPois.length-1].getCoordinate().getOrdinate("Y")};        //最后一个用户点
        let head_d = Math.sqrt((pointU_E2.x-pointU_E1.x)*(pointU_E2.x-pointU_E1.x) + (pointU_E2.y-pointU_E1.y)*(pointU_E2.y-pointU_E1.y));
        //定义头部的左右两结束点
        let point_h_l = {x:0,y:0};
        let point_h_r = {x:0,y:0};
        //三角形左右两点数组
        let point_lr_t = [];
        //定义曲线最后一个控制点，也就是头部结束点和最后一个拐角点的中点
        let point_C_l_e = {x:0,y:0};
        let point_C_r_e = {x:0,y:0};
        //定义三角形的左右两个点
        let point_triangle_l = {x:0,y:0};
        let point_triangle_r = {x:0,y:0};

        //获取当前的最后的控制点，也就是之前计算的拐角点
        let point_C_l_eq = points_C_l[points_C_l.length-1];
        let point_C_r_eq = points_C_r[points_C_r.length-1];
        //申明三角形的两边向量
        let v_l_t = {x:0,y:0};
        let v_r_t = {x:0,y:0};
        //三角的高度都不够
        if(head_d <= w)
        {
            point_lr_t = this.calculateVector({x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y},Math.PI/2,w/2);
            //获取三角形左右两个向量
            v_l_t = point_lr_t[0];
            v_r_t = point_lr_t[1];

            point_h_l = {x:v_l_t.x/this._ratio+pointU_E2.x,y:v_l_t.y/this._ratio+pointU_E2.y};
            point_h_r = {x:v_r_t.x/this._ratio+pointU_E2.x,y:v_r_t.y/this._ratio+pointU_E2.y};
            //计算三角形的左右两点
            point_triangle_l = {x:point_h_l.x*2-point_h_r.x,y:point_h_l.y*2-point_h_r.y};
            point_triangle_r = {x:point_h_r.x*2-point_h_l.x,y:point_h_r.y*2-point_h_l.y};


            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);
        }
        //足够三角的高度
        else
        {
            //由于够了三角的高度，所以首先去掉三角的高度
            //计算向量
            let v_E2_E1 = {x:pointU_E1.x-pointU_E2.x,y:pointU_E1.y-pointU_E2.y};
            //取模
            let v_E2_E1_d = Math.sqrt(v_E2_E1.x*v_E2_E1.x+v_E2_E1.y*v_E2_E1.y);
            //首先需要计算三角形的底部中心点
            let point_c = {x:pointU_E1.x-v_E2_E1.x*w/v_E2_E1_d,y:pointU_E1.y-v_E2_E1.y*w/v_E2_E1_d};

            //计算出在三角形上底边上头部结束点
            point_lr_t = this.calculateVector({x:pointU_E1.x-point_c.x,y:pointU_E1.y-point_c.y},Math.PI/2,w/2);
            //获取三角形左右两个向量
            v_l_t = point_lr_t[0];
            v_r_t = point_lr_t[1];

            point_h_l = {x:v_l_t.x/this._ratio+point_c.x,y:v_l_t.y/this._ratio+point_c.y};
            point_h_r = {x:v_r_t.x/this._ratio+point_c.x,y:v_r_t.y/this._ratio+point_c.y};
            //计算三角形的左右两点
            point_triangle_l = {x:point_h_l.x*2-point_h_r.x,y:point_h_l.y*2-point_h_r.y};
            point_triangle_r = {x:point_h_r.x*2-point_h_l.x,y:point_h_r.y*2-point_h_l.y};

            //计算最后的控制点
            point_C_l_e = {x:(point_C_l_eq.x+point_h_l.x)/2,y:(point_C_l_eq.y+point_h_l.y)/2};
            point_C_r_e = {x:(point_C_r_eq.x+point_h_r.x)/2,y:(point_C_r_eq.y+point_h_r.y)/2};

            //添加最后的控制点（中心点）
            points_C_l.push(point_C_l_e);
            points_C_r.push(point_C_r_e);
        }
        const leftPoints = [];
        const rightPoints = [];
        for(let i=0;i<points_C_l.length;i++){
            leftPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_l[i].x,points_C_l[i].y,0)));
        }
        for(let i=0;i<points_C_r.length;i++){
            rightPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(points_C_r[i].x,points_C_r[i].y,0)));
        }
        //计算贝塞尔的控制点
        let points_BC_l = this.getBezierPoints(leftPoints);
        let points_BC_r = this.getBezierPoints(rightPoints);
        let pointsR = [new hmap.geom.Point(new hmap.basetype.Coordinate(point_tail.x,point_tail.y,0))];
        //组合左右点集和三角形三个点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_l.x,point_t_l.y,0)));
        //首先连接左边的差值曲线
        pointsR = pointsR.concat(points_BC_l);
        //添加左边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_l.x,point_h_l.y,0)));
        //添加三角形左边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_l.x,point_triangle_l.y,0)));
        //添加三角形顶点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_E1.x,pointU_E1.y,0)));
        //添加三角形右边点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_triangle_r.x,point_triangle_r.y,0)));
        //添加右边头部结束点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_h_r.x,point_h_r.y,0)));
        //合并右边的所有点
        for(let k = points_BC_r.length-1; k>=0; k--)
        {
            pointsR.push(points_BC_r[k]);
        }
        //添加右边尾部起始点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_t_r.x,point_t_r.y,0)));
        //添加尾巴点
        pointsR.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_tail.x,point_tail.y,0)));

        this._pointArr = pointsR;
    }

    /**
     * 提取燕尾斜箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = dtdArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将燕尾斜箭头转化为面几何
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = dtdArrowGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = dtdArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.ARROW.DOVETAIL_DIAGONAL_ARROW;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  dtdArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 双箭头
 * @type {hmap.geomext.DoubleArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
 * let dbArrowGeom = new hmap.geomext.DoubleArrow([point1,point2,point3,point4]);
 */
hmap.geomext.DoubleArrow = class extends hmap.geomext.GeometryExt {
    /**
     *  根据控制点构造双箭头，控制点数量为4
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于4或非数组类型时，则抛出构造异常；当数组长度大于4时，取前4个点几何
     *  @throws 数组长度小于4或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        points = this._getDistinctPoints(points);
        if(points.length < 4){
            throw  new RangeError("At least four distinct points are required!");
        }else{
            points = points.slice(0,4);
        }
        this._ctrlPoints = points;                //关键点不重复
        this._pointArr = [];
        this._ratio = 6,            //箭头长度与宽度的比值，箭头三角形需要占用总长度的1/_ratio
        this._tailRatio = 5,        //箭头起始两个节点长度与箭头尾巴的比值
        this.CLASS_NAME = "hmap.geomext.DoubleArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     * 获取不重复的点
     * @private
     */
    _getDistinctPoints(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        return distinctPoints
    }

    /**
     *  计算双箭头的组成点坐标
     *  @private
     */
    _generatePoints(){
        //判定少于四个点或者为空，则直接返回
        if(this._ctrlPoints == null || this._ctrlPoints.length<4)
        {
            return;
        }
        let controlPois = this._ctrlPoints;

        //定义四个用户输入点
        let pointU_1 = {x:controlPois[0].getCoordinate().getOrdinate("X"),y:controlPois[0].getCoordinate().getOrdinate("Y")};
        let pointU_2 = {x:controlPois[1].getCoordinate().getOrdinate("X"),y:controlPois[1].getCoordinate().getOrdinate("Y")};
        let pointU_3 = {x:controlPois[2].getCoordinate().getOrdinate("X"),y:controlPois[2].getCoordinate().getOrdinate("Y")};
        let pointU_4 = {x:controlPois[3].getCoordinate().getOrdinate("X"),y:controlPois[3].getCoordinate().getOrdinate("Y")};

        //计算控制点
        //计算中间用户点
        let pointU_C = {x:((pointU_1.x+pointU_2.x)*5+(pointU_3.x+pointU_4.x))/12,y:((pointU_1.y+pointU_2.y)*5+(pointU_3.y+pointU_4.y))/12};
        //计算左边外弧的控制点
        let pointC_l_out = this._calculateIntersectionFromTwoCorner(pointU_1,pointU_4,Math.PI/8,Math.PI/6)[0];
        //计算左边内弧的控制点
        let pointC_l_inner = this._calculateIntersectionFromTwoCorner(pointU_C,pointU_4,Math.PI/8,Math.PI/16)[0];
        //计算右边外弧的控制点
        let pointC_r_out = this._calculateIntersectionFromTwoCorner(pointU_2,pointU_3,Math.PI/8,Math.PI/6)[1];
        //计算右边内弧的控制点
        let pointC_r_inner = this._calculateIntersectionFromTwoCorner(pointU_C,pointU_3,Math.PI/8,Math.PI/16)[1];

        let v_l_out = {x:pointC_l_out.x-pointU_4.x,y:pointC_l_out.y-pointU_4.y};
        let d_l_out = Math.sqrt(v_l_out.x*v_l_out.x+v_l_out.y*v_l_out.y);
        //单位向量
        let v_l_out_1 = {x:v_l_out.x/d_l_out,y:v_l_out.y/d_l_out};

        let v_l_inner = {x:pointC_l_inner.x-pointU_4.x,y:pointC_l_inner.y-pointU_4.y};
        let d_l_inner = Math.sqrt(v_l_inner.x*v_l_inner.x+v_l_inner.y*v_l_inner.y);
        //单位向量
        let v_l_inner_1 = {x:v_l_inner.x/d_l_inner,y:v_l_inner.y/d_l_inner};

        //定义箭头头部的大小比例
        let ab = 0.25;

        //取最短的，除以5是一个经验值，这样效果比较好
        let d_l_a = d_l_out<d_l_inner?d_l_out*ab:d_l_inner*ab;
        //
        let pointC_l_out_2 = {x:v_l_out_1.x*d_l_a+pointU_4.x,y:v_l_out_1.y*d_l_a+pointU_4.y};
        let pointC_l_inner_2 = {x:v_l_inner_1.x*d_l_a+pointU_4.x,y:v_l_inner_1.y*d_l_a+pointU_4.y};

        //左箭头左边点
        let pointC_l_a_l = {x:pointC_l_out_2.x*1.5-pointC_l_inner_2.x*0.5,y:pointC_l_out_2.y*1.5-pointC_l_inner_2.y*0.5};
        //左箭头右边点
        let pointC_l_a_r = {x:pointC_l_inner_2.x*1.5-pointC_l_out_2.x*0.5,y:pointC_l_inner_2.y*1.5-pointC_l_out_2.y*0.5};

        let v_r_out = {x:pointC_r_out.x-pointU_3.x,y:pointC_r_out.y-pointU_3.y};
        let d_r_out = Math.sqrt(v_r_out.x*v_r_out.x+v_r_out.y*v_r_out.y);
        let v_r_out_1 = {x:v_r_out.x/d_r_out,y:v_r_out.y/d_r_out};

        let v_r_inner = {x:pointC_r_inner.x-pointU_3.x,y:pointC_r_inner.y-pointU_3.y};
        let d_r_inner = Math.sqrt(v_r_inner.x*v_r_inner.x+v_r_inner.y*v_r_inner.y);
        let v_r_inner_1 = {x:v_r_inner.x/d_r_inner,y:v_r_inner.y/d_r_inner};

        //取最短的，除以5是一个经验值，这样效果比较好
        let d_r_a = d_r_out<d_r_inner?d_r_out*ab:d_r_inner*ab;
        let pointC_r_out_2 = {x:v_r_out_1.x*d_r_a+pointU_3.x,y:v_r_out_1.y*d_r_a+pointU_3.y};
        let pointC_r_inner_2 = {x:v_r_inner_1.x*d_r_a+pointU_3.x,y:v_r_inner_1.y*d_r_a+pointU_3.y};

        //右箭头箭头右边点
        let pointC_r_a_r = {x:pointC_r_out_2.x*1.5-pointC_r_inner_2.x*0.5,y:pointC_r_out_2.y*1.5-pointC_r_inner_2.y*0.5};
        //左箭头左边点
        let pointC_r_a_l = {x:pointC_r_inner_2.x*1.5-pointC_r_out_2.x*0.5,y:pointC_r_inner_2.y*1.5-pointC_r_out_2.y*0.5};

        //计算坐边外弧所有点
        let points_out_l = [
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_1.x,pointU_1.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_out.x,pointC_l_out.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_out_2.x,pointC_l_out_2.y,0))
        ]
        let points_l = this.getBezierPoints(points_out_l);

        //计算控制点
        //定义向量
        let v_U_4_3 = {x:pointU_3.x-pointU_4.x,y:pointU_3.y-pointU_4.y};

        //取部分
        //需要优化，不能左右都取一样，需要按照左右的长度取值，这样更合理一些
        //取u4和C的向量模
        //取u3和C的向量模
        //根据模的大小来取左右向量的长度，；来定位置
        let v_U_4_C = {x:pointU_C.x-pointU_4.x,y:pointU_C.y-pointU_4.y};
        //求模
        let d_U_4_C = Math.sqrt(v_U_4_C.x*v_U_4_C.x+v_U_4_C.y*v_U_4_C.y);
        let v_U_3_C = {x:pointU_C.x-pointU_3.x,y:pointU_C.y-pointU_3.y};
        //求模
        let d_U_3_C = Math.sqrt(v_U_3_C.x*v_U_3_C.x+v_U_3_C.y*v_U_3_C.y);

        let percent = 0.4;
        let v_U_4_3_ = {x:v_U_4_3.x*percent,y:v_U_4_3.y*percent};
        let v_U_4_3_l = {x:v_U_4_3_.x*d_U_4_C/(d_U_4_C+d_U_3_C),y:v_U_4_3_.y*d_U_4_C/(d_U_4_C+d_U_3_C)};
        let v_U_4_3_r = {x:v_U_4_3_.x*d_U_3_C/(d_U_4_C+d_U_3_C),y:v_U_4_3_.y*d_U_3_C/(d_U_4_C+d_U_3_C)};
        //中心点的左控制点
        let pointC_c_l = {x:pointU_C.x-v_U_4_3_l.x,y:pointU_C.y-v_U_4_3_l.y};
        //中心点右边的控制点
        let pointC_c_r = {x:pointU_C.x+v_U_4_3_r.x,y:pointU_C.y+v_U_4_3_r.y};

        //测试
        let arr = [
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_inner_2.x,pointC_l_inner_2.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_inner.x,pointC_l_inner.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_c_l.x,pointC_c_l.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_C.x,pointU_C.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_c_r.x,pointC_c_r.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_inner.x,pointC_r_inner.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_inner_2.x,pointC_r_inner_2.y,0))
        ]
        let points_c = this.getBezierPoints(arr);

        //计算右边外弧的所有点
        let points_out_r = [
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_out_2.x,pointC_r_out_2.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_out.x,pointC_r_out.y,0)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_2.x,pointU_2.y,0))
        ]
        let points_r = this.getBezierPoints(points_out_r);

        //定义结果数组
        let result = points_l;
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_a_l.x,pointC_l_a_l.y,0)));
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_4.x,pointU_4.y,0)));
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_l_a_r.x,pointC_l_a_r.y,0)));
        result = result.concat(points_c);
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_a_l.x,pointC_r_a_l.y,0)));
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointU_3.x,pointU_3.y,0)));
        result.push(new hmap.geom.Point(new hmap.basetype.Coordinate(pointC_r_a_r.x,pointC_r_a_r.y,0)));
        result = result.concat(points_r);
        result.push(points_l[0]);

        this._pointArr = result;
    }

    /**
     * 通过三角形的底边两端点坐标以及底边两夹角，计算第三个点坐标
     * @param {Object} pointS 底边第一个点，{x:x,y:y}类型的坐标
     * @param {Object} pointE 底边第二个点，{x:x,y:y}类型的坐标
     * @param {Number} a_S底边和第一个点所在的另一条边的夹角
     * @param {Number} a_E 底边和第二个点所在的另一条边的夹角
     * @returns {Array<Object>} {x:x,y:y}类型的坐标数组
     * @private
     */
    _calculateIntersectionFromTwoCorner(pointXY_S, pointXY_E, a_S, a_E) {
        if (!a_S) a_S = Math.PI / 4;
        if (!a_E) a_E = Math.PI / 4;

        //起始点、结束点、交点加起来三个点，形成一个三角形
        //斜边（起始点到结束点）的向量为
        let v_SE = {x:pointXY_E.x - pointXY_S.x, y:pointXY_E.y - pointXY_S.y};
        //计算起始点、交点的单位向量
        let v_SI_lr = this.calculateVector(v_SE, a_S, 1);
        //获取
        let v_SI_l = v_SI_lr[0];
        let v_SI_r = v_SI_lr[1];
        //计算结束点、交点的单位向量
        let v_EI_lr = this.calculateVector(v_SE, Math.PI - a_S, 1);
        //获取
        let v_EI_l = v_EI_lr[0];
        let v_EI_r = v_EI_lr[1];
        //求左边的交点
        let pointI_l = this.calculateIntersection(v_SI_l, v_EI_l, pointXY_S, pointXY_E);
        //计算右边的交点
        let pointI_r = this.calculateIntersection(v_SI_r, v_EI_r, pointXY_S, pointXY_E);
        return [pointI_l, pointI_r];
    }


    /**
     * 提取双箭头图形的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = dbArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        const circleCoordArr = [];
        if(this._pointArr.length != 0){
            for (let point of this._pointArr) {
                circleCoordArr.push(point.getCoordinate());
            }
        }
        return [new hmap.basetype.CoordSeq(circleCoordArr)];
    }

    /**
     * 将双箭头图形转化为面几何。
     * @returns {hmap.geom.Polygon} 面几何
     * @example
     * let polygon = dbArrowGeom.toPolygon();
     */
    toPolygon() {
        return new hmap.geom.Polygon([new hmap.geom.LinearRing(this._pointArr)]);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toPolygon().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = dbArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.ARROW.DOUBLE_ARROW;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于4或非数组类型时，则抛出构造异常；当数组长度大于4时，取前4个点几何
     *  @throws 数组长度小于4或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,32,0));
     *  let point4 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,32,0));
     *  dbArrowGeom.setCtrlPoints([point1,point2,point3,point4]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 4){
            throw  new RangeError("At least four points are required!");
        }else{
            points = points.slice(0,4);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 折线箭头
 * @type {hmap.geomext.PolylineArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let lineArrowGeom = new hmap.geomext.PolylineArrow([point1,point2]);
 */
hmap.geomext.PolylineArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造折线箭头，控制点数量至少为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //控制点不重复
        this._lines = [];                           //折线箭头包含的线段数
        this.CLASS_NAME = "hmap.geomext.PolylineArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算折线箭头图形的组成点坐标
     *  @private
     * */
    _generatePoints(){
        let straightLine=new hmap.geom.Line(this._ctrlPoints);      //直线
        let prevP=this._ctrlPoints[this._ctrlPoints.length-2];
        let endP=this._ctrlPoints[this._ctrlPoints.length-1];
        let prevP_XY={x:prevP.getCoordinate().getOrdinate("X"),y:prevP.getCoordinate().getOrdinate("Y")};
        let endP_XY={x:endP.getCoordinate().getOrdinate("X"),y:endP.getCoordinate().getOrdinate("Y")};
        let arrowLine=this._calculateArrowLines(prevP_XY,endP_XY,10);
        this._lines.push(straightLine,arrowLine);
    }

    /**
     *  根据两点计算其所在向量的箭头（即两条直线）
     *  @param {Object} startP 向量的起点 {x:xVal,y:yVal}
     *  @param {Object} endP 向量的终点 {x:xVal,y:yVal}
     *  @param {Number} ratio 直线长度与箭头长度的比值，默认为10倍
     *  @param {Number} angle 箭头所在直线与直线的夹角，范围为0到π，默认为Math.PI/6。
     *  @returns {hmap.geom.Line} 返回箭头线几何
     *  @private
     */
    _calculateArrowLines(startP, endP,ratio,angle) {
        if(!ratio)ratio=10;
        if(!angle)angle=Math.PI/6;
        let dictance=this.calculateDistance(startP,endP);
        let vectorArrows=this.calculateVector({x:startP.x-endP.x,y:startP.y-endP.y},angle,dictance/ratio);
        let arrowLineP_l={x:vectorArrows[0].x+endP.x,y:vectorArrows[0].y+endP.y};
        let arrowLineP_r={x:vectorArrows[1].x+endP.x,y:vectorArrows[1].y+endP.y};
        let points=[];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_l.x,arrowLineP_l.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_r.x,arrowLineP_r.y,0)));
        let arrowLine = new hmap.geom.Line(points)
        return arrowLine;
    }

    /**
     * 提取折线箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = lineArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        let coordSeqs=[];
        for(let i=0;i<this._lines.length;i++){
            coordSeqs.push(this._lines[i].getCoordSeq());
        }
        return coordSeqs;
    }

    /**
     * 将折线箭头转为多线要素
     * @returns {hmap.geom.MultiLine} 多线几何
     * @example
     * let multiLine = lineArrowGeom.toMultiLine();
     */
    toMultiLine() {
        return new hmap.geom.MultiLine(this._lines);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toMultiLine().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = lineArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.LARROW.POLYLINE_ARROW;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
        // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  lineArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 平行搜索区
 * @type {hmap.geomext.ParallelSearch}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let psGeom = new hmap.geomext.ParallelSearch([point1,point2,point3]);
 */
hmap.geomext.ParallelSearch = class extends hmap.geomext.GeometryExt {
    /**
     *  根据控制点构造平行搜索区图形，控制点数量至少为3
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }
        this._ctrlPoints = points;                //关键点不重复
        this._lines = [];                         //直线箭头包含的线段数
        this.CLASS_NAME = "hmap.geomext.ParallelSearch";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据关键点计算图形的点几何
    }

    /**
     *  计算平行搜索区图形的组成点坐标
     *  @private
     * */
    _generatePoints(){
        let firstP=this._ctrlPoints[0];
        let secondP=this._ctrlPoints[1];
        //第一、二个点的向量为基准向量
        let vectorBase={x:firstP.getCoordinate().getOrdinate("X")-secondP.getCoordinate().getOrdinate("X"),y:firstP.getCoordinate().getOrdinate("Y")-secondP.getCoordinate().getOrdinate("Y")};
        //基准向量的法向量
        let vectorNormal=this.calculateVector(vectorBase)[0];
        //从第三个点开始，当i为奇数，则第i-1、i个点的向量垂直于基准向量，当i为偶数，则第i-1、i个点的向量平行于垂直基准向量。
        let isParalel=false;

        let points=[];
        points.push(firstP);

        let multiLine=[];
        for(let i=1;i<this._ctrlPoints.length;i++)
        {
            //判断是否平行
            isParalel=i%2!==0;
            let pointI={x:this._ctrlPoints[i].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[i].getCoordinate().getOrdinate("Y")};
            //平行
            if(isParalel){

                let previousP={x:points[i-1].getCoordinate().getOrdinate("X"),y:points[i-1].getCoordinate().getOrdinate("Y")};
                let point=this.calculateIntersection(vectorNormal,vectorBase,pointI,previousP);
                points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point.x,point.y,0)));
                let arrowLine=this._calculateArrowLines(previousP,point,15);
                multiLine.push(arrowLine);
            }
            //垂直
            else{

                let previousP={x:points[i-1].getCoordinate().getOrdinate("X"),y:points[i-1].getCoordinate().getOrdinate("Y")};//points[i-1];
                let point=this.calculateIntersection(vectorBase,vectorNormal,pointI,previousP);
                points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point.x,point.y,0)));     //point
                let arrowLine=this._calculateArrowLines(previousP,point,15);
                multiLine.push(arrowLine);
            }
            multiLine.unshift(new hmap.geom.Line(points));
        }
        this._lines = multiLine;
    }

    /**
     *  根据两点计算其所在向量的箭头（即两条直线）
     *  @param {Object} startP 向量的起点 {x:xVal,y:yVal}
     *  @param {Object} endP 向量的终点 {x:xVal,y:yVal}
     *  @param {Number} ratio 直线长度与箭头长度的比值，默认为10倍
     *  @param {Number} angle 箭头所在直线与直线的夹角，范围为0到π，默认为Math.PI/6。
     *  @returns {hmap.geom.Line} 返回箭头线几何
     *  @private
     */
    _calculateArrowLines(startP, endP,ratio,angle) {
        if(!ratio)ratio=10;
        if(!angle)angle=Math.PI/6;
        let dictance=this.calculateDistance(startP,endP);
        let vectorArrows=this.calculateVector({x:startP.x-endP.x,y:startP.y-endP.y},angle,dictance/ratio);
        let arrowLineP_l={x:vectorArrows[0].x+endP.x,y:vectorArrows[0].y+endP.y};
        let arrowLineP_r={x:vectorArrows[1].x+endP.x,y:vectorArrows[1].y+endP.y};
        let points=[];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_l.x,arrowLineP_l.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_r.x,arrowLineP_r.y,0)));
        let arrowLine = new hmap.geom.Line(points)
        return arrowLine;
    }

    /**
     * 提取平行搜索区图形的坐标序列数组
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = psGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        let coordSeqs=[];
        for(let i=0;i<this._lines.length;i++){
            coordSeqs.push(this._lines[i].getCoordSeq());
        }
        return coordSeqs;
    }

    /**
     *  将平行搜索区图形转化为多线几何
     *  @returns {hmap.geom.MultiLine} 多线几何
     *  @example
     *  let multiLine = psGeom.toMultiLine();
     */
    toMultiLine() {
        return new hmap.geom.MultiLine(this._lines);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toMultiLine().getBBox();
    }

    /**
     *  获取几何体类型
     *  @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     *  @example
     *  let type = psGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.LARROW.PARALLEL_SEARCH;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
        // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于3或非数组类型时，则抛出构造异常
     *  @throws 数组长度小于3或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,30,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(122,31,0));
     *  psGeom.setCtrlPoints([point1,point2,point3]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 3){
            throw  new RangeError("At least three points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomExt = hmap.geomExt || {};
/**
 * 扇形搜索区
 * @type {hmap.geomext.SectorSearch}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let ssGeom = new hmap.geomext.SectorSearch([point1,point2]);
 */
hmap.geomext.SectorSearch = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造扇形搜索区，控制点数量为2
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;                //关键点不重复
        this._lines = [];                           //包含的线段数
        this.CLASS_NAME = "hmap.geomext.SectorSearch";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算扇形搜索区的组成点坐标
     *  @private
     */
    _generatePoints(){
        let multiLines=[];
        //第一个点为起点，也是中心点
        let centerPoint={x:this._ctrlPoints[0].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[0].getCoordinate().getOrdinate("Y")};
        let offsetX=2*centerPoint.x;
        let offsetY=2*centerPoint.y;
        //第二个点确定半径和起始方向，且为第一个扇形(Fisrst)的点
        let point_FB={x:this._ctrlPoints[this._ctrlPoints.length-1].getCoordinate().getOrdinate("X"),y:this._ctrlPoints[this._ctrlPoints.length-1].getCoordinate().getOrdinate("Y")};
        let radius = this.calculateDistance(centerPoint,point_FB);
        let vector_S={x:centerPoint.x-point_FB.x,y:centerPoint.y-point_FB.y};
        //起始方向向右120°为第二个方向，确定第一个扇形的点
        let vectors=this.calculateVector(vector_S,4*Math.PI/3,radius);
        let vector_FR=vectors[0];
        let point_FC={x:vector_FR.x+centerPoint.x,y:vector_FR.y+centerPoint.y};

        //第二个(second)扇形
        let point_SB={x:-point_FC.x+offsetX,y:-point_FC.y+offsetY};
        let vector_SL=vectors[1];
        let point_SC={x:vector_SL.x+centerPoint.x,y:vector_SL.y+centerPoint.y};

        //第三个(Third)扇形
        let point_TB={x:-point_SC.x+offsetX,y:-point_SC.y+offsetY};
        let point_TC={x:-point_FB.x+offsetX,y:-point_FB.y+offsetY};

        //连接点成扇形搜寻符号
        const points  = [];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(centerPoint.x,centerPoint.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_FB.x,point_FB.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_FC.x,point_FC.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_SB.x,point_SB.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_SC.x,point_SC.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_TB.x,point_TB.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(point_TC.x,point_TC.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(centerPoint.x,centerPoint.y,0)));
        multiLines.push(new hmap.geom.Line(points));

        //计算各边的箭头
        let arrows_FA=this._calculateArrowLines(centerPoint,point_FB);
        let arrows_FB=this._calculateArrowLines(point_FB,point_FC);
        let arrows_FC=this._calculateArrowLines(point_FC,point_SB);
        let arrows_SB=this._calculateArrowLines(point_SB,point_SC);
        let arrows_SC=this._calculateArrowLines(point_SC,point_TB);
        let arrows_TB=this._calculateArrowLines(point_TB,point_TC);
        let arrows_TC=this._calculateArrowLines(point_TC,centerPoint);
        multiLines.push(arrows_FA);
        multiLines.push(arrows_FB);
        multiLines.push(arrows_FC);
        multiLines.push(arrows_SB);
        multiLines.push(arrows_SC);
        multiLines.push(arrows_TB);
        multiLines.push(arrows_TC);

        this._lines=multiLines;
    }

    /**
     *  根据两点计算其所在向量的箭头（即两条直线）
     *  @param {Object} startP 向量的起点 {x:xVal,y:yVal}
     *  @param {Object} endP 向量的终点 {x:xVal,y:yVal}
     *  @param {Number} ratio 直线长度与箭头长度的比值，默认为10倍
     *  @param {Number} angle 箭头所在直线与直线的夹角，范围为0到π，默认为Math.PI/6。
     *  @returns {hmap.geom.Line} 返回箭头线几何
     *  @private
     */
    _calculateArrowLines(startP, endP,ratio,angle) {
        if(!ratio)ratio = 10;
        if(!angle)angle = Math.PI/6;
        let dictance = this.calculateDistance(startP,endP);
        let vectorArrows = this.calculateVector({x:startP.x-endP.x,y:startP.y-endP.y},angle,dictance/ratio);
        let arrowLineP_l = {x:vectorArrows[0].x+endP.x,y:vectorArrows[0].y+endP.y};
        let arrowLineP_r = {x:vectorArrows[1].x+endP.x,y:vectorArrows[1].y+endP.y};
        let points=[];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_l.x,arrowLineP_l.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_r.x,arrowLineP_r.y,0)));
        let arrowLine = new hmap.geom.Line(points)
        return arrowLine;
    }

    /**
     * 提取扇形搜索区图形的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = ssGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        let coordSeqs=[];
        for(let i=0;i<this._lines.length;i++){
            coordSeqs.push(this._lines[i].getCoordSeq());
        }
        return coordSeqs;
    }

    /**
     * 将扇形搜索区图形转化为多线几何
     * @returns {hmap.geom.MultiLine} 多线几何
     * @example
     * let multiLine = ssGeom.toMultiLine();
     */
    toMultiLine() {
        return new hmap.geom.MultiLine(this._lines);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toMultiLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = ssGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.LARROW.SECTOR_SEARCH;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
        // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型时，则抛出构造异常；当数组长度大于2时，取前2个点几何
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  ssGeom.setCtrlPoints([point1,point2]);
     */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }else{
            points = points.slice(0,2);
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * 贝塞尔曲线箭头
 * @type {hmap.geomext.BezierCurveArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let bezierArrowGeom = new hmap.geomext.BezierCurveArrow([point1,point2]);
 */
hmap.geomext.BezierCurveArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造贝塞尔曲线箭头，控制点数量不少于2。
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }

        this._ctrlPoints = points;                //控制点不重复
        this._lines = [];                   //包含的线段数

        this.CLASS_NAME = "hmap.geomext.BezierCurveArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算贝塞尔曲线箭头的组成点坐标
     *  @private
     * */
    _generatePoints(){
        let  multiLines=[];
        if (this._ctrlPoints.length==2) {       //两点直线箭头
            let startP=this._ctrlPoints[0];
            let endP=this._ctrlPoints[1];
            let straightLine=new hmap.geom.Line([startP,endP]);     //直线
            let startP_XY = {x:startP.getCoordinate().getOrdinate("X"),y:startP.getCoordinate().getOrdinate("Y")};
            let endP_XY = {x:endP.getCoordinate().getOrdinate("X"),y:endP.getCoordinate().getOrdinate("Y")};
            let arrowLine=this._calculateArrowLines(startP_XY,endP_XY,10);      //箭头
            multiLines.push(straightLine,arrowLine);
        }
        //多个控制点
        else{
            let startP=this._ctrlPoints[this._ctrlPoints.length - 2];
            let endP=this._ctrlPoints[this._ctrlPoints.length - 1];
            //曲线
            let bezierLine=new hmap.geom.Line(this.getBezierPoints(this._ctrlPoints));
            //箭头
            let startP_XY = {x:startP.getCoordinate().getOrdinate("X"),y:startP.getCoordinate().getOrdinate("Y")};
            let endP_XY = {x:endP.getCoordinate().getOrdinate("X"),y:endP.getCoordinate().getOrdinate("Y")};
            let arrowLine=this._calculateArrowLines(startP_XY,endP_XY,10);
            multiLines.push(bezierLine,arrowLine);
        }
        this._lines=multiLines;
    }

    /**
     *  根据两点计算其所在向量的箭头（即两条直线）
     *  @param {Object} startP 向量的起点 {x:xVal,y:yVal}
     *  @param {Object} endP 向量的终点 {x:xVal,y:yVal}
     *  @param {Number} ratio 直线长度与箭头长度的比值，默认为10倍
     *  @param {Number} angle 箭头所在直线与直线的夹角，范围为0到Math.PI，默认为Math.PI/6。
     *  @returns {hmap.geom.Line} 返回箭头线几何
     *  @private
     */
    _calculateArrowLines(startP, endP,ratio,angle) {
        if(!ratio)ratio=10;
        if(!angle)angle=Math.PI/6;
        let dictance=this.calculateDistance(startP,endP);
        let vectorArrows=this.calculateVector({x:startP.x-endP.x,y:startP.y-endP.y},angle,dictance/ratio);
        let arrowLineP_l={x:vectorArrows[0].x+endP.x,y:vectorArrows[0].y+endP.y};
        let arrowLineP_r={x:vectorArrows[1].x+endP.x,y:vectorArrows[1].y+endP.y};
        let points=[];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_l.x,arrowLineP_l.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_r.x,arrowLineP_r.y,0)));
        let arrowLine = new hmap.geom.Line(points)
        return arrowLine;
    }

    /**
     * 提取贝塞尔曲线箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = bezierArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        let coordSeqs=[];
        for(let i=0;i<this._lines.length;i++){
            coordSeqs.push(this._lines[i].getCoordSeq());
        }
        return coordSeqs;
    }

    /**
     * 将贝塞尔曲线箭头转为多线几何
     * @returns {hmap.geom.MultiLine} 多线几何
     * @example
     * let multiLine = bezierArrowGeom.toMultiLine();
     */
    toMultiLine() {
        return new hmap.geom.MultiLine(this._lines);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toMultiLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = bezierArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.LARROW.BEZIER_CURVE_ARROW;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
        // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }

    /**
     *  重新设置图形的控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,31,0));
     *  bezierArrowGeom.setCtrlPoints([point1,point2]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.geomext = hmap.geomext || {};
/**
 * Cardinal曲线箭头，箭头本身由多线几何组成
 * @type {hmap.geomext.CardinalCurveArrow}
 * @extends hmap.geomext.GeometryExt
 * @example
 * let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
 * let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,30,0));
 * let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
 * let ccArrowGeom = new hmap.geomext.CardinalCurveArrow([point1,point2,point3]);
 */
hmap.geomext.CardinalCurveArrow = class extends hmap.geomext.GeometryExt {
    /**
     * 根据控制点构造Cardinal曲线箭头
     * @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     * @throws 数组长度小于2或非数组类型，则抛出构造异常
     */
    constructor(points) {
        super();
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;                //控制点不重复
        this._lines = [];                         //直线箭头包含的线段数
        this.CLASS_NAME = "hmap.geomext.CardinalCurveArrow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._generatePoints();          //根据控制点计算图形的点几何
    }

    /**
     *  计算Cardinal曲线箭头的组成点坐标
     *  @private
     * */
    _generatePoints(){
        const multiLines = [];
        if (this._ctrlPoints.length==2) {
            let startP=this._ctrlPoints[0];
            let endP=this._ctrlPoints[1];
            let straightLine=new hmap.geom.Line([startP,endP]);     //直线
            let startP_XY = {x:startP.getCoordinate().getOrdinate("X"),y:startP.getCoordinate().getOrdinate("Y")};
            let endP_XY = {x:endP.getCoordinate().getOrdinate("X"),y:endP.getCoordinate().getOrdinate("Y")};
            let arrowLine=this._calculateArrowLines(startP_XY,endP_XY,10);      //箭头
            multiLines.push(straightLine,arrowLine);
        }else{
            let cardinalPoints = this.calculateCardinalPoints(this._ctrlPoints);
            let bezierPoints = this.getBezierPoints(cardinalPoints);
            //曲线
            let curveLine=new hmap.geom.Line(bezierPoints);
            //箭头
            let startP=cardinalPoints[cardinalPoints.length - 2];
            let endP=cardinalPoints[cardinalPoints.length - 1];
            let startP_XY = {x:startP.getCoordinate().getOrdinate("X"),y:startP.getCoordinate().getOrdinate("Y")};
            let endP_XY = {x:endP.getCoordinate().getOrdinate("X"),y:endP.getCoordinate().getOrdinate("Y")};
            let arrowLine=this._calculateArrowLines(startP_XY,endP_XY,2);
            multiLines.push(curveLine,arrowLine);
        }
        this._lines=multiLines;
    }

    /**
     *  根据两点计算其所在向量的箭头（即两条直线）
     *  @param {Object} startP 向量的起点 {x:xVal,y:yVal}
     *  @param {Object} endP 向量的终点 {x:xVal,y:yVal}
     *  @param {Number} ratio 直线长度与箭头长度的比值，默认为10倍
     *  @param {Number} angle 箭头所在直线与直线的夹角，范围为0到π，默认为Math.PI/6。
     *  @returns {hmap.geom.Line} 返回箭头线几何
     *  @private
     */
    _calculateArrowLines(startP, endP,ratio,angle) {
        if(!ratio)ratio=10;
        if(!angle)angle=Math.PI/6;
        let dictance=this.calculateDistance(startP,endP);
        let vectorArrows=this.calculateVector({x:startP.x-endP.x,y:startP.y-endP.y},angle,dictance/ratio);
        let arrowLineP_l={x:vectorArrows[0].x+endP.x,y:vectorArrows[0].y+endP.y};
        let arrowLineP_r={x:vectorArrows[1].x+endP.x,y:vectorArrows[1].y+endP.y};
        let points=[];
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_l.x,arrowLineP_l.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(endP.x,endP.y,0)));
        points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(arrowLineP_r.x,arrowLineP_r.y,0)));
        let arrowLine = new hmap.geom.Line(points)
        return arrowLine;
    }

    /**
     * 提取Cardinal曲线箭头的坐标序列
     * @returns {Array<hmap.basetype.CoordSeq>} 坐标序列数组
     * @example
     * let coordSeqs = ccArrowGeom.getCoordSeqs();
     */
    getCoordSeqs() {
        let coordSeqs=[];
        for(let i=0;i<this._lines.length;i++){
            coordSeqs.push(this._lines[i].getCoordSeq());
        }
        return coordSeqs;
    }

    /**
     * 将Cardinal曲线箭头转为多线几何
     * @returns {hmap.geom.MultiLine} 多线几何
     * @example
     * let result = ccArrowGeom.toMultiLine();
     */
    toMultiLine() {
        return new hmap.geom.MultiLine(this._lines);
    }

    /**
     * 获取拓展几何的三维包围盒
     * @returns {hmap.basetype.BBox} 返回三维包围盒
     */
    getBBox() {
        return this.toMultiLine().getBBox();
    }

    /**
     * 获取几何体类型
     * @returns {String} hmap拓展的几何类型，参见{@link hmap.geom.GeometryExtType}
     * @example
     * let type = ccArrowGeom.getType();
     */
    getType() {
        return hmap.geom.GeometryExtType.LARROW.CARDINAL_CURVE_ARROW;
    }

    /**
     * 获取多线中所有的{@link hmap.geom.Line}对象。
     * @returns {Array<hmap.geom.Line>} 线的数组。
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,31,0);
     * let coord3 = new hmap.basetype.Coordinate(122,32,0);
     * let coord4 = new hmap.basetype.Coordinate(123,33,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let point3 = new hmap.geom.Point(coord3);
     * let point4 = new hmap.geom.Point(coord4);
     * let line1 = new hmap.geom.Line([point1,point2]);
     * let line2 = new hmap.geom.Line([point3,point4]);
     * let multiLine = new hmap.geom.MultiLine([line1,line2]);
     * let result = multiLine.getLines();
     */
    getLines(){
        // return this._lines.map(function(item,index,array){return item.clone();});
        return this._lines;
    }

    /**
     *  重新设置图形控制点
     *  @param {Array<hmap.geom.Point>} points 点几何数组，数组长度小于2或非数组类型，则抛出构造异常
     *  @throws 数组长度小于2或非数组类型，则抛出构造异常
     *  @example
     *  let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0));
     *  let point2 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0));
     *  let ccArrowGeom = new hmap.geomext.CardinalCurveArrow([point1,point2,point3]);
     * */
    setCtrlPoints(points) {
        if(!(points instanceof  Array)){
            throw new TypeError("the parameter of points must be 'Array'");
        }
        if(points.length < 2){
            throw  new RangeError("At least two points are required!");
        }
        this._ctrlPoints = points;
        this._generatePoints();
    }
};
;"use strict";
hmap.model = hmap.model || {};
/**
 * 3d模型，抽象类。
 * @type {hmap.model.Model}
 *
 */
hmap.model.Model = class{
    constructor(){
        if (new.target === hmap.model.Model) {
            throw new TypeError("The Model is an abstract class,and can not be instanced!");
        }
        this.CLASS_NAME = "hmap.model.Model";
        //承载模型数据，组织成webgl渲染的方式
        this._modelData={};
        // this._mid=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 获取模型唯一标识
     * @private
     */
    _getMid(){
        return this._mid;
    }
}
;"use strict";
hmap.model = hmap.model || {};
/**
 * 本类用于构造ObJ格式的三维几何体。obj是3D模型文件格式，由用户进行建模处理，导出成Obj格式后在本类中构造。一个hmap.model.Obj对象对应一个obj格式的文件。
 * @type {hmap.model.Obj}
 * @extends hmap.model.Model
 */
hmap.model.Obj = class extends hmap.model.Model {
    /**
     * 构造方法。
     * 因Obj原始模型往往不能在地图上进行准确标定，新构建的对象需要调用本类平移、缩放、旋转方法，才能使模型与真实地理图标匹配。
     * @param {Object} options Obj构造选项。
     * @param {Boolean} options.isImmediate 设置为true则在添加到图层上以后立即加载，设置为false则在绘制时加载。
     * @param {String} options.obj Obj模型的URL地址。
     * @param {String|Boolean} options.mtl MTL材质的URL地址，设为true时则使用options.obj选项中的值，并将".obj"后缀替换为".mtl"。
     * @example
     * let options = {
            obj: "../public/obj/hkyq.obj", 
            mtl: true
     * };
     * let obj = new hmap.model.Obj(options);
     */
    constructor(options) {
        super();
        this.CLASS_NAME = "hmap.model.Obj";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this.mesh = null;
        this.options = options;
        this.isImmediate = options.isImmediate;
        this._modelPromise = null;
        this.alpha = 1.0;
        this.modelMatrix = new hmap.util.Matrix4();
        this.modelPosition = [0,0,0];//记录模型原点位置
        this.axisExchangeMatrix = new hmap.util.Matrix4();
    }

    /**
     * 复制一个Obj对象。
     * @return {hmap.model.Obj} 新的Obj对象。
     * @example
     * let newObj = obj.clone();
     */
    clone() {
        const obj = new hmap.model.Obj(this.options);
        obj.mesh = this.mesh;
        obj.modelMatrix = this.modelMatrix.clone();
        obj.axisExchangeMatrix = this.axisExchangeMatrix.clone();
        return obj;
    }

    /**
     * 获取id
     * @returns {String} id
     * @private
     */
    _getMid() {
        return this._id;
    }

    /**
     * 获取透明度
     * @return {Number} 透明度
     * @example
     * let alpha = obj.getAlpha();
     */
    getAlpha() {
        return this.alpha;
    }

    /**
     * 设置坐标维度映射，即将指定维度替换为新的坐标维度，“X”坐标轴为第1维，“Y”坐标轴的为第2维，“Z”坐标轴的第3维。
     * 针对模型的平移、旋转和缩放操作基于坐标维度映射后的新维度进行。
     * @param {Number} dim 被替换的维度。
     * @param {Number} newDim 新的维度。
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setDimensionMapping(1, 2);
     * obj.setDimensionMapping(2, 3);
     * obj.setDimensionMapping(3, 1);
     */
    setDimensionMapping(dim, newDim) {
        if (dim <= 0 || dim > 3) {
            return;
        }
        const elements = this.axisExchangeMatrix.getElements();
        const dimRowStartIndex = (dim - 1) * 4; // 当前维对应的矩阵行
        for (let i = 0; i < 3; i++) {
            if (i === newDim - 1) {
                elements[dimRowStartIndex + i] = 1;
            } else {
                elements[dimRowStartIndex + i] = 0;
            }
        }
        return this;
    }

    /**
     * 设置透明度
     * @param {Number} alpha 透明度
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setAlpha(0.5);
     */
    setAlpha(alpha) {
        this.alpha = alpha;
        return this;
    }

    /**
     * 设置添加到图层上以后是否立即加载。
     * @param {Boolean} isImmediate 设置为true则在添加到图层上以后立即加载，设置为false则在绘制时加载。
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setImmediate(true);
     */
    setImmediate(isImmediate) {
        this.isImmediate = isImmediate;
        return this;
    }

    /**
     * 设置旋转分量。
     * @param {Number} rotateX X轴旋转分量
     * @param {Number} rotateY Y轴旋转分量
     * @param {Number} rotateZ Z轴旋转分量
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setRotate(0, 0, -68);
     */
    setRotate(rotateX, rotateY, rotateZ) {
        this.modelMatrix.rotate(rotateX, 1, 0, 0);
        this.modelMatrix.rotate(rotateY, 0, 1, 0);
        this.modelMatrix.rotate(rotateZ, 0, 0, 1);
        return this;
    }

    /**
     * 设置缩放分量。
     * @param {Number} scaleX X轴缩放分量
     * @param {Number} scaleY Y轴缩放分量
     * @param {Number} scaleZ Z轴缩放分量
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setScale(1/11100*15, 1/11100*15, 1/11100*15/1.4);
     */
    setScale(scaleX, scaleY, scaleZ) {
        this.modelMatrix.scale(scaleX, scaleY, scaleZ);
        return this;
    }

    /**
     * 相对模型之前位置的平移分量设置
     * @param {Number} translateX X轴平移分量
     * @param {Number} translateY Y轴平移分量
     * @param {Number} translateZ Z轴平移分量
     * @return {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setTranslate(120.2187, 30.21259, 0);
     */
    setTranslate(translateX, translateY, translateZ) {
        this.modelMatrix.translate(translateX, translateY, translateZ);
        this.modelPosition[0] += translateX;
        this.modelPosition[1] += translateY;
        this.modelPosition[2] += translateZ;
        return this;
    }

    /**
     * 设置模型原点的位置
     * @param {Number} positionX X值
     * @param {Number} positionY Y值
     * @param {Number} positionZ Z值
     * @returns {hmap.model.Obj} 返回模型对象
     * @example
     * obj.setPosition(120.2187, 30.21259, 0);
     */
    setPosition(positionX, positionY, positionZ) {
        let e = this.modelMatrix._elements;
        e[12]=positionX;
        e[13]=positionY;
        e[14]=positionZ;

        this.modelPosition[0] = positionX;
        this.modelPosition[1] = positionY;
        this.modelPosition[2] = positionZ;
        return this;
    }

    /**
     * 读取模型
     * @return {Promise<hmap.model.Obj>} 返回读取模型的Promise对象
     * @example
     * let promise = obj.readModel();
     * promise.then(function(){
            modelLayer.addModel(obj);//图层添加obj模型
            map.redraw();//地图重绘
     * });
     */
    readModel() {
        if (!this._modelPromise) {
            this._modelPromise = this.downloadModels([
                this.options
            ]);
            this._modelPromise.then(models => {
                for (const [name, mesh] of Object.entries(models)) {
                    this.mesh = mesh;
                    this._calculateBBox(this.mesh)
                }
            });
        }
        return this._modelPromise;
    }

    /**
     * @private
     */
    downloadMtlTextures(mtl, root) {
        const mapAttributes = [
            "mapDiffuse",
            "mapAmbient",
            "mapSpecular",
            "mapDissolve",
            "mapBump",
            "mapDisplacement",
            "mapDecal",
            "mapEmissive"
        ];
        if (!root.endsWith("/")) {
            root += "/";
        }
        let textures = [];

        for (let material in mtl.materials) {
            if (!mtl.materials.hasOwnProperty(material)) {
                continue;
            }
            material = mtl.materials[material];

            for (let attr of mapAttributes) {
                let mapData = material[attr];
                if (!mapData) {
                    continue;
                }

                let url = root + mapData.filename;
                textures.push(
                    fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error();
                            }
                            return response.blob();
                        })
                        .then(function (data) {
                            let image = new Image();
                            image.src = URL.createObjectURL(data);
                            mapData.texture = image;
                            return new Promise(resolve => (image.onload = resolve));
                        })
                        .catch(() => {
                            console.error(`Unable to download texture: ${url}`);
                        })
                );
            }
        }

        return Promise.all(textures);
    }

    /**
     * Accepts a list of model request objects and returns a Promise that
     * resolves when all models have been downloaded and parsed.
     *
     * The list of model objects follow this interface:
     * {
     *  obj: 'path/to/model.obj',
     *  mtl: true | 'path/to/model.mtl',
     *  downloadMtlTextures: true | false
     *  mtlTextureRoot: '/models/suzanne/maps'
     *  name: 'suzanne'
     * }
     *
     * The `obj` attribute is required and should be the path to the
     * model's .obj file relative to the current repo (absolute URLs are
     * suggested).
     *
     * The `mtl` attribute is optional and can either be a boolean or
     * a path to the model's .mtl file relative to the current URL. If
     * the value is `true`, then the path and basename given for the `obj`
     * attribute is used replacing the .obj suffix for .mtl
     * E.g.: {obj: 'models/foo.obj', mtl: true} would search for 'models/foo.mtl'
     *
     * The `name` attribute is optional and is a human friendly name to be
     * included with the parsed OBJ and MTL files. If not given, the base .obj
     * filename will be used.
     *
     * The `downloadMtlTextures` attribute is a flag for automatically downloading
     * any images found in the MTL file and attaching them to each Material
     * created from that file. For example, if material.mapDiffuse is set (there
     * was data in the MTL file), then material.mapDiffuse.texture will contain
     * the downloaded image. This option defaults to `true`. By default, the MTL's
     * URL will be used to determine the location of the images.
     *
     * The `mtlTextureRoot` attribute is optional and should point to the location
     * on the server that this MTL's texture files are located. The default is to
     * use the MTL file's location.
     * @private
     *
     * @returns {Promise} the result of downloading the given list of models. The
     * promise will resolve with an object whose keys are the names of the models
     * and the value is its Mesh object. Each Mesh object will automatically
     * have its addMaterialLibrary() method called to set the given MTL data (if given).
     */
    downloadModels(models) {
        const finished = [];

        for (const model of models) {
            const parsed = [];

            if (!model.obj) {
                throw new Error(
                    '"obj" attribute of model object not set. The .obj file is required to be set ' +
                    "in order to use downloadModels()"
                );
            }

            let options = Object.assign({indicesPerMaterial: true}, model);
            options.indicesPerMaterial = !!options.indicesPerMaterial;
            options.calcTangentsAndBitangents = !!options.calcTangentsAndBitangents;

            // if the name is not provided, dervive it from the given OBJ
            let name = model.name;
            if (!name) {
                let parts = model.obj.split("/");
                name = parts[parts.length - 1].replace(".obj", "");
            }
            parsed.push(Promise.resolve(name));

            parsed.push(
                fetch(model.obj)
                    .then(response => response.text())
                    .then(data => {
                        return new hmap.format.obj.Mesh(data, options);
                    })
            );

            // Download MaterialLibrary file?
            if (model.mtl) {
                let mtl = model.mtl;
                if (typeof mtl === "boolean") {
                    mtl = model.obj.replace(/\.obj$/, ".mtl");
                }

                parsed.push(
                    fetch(mtl)
                        .then(response => response.text())
                        .then(data => {
                            let material = new hmap.format.obj.MaterialLibrary(data);
                            if (model.downloadMtlTextures !== false) {
                                let root = model.mtlTextureRoot;
                                if (!root) {
                                    // get the directory of the MTL file as default
                                    root = mtl.substr(0, mtl.lastIndexOf("/"));
                                }
                                // downloadMtlTextures returns a Promise that
                                // is resolved once all of the images it
                                // contains are downloaded. These are then
                                // attached to the map data objects
                                return Promise.all([Promise.resolve(material), this.downloadMtlTextures(material, root)]);
                            }
                            return Promise.all(Promise.resolve(material));
                        })
                        .then(value => {
                            return value[0];
                        })
                );
            }

            finished.push(Promise.all(parsed));
        }

        return Promise.all(finished).then(ms => {
            // the "finished" promise is a list of name, Mesh instance,
            // and MaterialLibary instance. This unpacks and returns an
            // object mapping name to Mesh (Mesh points to MTL).
            const models = {};
            for (const model of ms) {
                const [name, mesh, mtl] = model;
                mesh.name = name;
                if (mtl) {
                    mesh.addMaterialLibrary(mtl);
                }
                models[name] = mesh;
            }

            return models;
        });
    }

    /**
     *
     * Takes in an object of `mesh_name`, `'/url/to/OBJ/file'` pairs and a callback
     * function. Each OBJ file will be ajaxed in and automatically converted to
     * an OBJ.Mesh. When all files have successfully downloaded the callback
     * function provided will be called and passed in an object containing
     * the newly created meshes.
     *
     * **Note:** In order to use this function as a way to download meshes, a
     * webserver of some sort must be used.
     * @private
     * @param {Object} nameAndAttrs an object where the key is the name of the mesh and the value is the url to that mesh's OBJ file
     *
     * @param {Function} completionCallback should contain a function that will take one parameter: an object array where the keys will be the unique object name and the value will be a Mesh object
     *
     * @param {Object} meshes In case other meshes are loaded separately or if a previously declared variable is desired to be used, pass in a (possibly empty) json object of the pattern: { '<mesh_name>': OBJ.Mesh }
     */
    downloadMeshes(nameAndURLs, completionCallback, meshes) {
        if (meshes === undefined) {
            meshes = {};
        }

        const completed = [];

        for (const mesh_name in nameAndURLs) {
            if (!nameAndURLs.hasOwnProperty(mesh_name)) {
                continue;
            }
            const url = nameAndURLs[mesh_name];
            completed.push(
                fetch(url)
                    .then(response => response.text())
                    .then(data => {
                        return [mesh_name, new Mesh(data)];
                    })
            );
        }

        Promise.all(completed).then(ms => {
            for (let [name, mesh] of ms) {
                meshes[name] = mesh;
            }

            return completionCallback(meshes);
        });
    }

    /**
     * @private
     * @param gl
     * @param type
     * @param data
     * @param itemSize
     * @return {AudioBuffer | WebGLBuffer}
     */
    _buildBuffer(gl, type, data, itemSize) {
        var buffer = gl.createBuffer();
        var arrayView = type === gl.ARRAY_BUFFER ? Float32Array : Uint16Array;
        gl.bindBuffer(type, buffer);
        gl.bufferData(type, new arrayView(data), gl.STATIC_DRAW);
        buffer.itemSize = itemSize;
        buffer.numItems = data.length / itemSize;
        return buffer;
    };

    /**
     * Takes in the WebGL context and a Mesh, then creates and appends the buffers
     * to the mesh object as attributes.
     * @private
     * @param {WebGLRenderingContext} gl the `canvas.getContext('webgl')` context instance
     * @param {Mesh} mesh a single `OBJ.Mesh` instance
     * The newly created mesh attributes are:
     * Attrbute | Description
     * :--- | ---
     * **normalBuffer**       |contains the model&#39;s Vertex Normals
     * normalBuffer.itemSize  |set to 3 items
     * normalBuffer.numItems  |the total number of vertex normals
     * |
     * **textureBuffer**      |contains the model&#39;s Texture Coordinates
     * textureBuffer.itemSize |set to 2 items
     * textureBuffer.numItems |the number of texture coordinates
     * |
     * **vertexBuffer**       |contains the model&#39;s Vertex Position Coordinates (does not include w)
     * vertexBuffer.itemSize  |set to 3 items
     * vertexBuffer.numItems  |the total number of vertices
     * |
     * **indexBuffer**        |contains the indices of the faces
     * indexBuffer.itemSize   |is set to 1
     * indexBuffer.numItems   |the total number of indices
     * A simple example (a lot of steps are missing, so don't copy and paste):
     *
     *     var gl   = canvas.getContext('webgl'),
     *         mesh = OBJ.Mesh(obj_file_data);
     *     // compile the shaders and create a shader program
     *     var shaderProgram = gl.createProgram();
     *     // compilation stuff here
     *     ...
     *     // make sure you have vertex, vertex normal, and texture coordinate
     *     // attributes located in your shaders and attach them to the shader program
     *     shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
     *     gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
     *
     *     shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
     *     gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
     *
     *     shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
     *     gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
     *
     *     // create and initialize the vertex, vertex normal, and texture coordinate buffers
     *     // and save on to the mesh object
     *     OBJ.initMeshBuffers(gl, mesh);
     *
     *     // now to render the mesh
     *     gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
     *     gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, mesh.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
     *     // it's possible that the mesh doesn't contain
     *     // any texture coordinates (e.g. suzanne.obj in the development branch).
     *     // in this case, the texture vertexAttribArray will need to be disabled
     *     // before the call to drawElements
     *     if(!mesh.textures.length){
     *       gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
     *     }
     *     else{
     *       // if the texture vertexAttribArray has been previously
     *       // disabled, then it needs to be re-enabled
     *       gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
     *       gl.bindBuffer(gl.ARRAY_BUFFER, mesh.textureBuffer);
     *       gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, mesh.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
     *     }
     *
     *     gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
     *     gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, mesh.normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
     *
     *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.mesh.indexBuffer);
     *     gl.drawElements(gl.TRIANGLES, model.mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
     */
    initMeshBuffers(gl, mesh) {
        mesh.normalBuffer = _buildBuffer(gl, gl.ARRAY_BUFFER, mesh.vertexNormals, 3);
        mesh.textureBuffer = _buildBuffer(gl, gl.ARRAY_BUFFER, mesh.textures, mesh.textureStride);
        mesh.vertexBuffer = _buildBuffer(gl, gl.ARRAY_BUFFER, mesh.vertices, 3);
        mesh.indexBuffer = _buildBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, mesh.indices, 1);
    }

    /**
     * @private
     * @param gl
     * @param mesh
     */
    deleteMeshBuffers(gl, mesh) {
        gl.deleteBuffer(mesh.normalBuffer);
        gl.deleteBuffer(mesh.textureBuffer);
        gl.deleteBuffer(mesh.vertexBuffer);
        gl.deleteBuffer(mesh.indexBuffer);
    }

    // 计算该模型每个mesh的三维包围盒。
    // getBBox() {
    //     return this._box;
    // }

    /**
     * 计算包围盒
     * @private
     */
    _calculateBBox(mesh) {
        let modelMatrix = new hmap.util.Matrix4();
        modelMatrix.setIdentity();
        modelMatrix.multiply(this.modelMatrix);
        modelMatrix.multiply(this.axisExchangeMatrix);

        let arrPoint = this.mesh.vertices;
        mesh._bbox = this._createAxisAlignBoundingBox(arrPoint, modelMatrix);
    }

    /**
     * 点云的包围盒计算
     * @private
     * @param arrPoint
     * @param matrix
     * @return {*}
     */
    _createAxisAlignBoundingBox(arrPoint, matrix) {
        let xMin = Number.POSITIVE_INFINITY,
            yMin = Number.POSITIVE_INFINITY,
            zMin = Number.POSITIVE_INFINITY,
            xMax = Number.NEGATIVE_INFINITY,
            yMax = Number.NEGATIVE_INFINITY,
            zMax = Number.NEGATIVE_INFINITY;
        //顶点坐标个数必然是3的倍数
        if (arrPoint.length % 3 !== 0) {
            return null;
        }
        //间隔取值,TODO
        const numInterval = 3 * 10 * 6;
        for (let i = 0, len = arrPoint.length; i < len; i += numInterval) {
            let vector = matrix.multiplyVector4(new hmap.util.Vector4(arrPoint[i], arrPoint[i + 1], arrPoint[i + 2], 1));
            let value1 = vector.getElement(0),
                value2 = vector.getElement(1),
                value3 = vector.getElement(2);
            if (xMin > value1) xMin = value1; else if (xMax < value1) xMax = value1;
            if (yMin > value2) yMin = value2; else if (yMax < value2) yMax = value2;
            if (zMin > value3) zMin = value3; else if (zMax < value3) zMax = value3;
        }
        return new hmap.basetype.BBox(xMin, yMin, zMin, xMax, yMax, zMax);
    }


}
;"use strict";
hmap.model = hmap.model || {};
/**
 * @type {hmap.model.Cube}
 * @private
 */
hmap.model.Cube = class extends hmap.model.Model {
    constructor(feature){
        super();
        this.CLASS_NAME = "hmap.model.Cube";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._fid = this._id;
        this._height=feature.getAttributes().height;
        this._poly=feature.getGeometry();
        this._center=this._poly.getCentroid();
        this._coords=this._poly.getCoordSeqs()[0]._coordArr;
        this._modelData={
            "poly":{},
            "line":{},
            "point":{}
        };
        //1.创建面的渲染数据
        this._buildPoly();
        //2.创建边框线的渲染数据
        this._buildLine();
        //3.创建Cube标记的点状渲染数据
        this._buildPoint();
    }
    getpolyIndexCount(){
        return this._polyIndexCount;
    }
    _buildPoly(){
        let n=this._coords.length-1;
        const vertices=new Array(n*2*3);
        const indices=[];
        const colors=[];
        const normals=[];
        for(let i=0;i<n;i++){
            vertices[3*i]=this._coords[i].getOrdinate("X");
            vertices[3*i+1]=this._coords[i].getOrdinate("Y");
            vertices[3*i+2]=this._coords[i].getOrdinate("Z");
            colors.push(0.2,0.2,0.2,0.5);
            const temp=this._coords[i].clone().setOrdinate("Z",this._height);
            vertices[3*n+3*i]=temp.getOrdinate("X");
            vertices[3*n+3*i+1]=temp.getOrdinate("Y");
            vertices[3*n+3*i+2]=temp.getOrdinate("Z");
            colors.push(0.2,0.2,0.2,0.5);
            //创建侧面三角形索引
            if(i==n-1){
                // indices.push(n+i,n,i+1,0,i,n+1);
                indices.push(n,0,i,n,i,n+i);
                normals.push(0.0,0.0,1.0);
            }else{
                // indices.push(n+i+1,n+i+1,i+1,i+1,i,n+1);
                indices.push(n+i+1,i+1,i,n+i+1,i,n+i);
                normals.push(0.0,0.0,1.0);
            }
            if(i<n-2){
                //创建底部三角形索引
                indices.push(0,i+1,i+2);
                //创建顶部三角形索引
                indices.push(2*n-1,i+n+1,i+n);
                normals.push(0.0,0.0,1.0);
                normals.push(0.0,0.0,1.0);
            }
        }
        this._modelData.poly.vertices=new Float32Array(vertices);
        this._modelData.poly.colors=new Float32Array(colors);
        this._modelData.poly.normals=new Float32Array(normals);
        this._modelData.poly.indices=new Uint16Array(indices);
    }
    _buildLine(){
        let n=this._coords.length-1;
        const vertices=new Array(n*3);
        const indices=[];
        const colors=[];
        const normals=[];
        for(let i=0;i<n;i++){
            vertices[3*i]=this._coords[i].getOrdinate("X");
            vertices[3*i+1]=this._coords[i].getOrdinate("Y");
            vertices[3*i+2]=this._coords[i].getOrdinate("Z");
            colors.push(0.2,0.2,0.2,1.0);
            if(i==n-1){
                indices.push(i,0);
                normals.push(0.0,0.0,1.0);
            }else{
                indices.push(i,i+1);
                normals.push(0.0,0.0,1.0);
            }
        }
        this._modelData.line.vertices=new Float32Array(vertices);
        this._modelData.line.colors=new Float32Array(colors);
        this._modelData.line.normals=new Float32Array(normals);
        this._modelData.line.indices=new Uint16Array(indices);
    }
    _buildPoint(){
    }
};"use strict";
hmap.model = hmap.model || {};

/**
 * 3D拉伸体。根据几何图形和指定高度将几何图形拔高，拔高后顶部、底部的形状和原始图形保持一致，顶部和底部相连构成垂直面，其中线拔高后效果类似没有厚度的墙，
 * 多边形拔高后效果是由顶部、底部及侧面包围的体。
 * @type {hmap.model.Stretch}
 * @extends hmap.model.Model
 */
hmap.model.Stretch = class extends hmap.model.Model {

    /**
     * 构造函数
     * @param {hmap.feature.Vector} vector vector的geometry可以是hmap.geom.Line, hmap.geom.MultiLine, hmap.geom.Polygon, hmap.geom.MultiPolygon的一种，
     * vector的属性可以包含height(拉伸体高度，单位是米)，surfaceColor(拉伸体表面颜色), topBorderColor(拉伸体顶部和侧面连接处边框的颜色)，其中height的默认值是
     * 10到600米之间的一个随机值，surfaceColor和topBorderColor的默认值均是hmap.style.Color(0, 211, 211, 0.7)
     * @param {Boolean} showBorder 是否显示上边框，true时显示，false不显示，默认为false
     * @param {String} mapUnit 地图单位，默认是degrees
     *
     * @example
     * let coords = [ [ 120.2121967, 30.2291469 ], [ 120.2121967, 30.2239783 ], [ 120.2191932, 30.2239783 ], [ 120.2191932, 30.2291469 ], [ 120.2121967, 30.2291469 ]]
     * let pts = coords.map(coord => {
     *     coord = new hmap.basetype.Coordinate(coord[0], coord[1], 0)
     *     return new hmap.geom.Point(coord)
     * })
     * let lineRing = new hmap.geom.LinearRing(pts)
     * let polygon = new hmap.geom.Polygon([lineRing])
     * let vector = new hmap.feature.Vector(polygon, {height: 100, surfaceColor: new hmap.style.Color(211, 0, 0, 1),
     *     topBorderColor: new hmap.style.Color(211, 0, 0, 1)})
     * let stretch = new hmap.model.Stretch(vector)
     */
    constructor(vector, showBorder = false, mapUnit='degrees') {
        super();
        this.CLASS_NAME = 'hmap.model.Stretch';
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._strict = false;
        this._showBorder = showBorder;
        this.vector=vector;
        //this.dataMap = this._createStretchObj(vector);
        this.type="Stretch";
        this._bbox=null;
        this._mapUnit = mapUnit;
        this._painterType=hmap.core.painterType.STRETCH;
        this._visible = vector._visible;
    }
    get id(){
        return this._id;
    }
    getPainterType(){
        return hmap.core.painterType.STRETCH;
    }
    updatePainterType(){}

    getGeometry(){
        return this.vector.getGeometry();
    }
    /**
     * 获取当前地理要素的可见性
     * @return {Boolean} true表示可见，false表示不可见。
     * @example
     * let visible = feature.getVisibility();
     */
    getVisibility() {
        return this._visible;
    }

    /**
     * 设置拉伸体可见性（该方法会同步对应适量要素对应属性）。
     * @param  {Boolean}  visible  可见用true;不可见用false。
     * @example
     * feature.setVisibility(true);
     */
    setVisibility(visible) {
        this._visible = visible;
        this.vector.setVisibility(visible);
    }

    /**
     * 获取该Stretch实例的id
     * @returns {String} 返回Stretch实例的id
     */
    getId() {
        return this._id;
    }

    /**
     * 计算该拉伸体的三维包围盒。
     * @returns {hmap.basetype.BBox} 返回拉伸体的三维包围盒。
     */
    getBBox() {
        return this._bbox;
    }

    getGeometry(){
        return this.vector.getGeometry();
    }
    getAttributes(){
        return this.vector.getAttributes();
    }
    getStyle(){
        return this.vector.getStyle();
    }
    clone(){
        const feature = this.vector.clone();
        return new hmap.model.Stretch(feature,this._showBorder);
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster}ray 射线
     * @param {Number}tolerance
     * @param {hmap.Map}map
     * @private
     */
    intersectRay(ray, tolerance, map) {
        return this._bbox.intersectRay(ray)
    }
}
;"use strict";
hmap.model = hmap.model || {};
/**
 * FBX格式的模型
 * 1、要求FBX文件的版本为大于等于6400的二进制格式。
 * 2、支持模型颜色,支持模型的自发光、环境光、漫反射光(即点光源、平行光)、镜面高光。
 * 3、支持200兆左右的纹理贴图，纹理贴图不支持.tga .psd的格式。
 * 4、几何中暂不支持Nurbs曲线、变形、动画。
 * @type {hmap.model.FbxModel}
 * @extends hmap.model.Model
 */
hmap.model.FbxModel = class extends hmap.model.Model {
    /**
     * 构造Fbx格式模型。
     * 1、光的色值来自于模型fbx文件。当模型文件没有设置色值，则环境光、自发光、高光默认为黑色；漫反射光默认为白色。
     * 2、透明度值来自于模型fbx文件。可以通过下面开放的透明度因子接口，来调节模型的整个透明度。
     * 3、模型颜色值来自于模型fbx文件。当模型文件没有颜色值时，会使用下面color属性的值替代。
     * @param {String} fileUrl 模型文件的地址
     * @param {Object} options
     * @param {Array} options.color 模型被设置的颜色值，rbg值范围为0-255，该属性默认值为[255,255,255]。当模型文件中未带有颜色信息时，该属性才会被使用。
     * @param {Boolean} options.useEmissive 是否启用模型数据解析的自发光。默认启用。启用设置为true，不启用设置为false。
     * @param {Boolean} options.useAmbient 是否启用模型数据解析的环境光。默认启用。启用设置为true，不启用设置为false。
     * @param {Boolean} options.usePointDiffuse 是否启用模型数据解析的点光源的漫反射光。默认启用。启用设置为true，不启用设置为false。
     * @param {Array} options.lightPosition 点光源的坐标
     * @param {Boolean} options.useDirectDiffuse 是否启用模型数据解析的平行光的漫反射光。默认启用。启用设置为true，不启用设置为false。
     * @param {Array} options.lightDirection 平行光的光源坐标。平行光的光照方向为:该坐标点指向地理坐标系原点的方向。
     * @param {Boolean} options.useSpecular 是否启用模型数据解析的镜面高光。默认启用。启用设置为true，不启用设置为false。
     * @example
     * let model = new hmap.model.FbxModel('../public/fbxData/nanjing.fbx');
     */
    constructor(fileUrl, options = {}) {
        super();
        this.CLASS_NAME = "hmap.model.FbxModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.fileUrl = fileUrl;
        this.modelMatrix = new hmap.util.Matrix4();
        this.modelPosition = [0,0,0];//记录模型原点位置
        this.modelData = [];//包括很多个mesh的绘制数据
        this.color = options.color ? options.color : [255.0, 255.0, 255.0];
        this.setColor();
        this.opacityFactor = 1.0;//透明度因子
        this.strict = options.strict ? options.strict : false;//高精度拾取

        // 模型的光照需要加哪些需要用户手动授予权限
        this.useEmissive = options.hasOwnProperty("useEmissive") ? options.useEmissive : true;//自发光
        this.useAmbient = options.hasOwnProperty("useAmbient") ? options.useAmbient : true;//环境光

        this.usePointDiffuse = options.hasOwnProperty("usePointDiffuse") ? options.usePointDiffuse : true;//点光源漫反射
        this.lightPosition = options.lightPosition ? options.lightPosition : [0.0, 0.0, 0.0];//点光源位置

        this.useDirectDiffuse = options.hasOwnProperty("useDirectDiffuse") ? options.useDirectDiffuse : true;//平行光漫反射
        this.lightDirection = options.lightDirection ? options.lightDirection : [0.0, 0.0, 0.0];//平行光方向

        this.useSpecular = options.hasOwnProperty("useSpecular") ? options.useSpecular : true;//镜面高光
        this.promise = this._readModel();
    }

    /**
     * @private
     */
    setColor() {
        if (this.color instanceof Array && this.color.length >= 3) {
            this.color = this.color.map((value) => value / 255);
        }
    }

    /**
     * 获取设置的透明度的透明因子
     * @returns {Number} 透明因子
     * @example
     * let opacityFactor = model.getOpacityFactor();
     */
    getOpacityFactor() {
        return this.opacityFactor;
    }

    /**
     * 设置透明度的透明因子，即：模型每个部分的透明度*透明因子=最终每个部分显示的透明度
     * @param {Number} opacityFactor 透明因子
     * @example
     * model.setOpacityFactor(0.8);
     */
    setOpacityFactor(opacityFactor) {
        this.opacityFactor = opacityFactor;
        return this;
    }

    /**
     * @private
     */
    _readModel() {
        let flag = this;
        return new Promise(function (res, rej) {
            let fbx = new hmap.format.FBX(flag.fileUrl);
            fbx.parse(function (objectMesh) {

                // let arr = objectMesh.children;
                // for(let i=0,len=arr.length;i<len;i++){
                //     if(arr[i].children.length>0){
                //         console.log(1,arr[i]);
                //         for(let j=0,len=arr[i].children.length;j<len;j++){
                //             if(arr[i].children[j].geometry&&arr[i].children[j].geometry.get('uv')){
                //                 console.log(2,arr[i].children[j])
                //             }
                //         }
                //     }
                // }

                objectMesh.updateMatrix();
                flag._setData(objectMesh);
                flag._calculateBBox();
                res();
            });
        });
    }

    /**
     * @private
     */
    _setData(objectMesh) {
    // 只需要把mesh分开，不需要存数据;考虑：模型数据很大，不需要保存数据原型
        if (objectMesh.children.length > 0) {
            objectMesh.children.forEach(function (mesh) {
                this._setData(mesh);
            }.bind(this));
        } else if (objectMesh.geometry && objectMesh.material) {
            this.modelData.push(objectMesh);
        }
    }

    /**
     * 获取模型的id值
     * @returns {String} 模型的id值
     * @example
     * let mid = model.getMid();
     */
    getMid() {
        return this._id;
    }

    /**
     * 设置模型位置，即设置模型原点在地图上的地理坐标。
     * @param {Number} positionX X值
     * @param {Number} positionY Y值
     * @param {Number} positionZ Z值
     * @returns {hmap.model.FbxModel} 返回模型对象
     * @example
     * model.setPosition(120, 30, 0);
     */
    setPosition(positionX, positionY, positionZ) {
        let e = this.modelMatrix._elements;
        e[12]=positionX;
        e[13]=positionY;
        e[14]=positionZ;
        return this;
    }

    /**
     * 相对于模型之前位置的平移量。
     * @param {Number} translateX X轴平移分量
     * @param {Number} translateY Y轴平移分量
     * @param {Number} translateZ Z轴平移分量
     * @returns {hmap.model.FbxModel} 返回模型对象
     * @example
     * model.setTranslate(120, 30, 0);
     */
    setTranslate(translateX, translateY, translateZ) {
        this.modelMatrix.translate(translateX, translateY, translateZ);
        return this;
    }

    /**
     * 相对于模型之前位置的旋转量。
     * @param {Number} rotateX X轴旋转分量
     * @param {Number} rotateY Y轴旋转分量
     * @param {Number} rotateZ Z轴旋转分量
     * @returns {hmap.model.FbxModel} 返回模型对象
     * @example
     * model.setRotate(90, 0, 0);
     */
    setRotate(rotateX, rotateY, rotateZ) {
        this.modelMatrix.rotate(rotateX, 1, 0, 0);
        this.modelMatrix.rotate(rotateY, 0, 1, 0);
        this.modelMatrix.rotate(rotateZ, 0, 0, 1);
        return this;
    }

    /**
     * 相对于模型之前大小的缩放量。
     * @param {Number} scaleX X轴缩放分量
     * @param {Number} scaleY Y轴缩放分量
     * @param {Number} scaleZ Z轴缩放分量
     * @returns {hmap.model.FbxModel} 返回模型对象
     * @example
     * model.setScale(0.00001, 0.00001, 0.00001);
     */
    setScale(scaleX, scaleY, scaleZ) {
        this.modelMatrix.scale(scaleX, scaleY, scaleZ);
        return this;
    }

    /**
     * 计算该模型整体三维包围盒。
     * @private
     * @returns {hmap.basetype.BBox} 返回拉伸体的三维包围盒。
     */
    getBBox() {
        for (let i = 0, len = this.modelData.length; i < len; i++) {
            let mesh = this.modelData[i];
            if (mesh.box) {
                this._bbox.extendBBox(mesh.box)
            }
        }
        return this._bbox;
    }

    /**
     * 计算该模型每个mesh的三维包围盒。
     * @private
     * @return {Array}
     */
    getBBoxGroup() {
        let boxes=[];
        for (let i = 0, len = this.modelData.length; i < len; i++) {
            let mesh = this.modelData[i];
            if (mesh.box) {
                boxes.push(mesh.box)
            }
        }
        return boxes;
    }

    /**
     * 计算每个mesh的包围盒并保存到mesh对象
     * @private
     */
    _calculateBBox() {
        const allMMatrix = new hmap.util.Matrix4();
        for (let i = 0, len = this.modelData.length; i < len; i++) {
            let mesh = this.modelData[i];
            if (mesh.geometry) {
                let arrPoints = mesh.geometry.get("position").item;
                let u_pmatrix = new hmap.util.Matrix4();
                u_pmatrix = u_pmatrix.multiply(mesh.matrixWorld).multiply(mesh.matrix);
                allMMatrix.setIdentity();
                allMMatrix.multiply(this.modelMatrix);
                allMMatrix.multiply(u_pmatrix);
                mesh._bbox = this._createAxisAlignBoundingBox(arrPoints, allMMatrix);
            }
        }
    }

    /**
     * 点云的包围盒
     * @param arrPoint
     * @param matrix
     * @return {*}
     * @private
     */
    _createAxisAlignBoundingBox(arrPoint, matrix) {
        let xMin = Number.POSITIVE_INFINITY,
            yMin = Number.POSITIVE_INFINITY,
            zMin = Number.POSITIVE_INFINITY,
            xMax = Number.NEGATIVE_INFINITY,
            yMax = Number.NEGATIVE_INFINITY,
            zMax = Number.NEGATIVE_INFINITY;
        //顶点坐标个数必然是3的倍数
        if (arrPoint.length % 3 !== 0) {
            return null;
        }
        //间隔取值，
        const numInterval = 3 * 10;
        for (let i = 0, len = arrPoint.length; i < len; i += numInterval) {
            let vector = matrix.multiplyVector4(new hmap.util.Vector4(arrPoint[i], arrPoint[i + 1], arrPoint[i + 2], 1));
            let value1 = vector.getElement(0),
                value2 = vector.getElement(1),
                value3 = vector.getElement(2);
            if (xMin > value1) xMin = value1; else if (xMax < value1) xMax = value1;
            if (yMin > value2) yMin = value2; else if (yMax < value2) yMax = value2;
            if (zMin > value3) zMin = value3; else if (zMax < value3) zMax = value3;
        }
        return new hmap.basetype.BBox(xMin, yMin, zMin, xMax, yMax, zMax);
    }
}
;"use strict";
hmap.model.gltf = hmap.model.gltf || {};
/**
 * gltf格式的模型类，支持2.0即以上版本，主要负责gltf的加载与解析
 * @type {hmap.model.gltf.GLTF}
 */
hmap.model.gltf.GLTF = class {
    /**
     * 构造gltf格式模型。
     * @param {String} url 模型文件的地址
     * @example
     * let model = new hmap.model.gltf.GLTF("model.gltf");
     */
    constructor(url) {
        this.CLASS_NAME = "hmap.model.gltf.GLTF";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        if (!url) {
            throw new Error("url must need!");
        } else if (url === "3dtile0627") {
            this._mode = "3dtile";
        } else {
            this.parseModeFromUrl(url);
        }
        this.modelMatrix = new hmap.util.Matrix4();
        this.modelPosition = [0,0,0];//记录模型原点位置
        this._sRMatrix=new hmap.util.Matrix4();//模型使用的缩放和旋转矩阵
    }

    /**
     * 设置模型原点的位置
     * @param {Number} positionX X值
     * @param {Number} positionY Y值
     * @param {Number} positionZ Z值
     * @returns {hmap.model.gltf.GLTF} 返回模型对象
     * @example
     * model.setPosition(120.2187, 30.21259, 0);
     */
    setPosition(positionX, positionY, positionZ) {
        // this.setTranslate(positionX-this.modelPosition[0], positionY-this.modelPosition[1], positionZ-this.modelPosition[2]);
        let e = this.modelMatrix._elements;
        e[12]=positionX;
        e[13]=positionY;
        e[14]=positionZ;

        this.modelPosition[0] = positionX;
        this.modelPosition[1] = positionY;
        this.modelPosition[2] = positionZ;
        return this;
    }

    /**
     * 相对模型之前位置的平移分量设置
     * @param {Number} translateX X轴平移分量
     * @param {Number} translateY Y轴平移分量
     * @param {Number} translateZ Z轴平移分量
     * @return {hmap.model.gltf.GLTF} 返回模型对象
     * @example
     * model.setTranslate(120.2187, 30.21259, 0);
     */
    setTranslate(translateX, translateY, translateZ) {
        this.modelMatrix.translate(translateX, translateY, translateZ);
        this.modelPosition[0] += translateX;
        this.modelPosition[1] += translateY;
        this.modelPosition[2] += translateZ;
        return this;
    }

    /**
     * 设置模型旋转分量
     * @param {Number} rotateX X轴旋转分量
     * @param {Number} rotateY Y轴旋转分量
     * @param {Number} rotateZ Z轴旋转分量
     * @return {hmap.model.gltf.GLTF} 返回模型对象
     * @example
     * model.setRotate(90, 25, 0);
     */
    setRotate(rotateX, rotateY, rotateZ) {
        this.modelMatrix.rotate(rotateX, 1, 0, 0);
        this.modelMatrix.rotate(rotateY, 0, 1, 0);
        this.modelMatrix.rotate(rotateZ, 0, 0, 1);
        this._sRMatrix.rotate(rotateX, 1,0,0).rotate(rotateY,0,1,0).rotate(rotateZ,0,0,1);
        return this;
    }

    /**
     * 设置模型缩放分量
     * @param {Number} scaleX X轴缩放分量
     * @param {Number} scaleY Y轴缩放分量
     * @param {Number} scaleZ Z轴缩放分量
     * @return {hmap.model.gltf.GLTF} 返回模型对象
     * @example
     * model.setScale(0.0015, 0.0015, 0.0015);
     */
    setScale(scaleX, scaleY, scaleZ) {
        this.modelMatrix.scale(scaleX, scaleY, scaleZ);
        this._sRMatrix.scale(scaleX,scaleY,scaleZ);
        return this;
    }

    /**
     * 获取解析的gltf对象。
     * @private
     */
    getPromiseGLTF() {
        return this.gltf;
    }

    /**
     * 获取模型id值
     * @return {String} 返回模型对象的id值
     * @example
     * let id = model.getId();
     */
    getId() {
        return this._id;
    }

    /**
     * 通过url解析时gltf还是glb类型
     * @private
     */
    parseModeFromUrl(url) {
        const index = url.lastIndexOf(".");
        const type = url.substr(index + 1);
        if (type === "gltf") {
            this._mode = "gltf";
            this.gltf = this._loadGLTF(url);
        } else if (type === "glb") {
            this._mode = "glb";
            this.gltf = this._loadBinaryGLTF(url);
        } else {
            this._mode = null;
            throw new Error("cannot parse this type!");
        }
    }

    /**
     * load glTF
     * @private
     * @param url
     * @return {Promise<void>}
     */
    async _loadGLTF(url) {
        const gltf = await this._loadJSON(url);
        if (!gltf.asset === undefined || gltf.asset.version[0] < 2) {
            throw new Error("glTF version < 2.0 are not supported!");
        }
        this._baseURL = new URL(url, location.href);

        await this._loadBuffer(gltf);
        this._loadImages(gltf);
        this._parseMeshes(gltf);//非required
        this._parseNodes(gltf);//非required
        this._parseScenes(gltf);//非required
        gltf._id = this._id;
        return gltf;
    }

    /**
     * @private
     */
    async _loadJSON(url) {
        return await this._loadFile(url, "json");
    }

    /**
     * @private
     */
    async _loadFile(url, type) {
        const response = await fetch(url);
        return await response[type]();
    }

    /**
     * @private
     */
    async _loadBinary(url) {
        return this._loadFile(url, "arrayBuffer");
    }

    /**
     * @private
     */
    async _loadBuffer(gltf) {
        gltf.buffers=gltf.buffers||[];
        gltf.buffers = await Promise.all(gltf.buffers.map((buffer) => {
            const url = new URL(buffer.uri, this._baseURL.href);
            return this._loadBinary(url.href);
        }));
    }

    /**
     * @private
     */
    _parseMeshes(gltf) {
        const meshes = gltf.meshes||[];
        for (let i = 0, len = meshes.length; i < len; i++) {
            const mesh = meshes[i];
            const primitives = mesh.primitives;
            for (let j = 0, len = primitives.length; j < len; j++) {
                const primitive = primitives[j];
                const attribs = {};
                let numElements;
                //单个图元的处理（处理图元中的所有属性
                // ，暂时不生成bufferInfo，考虑是否和绘制分开）
                for (const [attribName, index] of Object.entries(primitive.attributes)) {
                    const {accessor, buffer, stride} = hmap.model.gltf.GLTF.getAccessorAndBuffer(gltf, index);
                    numElements = accessor.count;
                    attribs["a_" + attribName.toLowerCase()] = {
                        buffer,
                        type: accessor.componentType,
                        numComponents: hmap.model.gltf.GLTF.accessorTypeToNumCompenents(accessor.type),
                        stride,
                        offset: accessor.byteOffset || 0,
                        min:accessor.min,
                        max:accessor.max
                    };
                }
                const bufferInfo = {
                    attribs,
                    numElements
                };

                if (primitive.indices !== undefined) {
                    const {accessor, buffer} = hmap.model.gltf.GLTF.getAccessorAndBuffer(gltf, primitive.indices);
                    bufferInfo.numElements = accessor.count;
                    bufferInfo.indices = buffer;
                    bufferInfo.elementType = accessor.componentType;
                    bufferInfo.byteOffset = accessor.byteOffset || 0;
                }

                primitive.bufferInfo = bufferInfo;

                // primitive.material=gltf.materials&&gltf.materials[primitive.material]||defaultMaterial;
                primitive.material = this._getMaterial(gltf, primitive.material);
            }
        }
    }

    /**
     * @private
     */
    _getMaterial(gltf, materialIndex) {
        if (!(gltf.materials && gltf.materials[materialIndex])) {
            return hmap.model.gltf.defaultMaterial;
        }
        let material = hmap.model.gltf.defaultMaterial, textures = {};//使用默认值，为防止渲染模式为其他类
        //元素处理,pbr渲染中的baseColorTexture为基础纹理数据，如果没有其他纹理，该纹理将定义整个物体颜色（暂时只处理基础纹理数据）
        const {name, pbrMetallicRoughness, normalTexture, occlusionTexture, emssiveTexture} = gltf.materials[materialIndex];
        //如果存在pbr则只解析基础颜色和纹理
        if (pbrMetallicRoughness) {
            material.colorFactor = pbrMetallicRoughness.baseColorFactor || [1.0, 1.0, 1.0, 1.0];
            const colorTexture = pbrMetallicRoughness.baseColorTexture;
            material.isTex = false;
            if (colorTexture) {
                colorTexture.texture = this._loadTexture(gltf, colorTexture.index);
                textures.colorTexture = colorTexture;
                material.textures = textures;//后期textures存储各种纹理模式，当前仅为颜色纹理
                material.isTex = true;
            }
        }
        if (this._mode === "3dtile") {
            const khrTechWebgl = gltf.materials[materialIndex].extensions.KHR_techniques_webgl;
            const {techniques, values} = khrTechWebgl;
            material.colorFactor = values.u_diffuse || [1.0, 1.0, 1.0, 1.0];
            material.isTex = false;
            const colorTexture = values.u_diffuseTex;
            if (values.u_hasTex) {
                colorTexture.texture = this._loadTexture(gltf, colorTexture.index);
                textures.colorTexture = colorTexture;
                material.textures = textures;
                material.isTex = true;
            }
        }
        return material;
    }

    /**
     * @private
     */
    _loadTexture(gltf, textureIndex) {
        const texture = gltf.textures[textureIndex];
        if (!texture.imgArrayBuffer) {
            const img = gltf.images[texture.source];
            img.then((value) => {
                texture.imgArrayBuffer = value.arrayBuffer;
            });
        }

        if (!texture.samplerObj) {
            texture.samplerObj = {};
        }
        return texture;
    }

    /**
     * 处理images对象，将uri和bufferView替换为数据形式
     * @private
     */
    async _loadImages(gltf) {
        // if(gltf.images===undefined){
        //     // gltf.images=null;
        //     return;
        // }
        gltf.images=gltf.images||[];
        gltf.images = gltf.images.map((img) => {
            const {name, uri, bufferView} = img;
            img.isLoad=false;
            return new Promise((resolve => {
                const image = new Image();
                // if (uri&&(this._mode !== "3dtile")) {
                //     image.src = new URL(uri, this._baseURL.href);
                // } else
                if ((bufferView !== undefined) && (img.mimeType !== undefined)) {
                    const glBufferView = gltf.bufferViews[bufferView];
                    if (!glBufferView.data) {
                        // const target=bufferView.target||34962;
                        const arrayBuffer = gltf.buffers[glBufferView.buffer] || gltf.buffers;
                        glBufferView.data = new Uint8Array(arrayBuffer, glBufferView.byteOffset, glBufferView.byteLength);
                        const mimeType = img.mimeType;
                        img.blob = new Blob([glBufferView.data], {type: mimeType});
                        image.src = URL.createObjectURL(img.blob);
                    }
                } else if (uri) {
                    image.src = new URL(uri, this._baseURL.href);
                }
                image.onload = function () {
                    img.arrayBuffer = image;
                    img.isLoad=true;
                    URL.revokeObjectURL(img.blob || "");
                    resolve(img);
                };
            }));
        });
    }

    /**
     * @private
     */
    _parseNodes(gltf) {
        gltf.nodes=gltf.nodes||[];
        const skinNodes = [];
        const origNodes = gltf.nodes;
        gltf.nodes = gltf.nodes.map((n) => {
            const {name, skin, mesh, translation, rotation, scale, matrix} = n;
            const trs = new hmap.model.gltf.TRS(translation, rotation, scale, matrix);
            const node = new hmap.model.gltf.Node(trs, name);
            const realMesh = gltf.meshes[mesh];
            if (realMesh) {
                node.drawables.push(new hmap.model.gltf.MeshRender(realMesh));
            }
            return node;
        });

        gltf.nodes.forEach((node, ndx) => {
            const children = origNodes[ndx].children;
            if (children) {
                this._addChildren(gltf.nodes, node, children);
            }
        });
    }

    /**
     * @private
     */
    _parseScenes(gltf) {
        gltf.scenes=gltf.scenes||[];
        for (const scene of gltf.scenes) {
            scene.root = new hmap.model.gltf.Node(new hmap.model.gltf.TRS(), scene.name);
            this._addChildren(gltf.nodes, scene.root, scene.nodes);
        }
    }

    /**
     * @private
     */
    static getAccessorAndBuffer(gltf, accessorIndex) {
        const accessor = gltf.accessors[accessorIndex];
        const bufferView = gltf.bufferViews[accessor.bufferView];
        if (!bufferView.data) {
            // const target=bufferView.target||34962;
            const arrayBuffer = gltf.buffers[bufferView.buffer] || gltf.buffers;
            bufferView.data = new Uint8Array(arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
        }

        return {
            accessor,
            buffer: bufferView,
            stride: bufferView.stride || 0,
            // data:data
        }
    }

    /**
     * @private
     */
    static accessorTypeToNumCompenents(type) {
        return hmap.model.gltf.accessorTypeToNumComponentsMap[type] || null;
    }

    /**
     * @private
     */
    _addChildren(nodes, node, childIndices) {
        childIndices.forEach((childNdx) => {
            const child = nodes[childNdx];
            child.setParent(node);
        });
    }

    /**
     * @private
     */
    async _loadBinaryGLTF(url) {
        const gltfBinary = await this._loadFile(url, "arrayBuffer");
        this._baseURL = new URL(url, location.href);
        let gltf = this._parseBinaryGLTF(gltfBinary);
        return gltf;
    }

    /**
     * @private
     */
    async _parseBinaryGLTF(gltfBinary) {
        let gltf = {};
        const magic = hmap.model.gltf.GLTF.decodeText(new Uint8Array(gltfBinary.slice(0, 4)));
        const headerView = new DataView(gltfBinary, 0, 12);
        gltf.header = {
            magic: magic,
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
        };

        //切割，查看是bin还是json
        const chunkView = new DataView(gltfBinary, 12);
        let chunkIndex = 0;
        while (chunkIndex < chunkView.byteLength) {
            const chunkLen = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            const chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;

            if (chunkType === 0x4E4F534A) {
                gltf.json = hmap.model.gltf.GLTF.decodeText(new Uint8Array(gltfBinary, 12 + chunkIndex, chunkLen));
            } else if (chunkType === 0x004E4942) {
                const byteOffset = 12 + chunkIndex;
                gltf.buffers = gltfBinary.slice(byteOffset, byteOffset + chunkLen);
            }
        }

        if (gltf.header.version < 2) {
            throw new Error("glTF version < 2.0 are not supported!");
        }

        //统一数据结构
        let gltfB = JSON.parse(gltf.json);
        gltfB.buffers = gltf.buffers;

        this._loadImages(gltfB);
        this._parseMeshes(gltfB);
        this._parseNodes(gltfB);
        this._parseScenes(gltfB);
        gltfB._id = this._id;
        // this.gltf=gltfB;
        return gltfB;
    }

    /**
     * @private
     */
    parse3DtileGltf(gltf) {
        this._loadImages(gltf);
        this._parseMeshes(gltf);
        this._parseNodes(gltf);
        this._parseScenes(gltf);
        gltf._id = this._id;
        this.gltf = gltf;
        return gltf;
    }

    /**
     * gltf模型销毁
     * @example
     * model.destroy();
     */
    destroy(){
        // let me=this;
        for(let key in this.gltf){
            delete this.gltf[key];
        }
        for(let i in this){
            delete this[i];
        }
    }

    /**
     * 3dtile Render 解析gltf使用，返回组织好的绘制数据
     * @private
     * @param gltf
     * @param gl
     * @param program
     */
    parse3DTileGltf2(gltf,gl,program=null){
    }

    /**
     * @private
     */
    static decodeText(array) {
        let s = "";
        for (let i = 0, len = array.length; i < len; i++) {
            s += String.fromCharCode(array[i]);
        }
        return decodeURIComponent(decodeURI(s));
    }
};

//access类型数字枚举
hmap.model.gltf.accessorTypeToNumComponentsMap = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16,
};

//array类型枚举
hmap.model.gltf.glTypeToTypedArrayMap = {
    '5120': Int8Array,    // gl.BYTE
    '5121': Uint8Array,   // gl.UNSIGNED_BYTE
    '5122': Int16Array,   // gl.SHORT
    '5123': Uint16Array,  // gl.UNSIGNED_SHORT
    '5124': Int32Array,   // gl.INT
    '5125': Uint32Array,  // gl.UNSIGNED_INT
    '5126': Float32Array, // gl.FLOAT
};

//image资源类型对应
hmap.model.gltf.imageMimeTypeMap = {
    'image/png': 'RGBAFormat',
    'image/jpeg': 'RGBFormat'
};
//设定的默认反射材质
hmap.model.gltf.defaultMaterial = {
    colorFactor: [.5, .8, 1, 1],
    isTex:false,
};
;"use strict";
/**
 * gltf使用的坐标系统，存储和更新坐标矩阵（平移、旋转、缩放或者复合矩阵）
 * gltf专用，不对外
 * @private
 */
hmap.model.gltf=hmap.model.gltf||{};
hmap.model.gltf.TRS=class{
    constructor(position=[0,0,0],rotation=[0,0,0,1],scale=[1,1,1],matrix=[]){
        this.position=position;
        this.rotation=rotation;
        this.scale=scale;
        this.matrix=matrix;
    }

    /**
     * 获取矩阵
     * @param dst
     * @returns {*}
     */
    getMatrix(dst){
        if(this.matrix.length===16){
            return new hmap.util.Matrix4(new Float32Array(this.matrix));
        }else{
            dst=dst||new hmap.util.Matrix4();
            return dst.composeFromArray(this.position,this.rotation,this.scale);
        }
    }
};;"use strict";
hmap.model.gltf=hmap.model.gltf||{};
hmap.model.gltf.MeshRender=class{
    constructor(mesh){
        this.mesh=mesh;
    }
    getPrimitives(){
        return this.mesh.primitives;
    }
};;"use strict";
/**
 * gltf数据解析格式中的节点类，包含节点中的数据、层级关系、矩阵变换、可绘制调用等
 * 私有类，供gltf调用不对外
 * @private
 */
hmap.model.gltf=hmap.model.gltf||{};
hmap.model.gltf.Node=class{
    constructor(source,name){
        this.name=name;
        this.source=source;//矩阵源，存储变换前的原矩阵？？？(用来计算本地矩阵)。hmap.model.gltf.TRS格式
        this.parent=null;
        this.children=[];
        this.localMatrix=new hmap.util.Matrix4();//当前节点的本地矩阵
        this.worldMatrix=new hmap.util.Matrix4();//当前节点的世界矩阵
        this.drawables=[];
    };

    /**
     * 设置父节点，同时更新父节点的子节点。
     * @param parent
     */
    setParent(parent){
        if(this.parent){
            this.parent._removeChild(this);
            this.parent=null;
        }
        if(parent){
            parent._addChild(this);
            this.parent=parent;
        }
    }

    /**
     * 更新世界矩阵，根据传输的
     * @param parentWorldMatrix
     */
    updateWorldMatrix(parentWorldMatrix){
        const source=this.source;
        if(source){
            //更新本地矩阵
            source.getMatrix(this.localMatrix);
        }

        //根据父世界矩阵，更新本地世界矩阵
        if(parentWorldMatrix){
            //如果有父级矩阵传入则做数学运算（如果有父级矩阵，用来更新该节点的世界矩阵）
            this.worldMatrix=parentWorldMatrix.clone().multiply(this.localMatrix);
        }else{
            //如果不存在父级矩阵，则将本地矩阵复制一份作为该节点的世界矩阵
            this.worldMatrix=this.localMatrix.clone();
        }

        //处理所有子
        const worldMatrix=this.worldMatrix;
        for(let child of this.children){
            child.updateWorldMatrix(worldMatrix);
        }
    }

    /**
     * 节点变换
     * @param fn
     */
    traverse(fn){
        fn(this);
        for(const child of this.children){
            child.traverse(fn);
        }
    }

    _addChild(child){
        this.children.push(child);
    }

    _removeChild(child){
        const ndx=this.children.indexof(child);
        this.children.splice(ndx,1);
    }

    /**
     * 重设初始化的矩阵源
     */
    resetMatrixSource(position=[0,0,0],rotation=[0,0,0,1],scale=[1,1,1]){
        //地图使用的坐标系为垂直方向为z轴，水平方向为xy轴；原始模型坐标多为xz平面为水平面，y为垂直方向，此处做调整，供拾取后改变node调用
        this.source = new hmap.model.gltf.TRS([position[0],position[2],position[1]], [rotation[0],rotation[2],rotation[1],rotation[3]], [scale[0],scale[2],scale[1]]);
    }
};;'use strict';
hmap.status = hmap.status || {};
 /**
 * 颜色混合状态
 * @private
 * @type {hmap.status.BlendStatus}
 */
hmap.status.BlendStatus = class {
	/**
     * 构造方法.
     * @example
     * let blendStatus = new hmap.status.BlendStatus();
     */
	constructor(){
		this._enable = true;
		this._rgbSrcFactor = "SRC_ALPHA";
		this._rgbDstFactor = "ONE_MINUS_SRC_ALPHA";
		this._alphaSrcFactor = "ONE";
		this._alphaDstFactor = "ONE";
		this._rgbMode = "FUNC_ADD";
		this._alphaMode = "FUNC_ADD";
		this._rgba = [0,0,0,0];
	}
	
	/**
	 * 激活颜色混合状态
	 * @param {WebGL2RenderingContext} gl 渲染上下文
	 */
    active(gl){
        if(this._enable){
        	gl.enable(gl.BLEND);
        	gl.blendFuncSeparate(gl[this._rgbSrcFactor], gl[this._rgbDstFactor],gl[this._alphaSrcFactor],gl[this._alphaDstFactor]);
        	gl.blendEquationSeparate(gl[this._rgbMode],gl[this._alphaMode]);
        	gl.blendColor(this._rgba[0],this._rgba[1],this._rgba[2],this._rgba[3]);
        }else{
        	gl.disable(gl.BLEND);
        }
    }

	/**
	 * 设置颜色混合状态是否开启。状态默认开启。
	 * @param {Boolean} enable 开启/关闭。状态开启设置true，状态关闭设置false。
	 * @example
	 * blendStatus.setEnable(true);
	 */
	setEnable(enable){
		if(typeof enable === "boolean"){
			this._enable = enable;
		}
	}

	/**
	 * 获取颜色混合是否开启
	 * @returns {Boolean} 状态
	 * @example
	 * let enable = blendStatus.getEnable();
	 */
	getEnable(){
		return this._enable;
	}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

	/**
	 * 设置颜色混合的方式，包括源颜色和目标颜色rgba分量的比例、混合方式;
	 * @param {Object} options 
	 * @param {hmap.status.BlendFactor} options.rgbSrcFactor    枚举值，源颜色rgb分量在混合后颜色中的权重因子，默认值为:hmap.status.BlendFactor.SRC_ALPHA
	 * @param {hmap.status.BlendFactor} options.rgbDstFactor    枚举值，目标颜色rgb分量在混合后颜色中的权重因子,默认值为：hmap.status.BlendFactor.ONE_MINUS_SRC_ALPHA
	 * @param {hmap.status.BlendFactor} options.alphaSrcFactor  枚举值，源颜色alpha分量在混合后颜色中的权重因子,默认值为：hmap.status.BlendFactor.ONE
	 * @param {hmap.status.BlendFactor} options.alphaDstFactor  枚举值，目标颜色alpha分量在混合后颜色中的权重因子,默认值为：hmap.status.BlendFactor.ONE_MINUS_SRC_ALPHA
	 * @param {hmap.status.BlendFunc}   options.rgbMode         枚举值，源颜色rgb分量和目标颜色rgb分量的混合方式,默认值为：hmap.status.BlendFunc.FUNC_ADD
	 * @param {hmap.status.BlendFunc}   options.alphaMode       枚举值，源颜色alpha分量和目标颜色alpha分量的混合方式,默认值为：hmap.status.BlendFunc.FUNC_ADD
	 * @example
	 * blendStatus.setFunc({
	 * 		rgbSrcFactor: hmap.status.BlendFactor.SRC_ALPHA,
	 *		rgbDstFactor: hmap.status.BlendFactor.ONE_MINUS_SRC_ALPHA,
	 *		alphaSrcFactor: hmap.status.BlendFactor.ONE,
	 *		alphaDstFactor: hmap.status.BlendFactor.ZERO,
	 *		rgbMode: hmap.status.BlendFunc.FUNC_ADD,
	 *		alphaMode: hmap.status.BlendFunc.FUNC_ADD
	 * });
	 */  
	setFunc(options){
		this._rgbSrcFactor = options.rgbSrcFactor || this._rgbSrcFactor;
		this._rgbDstFactor = options.rgbDstFactor || this._rgbDstFactor;
		this._alphaSrcFactor = options.alphaSrcFactor || this._alphaSrcFactor;
		this._alphaDstFactor = options.alphaDstFactor || this._alphaDstFactor;
		this._rgbMode = options.rgbMode || this._rgbMode;
		this._alphaMode = options.alphaMode || this._alphaMode;
	}

	/**
	 * 返回颜色混合方式的参数
	 * @returns {Object} 混合方式的参数,参数同setFunc方法的参数说明
	 * @example
	 * let options = blendStatus.getFuncParam();
	 */
	getFuncParam(){
		return {
			rgbSrcFactor: this._rgbSrcFactor,
			rgbDstFactor: this._rgbDstFactor,
			alphaSrcFactor: this._alphaSrcFactor,
			alphaDstFactor: this._alphaDstFactor,
			rgbMode: this._rgbMode,
			alphaMode: this._alphaMode
		};
	}
                  
	/**
	 * 设置混合后颜色的rgba值。在设置混合方式时，混合后颜色被设置为常量，setBlendColor方法设置的颜色值才被使用。
	 * @param {hmap.style.Color} color 颜色值，参数默认值为[0,0,0,0]。
	 * @example
	 * let color = new hmap.style.Color(255,0,0,1);
	 * blendStatus.setBlendColor(color);
	 */
	setBlendColor(color){
		if(color instanceof hmap.style.Color){
			const rgba = color.toNormalizeArray();
			this._rgba = rgba;
		}
	}

	/**
	 * 获取设置的混合后颜色的rgba值
	 * @returns {hmap.style.Color} color 颜色值
	 * @example
	 * let color = blendStatus.getBlendColor();
	 */
	getBlendColor(){
		return this._rgba;
	}
}

/**
 * 混合前源颜色和目标颜色的因子设置的枚举类:源颜色(Rs,Gs,Bs,As)、目标颜色(Rd,Gd,Bd,Ad)、常量颜色(Rc,Gc,Bc,Ac)
 * 颜色因子						RGB因子				                Alpha因子
 * ZERO							0,0,0，				                0
 * ONE          				1,1,1,				                1
 * SRC_COLOR 					Rs,Gs,Bs,			                As
 * ONE_MINUS_SRC_COLOR			1-Rs,1-Gs,1-Bs, 	                1-As
 * DST_COLOR     				Rd,Gd,Bd,	                        Ad
 * ONE_MINUS_DST_COLOR 			1-Rd,1-Gd,1-Bd,	                    1-Ad
 * SRC_ALPHA 					As，As，As	                        As
 * ONE_MINUS_SRC_ALPHA  		1-As，1-As，1-As                    1-As
 * DST_ALPHA 					Ad，Ad，Ad	                        Ad
 * ONE_MINUS_DST_ALPHA          1-Ad，1-Ad，1-Ad	                    1-Ad
 * CONSTANT_COLOR 				Rc,Gc,Bc,                           Ac
 * ONE_MINUS_CONSTANT_COLOR     1-Rc,1-Gc,1-Bc,                     1-Ac
 * CONSTANT_ALPHA               Ac,Ac,Ac                            Ac
 * ONE_MINUS_CONSTANT_ALPHA     1-Ac,1-Ac,1-Ac                      1-Ac
 * SRC_ALPHA_SATURATE           min(As,Ad),min(As,Ad),min(As,Ad)    1
 */
hmap.status.BlendFactor = {		
	ZERO: 				      "ZERO",		   		
	ONE: 				      "ONE",		   		
	SRC_COLOR: 			      "SRC_COLOR",		
	ONE_MINUS_SRC_COLOR:      "ONE_MINUS_SRC_COLOR",
	DST_COLOR: 			      "DST_COLOR",	
	ONE_MINUS_DST_COLOR:      "ONE_MINUS_DST_COLOR",
	SRC_ALPHA:                "SRC_ALPHA",
	ONE_MINUS_SRC_ALPHA:      "ONE_MINUS_SRC_ALPHA",
	DST_ALPHA:                "DST_ALPHA",
	ONE_MINUS_DST_ALPHA:      "ONE_MINUS_DST_ALPHA",
	CONSTANT_COLOR:           "CONSTANT_COLOR",
	ONE_MINUS_CONSTANT_COLOR: "ONE_MINUS_CONSTANT_COLOR",
	CONSTANT_ALPHA:           "CONSTANT_ALPHA",
	ONE_MINUS_CONSTANT_ALPHA: "ONE_MINUS_CONSTANT_ALPHA",
	SRC_ALPHA_SATURATE:       "SRC_ALPHA_SATURATE"//只能sfactor能用
};

/**
 * 颜色混合方式枚举类
 * 混合方式					混合方程
 * FUNC_ADD					源颜色*源因子 + 目标颜色*目标因子
 * FUNC_SUBSTRACT			源颜色*源因子 - 目标颜色*目标因子
 * FUNC_REVERSE_SUBSTRACT	目标颜色*目标因子 - 源颜色*源因子
 */
hmap.status.BlendFunc = {
	FUNC_ADD:"FUNC_ADD",
	FUNC_SUBTRACT:"FUNC_SUBTRACT",
	FUNC_REVERSE_SUBTRACT:"FUNC_REVERSE_SUBTRACT",
};;'use strict';
hmap.status = hmap.status || {};
/**
 * 剔除状态
 * @private
 * @type {hmap.status.CullFaceStatus}
 */
hmap.status.CullFaceStatus = class {
	/**
     * 构造方法.
     * @example
     * let cullFaceStatus = new hmap.status.CullFaceStatus();
     */
	constructor(){
		this._enable = true;
		this._cullFaceFunc = "BACK";
		this._frontFace = "CCW";
	}

	/**
	 * 激活剔除的状态
	 * @param {WebGL2RenderingContext} gl 渲染上下文
	 */
	active(gl){
        if(this._enable){
        	gl.enable(gl.CULL_FACE);
        	gl.cullFace(gl[this._cullFaceFunc]);
        	gl.frontFace(gl[this._frontFace]);
        }else{
        	gl.disable(gl.CULL_FACE);
        }
	}
	/**
	 * 设置剔除状态是否开启。状态默认开启。
	 * @param {Boolean} enable 开启/关闭。状态开启设置true，状态关闭设置false。
	 * @example
	 * cullFaceStatus.setEnable(true);
	 */
	setEnable(enable){
		if(typeof enable === "boolean"){
			this._enable = enable;
		}
	}

	/**
	 * 获取剔除是否开启
	 * @returns {Boolean} 状态
	 * @example
	 * let enable = cullFaceStatus.getEnable();
	 */
	getEnable(){
		return this._enable;
	}

	/**
	 * 设置剔除方式。默认是背面剔除。
	 * @param {hmap.status.CullFaceFunc} cullFaceFunc 剔除方式
	 * @example
	 * cullFaceStatus.setFunc(hmap.status.CullFaceFunc.BACK);
	 */
	setFunc(cullFaceFunc){
		if(cullFaceFunc){
			this._cullFaceFunc = cullFaceFunc;
		}
	}

	/**
	 * 获取剔除方式
	 * @returns {hmap.status.CullFaceFunc} 剔除方式
	 * @example
	 * let cullFaceFunc = cullFaceStatus.getFunc();
	 */
	getFunc(){
		return this._cullFaceFunc;
	}

	/**
	 * 设置多边形正面的顶点是逆时针还是顺时针。默认正面的顶点为逆时针。
	 * @param {hmap.status.FrontFace} frontFace 顶点走势
	 * @example
	 * cullFaceStatus.setFrontFace(hmap.status.FrontFace.CW);
	 */
	setFrontFace(frontFace){
		if(frontFace){
			this._frontFace = frontFace;
		}
	}

	/**
	 * 获取多边形正面的顶点是逆时针还是顺时针
	 * @returns {hmap.status.FrontFace} 顶点走势
	 * @example
	 * let frontFace = cullFaceStatus.getFrontFace();
	 */
	getFrontFace(){
		return this._frontFace;
	}
}

/**
 * 剔除方式枚举类
 * 参数 		        剔除面
 * BACK 			背面
 * FRONT 			正面
 * FRONT_AND_BACK   背面正面同时剔除
 */
hmap.status.CullFaceFunc = {
	BACK:   "BACK",//背面
	FRONT:  "FRONT",//正面
	FRONT_AND_BACK: "FRONT_AND_BACK",//背面正面同时剔除
};

/**
 * 设置多边形正面的顶点是逆时针还是顺时针
 * 参数 		顶点走势
 * CW 		顺时针
 * CCW 		逆时针
 */
hmap.status.FrontFace = {
	CW:  "CW", 
	CCW: "CCW",
};;'use strict';
hmap.status = hmap.status || {};
/**
 * 深度测试状态
 * @private
 * @type {hmap.status.DepthStatus}
 */
hmap.status.DepthStatus = class {
	/**
     * 构造方法.
     * @example
     * let depthStatus = new hmap.status.DepthStatus();
     */
	constructor(){
		this._enable = true;
		this._depthFunc = "LEQUAL";
		this._clearValue = 1.0;
		this._depthRange = [0.0,1.0];
		this._depthMask = true;
	}

	/**
	 * 激活深度测试状态
	 * @param {WebGL2RenderingContext} gl 渲染上下文
	 */
	active(gl){
		if(this._enable){
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl[this._depthFunc]);
        	gl.clearDepth(this._clearValue);
        	gl.depthRange(this._depthRange[0],this._depthRange[1]);
        	gl.depthMask(this._depthMask);
		}else{
			gl.disable(gl.DEPTH_TEST);
		}
	}

	/**
	 * 设置深度测试是否开启。默认状态开启。
	 * @param {Boolean} enable 开启/关闭。状态开启设置true，状态关闭设置false。
	 * @example
	 * depthStatus.setEnable(true);
	 */
	setEnable(enable){
		if(typeof enable === "boolean"){
			this._enable = enable;
		}
	}

	/**
	 * 获取深度测试是否开启
	 * @returns {Boolean} 状态
	 * @example
	 * let enable = depthStatus.getEnable();
	 */
	getEnable(){
		return this._enable;
	}

	/**
	 * 设置深度检测方式。
	 * @param {hmap.status.DepthFunc} depthFunc 深度检测方式。参数默认值为hmap.status.DepthFunc.LEQUAL。
	 * @example
	 * depthStatus.setFunc(hmap.status.DepthFunc.LESS);
	 */
	setFunc(depthFunc){
		this._depthFunc = depthFunc;
	}

	/**
	 * 获取深度检测方式
	 * @returns {hmap.status.DepthFunc} 深度检测方式
	 * @example
	 * let depthFunc = depthStatus.getFunc();
	 */
	getFunc(){
		return this._depthFunc;
	}

	/**
	 * 设置初始化深度缓存的深度值,参数是0.0到1.0范围内的任意值；否则设置无效。
	 * @param {Number} clearValue 深度值,参数默认值为1.0
	 * @example
	 * depthStatus.setClearValue(1.0);
	 */
	setClearValue(clearValue){
		if(Number.isFinite(clearValue)&&clearValue>=0.0&&clearValue<=1.0){
			this._clearValue = clearValue;
		}
	}

	/**
	 * 获取初始化深度缓存的深度值
	 * @returns {Number} 深度值
	 * @example
	 * let clearValue = depthStatus.getClearValue();
	 */
	getClearValue(){
		return this._clearValue;
	}

	/**
	 * 设置深度缓存的范围。默认值为[0,1]。
	 * @param {Array} depthRange 深度缓存的范围[zNear,zFar],要求zNear和zFar值被限制在0到1的范围内。此外，zNear必须小于或等于zFar。
	 * @example
	 * depthStatus.setRange([0,1]);
	 */
	setRange(depthRange){
		if(depthRange instanceof Array && depthRange.length==2 && depthRange[0]>=0 && depthRange[0]<=depthRange[1] && depthRange[1]<=1.0){
			this._depthRange = depthRange;
		}
	}

	/**
	 * 获取初始化深度缓存的深度值
	 * @returns {Array} 深度缓存的范围
	 * @example
	 * let depthRange = depthStatus.getRange();
	 */
	getRange(){
		return this._depthRange;
	}

	/**
	 * 锁定(false)或释放(true)深度缓存的写入操作。状态默认值为释放。
	 * @param {Boolean} depthMask 写入操作的状态。锁定设置为false;释放设置为true.
	 * @example
	 * depthStatus.setMask(false);
	 */
	setMask(depthMask){
		if(typeof depthMask === "boolean"){
			this._depthMask = depthMask;
		}
	}

	/**
	 * 获取深度缓存的写入操作是否锁定
	 * @returns {Boolean} 写入操作的状态。返回false为锁定;返回true为释放.
	 * @example
	 * let depthMask = depthStatus.getMask();
	 */
	getMask(){
		return this._depthMask;
	}

}

/**
 * 深度检测方式枚举类
 * 参数 			深度检测方式
 * NEVER 	 	永不通过
 * LESS		 	小于
 * EQUAL 	 	等于
 * LEQUAL 	 	小于或等于
 * GREATER 	 	大于
 * NOTEQUAL  	不等于
 * GEQUAL 	 	大于或等于
 * ALWAYS 	 	总是通过 
 */
hmap.status.DepthFunc = {
	NEVER:"NEVER",		
	LESS: "LESS",		
	EQUAL:"EQUAL",		
	LEQUAL:"LEQUAL",	
	GREATER:"GREATER",	
	NOTEQUAL:"NOTEQUAL",
	GEQUAL:"GEQUAL",	
	ALWAYS:"ALWAYS",	
};;'use strict';
hmap.status = hmap.status || {};
/**
 * 裁剪状态
 * @private
 * @type {hmap.status.ScissorStatus}
 */
hmap.status.ScissorStatus = class {
    /**
     * 构造方法.
     * @example
     * let scissorStatus = new hmap.status.ScissorStatus();
     */
    constructor(){
        this._enable = false;
        this._scissorRange = [0,0,0,0];
    }

    /**
     * 激活裁剪状态
     * @param {WebGL2RenderingContext} gl 渲染上下文
     */
    active(gl){
        if(this._enable){
            gl.enable(gl.SCISSOR_TEST);
            gl.scissor(this._scissorRange[0],this._scissorRange[1],this._scissorRange[2],this._scissorRange[3]);
        }else{
            gl.disable(gl.SCISSOR_TEST);
        }
    }
    
    /**
     * 设置裁剪状态是否开启。默认状态关闭。
     * @param {Boolean} enable 开启/关闭。状态开启设置true，状态关闭设置false。
     * @example
     * scissorStatus.setEnable(true);
     */
    setEnable(enable){
        if(typeof enable === "boolean"){
            this._enable = enable;
        }
    }

    /**
     * 获取裁剪状态是否开启
     * @returns {Boolean} 状态
     * @example
     * let enable = scissorStatus.getEnable();
     */
    getEnable(){
        return this._enable;
    }

    /**
     * 设置裁剪范围。默认裁剪范围为[0,0,0,0].
     * @param {Array} scissorRange 裁剪范围[x,y,width,height],每个分量都大于0。xy分别是裁剪框左下角的分量，width、height分别是裁剪框宽高。单位像素。
     * @example
     * scissorStatus.setScissorRange([100,100,600,400]);
     */
    setScissorRange(scissorRange){
        if(scissorRange instanceof Array && scissorRange.length==4 && scissorRange[0]>=0 && scissorRange[1]>=0 && scissorRange[2]>=0 && scissorRange[3]>=0){
            this._scissorRange = scissorRange;
        }
    }

    /**
     * 获取裁剪范围
     * @returns {Array} 裁剪范围，同setScissorRange接口解释
     * @example
     * let scissorRange = scissorStatus.getScissorRange();
     */
    getScissorRange(){
        return this._scissorRange;
    }
}
;'use strict';
hmap.status = hmap.status || {};
/**
 * 多边形偏移状态
 * @private
 * @type {hmap.status.PolygonOffsetStatus}
 */
hmap.status.PolygonOffsetStatus = class {
	/**
     * 构造方法.
     * @example
     * let polygonOffsetStatus = new hmap.status.PolygonOffsetStatus();
     */
	constructor(){
		this._enable = false;
		this._polygonOffsetValue = [0.0,0.0];
	}

	/**
	 * 激活多边形偏移状态
	 * @param {WebGL2RenderingContext} gl 渲染上下文
	 */
	active(gl){
		if(this._enable){
			gl.enable(gl.POLYGON_OFFSET_FILL);
			gl.polygonOffset(this._polygonOffsetValue[0],this._polygonOffsetValue[1]);
		}else{
			gl.disable(gl.POLYGON_OFFSET_FILL);
		}
	}

	/**
	 * 设置多边形偏移状态是否开启。默认状态关闭。
	 * @param {Boolean} enable 开启/关闭。状态开启设置true，状态关闭设置false。
	 * @example
	 * polygonOffsetStatus.setEnable(true);
	 */
	setEnable(enable){
		if(typeof enable === "boolean"){
			this._enable = enable;
		}
	}

	/**
	 * 获取多边形偏移状态是否开启
	 * @returns {Boolean} 状态
	 * @example
	 * let enable = polygonOffsetStatus.getEnable();
	 */
	getEnable(){
		return this._enable;
	}

	/**
	 * 设置多边形偏移量。默认多边形偏移量为0。
	 * 指定加到每个顶点绘制后z值上的偏移量，偏移量按照公式 m*factor+r*units计算。
	 * m是顶点所在表面相对于观察者的视线角度；r是硬件能够区分两个z值之差的最小值。
	 * @param {Array} polygonOffsetValue 多边形偏移量系数,参数默认为[0,0].
	 * @example
	 * polygonOffsetStatus.setPolygonOffsetValue([1.0,1.0]);
	 */
	setPolygonOffsetValue(polygonOffsetValue){
		if(polygonOffsetValue instanceof Array && polygonOffsetValue.length==2){
			this._polygonOffsetValue = polygonOffsetValue;
		}
	}

	/**
	 * 获取多边形偏移量系数
	 * @returns {Array} 多边形偏移量系数
	 * @example
	 * let polygonOffsetValue = polygonOffsetStatus.getPolygonOffsetValue();
	 */
	getPolygonOffsetValue(){
		return this._polygonOffsetValue;
	}
}
;'use strict';
hmap.status = hmap.status || {};
/**
 * 管理图层状态的状态管理器，管理的状态包括：深度测试、颜色混合、正背面剔除、多边形偏移、渲染窗口裁剪。
 * @private
 * @type {hmap.status.GLStatusManager}
 */
hmap.status.GLStatusManager = class {
	/**
     * 构造方法.
     * @example
     * let glStatusManager = new hmap.status.GLStatusManager();
     */
	constructor(){
        this._depthStatus = new hmap.status.DepthStatus();
        this._blendStatus = new hmap.status.BlendStatus();
        this._cullFaceStatus = new hmap.status.CullFaceStatus();
        this._polygonOffsetStatus = new hmap.status.PolygonOffsetStatus();
        this._scissorStatus = new hmap.status.ScissorStatus();
	}

	/**
	 * 激活状态管理器管理的每种状态
	 * @param {WebGL2RenderingContext} gl 渲染上下文
	 */
	activeStatusManager(gl){
        this._depthStatus.active(gl);
        this._blendStatus.active(gl);
        this._cullFaceStatus.active(gl);
        this._polygonOffsetStatus.active(gl);
        this._scissorStatus.active(gl);
	}

	/**
	 * 获取深度测试状态
	 * @returns {hmap.status.DepthStatus} 深度测试状态
	 * @example
	 * let depthStatus = glStatusManager.getDepthStatus();
	 */
	getDepthStatus(){
		return this._depthStatus;
	}

	/**
	 * 获取颜色混合状态
	 * @returns {hmap.status.BlendStatus} 颜色混合状态对象
	 * @example
	 * let blendStatus = glStatusManager.getBlendStatus();
	 */
	getBlendStatus(){
		return this._blendStatus;
	}

	/**
	 * 获取剔除状态
	 * @returns {hmap.status.CullFaceStatus} 剔除状态对象
	 * @example
	 * let cullFaceStatus = glStatusManager.getCullFaceStatus();
	 */
	getCullFaceStatus(){
		return this._cullFaceStatus;
	}

	/**
	 * 获取多边形偏移状态
	 * @returns {hmap.status.PolygonOffsetStatus} 多边形偏移状态对象
	 * @example
	 * let polygonOffsetStatus = glStatusManager.getPolygonOffsetStatus();
	 */
	getPolygonOffsetStatus(){
		return this._polygonOffsetStatus;
	}

	/**
	 * 获取裁剪状态
	 * @returns {hmap.status.ScissorStatus} 裁剪状态对象
	 * @example
	 * let scissorStatus = glStatusManager.getScissorStatus();
	 */
	getScissorStatus(){
		return this._scissorStatus;
	}
}
;"use strict";
hmap.feature = hmap.feature || {};
/**
 * 矢量地理要素类。矢量在数学上定义为由点组成的几何图形。由这种几何图形再加上样式，用以表达地表系统中某一实际物体的数据结构，称为矢量地理要素。
 * @type {hmap.feature.Vector}
 * @example
 * let coord = new hmap.basetype.Coordinate(120,30,0);
 * let point = new hmap.geom.Point(coord);
 * let style = hmap.style.Style.getDefault();
 * let feature = new hmap.feature.Vector(point,{name:'摄像头', id:205},style);
 */
hmap.feature.Vector = class {
    /**
     * 地理要素类
     * @param {hmap.geom.Geometry} geometry 地理几何体
     * @param {Object} attributes 一个对象，用来描述地理要素的非空间属性
     * @param {hmap.style.Style} style 用来描述地理要素在地图上表现形态。当添加到图层上时，如果不指定样式，则采用默认的图层样式
     */
    constructor(geometry, attributes, style) {
        if (!(geometry instanceof hmap.geom.Geometry)) {
            return;
        }
        if (geometry.hasOwnProperty("_enableToPolygon")) {
            geometry = geometry.toPolygon();
        }
        this._geometry = geometry;
        if (attributes) {
            this._attributes = attributes;
        }
        if (style) {
            this.setStyle(style);//设置样式
        }
        this._styleFunction = undefined;
        this._visible = true;
        this._selected = false;//标识该要素是否被选中
        // this._layer = null;//当前地理要素所在的图层，在未与图层挂接前为空。
        this.CLASS_NAME = "hmap.feature.Vector";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._bbox = this.getBBox();
        this._painterType = hmap.core.painterType.NONE;
    }

    /**
     * @private
     */
    get id(){
        return this._id;
    }

    /**
     * 获取系统保留的唯一标识
     * @return {string} 唯一标识
     * @example
     * let fid = feature.getFid();
     */
    getFid() {
        return this._id;
    }

    /**
     * 设置地理要素的唯一标识
     * @param {String} id 唯一标识
     * @example
     * feature.setFid("feature0");
     */
    setFid(id) {
        this._id = id;
    }

    /**
     * 获取根据geometry和style获取painter类型,在addFeature()中使用，避免初始化调用
     * @private
     */
    updatePainterType(sync = true) {
        let painterType = hmap.core.painterType.NONE;
        if (!this._style) return;
        let geo = this.getBasicGeometry();
        switch (geo.getType()) {
            case hmap.geom.GeometryType.Point:          //点，只有一种绘制类型
            case hmap.geom.GeometryType.MultiPoint:
                const sprite = (this._style.getMarkerSymbols()[0] && this._style.getMarkerSymbols()[0].sprite) || (this._style.getTextSymbols()[0] && this._style.getTextSymbols()[0].sprite);
                painterType = sprite ? hmap.core.painterType.SPRITEPOINT : hmap.core.painterType.POINT;
                break;
            case hmap.geom.GeometryType.Line:           //线，有四种，宽线和细线，以及实线和虚线
            case hmap.geom.GeometryType.LinearRing:
            case hmap.geom.GeometryType.MultiLine:
                const lineSymbol = this._style.getLineSymbols()[0];
                if (lineSymbol.getWidth() > 1) {
                    painterType = hmap.core.painterType.LINE_WIDTH;
                } else {
                    painterType = hmap.core.painterType.LINE;
                }
                //虚线
                if (lineSymbol.getLineStyle() !== 'solid') {
                    painterType += "Dash";
                }
                break;
            case hmap.geom.GeometryType.Polygon:        //面，有三种，普通面，宽边框面，纹理面
            case hmap.geom.GeometryType.MultiPolygon:
            case hmap.geom.GeometryType.Circle:
            case hmap.geom.GeometryType.Rectangle:
            case hmap.geom.GeometryType.Triangle:
                const fillSymbol = this._style.getFillSymbols()[0];
                if (fillSymbol instanceof hmap.style.TextureFill) {
                    painterType = hmap.core.painterType.POLYGON_TEXTURE;
                } else {
                    const lineSymbol = this._style.getLineSymbols()[0];
                    painterType = (lineSymbol && lineSymbol.getWidth() > 1) ?
                        hmap.core.painterType.POLYGON_BORDER : hmap.core.painterType.POLYGON;
                }
                break;
        }
        if (sync) this._painterType = painterType;
        return painterType;
    }

    getPainterType() {
        return this._painterType;
    }

    /**
     * 根据传入的style对象或style对象数组或返回style数组的函数，来构造成一个styleFunction，即样式函数。（该接口暂不启用）
     * @param obj 单个style对象或style对象数组或返回style数组的函数
     * @return {Function} 样式函数
     * @example
     *函数传入
     let fun = function(){
            let style1 = hmap.style.Style.getDefault();
            let style2 = hmap.style.Style.getDefault();
            return [style1,style2];
        };
     let styleFunc = hmap.feature.Vector.createStyleFunction(fun);
     *传入数组
     let style1 = hmap.style.Style.getDefault();
     let style2 = hmap.style.Style.getDefault();
     let styleFunc2 = hmap.feature.Vector.createStyleFunction([style1,style2]);
     *传入单个style
     let style = hmap.style.Style.getDefault();
     let styleFunc3 = hmap.feature.Vector.createStyleFunction(style);
     */
    static createStyleFunction(obj) {
        let styleFunction;
        if (typeof obj === "function") {
            if (obj.length === 2) {
                styleFunction = function (resolution) {
                    return (obj)(this, resolution);
                };
            } else {
                styleFunction = obj;
            }
        } else {
            let styles;
            if (Array.isArray(obj)) {
                styles = obj;
            } else if (obj instanceof hmap.style.Style) {
                styles = [obj];
            }
            styleFunction = function () {
                return styles;
            };
        }
        return styleFunction;
    }

    //要素显示范围到多边形的距离
    displayDistanceToPolygon(camera, polygon) {
        const geom = this.getBasicGeometry();
        const geomType = geom.getType();
        let style = this.getStyle();
        // if (!style) {
        //     style = this.getLayer().getStyle();
        // }
        if (geomType === hmap.geom.GeometryType.Point) {
            return this._pointFeatureDistanceToPolygon(camera, geom, style, polygon);
        } else if (geomType === hmap.geom.GeometryType.MultiPoint) {
            let minDistance = Number.MAX_VALUE;
            for (const point of geom.getPoints()) {
                const pointDistance = this._pointFeatureDistanceToPolygon(camera, point, style, polygon);
                if (pointDistance < minDistance) {
                    minDistance = pointDistance;
                }
            }
            return minDistance;
        } else if (geomType === hmap.geom.GeometryType.Line || geomType === hmap.geom.GeometryType.MultiLine) {
            return this._lineFeatureDistanceToPolygon(camera, geom, style, polygon);
        }
        return geom.distanceTo(polygon, {details: false, edge: false});
    }

    getBasicGeometry() {
        const geom = this.getGeometry();
        const geomType = geom.getType();
        // 基础几何类型不作处理，直接返回，扩展几何类型先转换为基础几何类型
        switch (geomType) {
            case hmap.geom.GeometryExtType.POLYLINE.ARC:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE2:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE3:
            case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVEN:
            case hmap.geom.GeometryExtType.POLYLINE.CARDINAL_CURVE:
                return geom.toLine();
            case hmap.geom.GeometryExtType.POLYGON.RECTANGLE:
            case hmap.geom.GeometryExtType.POLYGON.LUNE:
            case hmap.geom.GeometryExtType.POLYGON.ROUNDED_RECT:
            case hmap.geom.GeometryExtType.POLYGON.CIRCLE:
            case hmap.geom.GeometryExtType.POLYGON.ELLIPSE:
            case hmap.geom.GeometryExtType.POLYGON.SECTOR:
            case hmap.geom.GeometryExtType.POLYGON.CLOSE_CURVE:
            case hmap.geom.GeometryExtType.POLYGON.GATHERING_PLACE:
            case hmap.geom.GeometryExtType.FLAG.RECT_FLAG:
            case hmap.geom.GeometryExtType.FLAG.TRIANGLE_FLAG:
            case hmap.geom.GeometryExtType.FLAG.CURVE_FLAG:
            case hmap.geom.GeometryExtType.ARROW.STRAIGHT_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DIAGONAL_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOUBLE_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOVETAIL_STRAIGHT_ARROW:
            case hmap.geom.GeometryExtType.ARROW.DOVETAIL_DIAGONAL_ARROW:
                return geom.toPolygon();
            case hmap.geom.GeometryExtType.LARROW.POLYLINE_ARROW:
            case hmap.geom.GeometryExtType.LARROW.BEZIER_CURVE_ARROW:
            case hmap.geom.GeometryExtType.LARROW.CARDINAL_CURVE_ARROW:
            case hmap.geom.GeometryExtType.LARROW.PARALLEL_SEARCH:
            case hmap.geom.GeometryExtType.LARROW.SECTOR_SEARCH:
                return geom.toMultiLine();
        }
        return geom;
    }

    _lineFeatureDistanceToPolygon(camera, geometry, style, polygon) {
        const lineSymbols = style.getLineSymbols();
        const distanceToLineCenter = this.getBasicGeometry().distanceTo(polygon, {details: false, edge: false});
        let maxLineWidth = 0;
        for (const lineSymbol of lineSymbols) {
            if (lineSymbol.getWidth() > maxLineWidth) {
                maxLineWidth = lineSymbol.getWidth();
            }
        }
        const distance = distanceToLineCenter - maxLineWidth / 2 * camera.getResolution();
        // const distance = distanceToLineCenter;
        return distance;
    }

    _pointTextSymbolDistanceToPolygon(camera, geometry, textSymbol, polygon) {
        // 本部分参考TextSymbol.getRenderData
        let text = textSymbol.getText().trim();
        if (text.indexOf("{") !== -1) {//判断是否需要从attri中获取字段
            let fieldName = text.substring(1, text.length - 1);
            text = feature.getAttributes()[fieldName].trim();
        }

        const textLength = text.length; // TODO:双字节UTF8处理
        const fontSize = textSymbol.getFontSize();
        let xOffset = textSymbol.getOffset().getValue("X");
        let yOffset = -textSymbol.getOffset().getValue("Y");
        const align = textSymbol.getTextAlign();
        const baseline = textSymbol.getTextBaseline();

        let words;
        let maxWordLengthLine;
        const firtLineMaxLength = 6;
        if (textLength <= firtLineMaxLength) {
            words = [text];
            maxWordLengthLine = textLength;
        } else {
            words = [text.substr(0, firtLineMaxLength), text.substring(firtLineMaxLength, textLength)];
            const secondLineLength = textLength - firtLineMaxLength;
            maxWordLengthLine = secondLineLength > firtLineMaxLength ? secondLineLength : firtLineMaxLength;
        }
        const tl = words.length;
        //计算水平方向的偏移
        if (align === "left") {
            xOffset = xOffset - maxWordLengthLine * fontSize;
        } else if (align === "right") {
        } else {
            xOffset = xOffset - maxWordLengthLine * fontSize / 2;
        }
        //计算垂直方向的偏移
        if (baseline === "top") {
            yOffset = yOffset - fontSize * tl;
        } else if (baseline === "bottom") {
        } else {
            yOffset = yOffset - fontSize * (tl / 2);
        }
        // 左上角
        const xmin = xOffset;
        const ymin = yOffset;
        // 右下角
        const xmax = xmin + maxWordLengthLine * fontSize;
        const ymax = ymin + tl * fontSize;
        const coord = geometry.getCoordinate();
        const pixel = camera.getPixelFromCoordinate(coord);
        const textBoundingPolygon = this._getBoundingPolygon(camera, pixel.getX() + xmin, pixel.getY() + ymin, pixel.getX() + xmax, pixel.getY() + ymax);
        // this.getLayer().addFeature(new hmap.feature.Vector(textBoundingPolygon)); //测试
        return textBoundingPolygon.distanceTo(polygon, {details: false, edge: false});
    }

    _getBoundingPolygon(camera, xMin, yMin, xMax, yMax) {
        const upperLeftPixel = new hmap.basetype.Pixel(xMin, yMin);
        const upperRightPixel = new hmap.basetype.Pixel(xMax, yMin);
        const lowerLeftPixel = new hmap.basetype.Pixel(xMin, yMax);
        const lowerRightPixel = new hmap.basetype.Pixel(xMax, yMax);
        const upperLeftCoord = camera.getCoordinateFromPixel(upperLeftPixel);
        const upperRightCoord = camera.getCoordinateFromPixel(upperRightPixel);
        const lowerLeftCoord = camera.getCoordinateFromPixel(lowerLeftPixel);
        const lowerRightCoord = camera.getCoordinateFromPixel(lowerRightPixel);
        const linearRing = new hmap.geom.LinearRing([
            new hmap.geom.Point(lowerLeftCoord),
            new hmap.geom.Point(lowerRightCoord),
            new hmap.geom.Point(upperRightCoord),
            new hmap.geom.Point(upperLeftCoord),
            new hmap.geom.Point(lowerLeftCoord)
        ]);
        return new hmap.geom.Polygon([linearRing]);
    }

    _pointMarkerSymbolDistanceToPolygon(camera, geometry, markerSymbol, polygon) {
        let markerPolygon;
        if (markerSymbol instanceof hmap.style.Icon || markerSymbol instanceof hmap.style.IconFont) {
            let width, height;
            if (markerSymbol instanceof hmap.style.Icon) {
                const size = markerSymbol.getSize();
                width = size.getWidth();
                height = size.getHeight();
            } else {
                const size = markerSymbol.getFontSize();
                width = size;
                height = size;
            }
            const offset = markerSymbol.getOffset();
            const anchor = markerSymbol.getAnchor();
            const xOffset = (0.5 - anchor[0]) * width + offset.getValue("X");
            const yOffset = (0.5 - anchor[1]) * height + offset.getValue("Y");
            let pixel = camera.getPixelFromCoordinate(geometry.getCoordinate());
            pixel = new hmap.basetype.Pixel(pixel.getX() + xOffset, pixel.getY() + yOffset);

            markerPolygon = this._getBoundingPolygon(camera, pixel.getX() - width / 2, pixel.getY() - height / 2, pixel.getX() + width / 2, pixel.getY() + height / 2);
            // this.getLayer().addFeature(new hmap.feature.Vector(markerPolygon)); //测试
        } else if (markerSymbol instanceof hmap.style.Circle) {
            const radius = markerSymbol._radius;
            const xOffset = markerSymbol.getOffset().getValue("X");
            const yOffset = markerSymbol.getOffset().getValue("Y");
            let pixel = camera.getPixelFromCoordinate(geometry.getCoordinate());
            pixel = new hmap.basetype.Pixel(pixel.getX() + xOffset, pixel.getY() + yOffset);

            // 创建16边形，接近圆形
            const pointCount = 16;
            const angleStep = Math.PI * 2 / pointCount;
            const edgePoints = [];
            for (let i = 0; i < pointCount; i++) {
                const angle = angleStep * i;
                const edgePixel = new hmap.basetype.Pixel(pixel.getX() + radius * Math.cos(angle),
                    pixel.getY() + radius * Math.sin(angle));
                const edgeCoord = camera.getCoordinateFromPixel(edgePixel);
                edgePoints.push(new hmap.geom.Point(edgeCoord));
            }
            const linearRing = new hmap.geom.LinearRing(edgePoints);
            markerPolygon = new hmap.geom.Polygon([linearRing]);
        }
        if (!markerPolygon) {
            markerPolygon = this.getGeometry();
        }
        return markerPolygon.distanceTo(polygon, {details: false, edge: false})
    }

    _pointFeatureDistanceToPolygon(camera, geometry, style, polygon) {
        const markerSymbols = style.getMarkerSymbols();
        let minMarkerDistance;
        if (markerSymbols.length > 0) {
            const markerSymbol = markerSymbols[0]; //取最下方的symbol计算大小
            minMarkerDistance = this._pointMarkerSymbolDistanceToPolygon(camera, geometry, markerSymbol, polygon);
        }
        const textSymbols = style.getTextSymbols();
        let minTextDistance = Number.MAX_VALUE;
        for (const textSymbol of textSymbols) {
            const textDistance = this._pointTextSymbolDistanceToPolygon(camera, geometry, textSymbol, polygon);
            if (textDistance < minTextDistance) {
                minTextDistance = textDistance;
            }
        }
        return minMarkerDistance < minTextDistance ? minMarkerDistance : minTextDistance;
    }

    /**
     * @private
     */
    // setLayer(layer) {
    //     if (layer instanceof hmap.layer.VectorLayer) {
    //         this._layer = layer;
    //     }
    // }

    /**
     * 获取矢量要素所在的图层。前提是该要素已被添加到矢量图层上。
     * @return {hmap.layer.Vector} 图层。
     * @example
     * let vectorLayer = new hmap.layer.Vector("矢量图层");
     * feature.setLayer(vectorLayer);
     * let result = feature.getLayer();//result=new hmap.layer.Vector("矢量图层")
     */
    // getLayer() {
    //     return this._layer;
    // }

    /**
     * 获取要素中的几何体
     * @return {hmap.geom.Geometry} 几何体对象
     * @example
     * let result = feature.getGeometry();
     * //result=new hmap.geom.Point(new hmap.basetype.Coordinate(120,30,0))
     */
    getGeometry() {
        return this._geometry;
    }

    /**
     * 获取当前要素的属性。
     * @return {JSON} 当前要素的属性信息
     * @example
     * let result = feature.getAttributes();//result={name:'摄像头', id:205}
     */
    getAttributes() {
        return this._attributes;
    }

    /**
     * 获取当前要素的样式
     * @return {hmap.style.Style} 样式
     * @example
     * let style = feature.getStyle();
     */
    getStyle() {
        return this._style;
    }

    /**
     * 重新设置地理要素的几何体。
     * @param {hmap.geom.Geometry} geom 几何体对象
     * @example
     * let coord = new hmap.basetype.Coordinate(122,32,0);
     * let point = new hmap.geom.Point(coord);
     * feature.setGeometry(point);
     * let result = feature;
     * //以下的point、style就是上面给出的变量值
     * //result=new hmap.feature.Vector(point,{},style)
     */
    setGeometry(geom) {
        if (geom instanceof hmap.geom.Geometry) {
            this._geometry = geom;
            this._bbox = this.getBBox();
        } else
            throw new TypeError("The parameter is not a Geometry .");
    }

    /**
     * 设置地理要素的非空间属性。注意:如果地理要素中的非空间属性与传入参数的重复,则已有属性的值将会被改变.否则该方法会向地理要素中加入新的属性.
     * @param {JSON} attributes 要设置的属性
     * @example
     * feature.setAttributes({name:'卡口', age:14});
     * let result = feature.getAttributes();
     * //result={name: "卡口", age: 14}
     */
    setAttributes(attributes) {
        this._attributes = attributes;
    }

    /**
     * 重新设置地理要素的样式.
     * @param {hmap.style.Style} style 样式
     * @example
     * let style = new hmap.style.Style();
     * feature.setStyle(style);
     */
    setStyle(style) {
        if (style instanceof hmap.style.Style || style == null) {//是Style实例或null
            this._style = style;
            this._styleFunction = !style ? undefined : hmap.feature.Vector.createStyleFunction(style);
            // this.updatePainterType();
        } else {
            throw "The parameter style is neither an instance of Style nor null";
        }
    }

    /**
     * 判断参数styles是否为合法的style数组
     * @private
     * @param styles
     * @returns {Boolean}
     */
    _validateStyleArr(styles) {
        if (Array.isArray(styles)) {
            let flag = true;
            for (let i = 0; i < styles.length; i++) {
                if (!(styles[i] instanceof hmap.style.Style)) {
                    flag = false;
                }
            }
            return flag;
        } else {
            return false;
        }
    }

    /**
     * 获取当前地理要素的可见性
     * @return {Boolean} true表示可见，false表示不可见。
     * @example
     * let visible = feature.getVisibility();
     */
    getVisibility() {
        return this._visible;
    }

    /**
     * 设置在图层中可见性。可见性决定了当前地理要素是否在图层中显示。
     * @param  {Boolean}  flag  可见用true;不可见用false。
     * @example
     * feature.setVisibility(true);
     */
    setVisibility(flag) {
        this._visible = flag;
    }

    /**
     * 获取要素的选中状态
     * @return {Boolean} 选中返回true;未选中返回false。
     * @example
     * let selected = feature.getSelected();
     */
    getSelected() {
        return this._selected;
    }

    /**
     * 设置地理要素的选中状态。
     * @param  {Boolean} selected 选中设置true;不选中设置false。
     * @throws 当参数selected既不是true,也不为false时，抛出参数类型异常。
     * @example
     * feature.setSelected(true);
     */
    setSelected(selected) {
        if (typeof (selected) === "boolean") {
            this._selected = selected;
        } else {
            throw new TypeError("The Parameter should be boolean type.");
        }
    }

    /**
     * 复制一个Feature，将得到的feature的地理范围中心变成传参的coordinate。该方法是以要素几何体的中心坐标到目标坐标为基准移动的，复制不影响原来的地理要素。
     * @param {hmap.basetype.Coordinate} coordinate 目标地理坐标。
     * @return {hmap.feature.Vector} 新地理要素
     * @example
     * let coordinate = new hmap.basetype.Coordinate(121,31,0);
     * let result = feature.copyTo(coordinate);
     * //result=new hmap.feature.Vector(
     * //             new hmap.geom.Point(new hmap.basetype.Coordinate(121,31,0)),
     * //             {name: "摄像头", id: 205},
     * //             hmap.style.Style.getDefault()
     * //)
     */
    copyTo(coordinate) {
        let geom = this.getGeometry().copyTo(coordinate);
        let attribs = this._copyAttrib(this._attributes);
        let style = this._style.clone();
        return new hmap.feature.Vector(geom, attribs, style);
    }

    // 对{}的深拷贝，Object.assign对{a:{b:c}},拷贝不纯粹
    _copyAttrib(attribs) {
        let newAttribs = {};
        for (let property in attribs) {
            newAttribs[property] = (typeof attribs[property] === "object") ? this._copyAttrib(attribs[property]) : attribs[property];
        }
        return newAttribs;
    }

    /**
     * 获取当前地理要素的地理范围
     * @return {hmap.basetype.Extent} 地理范围
     * @example
     * let result = feature.getExtent();
     * //result=new hmap.basetype.Extent(120,30,120,30)
     */
    getExtent() {
        return this.getGeometry().getExtent();
    }

    /**
     * 克隆方法
     * @return {hmap.feature.Vector} 新的地理要素
     * @example
     * let newFeature = feature.clone();
     */
    clone() {
        const attribute = {};
        Object.assign(attribute, this._attributes);
        let style = null;
        if (this.getStyle()) {
            style = this.getStyle().clone();
        }
        let vector = new hmap.feature.Vector(this.getGeometry().clone(), attribute, style);
        vector.setVisibility(this.getVisibility());
        return vector;
    }

    /**
     * 销毁要素内部所有属性
     * @example
     * feature.destroy();
     */
    destroy() {
        delete this._geometry;
        delete this._attributes;
        delete this._style;
        delete this._visible;
    }


    /**
     * 获取该矢量地理要素的三维包围盒。
     * @returns {hmap.basetype.BBox} 该矢量地理要素的三维包围盒。
     */
    getBBox() {
        return this._geometry.getBBox();
    }

    /**
     * 射线拾取
     * @param {hmap.strategy.Raycaster} ray 射线
     * @param {Number} tolerance
     * @param {hmap.Map} map
     * @private
     */
    intersectRay(ray, tolerance, map) {
        if (this._painterType === hmap.core.painterType.STRETCH) {
            return this._bbox.intersectRay(ray);
        }

        let geom = this.getGeometry();
        //由于样式存在offset（偏移），在拾取中需要等效进行处理，当前只处理第一个样式
        let geomOffset = [0, 0, 0];
        const resolotion = map.getResolution(map.getZoomWithInterval());
        switch (this._painterType) {
            case hmap.core.painterType.LINE:
            case hmap.core.painterType.LINE_DASH:
            case hmap.core.painterType.LINE_WIDTH:
            case hmap.core.painterType.LINE_WIDTH_DASH:
                const lOffset = this._style.getLineSymbols()[0].getLineOffset();
                if (lOffset instanceof hmap.basetype.Offset) {
                    geomOffset = [lOffset._x * resolotion, lOffset._y * resolotion, lOffset._z * resolotion];
                } else {
                    geomOffset = lOffset * resolotion;
                }
                break;
        }

        if (geom.getType() == hmap.geom.GeometryType.Point) {
            //根据图标样式进行坐标点偏移，使得坐标点位于图表中心（不改变原有左边位置）
            const symbol = this._style.getMarkerSymbols()[0];
            geomOffset = [0, 0, 0];//重置偏移，已经计算到等效几何体中
            if (symbol && symbol instanceof hmap.style.Icon) {
                //通过锚点和样式大小构造一个多边形
                const offset = symbol.getOffset();
                const size = symbol.getSize();
                const anchor = symbol.getAnchor();
                const pixel = map.getPixelFromCoordinate(geom.getCoordinate());
                //计算图标四个角组成的多边形
                const topLeft = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") - size.getWidth() * anchor[0],
                    pixel.getY() + offset.getValue("Y") - size.getHeight() * anchor[1]);
                const topRight = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") + size.getWidth() * (1 - anchor[0]),
                    pixel.getY() + offset.getValue("Y") - size.getHeight() * anchor[1]);
                const bottomLeft = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") - size.getWidth() * anchor[0],
                    pixel.getY() + offset.getValue("Y") + size.getHeight() * (1 - anchor[1]));
                const bottomRight = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") + size.getWidth() * (1 - anchor[0]),
                    pixel.getY() + offset.getValue("Y") + size.getHeight() * (1 - anchor[1]));

                geom = new hmap.geom.Polygon([new hmap.geom.LinearRing([
                    new hmap.geom.Point(map.getCoordinateFromPixel(topLeft)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(bottomLeft)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(bottomRight)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(topRight))
                ])]);
            } else if (symbol instanceof hmap.style.IconFont) {
                const size = symbol.getFontSize();
                const anchor = symbol.getAnchor();
                const offset = symbol.getOffset();
                const pixel = map.getPixelFromCoordinate(geom.getCoordinate());
                const bottomLeft = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") + size * 0.1 - size * anchor[0],
                    pixel.getY() + offset.getValue("Y") - size * anchor[1]);
                const bottomRight = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") - size * 0.1 - size * anchor[0] + size,
                    pixel.getY() + offset.getValue("Y") - size * anchor[1]);
                const topLeft = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") + size * 0.1 - size * anchor[0],
                    pixel.getY() + offset.getValue("Y") + size * (1 - anchor[1]));
                const topRight = new hmap.basetype.Pixel(pixel.getX() + offset.getValue("X") - size * 0.1 - size * anchor[0] + size,
                    pixel.getY() + offset.getValue("Y") + size * (1 - anchor[1]));

                geom = new hmap.geom.Polygon([new hmap.geom.LinearRing([
                    new hmap.geom.Point(map.getCoordinateFromPixel(topLeft)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(bottomLeft)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(bottomRight)),
                    new hmap.geom.Point(map.getCoordinateFromPixel(topRight))
                ])]);

            }
        }

        return geom.intersectRay(ray, tolerance, geomOffset);
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * @type {hmap.layer.Layer}
 */
hmap.layer.Layer = class extends hmap.status.GLStatusManager{
    /**
     * 该类是图层的顶级抽象类，可以被继承，但不能直接实例化,通过其子类实例化一个具体的图层对象。
     * 图层是由渲染系统、地理元素及一些特定的计算行为组成的数据表达机制，若干图层按顺序组合、叠加到地图容器中，把地球表面系统中的自然或人文特征概括性地表达出来。
     * 当图层被创建但未叠加到地图容器中时，是处于游离态的，图层中的地理元素可以参与逻辑运算，但不会被渲染；一旦叠加到地图上，图层的重绘行为即被触发，地理元素将被渲染到浏览器中。
     * 注意：图层坐标系与地图保持一致，是正确添加到地图上的必要条件；继承自本类的图层类必须重写redraw与setMap方法；不能在图层基类中注册图层事件。
     * @param options 可选项。包括属性：
     * @param options.enableHashCode {Boolean} 是否启用Hash编码，必须启用后才能进行要素拾取。默认为false。
     * @param options.crs {hmap.proj.Crs} 可选项，坐标系，默认为null。
     * @param options.isRTE {Boolean} 可选项。是否使用精度补偿。接收参数true|false，默认为false。如果设定为true会导致数据运算量增加，但层级较大时，渲染准确率高。
     * @param options.preserveDrawingBuffer {Boolean} 可选项。设置是否保存绘图缓冲区，默认为false，即默认不保存。
     * @param options.isLGD {Boolean} 可选项。设置是否对深度进行精度补偿的参数，默认值为true，即默认启用精度补偿
     * @param options.opacity {Number} 可选项。设置图层透明度，介于0~1之间，0表示完全透明，1表示完全不透明。默认为1.0，完全不透明。
     * @throws 当目标类型是hmap.layer.Layer时发生
     */
    constructor(options={}) {
        if (new.target === hmap.layer.Layer) {
            throw new Error("hmap.layer.Layer is abstract class,can not be instantiated!");
        }
        super();
        //图层容器
        this.container = null;
        this._map = null;
        //图层默认显示
        this._visibility = options.hasOwnProperty("visibility") ? options.visibility :true;
        this._crs = options.crs ? options.crs : null;
        this.CLASS_NAME = "hmap.layer.Layer";
        this._lock = false;
        this.enableHashCode =  false;//是否开启拾取
        this._isBaseLayer = false;//默认为非baselayer
        //是否对地理坐标进行精度补偿参数,默认为false
        this._isRTE = options.isRTE===true;
        //是否保存绘图缓冲区,默认为不保存,该参数当与map不共用GL上下文时起效
        this._preserveDrawingBuffer = options.preserveDrawingBuffer === true;
        //是否对深度进行精度补偿的参数,默认为true;
        this._isLGD = options.isLGD !== false;
        this._renderer = null;
        if (options.opacity!==undefined) {
            this._opacity = options.opacity;
        }else {
            this._opacity = 1.0;
        }
        this._layerContainer = null;
    }
    /**
     * 准备数据
     * @private
     */
    prepareData(){
    }
    /**
     * 获取该类是否为baseLayer图层，若为true，则为地图底图，若为false，则为地图叠加图层
     * @private
     * @return {Boolean} true或false
     * @example
     * let bsl = vectorLayer.isBaseLayer();
     */
    isBaseLayer() {
        return this._isBaseLayer;
    }

    /**
     * 返回该类的类型
     * @return {String} 返回地图类型
     * @example
     * modelLayer.getClassType()
     */
    getClassType() {
        return this.CLASS_NAME;
    }


    /**
     * 获取图层坐标系。
     * @returns {hmap.proj.Crs} 图层使用的坐标系
     */
    getCrs() {
        return this._crs;
    }

    /**
     * 设置图层坐标系
     * @param {hmap.proj.Crs} crs 坐标系对象
     */
    setCrs(crs) {
        if (crs && (crs instanceof hmap.proj.Crs)) {
            this._crs = crs;
        }
    }

    /**
     * 复制一个图层实例。
     */
    clone() {
    }

    /**
     * 销毁图层。
     */
    destroy() {
        delete this;
    }

    /**
     * 获取当前图层所在的地图
     * @returns {hmap.Map} 图层所属的地图对象
     */
    getMap() {
        return this._map;
    }

    /**
     * 返回唯一ID
     * @returns {String}
     * @private
    */
    getId() {
        return this._id;
    }

    /**
     * 获取图层名称
     * @returns {String} 图层名称
     */
    getName() {
        return this.name;
    }

    /**
     * 获取图层的可见性。
     * @return {Boolean} true表示可见，false表示不可见。
     */
    getVisibility() {
        return this._visibility;
    }

    /**
     * 获取图层不透明度
     * @returns {Number} 不透明度
     */
    getOpacity() {
        return this._opacity;
    }

    /**
     * 计算图层当前视窗的地理范围。
     * @returns {hmap.basetype.Extent}  地理范围,当图层未叠加到地图容器中时，该方法返回null。
     */
    getExtent() {
        if (!this.getMap()) {
            return null;
        }
        return this.getMap().getExtent();
    }

    /**
     * 获取图层的当前级别的分辨率
     * @returns {Number} 获取图层某一级别的分辨率
     */
    getResolution() {
        if (!this.getMap()) {
            return 0;
        }
        return this.getMap().getResolution();
    }

    /**
     * 计算屏幕像素坐标对应的地理坐标。
     * @param {hmap.basetype.Pixel} pixel 屏幕像素。
     * @returns {hmap.basetype.Coordinate} 地理坐标。因为像素是二维的，所以转换得到的地理坐标的高程分量为0.但是转换得到的地理坐标是准确值。
     * @throws 当图层未被添加到地图上时，则抛出异常。
     */
    getCoordinateFromPixel(pixel) {
        if (!this._map) {
            throw new ReferenceError("the layer has not been add to hmap.Map object!");
        }
        return this._map.getCoordinateFromPixel(pixel);
    }

    /**
     * 计算地理坐标对应的屏幕像素。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。因为像素必须是整数值，所以得到的像素坐标是近似值。近似值偏差和地理坐标所在当前的分辨率有关
     * @returns {hmap.basetype.Pixel} 屏幕像素
     * @throws 当图层未被添加到地图上时，则抛出异常。
     */
    getPixelFromCoordinate(coord) {
        if (!this._map) {
            throw  new ReferenceError("the layer has not been add to hmap.Map object!");
        }
        return this._map.getPixelFromCoordinate(coord);
    }

    /**
     * 获取子类图层类型（该方法暂未实现）。例：TMS图层的type为hmap.Layer.TMS
     * @returns {String} 图层类型名称
     */
    getLayerType() {

    }

    /**
     * 解除图层与地图的关联，即从图层去掉与地图对象有关的信息，同时在地图对象去掉与该图层有关的信息。关联解除后，图层依然存在，但与地图不再有关系。
     * 如果图层本身并未加载到地图上，那么该方法没有任何效果。
     *
     */
    offMap() {
        if (!this.getMap()) {
            return;
        }
        //TODO: 通知map对象
        this._map.removeLayer(this);
        this._map = null;
    }

    /**
     * 设置图层不透明度。
     * 0表示完全透明，1表示完全不透明。从0到1，越来越不透明。
     * @param {Number} opacity 图层透明度，介于0~1之间。
     * @throws 当图层的透明度值不是一个数值时发生
     */
    setOpacity(opacity = 1) {
        if (Number.isNaN(opacity)) {
            throw new TypeError("opacity must be instance of Number!");
        }

        if (opacity >= 1) {
            this._opacity = 1.0;
        } else if (opacity <= 0) {
            this._opacity = 0.0;
        } else {
            this._opacity = opacity;
        }

        this.redraw();
    }

    /**
     * 设置图层的可见性。
     * 仅设置该图层是否可见，而图层本身依然存在。
     * @param {Boolean} visible 是否可见
     * @throws 当参数不是布尔类型时,抛出异常
     */
    setVisibility(visible = true) {
        if (!(typeof (visible) === "boolean")) {
            throw new TypeError("visible must be boolean type!");
        }
        if (this._visibility !== visible) {
            this._visibility = visible;
        }

        this.redraw();
    }

    /**
     * 设置当前图层所属的地图。
     * 由于子类的渲染机制不同，在上图的时候，需要的dom类型也不相同，故应放在子类实现
     * @private
     * @param {hmap.Map} map 地图对象
     */
    setMap(map) {
        if (!(map instanceof hmap.Map)) {
            throw new TypeError("map must be instance of hmap.Map!");
        }
        this.event = map.event;
        this._map = map;
        const layerContainer = this.getLayerContainer();
        this.container = layerContainer.getContainer();
        this.gl = layerContainer.getContext();
    }

    /**
     * 射线相交拾取
     * @param {hmap.strategy.Raycaster} ray Raycaster对象
     * @private
     */
    raycasterIntersect(ray) {
        if (this.enableHashCode) {
            return this.layerOctree.raycast(ray);
        }
    }

    /**
     * 设置图层名称
     * @param {String} name 图层名称
     */
    setName(name) {
        if (!(typeof (name) === "string")) {
            throw "name must be string type!";
        }
        this.name = name;
    }

    /**
     * 获取当前图层的webgl上下文
     * @returns {object} webgl2.0的上下文
     */
    getWebglContext() {
        return this.gl;
    }

    /**
     * =======================特意增加的=============================
     * @private
     */
    getGlTexture(gl, img) {
        // let img=new Image();
        // img.src="img/worldMask.jpg";
        let texture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
            new Uint8Array([255, 255, 255, 255]));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.generateMipmap(gl.TEXTURE_2D);
        // img.onload=function () {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        // };

        return {
            texture: texture,
            unit: 0
        };

    }

    _checkLost() {
        let me = this;
        me.container.addEventListener('webglcontextlost', me._handleContextLost, false);
        me.container.addEventListener('webglcontextrestored', me._handleContextRestored.bind(this), false);
    }

    _handleContextLost(ev) {
        ev.preventDefault();
        cancelAnimationFrame(this.animateId);
    }

    /**
     * 处理恢复上下文事件
     * 注：当资源有余时才会触发恢复，恢复后需要重新设置相关绘制项。注释代码是以filledCircle举例
     * @private
     */
    _handleContextRestored() {
        this.redraw();
    }

    /**
     * 对视点坐标进行精度拆分(迁移到Renderer中处理)
     * @private
     */
    _splitCameraPrecision(unit="degrees") {
        const coord = this.getMap().getCamera().getCoordinate();
        const x = coord.getOrdinate("X"), y = coord.getOrdinate("Y"), z = coord.getOrdinate("Z");
        const xx=hmap.util.Correction.float32FromDouble64(x,unit),yy=hmap.util.Correction.float32FromDouble64(y,unit),zz=hmap.util.Correction.float32FromDouble64(z,unit);
        // const xx = this._float32FromDouble64(x), yy = this._float32FromDouble64(y), zz = this._float32FromDouble64(z);
        const splitPrecision = {
            chx: xx[0],
            clx: xx[1],
            chy: yy[0],
            cly: yy[1],
            chz: zz[0],
            clz: zz[1]
        };
        return splitPrecision;
    }

    /**
     * 个使用两个 32bit 浮点数来表示一个 64bit 浮点数
     * @private
     * @param num 传入的浮点型数字(迁移到renderer中处理) 注:迁移到renderer中处理,同时在renderer中添加坐标系属性
     */
    _float32FromDouble64(num) {
        let high = 0, low = 0, tempHigh = 0;
        if (this.getMap().getCrs().getUnit() === "degrees") {
            high = Math.floor(num);
            low = (num - high) * Math.pow(10, 7);
            low = Math.floor(low);
        } else {
            if (num > 0) {
                tempHigh = Math.floor(num / 65536) * 65536;
                high = tempHigh;
                low = num - tempHigh;
            } else {
                tempHigh = Math.floor(-num / 65536) * 65536;
                high = -tempHigh;
                low = num + tempHigh
            }
        }
        return [high, low];
    }

    /**
     * 重绘图层，效果和redraw相同。为了兼容老的版本，暂时保留。hmap2.2中删除该方法。
     * @private
     */
    refresh() {
        this.redraw();
    }

    /**
     * 重新绘制图层
     */
    redraw(type=1){
        if(this._layerContainer) {
            this._layerContainer.redraw(type);
        }
    }
    draw(){
        this.activeStatusManager(this.gl);
    }

    /**
     * 设置图层在图层容器中的图层顺序。
     * @param zIndex {Number} 图层的zIndex,值越大，图层越靠近上方。但是该值改变不了图层容器的上下顺序。
     */
    setZIndex(zIndex){
        this._zIndex = zIndex;
        if(this._layerContainer){
            this._layerContainer.orderLayerByIndex();
            this.redraw();
        }
    }

    /**
     * 返回图层的zIndex值
     * @returns {Number} 图层的zIndex
     */
    getZIndex(){
        return this._zIndex;
    }

    /**
     * 设置容器的zIndex
     * @param zIndex {Number} 控制上下顺序的索引值
     */
    setContainerZIndex(zIndex){
        this.container.style.zIndex = zIndex;
    }

    /**
     * 返回图层容器的zIndex
     * @returns {Number}
     */
    getContainerZIndex(){
        return parseFloat(this.container.style.zIndex);
    }

    /**
     * 返回图层使用的图层容器对象
     * @returns {null|*} 图层容器对象
     * @private
     */
    getLayerContainer(){
        return this._layerContainer;
    }

    /**
     * 设置图层使用的图层容器
     * @param layerContainer {hmap.LayerContainer} 图层容器对象
     * @private
     */
    setLayerContainer(layerContainer){
        this._layerContainer = layerContainer;
    }

    /**
     * painter中extra属性和layer的属性相结合
     * @param o1
     * @param o2
     * @param t
     * @private
     */
    _mergeExtra(o1, o2, t = {}) {
        Object.assign(t, o1, o2);
        return t;
    }

    _layerExtra(o = {}) {
        //精度纠正
        if (this._isRTE) {
            const precison = this._map._crs.getUnit() === "degrees" ? "precisionCorrect" : "precisionCorrectProject";
            o[precison] = 0;
        }
        //雾化

        //...
        return o;
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 注意：该类及类以下的所有接口暂不开放，谨慎使用
 *
 * 网格式图层的基类。所谓网格式图层，就是把地理范围划分成众多规则的单元格网，每一格网中囊括一部分地理数据。当请求方发起访问时，地理数据以分块的方式响应并渲染。
 * 一般情况下，在所有比例级别下，每个单元格网的大小是相同的，但不同比例级别下的网格地理数据的丰富程度不同。
 * @type {hmap.layer.GridLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.GridLayer = class extends hmap.layer.Layer {
    /**
     * 构造函数
     * @param {String} name    图层名称
     * @param {String} url     图层地址
     * @param {Object} options 自定义的额外属性键值对
     * @param {Array} options.serverResolutions 服务端切片的分辨率数组
     * @param {hmap.basetype.Coordinate} options.matrixOrigin 切片矩阵的原点坐标，也叫切片原点
     * @param {hmap.basetype.Size} options.gridSize 网格大小，即切片的大小
     * @param {String} options.dataFormat 切片格式，默认为‘png’
     */
    constructor(name, url, options={}) {
        super(options);
        this.name=name;
        this._oldTileBuffer = [];
        //瓦片集合，存储了要渲染的所有瓦片。 瓦片可以是矢量的，也可以是图片格式的。
        this._tileBuffer = [];
        //仅在grid模式下有效，存储地图视窗外围附近的瓦片。
        this._matrixOrigin = options.matrixOrigin ? options.matrixOrigin : null;
        this._matrixOriginCorner = options.matrixOriginCorner ? options.matrixOriginCorner : "tl";
        //图层变化前的瓦片缓存
        //this._resolution = 0;
        this._tileSize = options.gridSize ? options.gridSize : new hmap.basetype.Size(256, 256);
        this.layerUrl = url;
        this.dataFormat = options.dataFormat;
        this._program = null;
        this.CLASS_NAME="hmap.layer.GridLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        //vaoBook使用，目前仅矢量切片使用
        this._vaoPoolCapacity=options.vaoPoolCapacity?options.vaoPoolCapacity:30;//vao池大小 10屏幕
        this._vaoToDeleteOnce=options.vaoToDeleteOnce?options.vaoToDeleteOnce:0.3;//vao池满后，删除多少
        this._tilesToDrawOnce=options.tilesToDrawOnce ? options.tilesToDrawOnce : 10;//每来多少张切片绘制一次
        this._lock=false;

        this.serverResolutions = options.serverResolutions?options.serverResolutions:null;
        this._groupSideLength = options.groupSideLength || 1;//一次绘制的tile结构
    }

    /**
     * 为图层配置地图.继承自本图层的子类图层一率使用WebGl进行渲染
     * @private
     */
    setMap(map) {
        const oneScreen=Math.ceil(map.getContainerHSpan() * map.getContainerVSpan() / (256 * 256));
        this._vaoPoolCapacity = Math.min(this._vaoPoolCapacity * oneScreen, 8000);
        this._vaoToDeleteOnce = Math.floor(this._vaoPoolCapacity * this._vaoToDeleteOnce / Math.pow(this._groupSideLength, 2));
        this._vaoPoolCapacity = Math.ceil(this._vaoPoolCapacity / Math.pow(this._groupSideLength, 2));
        this.layerOctree = null;
        super.setMap(map);
        if(! this._matrixOrigin){
            this._matrixOrigin=map._crs._worldExtent.getTopLeft();
        }
    }

    /**
     * 获取单张瓦片的尺寸
     */
    getTileSize() {
        return this._tileSize;
    }

    /**
     * 设置网格大小 一般地，网格是一个正方形
     * @private
     * @param size Size
     */
    setTileSize(size) {
        if (size instanceof hmap.basetype.Size) {
            this._tileSize = size;
        } else {
            throw new Error("parameter is illegal!");
        }
    }
    /**
     * 给定一个坐标，返回该坐标所在网格的详细信息。
     * 返回结果是一个JSON对象，包括： 网格的地理范围，在屏幕中像素范围，网格行列编号。
     * 如果没有找到覆盖坐标参数的网格，返回null。
     * @param loc
     * @private
     */
    getTileInfo(loc) {
        if (!loc instanceof hmap.basetype.Coordinate) {
            throw new TypeError("the parameter loc is not a Coordinate instance");
        }
        //列号计算
        const minGeoPiexl = (loc.getOrdinate("X") - this._matrixOrigin.getOrdinate("X")) / this._map.getResolution(this._map.getZoom());
        const x = Math.floor(minGeoPiexl / this.getTileSize().getWidth());
        //行号计算
        const b = (this._matrixOrigin.getOrdinate("Y") - loc.getOrdinate("Y")) / this._map.getResolution(this._map.getZoom());
        const y = Math.floor(b / this.getTileSize().getWidth());
        //范围计算
        const ext = this.getTileExt(x, y);
        return {"row": y, "col": x, "geoExtent": ext};
    }
    /**
     * 计算瓦片标识
     * @private
     */
    setXYZ(z) {
        //因图层重绘的需要，清空tileBuffer内容,重新计算
        this._tileBuffer=[];
        // const z = this.getServerZoomByRes();//this.getMap().getZoom();
        z = z || this.getServerZoomByRes();
        const arrY = this.rangeRow(z);
        const arrX = this.rangeCol(z);
        //为X列Y行个瓦片配置标识
        for (let x = arrX.maxX-1; x>=arrX.minX; x--) {
            for (let y = arrY.maxY-1; y >=arrY.minY ; y--) {
                let tile = new Map();
                let {subXYZ} = this._getSubXYZ(x, y, z);
                tile.set("xyz", this._getXYZ(x,y,z));
                tile.set('subXYZ', subXYZ);
                this._tileBuffer[this._tileBuffer.length]=tile;
            }
        }
    }

    /**
     * 瓦片XYZ补充图层标识字符，防止纹理ID重复
     * @param x
     * @param y
     * @param z
     * @return {string}
     * @private
     */
    _getXYZ(x,y,z){
        return  x + "-" + y + "-" + z;
    }

    _getSubXYZ(groupX, groupY, z) {
        const subXYZ = [];
        const w = this._tileSize.getWidth(),
            h = this._tileSize.getHeight();
        for (let i = 0; i < this._groupSideLength; i++) {
            // const xOffset = i * this._groupSideLength * w;
            // const xOffset = (i + 1) / this._groupSideLength;
            const xOffset = i / this._groupSideLength;
            for (let j = 0; j < this._groupSideLength; j++) {
                // const yOffset = j * this._groupSideLength * h;
                const yOffset = j / this._groupSideLength;
                const sub = {
                    xyz: `${groupX * this._groupSideLength + i}-${groupY * this._groupSideLength + j}-${z}`,
                    url: '',
                    offset: [xOffset, yOffset],
                };
                subXYZ[subXYZ.length] = sub;
            }
        }

        return {subXYZ}
    }

    /**
     * 根据分辨率获取对应的服务端切片的级别
     * @private
     */
    getServerZoomByRes(){
        if(!this.serverResolutions){
            return this.getMap().getZoom();
        }else{
            const resolution = this.getServerResolutionByRes();
            return this.serverResolutions.indexOf(resolution);
        }
    }

    /**
     * 获取对应的服务端的分辨率
     * @private
     */
    getServerResolutionByRes(z){
        z = z || this._map.getZoom();
        let resolution = this.getMap().getResolution(z);
        let distance = Number.POSITIVE_INFINITY;

        if(this.serverResolutions && this.serverResolutions.indexOf(resolution) === -1) {
            let i, newDistance, newResolution, serverResolution;
            for(i=this.serverResolutions.length-1; i>= 0; i--) {
                newResolution = this.serverResolutions[i];
                newDistance = Math.abs(newResolution - resolution);
                if (newDistance > distance) {
                    break;
                }
                distance = newDistance;
                serverResolution = newResolution;
            }
            resolution = serverResolution;
        }
        return resolution;
    }
    /**
     * 计算行号范围 返回一个包含最大行号与最小行号的对象。
     * @private
     * @returns {{minY: number, maxY: number}}
     */
    rangeRow(z) {
        const resolution = this.getServerResolutionByRes(z);//this._map.getResolution();
        const ext = this.getMap().getExtent(), ordinateY = this._matrixOrigin.getOrdinate("Y");
        const h = this.getTileSize().getHeight() * this._groupSideLength;
        //最小行号
        const minGeoPiexl = (ordinateY - ext.getTop()) / resolution;
        const minY = Math.floor(minGeoPiexl / h);
        //最大行号
        const maxGeoPiexl = (ordinateY - ext.getBottom()) / resolution;
        const maxY = Math.ceil(maxGeoPiexl / h);
        return {"minY": minY, "maxY": maxY};
    }

    /**
     * 计算列号范围。 返回一个包含最大行号与最小行号的数组。
     * @private
     * @returns {{minX: number, maxX: number}}
     */
    rangeCol(z) {
        const ext = this.getMap().getExtent();
        const resolution=this.getServerResolutionByRes(z);//this._map.getResolution();
        const w = this.getTileSize().getWidth() * this._groupSideLength;
        //最小列号计算
        const spanMinGeoX = ext.getLeft() - this._matrixOrigin.getOrdinate("X");
        const minGeoPixel = spanMinGeoX / resolution;
        const minX = Math.floor(minGeoPixel / w);
        //------最大列号计算---------
        const spanMaxGeoX = ext.getRight() - this._matrixOrigin.getOrdinate("X");
        const maxGeoPixel = spanMaxGeoX / resolution;
        const maxX = Math.ceil(maxGeoPixel / w);
        //返回计算结果
        return {"minX": minX, "maxX": maxX};
    }


    /**
     * 补充一些附加信息
     * @private
     */
    addExterInfo() {
        const len = this._tileBuffer.length;
        for (let i = 0; i < len; i++) {
            let tile = this._tileBuffer[i];
            //设置瓦片数据格式
            const subTiles = tile.get('subXYZ');
            for (let j = 0, l = subTiles.length; j < l; j++) {
                const subTile = subTiles[j];
                const url = this.setTileUrl(subTile.xyz);//配置图层地址
                subTile.url = url;
            }
            if (!(this instanceof hmap.layer.VectorTileLayer)) {
                const ext = this.getTileGeoExt(tile);
                this._tileBuffer[i].set("ext", ext);
            }
        }
    }


    /**
     * 获取瓦片地理范围
     * @private
     * @param tile
     * @returns {*}
     */
    getTileGeoExt(tile) {
        const arr = tile.get("xyz").split("-");
        return this.getTileExt(arr[0] * 1, arr[1] * 1, arr[2] * 1, this._tileSize.getWidth() * this._groupSideLength, this._tileSize.getHeight() * this._groupSideLength);
    }

    /**
     * 计算单张瓦片的地理范围
     * @private
     * @param {int} row  行号
     * @param {int} col 列号
     * @returns {hmap.basetype.Extent}
     */
    getTileExt(col, row, z, tileWidth,tileHieght) {
        z = z || this._map.getZoom();
        tileWidth = tileWidth || this._tileSize.getWidth();
        tileHieght = tileHieght || this._tileSize.getHeight();
        //每张瓦片跨过的度数
        const tileSpanX = tileWidth * this._map.getResolution(z),
            tileSpanY = tileHieght * this._map.getResolution(z);
        const l = col * tileSpanX - Math.abs(this._matrixOrigin.getOrdinate("X")),
            r = (col * 1 + 1) * tileSpanX - Math.abs(this._matrixOrigin.getOrdinate("X"));

        const t = this._matrixOrigin.getOrdinate("Y") - row * tileSpanY,
            b = this._matrixOrigin.getOrdinate("Y") - (row * 1 + 1) * tileSpanY;
        return new hmap.basetype.Extent(l, b, r, t);
    }

    /**
     * 配置单张瓦片的像素范围，返回这个地理范围，对于已经添加到地图上的网格式图层，其瓦片在屏幕上表达的地理范围是确定的。
     * @private
     * @param {HashMap} tile 配置瓦片地理范围
     * @returns {Map}
     */
    getTilePixelExt(tile) {
        const arr = tile.get("xyz").split("-");//行列号标识
        const mapExt = this.getMap().getExtent(), tileExt = tile.get("ext");//当前地图瓦片的地理范围
        const l = (tileExt.getLeft() - mapExt.getLeft()) / this._map.getResolution();
        const t = (mapExt.getTop() - tileExt.getTop()) / this._map.getResolution();
        const r = l + this.getTileSize().getWidth(), b = t + this.getTileSize().getHeight();
        const e = new Map();
        e.set("l", l).set("t", t).set("r", r).set("b", b);
        tile.set("pixelExt", e);
        return tile;
    }

    /**
     * 图层服务地址layerURL与瓦片信息中的X,Y,Z拼接（该方法暂未实现）
     * 子类根据服务规则拼接URL。
     * @param {json} tile
     */
    setTileUrl(tile) {
        //子类实现
    }

    completeTileBuffer() {
        //定义单张瓦片请求成功的处理函数.
        let me = this,dataFormat=0;
        if(this.dataFormat==="png"){
            dataFormat="blob";
        }
        const len = this._tileBuffer.length;
        for (let i = 0; i < len; i++) {
            const img=new Image();
            img.src = this._tileBuffer[i].get("url");
            img.onload = function(){
                me._tileBuffer[i].set("data", img);
                let flag = true;
                for (let k = 0; k < len; k++) {
                    if (me._tileBuffer[k].get("data") === null) {
                        flag = false;
                    }
                }
                if (flag) {
                    me.drawGrid();
                }
            };
        }
    }


    /**
     * 将旧瓦片集合中的数据合并到新的瓦片集合中，以避免重复的数据请求，如果两个集合中有重复数据的话。
     * @private
     * @param tileKeys
     */
    _mergeTileData(tileKeys) {
        const oLen = this._oldTileBuffer.length;
        const nLen = this._tileBuffer.length;
        for (let i = 0; i < oLen; i++) {
            const oldTile = this._oldTileBuffer[i];
            const oldXYZ = oldTile.get("xyz");

            for (let k = 0; k < nLen; k++) {
                const newTile = this._tileBuffer[k];
                const newXYZ = newTile.get("xyz");
                if (newXYZ === oldXYZ) {
                    newTile.set(data, oldTile.get("data"));
                }
            }
        }
    }

    /**
     * 获取新旧瓦片集合中的差集，即将重绘的瓦片集合减去重绘前的瓦片集合
     * @private
     */
    _getDiffSet() {
        let oldKeys = new Set(), diffSet = new Set();
        for (let tile in this._oldTileBuffer) {
            oldKeys.add(tile.get("xyz"));
        }

        for (let tile of this._tileBuffer) {
            const newkey = tile.get("xyz");
            if (!oldKeys.has(newkey)) {
                diffSet.add(tile);
            }
        }
        return diffSet;
    }

    /**
     * 新旧瓦片集合交、差运算
     * @private
     */
    diffTileBuffer() {
        const diffTiles = new Set();
        //如果重绘前的缓冲区中与现有的缓冲区里有重复行列，则更新之，否则用新
        for (let i = 0; i < this._tileBuffer.length; i++) {
            const xyz = this._tileBuffer[i].get("xyz");
            for (let j = 0; j < this._oldTileBuffer.length; j++) {
                const oldTile = this._oldTileBuffer[j];
                //有相同的瓦片，则将旧的更新到新的瓦片集合
                if (oldTile.get("xyz") === xyz) {
                    tile.set("data", oldTile.get("data"));
                }
            }

        }
    }

};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * TMS瓦片地图服务。是tile map service的缩写，是一种瓦片地图服务，下文提到的切片等同于瓦片。TMS的算法思想是把投影后的世界地图按照层级进行四叉树切割，切割后的瓦片数量随层级指数式增长。
 * 第n级比例尺下的瓦片片数量是Math.pow(2,n)。如果缩放过程中出现图片模糊的情况，建议把地图创建时的参数zoomInterval设置为1。
 * @type {hmap.layer.TMSLayer}
 * @extends hmap.layer.GridLayer
 * @example
 * let matrixOrigin = new hmap.basetype.Coordinate(-180, 90);
 * let tmsOptions = {
        matrixOrigin: matrixOrigin,//切片原点
        dataFormat: "png"//切片格式
 * };
 * let tmsLayer = new hmap.layer.TMSLayer("TMS图层", "http://10.20.84.15:8080/GeoData/map/SpiritMap/vec/", tmsOptions);
 */
hmap.layer.TMSLayer = class extends hmap.layer.GridLayer {
    /**
     * 构造函数
     * @param {String} name 图层名称。
     * @param {String} layerUrl TMS服务地址
     * @param {Object} options 在图层上设置的附加属性。
     * @param {Array<Number>} options.resolutions 该图层上地图瓦片的分辨率
     * @param {Number} options.girdSize  瓦片大小。默认值是256像素大小
     * @param {Number} options.origin  切图原点。
     * @param {Boolean} options.isReverse 表示级别z值是否为逆序（降序），默认值为false，即正序（顺序），如果是逆序，该值需赋值为true。
     * @param {Number} options.zoomOffset 表示该图层的级别z相对于地图分辨率数组中的级别的偏移量，默认值为0。
     * @param {Boolean} options.visibility 表示该图层的可见性。默认值为true，即图层可见。
     */
    constructor(name, layerUrl, options={}){
        super(name, layerUrl, options);
        //计算layerUrl
        if(layerUrl.indexOf('{x}') === -1&&this instanceof hmap.layer.TMSLayer){//layerUrl中不包含{x},说明url是只包含z前面地址的url。
            this.layerUrl = layerUrl + "\/{z}\/{x}\/{y}." + this.dataFormat;
        }
        //包含{x} {y} {z}
        if(options.isReverse){//
            this.layerZFunc = function (mapZ,maxLevel) {
                let z = maxLevel - mapZ;
                if(options.zoomOffset){
                    z = z - options.zoomOffset;
                }
                return z;
            }
        }else {
            if (options.zoomOffset) {//存在且不为0
                this.layerZFunc = function (mapZ) {
                    return mapZ - options.zoomOffset;
                }
            }
        }

        this.CLASS_NAME="hmap.layer.TMSLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._resolutions = options.resolutions;
        //不传则为true。传true则为true，传false则为false
        this._isBaseLayer = options.isBaseLayer!==false;
        this.loadStatus=0;
        this._groupSideLength = 1;
        //切片缓存池
        this._cache = new Set();
        this._toDraw = new Set();
    }

    /**
     * 获取图层的baseLayer属性
     * @returns {Boolean} 返回图层是否是BaseLayer，true即为是，false为不是BaseLayer
     * @example
     * tmsLayer.isBaseLayer();
     */
    isBaseLayer(){
        return this._isBaseLayer;
    }

    /**
     * 获取图层的分辨率
     * @returns {Array<Number>} 返回图层的分辨率
     * @example
     * tms.getResolutions();
     */
    getResolutions(){
        return this._resolutions;
    }

    /**
     * 获取图层的类型
     * @returns {String} 返回图层的类型,该类中返回"hmap.layer.TMSLayer"字符串
     * @example
     * let layerType = tmsLayer.getClassType();
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 获取图层类型
     * @returns {String} 返回图层的类型
     * @example
     * let layerTypeName = hmap.layer.TMSLayer.getLayerType();
     */
    static getLayerType(){
        return "hmap.layer.TMSLayer";
    }


    /**
     * 已在map的addLayer中使用
     * 往地图上添加图层
     * @private
     */
    setMap(map){
        super.setMap(map);
        this.getDepthStatus().setEnable(false);
        this.maxLevel = this.getMap().getMaxZoom();

        const extra = this._layerExtra();
        this._painter = new hmap.core.painter.FillTexturePainter(this, this._mergeExtra(extra, {texture2D: 0}), {drawType: 'drawArrays'});
    }



    /**
     * 设置瓦片地址
     * @private
     */
    setTileUrl(xyz) {
        let [x, y, z] = xyz.split("-");//行列号标识
        if(this.layerZFunc) {
            z = this.layerZFunc(z, this.maxLevel);
        }
        return this.layerUrl.replace("{x}", x).replace("{y}", y).replace("{z}", z);

        // return  this.layerUrl+z+"\/" + x + "\/" + y +"."+this.dataFormat;
    }
    _initVtiles(){
        this._toDraw.clear();
        this.setXYZ();
        //为每个瓦片补充的信息
        this.addExterInfo();
        let len=this._tileBuffer.length;
        for(let i=0;i<len;i++){
            const tile = this._tileBuffer[i],
                xyz = tile.get("xyz");
            this._toDraw.add(xyz);
            if (this._cache.has(xyz)) {
                this._cache.delete(xyz);
            }
            else {
                tile.url = xyz;
                this._createTextureFill(tile);
                this._painter._add(tile);
                this._cache.add(xyz);
            }
            this._cache.add(xyz);
        }
        this._checkCacheSize();
    }

    /**
     * 设置标识，防止纹理ID重复
     * @param x
     * @param y
     * @param z
     * @return {string}
     * @private
     */
    _getXYZ(x, y, z) {
        return x + "-" + y + "-" + z + "-TMS";//补充图层标识，防止纹理id重复
    }

    _createTextureFill(tile) {
        const tiles = tile.get('subXYZ');
        for (let i = tiles.length - 1; i > -1; i--) {
            const tile = tiles[i],
                url = tile.url,
                texFill = new hmap.style.TextureFill(url, {
                    texture_wrap_s: 'CLAMP_TO_EDGE',
                    texture_wrap_t: 'CLAMP_TO_EDGE',
                    texture_mag_filter: 'NEAREST',
                    texture_min_filter: 'NEAREST',
                });
            tile.texFill = texFill;
        }
    }

    _checkCacheSize() {
        if (this._cache.size <= this._vaoPoolCapacity) {
            return;
        }

        let count = 0;
        for (let key of this._cache.keys()) {
            this._cache.delete(key);
            const block = this._painter.blocks.get(key);
            this._painter.removeBlock(block);
            this._painter.glHelper.removeTextureObject(key);
            count++;
            if (count === this._vaoToDeleteOnce) {
                break;
            }
        }
    }

    prepareData(){
        if(!this._map) return;
        this._initVtiles();
    }
    /**
     * 重新绘制当前图层中的所有内容。
     * @private
     */
   draw() {
        super.draw();

        this._painter.draw(this._toDraw);
    }

    /**
     * 设置透明度
     * @param opacity
     */
    setOpacity(opacity) {
        this._painter.opacity = opacity;
        super.setOpacity(opacity);
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 矢量要素图层，负责矢量要素表达的图层。
 * @type {hmap.layer.VectorLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.VectorLayer = class extends hmap.layer.Layer {
    /**
     * 构造一个矢量图层.
     * 注意：
     * 1、当报出“The size of Atlas is not enough”问题时：
     *       --说明矢量图层中存放图标和文字的*图集*不够用，即属性值atlasSize设置偏小；
     *       --建议选择256的倍数进行扩大atlasSize的值，默认值为256，最大值不超过2048。单位像素。
     * 2、当使用要素旋转功能、文字倾斜时，出现图标或文字被切角的情况时：
     *       --说明图集中存放的图标文字之间的间隔偏小，即属性值atlasSpace设置偏小；
     *       --atlasSpace默认值为1，最大值不能超过50。单位像素。
     * @param {String} name 图层名称
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @param {Boolean} options.visibility 可选项。设置图层的可见性，true表示图层可见，false表示图层不可见，若不传该参数，则默认图层可见。
     * @param {Number} options.opacity 可选项。设置图层的透明度，参数值可以为[0,1]区间内的任意值，数值越大，表示越不透明，其中0表示透明，1表示不透明。
     * @param {hmap.style.Style} options.style 可选项。设置该图层中要素的样式，若不传，则有默认样式。
     * @param {boolean} options.enableHashCode 可选项。对要素进行编码，从而进行要素拾取用的，默认该属性为true，若设为false，则无法进行要素拾取。
     * @param {boolean} options.isBaseLayer 可选项。设置图层是否为地图底图，若不传该参数，则默认为false，即默认为地图叠加层。
     * @param {Number} options.atlasSize 可选项。存放图标文字的图集canvas的大小。默认256。最大不能超过2048。单位像素。最大值都不够用的情况下，建议使用多个矢量图层来承载要素。
     * @param {Number} options.atlasSpace 可选项。图集上图标文字的间隔大小，默认值为1，最大不能超过50。单位像素。
     * @param {String} options.spriteUrl 可选项。雪碧图地址。雪碧图:即将多个小图标放在一张图片上。雪碧图可以使用spritezero-cli或其他工具生成。
     * @example
     * let options = {
     *  visibility:true,//可见性
     *  opacity:1, //透明度
     *  enableHashCode:true, //启用HashCode编码
     *  style:hmap.style.Style.getDefault()//设置图层样式
     *  atlasSpace: 10,//图集中每个要素的间隔
     *  atlasSize: 256,//存放要素的图集大小
     *  spriteUrl: './sprite/dark',
     * };
     * let vectorLayer = new hmap.layer.Vector("矢量图层",options);
     */
    constructor(name, options = {}) {
        super(options);
        this.CLASS_NAME = "hmap.layer.VectorLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.name = name;
        this._map = null;
        this._style = options.style || hmap.style.Style.getDefault();

        this._visibility = options.hasOwnProperty("visibility") ? options['visibility'] : true;
        //虚线一个单元像素数量，及实线占比
        this.pixelLength = options.pixelLength || 20;

        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : this.enableHashCode;
        this._isBaseLayer = options.isBaseLayer;
        options.atlasSize = options.atlasSize ? options.atlasSize : 256;//默认值是256
        if (options.atlasSize < 0 || options.atlasSize > 2048) throw new Error('The maximum value of "atlasSize" is 2048');
        options.atlasSpace = options.atlasSpace ? options.atlasSpace : 1;//图集绘制间隔
        this._atlasMgr = new hmap.strategy.AtlasManager(options.atlasSize,options.atlasSpace);
        if (options.spriteUrl) {
            this.enableSprite = true;
            this.sprite = new hmap.help.Sprite(options.spriteUrl);
        }
        this._painters = new Map();
        this._featuresToAdd = [];//未绑定地图时临时存储
    }

    get id() {
        return this._id;
    }

    get painters() {
        return this._painters;
    }

    /**
     * 将图层绑定到指定的map上
     * @private
     * @param {hmap.Map} map hmap的map对象
     * @example
     * vectorLayer.setMap(map); 功能和map.addLayer(vectorLayer)相同
     */
    setMap(map) {
        super.setMap(map);
        //添加地图单位属性,方便根据单位处理精度数据
        this.getDepthStatus().setEnable(false);

        //拾取相关，需要定义在painter实例之前
        if (this.enableHashCode) {
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }

        //图层extra
        const extra = this._layerExtra();
        //先添加的painter会优先绘制
        //纹理面
        const fillTexturePainter = new hmap.core.painter.FillTexturePainter(this, this._mergeExtra(extra, {texture2D: 0,offset: 0}));
        this._painters.set(hmap.core.painterType.POLYGON_TEXTURE, fillTexturePainter);

        //带宽边框的面
        const fillBorderPainter = new hmap.core.painter.FillBorderPainter(this, this._mergeExtra(extra, {offset: 0,colorI: 0}));
        this._painters.set(hmap.core.painterType.POLYGON_BORDER, fillBorderPainter);

        //普通面
        const fillPainter = new hmap.core.painter.FillPainter(this, this._mergeExtra(extra, {offset: 0, colorI: 0}));
        this._painters.set(hmap.core.painterType.POLYGON, fillPainter);

        // 宽线
        const wideLinePainter = new hmap.core.painter.LinePainter(this, this._mergeExtra(extra, {wideSolid: 0,colorI: 0,offset: 0 }));
        this._painters.set(hmap.core.painterType.LINE_WIDTH, wideLinePainter);

        // 虚线+宽线
        const dashWideLinePainter = new hmap.core.painter.LinePainter(this, this._mergeExtra(extra, {dash: 0,wideSolid: 0,colorI: 0,offset: 0}));
        this._painters.set(hmap.core.painterType.LINE_WIDTH_DASH, dashWideLinePainter);

        //细线
        const linePainter = new hmap.core.painter.LinePainter(this, this._mergeExtra(extra, {colorI: 0, offset: 0}));
        this._painters.set(hmap.core.painterType.LINE, linePainter);

        //细线+虚线
        const lineDashPainter = new hmap.core.painter.LinePainter(this, this._mergeExtra(extra, {colorI: 0,offset: 0,dash: 0}));
        this._painters.set(hmap.core.painterType.LINE_DASH, lineDashPainter);
        //拉伸体
        const stretchPainter = new hmap.core.painter.StretchPainter(this, this._mergeExtra(extra, {colorI: 0}));
        this._painters.set(hmap.core.painterType.STRETCH, stretchPainter);
        //点
        const symbolPainter = new hmap.core.painter.SymbolDynamicPainter(this, this._mergeExtra(extra, {
            offset: 1,
            sprite: 0,
            opacity: 0,
            dynamicText: 0,
        }), {"drawType": "drawArrays", "blockSize": 200,"atlasManager":this._atlasMgr});
        this._painters.set(hmap.core.painterType.POINT, symbolPainter);

        //雪碧图点
        if (this.enableSprite) {
            const staticSymbolPainter = new hmap.core.painter.SymbolStaticPainter(this, this._mergeExtra(extra, {offset: 0,sprite: 0,}), {"drawType": "drawArrays", "blockSize": 200});
            this._painters.set(hmap.core.painterType.SPRITEPOINT, staticSymbolPainter);
            this.sprite.request.then(() => {
                hmap.help.glHelper.get(this.gl).getTextureObject(this.sprite.url, 0).bufferImage(this.sprite.spriteImg);
            })
        }
        //临时存储数据恢复
        this.initStoredFeature();
    }

    initStoredFeature() {
        for (let f of this._featuresToAdd) {
            this.addFeature(f);
        }
        this._featuresToAdd = [];
    }


    /**
     * 返回该类的类型
     * @returns {String} 返回图层类型
     * @example
     * vectorLayer.getClassType()
     */
    getClassType() {
        return this.CLASS_NAME;
    }

    /**
     * 克隆一个图层
     * @returns {hmap.layer.Vector} 新的图层
     * @example
     * let newVectorLayer = vectorLayer.clone();
     */
    clone() {
        const cloneVector = new hmap.layer.VectorLayer(this.name, {
            visibility: this._visibility,
            opacity: this._opacity,
            style: this._style
        });
        return cloneVector;
    }


    /**
     * 获取图层类型
     * @returns {String} 图层类型
     * @example
     * let layerType = vectorLayer.getLayerType();
     */
    getLayerType() {
        return "hmap.layer.VectorLayer";
    }

    /**
     * 计算图层所有数据的地理边界，即这个边界范围内，包含该图层的所有要素，区别于图层的全球地理范围
     * @returns {hmap.basetype.Extent} 返回能包含所有要素的一个地理边界
     * @example
     * let dataExtent = vectorLayer.getDataExtent();
     */
    getDataExtent() {
        const features = this.getAllFeatures();
        if (features.length < 1) return null;
        let initExtent = features[0].getGeometry().getExtent();
        for (let i = features.length - 1; i > 0; i--) {
            const extentT = features[i].getGeometry().getExtent();
            initExtent = initExtent.extendExtent(extentT);
        }
        return initExtent;
    }

    /**
     * 获取一个地理要素
     * @param {String} fid 要素的fid编号
     * @returns {hmap.feature.Vector} id对应的地理要素。如果地理标识不存在，则返回undefined。
     * @example
     * let point = new hmap.geom.Point(new hmap.basetype.Coordinate(120.24,30.18,0.0));
     * let textSymbol=new hmap.style.TextSymbol({"text":"海康威视"});
     * let textStyle = new hmap.style.Style({"textSymbols":[textSymbol]});
     * let textfeature =new hmap.feature.Vector(point,{name:'摄像头', id:205},textStyle);
     * textfeature.setFid("textFeature0");
     * vectorLayer.addFeatures([textfeature]);
     * let feature = vectorLayer.getFeatureByFid("textFeature0");
     */
    getFeatureByFid(fid) {
        for (let painter of this.painters.values()) {
            let feature = painter.getById(fid);
            if (!(feature === undefined || feature == null)) {
                return feature;
            }
        }
    }

    /**
     * 给定属性与值，获取匹配的地理要素
     * 如果没有找到匹配的地理要素，则返回一个空的数组。
     * @param {String} attrName 属性名称或键名
     * @param {*} attrValue 属性值。字符串、数字等
     * @returns {Array} 返回所匹配的要素构成的数组
     * @example
     * let features = vectorLayer.getFeaturesByAttribute("name", 205);//得到属性name为205的要素数组
     */
    getFeaturesByAttribute(attrName, attrValue) {
        let arr = [];
        for (let painter of this.painters.values()) {
            arr.push.apply(arr, painter.getByAttribute(attrName, attrValue));
        }
        return arr;
    }

    /**
     * 返回该图层的所有要素
     * @returns {Array<hmap.feature.Vector>}
     * @example
     * let result = vectorLayer.getAllFeatures();
     */
    getAllFeatures() {
        const all = [];
        this.painters.forEach((value, key) => {
            all.push.apply(all, value.getAll());
        });
        return all
    }

    /**
     * 获取屏幕坐标附近在容差范围内的要素，推荐使用Map.detectFeaturesAtPixel()接口
     * @param {hmap.basetype.Pixel} pixel 像素坐标
     * @param {Number} tolerance 容差，以像素为单位
     * @private
     */
    getFeaturesByPixel(pixel, tolerance) {

    }

    /**
     * 根据坐标获取要素，推荐使用Map.detectFeaturesAtPixel()接口
     * @param {hmap.basetype.Coordinate} coord 坐标
     * @returns {Array} 以数组的形式返回所获取的要素
     * @private
     */
    getFeaturesByCoord(coord) {

    }

    /**
     * 获取图层样式
     * @returns {hmap.style.Style} 一个样式对象，表示图层样式。
     * @example
     * let style = vectorLayer.getStyle();
     */
    getStyle() {
        return this._style;
    }

    /**
     * 设置图层样式。
     * @param style {hmap.style.Style} 图层的样式对象。
     * @example
     * let style = hmap.style.Style.getDefault();
     * vectorLayer.setStyle(style);
     */
    setStyle(style) {
        const markerSymbols = style.getMarkerSymbols(),
            lineSymbols = style.getLineSymbols(),
            fillSymbols = style.getFillSymbols(),
            textSymbols = style.getTextSymbols();
        if (markerSymbols.length > 0) {
            this._style.setMarkerSymbols(markerSymbols);
        }
        if (textSymbols.length > 0) {
            this._style.setTextSymbols(textSymbols);
        }
        if (lineSymbols.length > 0) {
            this._style.setLineSymbols(lineSymbols);
        }
        if (fillSymbols.length > 0) {
            this._style.setFillSymbols(fillSymbols);
        }

        let features;

        if (this._map) {
            features = this.getAllFeatures();
        }
        else {
            features = this._featuresToAdd;
        }


        for (let i = 0, l = features.length; i < l; i++) {
            const feature = features[i],
                geo = feature.getGeometry(),
                geoType = geo.getType();

            switch (geoType) {
                case hmap.geom.GeometryType.Point:
                case hmap.geom.GeometryType.MultiPoint:
                    this._updateFeatureMarkerSymbols(feature, markerSymbols, textSymbols);
                    break;
                case hmap.geom.GeometryType.Line:
                case hmap.geom.GeometryType.LinearRing:
                case hmap.geom.GeometryType.MultiLine:
                case hmap.geom.GeometryExtType.POLYLINE.ARC:
                case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE2:
                case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVE3:
                case hmap.geom.GeometryExtType.POLYLINE.BEZIER_CURVEN:
                case hmap.geom.GeometryExtType.POLYLINE.CARDINAL_CURVE:
                case hmap.geom.GeometryExtType.LARROW.POLYLINE_ARROW:
                case hmap.geom.GeometryExtType.LARROW.BEZIER_CURVE_ARROW:
                case hmap.geom.GeometryExtType.LARROW.CARDINAL_CURVE_ARROW:
                case hmap.geom.GeometryExtType.LARROW.PARALLEL_SEARCH:
                case hmap.geom.GeometryExtType.LARROW.SECTOR_SEARCH:
                    this._updateFeatureLineSymbols(feature, lineSymbols);
                    break;
                case hmap.geom.GeometryType.Triangle:
                case hmap.geom.GeometryType.Circle:
                case hmap.geom.GeometryType.Rectangle:
                case hmap.geom.GeometryType.Polygon:
                case hmap.geom.GeometryType.MultiPolygon:
                case hmap.geom.GeometryExtType.POLYGON.RECTANGLE:
                case hmap.geom.GeometryExtType.POLYGON.LUNE:
                case hmap.geom.GeometryExtType.POLYGON.ROUNDED_RECT:
                case hmap.geom.GeometryExtType.POLYGON.CIRCLE:
                case hmap.geom.GeometryExtType.POLYGON.ELLIPSE:
                case hmap.geom.GeometryExtType.POLYGON.SECTOR:
                case hmap.geom.GeometryExtType.POLYGON.CLOSE_CURVE:
                case hmap.geom.GeometryExtType.POLYGON.GATHERING_PLACE:
                case hmap.geom.GeometryExtType.FLAG.RECT_FLAG:
                case hmap.geom.GeometryExtType.FLAG.TRIANGLE_FLAG:
                case hmap.geom.GeometryExtType.FLAG.CURVE_FLAG:
                case hmap.geom.GeometryExtType.ARROW.STRAIGHT_ARROW:
                case hmap.geom.GeometryExtType.ARROW.DIAGONAL_ARROW:
                case hmap.geom.GeometryExtType.ARROW.DOUBLE_ARROW:
                case hmap.geom.GeometryExtType.ARROW.DOVETAIL_STRAIGHT_ARROW:
                case hmap.geom.GeometryExtType.ARROW.DOVETAIL_DIAGONAL_ARROW:
                    this._updateFeatureFillSymbols(feature, fillSymbols, lineSymbols);
                    break;
            }
        }
    }

    /**
     * 更新点样式，包括icon和text
     * @param feature
     * @param markerSymbols
     * @param textSymbols
     * @private
     */
    _updateFeatureMarkerSymbols(feature, markerSymbols, textSymbols) {
        const markSymbolCount = markerSymbols.length,
            textSymbolCount = textSymbols.length;
        if (markSymbolCount == 0 && textSymbolCount == 0) {
            return;
        }
        const style = new hmap.style.Style({
            markerSymbols: markerSymbols,
            textSymbols: textSymbols,
        });
        feature.setStyle(style);
        this.updateFeature(feature);
    }

    /**
     * 更新线样式
     * @param feature
     * @param lineSymbols
     * @private
     */
    _updateFeatureLineSymbols(feature, lineSymbols) {
        if (lineSymbols.length == 0) {
            return;
        }

        const style = new hmap.style.Style({
            lineSymbols: lineSymbols,
        });
        feature.setStyle(style);
        this.updateFeature(feature);
    }

    /**
     * 更新多边形的样式，包括填充和边框
     * @param feature
     * @param fillSymbols
     * @param lineSymbols
     * @private
     */
    _updateFeatureFillSymbols(feature, fillSymbols, lineSymbols) {
        const fillSymbolCount = fillSymbols.length,
            lineSymbolCount = lineSymbols.length;
        if (fillSymbolCount == 0 && lineSymbolCount == 0) {
            return;
        }

        const style = new hmap.style.Style({
            fillSymbols: fillSymbols,
            lineSymbols: lineSymbols,
        });
        feature.setStyle(style);
        this.updateFeature(feature);
    }

    /**
     * 添加的单个地理要素。每调用一次，图层就会重绘一次。（请勿重复添加要素）
     * @param {hmap.feature.Vector} feature 要添加的地理要素
     * @example
     * let coord = new hmap.basetype.Coordinate(120.24,30.18,0.0);
     * let point = new hmap.geom.Point(coord);
     * let textSymbol=new hmap.style.TextSymbol({"text":"海康威视"});
     * let textStyle = new hmap.style.Style({"textSymbols":[textSymbol]});
     * let textfeature =new hmap.feature.Vector(point,{name:'摄像头', id:205},textStyle);
     * vectorLayer.addFeatures(textfeature);
     */
    addFeature(feature) {
        if (feature instanceof hmap.feature.Vector && !feature.getStyle())
            feature.setStyle(this._style);
        if (this._map) {
            feature.updatePainterType();
            this.painters.get(feature.getPainterType()).add(feature);
        } else {
            this._featuresToAdd.push(feature);
        }
    }

    /**
     * 添加多个地理要素，请勿重复添加要素
     * 注意，当前版本中暂不支持由集合体（Collection）组成的Feature。
     * @param {Array<hmap.feature.Vector|hmap.model.Stretch>} features 矢量地理要素的数组
     * @example
     * let coord = new hmap.basetype.Coordinate(120.24,30.18,0.0);
     * let point = new hmap.geom.Point(coord);
     * let textSymbol=new hmap.style.TextSymbol({"text":"海康威视"});
     * let textStyle = new hmap.style.Style({"textSymbols":[textSymbol]});
     * let textfeature =new hmap.feature.Vector(point,{name:'摄像头', id:205},textStyle);
     * vectorLayer.addFeatures([textfeature]);
     */
    addFeatures(features) {
        for (let i = 0, len = features.length; i < len; i++) {
            this.addFeature(features[i]);
        }
    }

    /**
     * 删除所有地理要素
     * @example
     * vectorLayer.removeAllFeatures();
     */
    removeAllFeatures() {
        this._featuresToAdd = [];
        this.painters.forEach((value, key) => {
            value.removeAll();
        });
    }

    /**
     * 删除一组地理要素。
     *  被移除的地理要素将被彻底销毁。如果仅希望解除地理要素与图层的绑定，请clone()。
     * @param {Array<hmap.feature.Vector>} features 删除指定的地理要素
     * @example
     * let coord = new hmap.basetype.Coordinate(120.24,30.18,0.0);
     * let point = new hmap.geom.Point(coord);
     * let textSymbol=new hmap.style.TextSymbol({"text":"海康威视"});
     * let textStyle = new hmap.style.Style({"textSymbols":[textSymbol]});
     * let textfeature =new hmap.feature.Vector(point,{name:'摄像头', id:205},textStyle);
     * vectorLayer.addFeatures([textfeature]);
     * vectorLayer.removeFeatures([textfeature]);
     */
    removeFeatures(features) {
        const len=features.length-1;
        for (let i = len; i >=0; i--) {
            this.removeFeature(features[i]);
        }
    }

    /**
     * 删除单个地理要素
     * @param feature 要删除的地理要素
     * @example
     * let coord = new hmap.basetype.Coordinate(120.24,30.18,0.0);
     * let point = new hmap.geom.Point(coord);
     * let textSymbol=new hmap.style.TextSymbol({"text":"海康威视"});
     * let textStyle = new hmap.style.Style({"textSymbols":[textSymbol]});
     * let textfeature =new hmap.feature.Vector(point,{name:'摄像头', id:205},textStyle);
     * vectorLayer.addFeatures([textfeature]);
     * vectorLayer.removeFeatures([textfeature]);
     */
    removeFeature(feature) {
        const painterType=feature.getPainterType();
        if(painterType===hmap.core.painterType.NONE){
            return false;
        }
        if (this._map) {
            this.painters.get(painterType).remove(feature);
        } else {
            const index = this._featuresToAdd.indexOf(feature);
            if (index > -1) {
                this._featuresToAdd.splice(index, 1);
            }
        }
    }

    /**
     * 更新已添加到图层中的指定的feature
     * @param {hmap.feature.Vector} feature 需要更新的要素
     */
    updateFeature(feature) {
        if (this._map) {
            const painterType = feature.updatePainterType(false);
            if (painterType === feature.getPainterType()) {
                this.painters.get(feature.getPainterType()).update(feature);
            } else {
                this.removeFeature(feature);
                this.addFeature(feature);
            }
        } else {
            const index = this._featuresToAdd.indexOf(feature);
            if (index > -1) {
                this._featuresToAdd[index] = feature;
            }
        }
    }

    /**
     * 更新已添加到图层中的指定feature数组。
     * @param {Array<hmap.feature.Vector>} features 需要更新的要素数组
     */
    updateFeatures(features) {
        for (let feature of features) {
            this.updateFeature(feature);
        }
    }

    /**
     * @private
     */
    draw() {
        super.draw();

        const ext = this._map.getExtent();
        this.painters.forEach((value, key) => {
            value.draw(ext);
        });
    }

    /**
     * 设置图层不透明度。
     * 0表示完全透明，1表示完全不透明。从0到1，越来越不透明。
     * @param {Number} opacity 图层透明度，介于0~1之间。
     */
    setOpacity(opacity = 1) {
        this._opacity = opacity;

        for (let value of this.painters.values()) {
            value.opacity = this._opacity;
        }

        this.redraw();
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 聚合图层，负责矢量点要素的聚合。
 * @type {hmap.layer.ClusterLayer}
 * @extends hmap.layer.VectorLayer
 */
hmap.layer.ClusterLayer = class extends hmap.layer.VectorLayer {
    /**
     * 构造一个聚合图层。
     * @param {String} name 图层名称
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @param {Boolean} options.enableHashCode 可选项。是否开启拾取功能，默认为false，无法进行要素拾取。当需要拾取时，设置该值为true。
     * @param {Number} options.gridSize 可选项，聚合计算时网格的大小，单位为像素，默认值为256。
     * @param {hmap.style.Style} options.clusterStyle 可选项，聚合点的样式
     * @param {Boolean} options.clusterOne    可选项，1个点时是否聚合，默认值为false，即1个点时不聚合。
     * @param {Number} options.disableClusteringAtZoom 可选项，表示大于或者等于该级别不再聚合,默认17
     * @param {Boolean} options.showText 散点是否显示文字
     * @example
     * let options = {
     *  opacity: 0.5,
     *  enableHashCode: true,
     *  clusterOne: true,
     *  _clusterStyle: clusterStyle,
     *  disableClusteringAtZoom: 18
     * };
     * let vectorLayer = new hmap.layer.ClusterLayer("聚合图层",options);
     */
    constructor(name, options = {}) {
        super(name, options);
        this.CLASS_NAME = "hmap.layer.ClusterLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._clusterStyle = options.clusterStyle ? options.clusterStyle : hmap.style.Style.getDefault();
        this._clusterOne = options.clusterOne ? options.clusterOne : false;
        this._gridSize = options.gridSize ? options.gridSize : 256;
        this._featuresToCluster = [];
        this._clusterFeatures = [];
        this._disableClusteringAtZoom = options.disableClusteringAtZoom ? options.disableClusteringAtZoom : 17;
        this._featureMap = new Map();
        this._af = new hmap.util.AF(this, 200);
        this._showText = options.showText || false;
        this._disableClustered = false;
    }

    /**
     * 添加多个要聚合的原始数据。
     * 注意，当前版本中仅支持point Feature。
     * @param {Array<hmap.feature.Vector>} features 要聚合的要素数组
     */
    addFeatures(features) {
        features.forEach(feature => {
            this.addFeature(feature);
        })
        this.prepareData();
    }

    /**
     * 添加要聚合的原始数据
     * 注意，当前版本中仅支持point Feature。
     * @param {hmap.feature.Vector} feature 要聚合的要素
     */
    addFeature(feature) {
        if (!feature.getAttributes()) {
            feature.setAttributes({})
        }
        let featureClone = feature.clone(); //操作副本，不要影响原始的数据
        feature.setAttributes(Object.assign(feature.getAttributes(), {
            clusterCount: 1,
            clusterFeaturesArray: [featureClone]
        }));
        this._featuresToCluster.push(feature);
        this.prepareData();
    }

    /**
     * 删除所有地理要素
     */
    removeAllFeatures() {
        this._featuresToCluster = [];
        this._removeAllClusterFeatures();
        this.prepareData();
    }

    /**
     * 删除一组地理要素。
     * @param {Array<hmap.feature.Vector>} features 删除指定的地理要素
     */
    removeFeatures(features) {
        this._featuresToCluster = this._featuresToCluster.filter(feature => {
            return features.indexOf(feature) == -1;
        });
        this.prepareData();
    }

    /**
     * 删除单个地理要素
     * @param {hmap.feature.Vector} feature 要删除的地理要素
     */
    removeFeature(feature) {
        const count = this._featuresToCluster.length;
        for (let i = 0; i < count; i++) {
            if (this._featuresToCluster[i] == feature) {
                this._featuresToCluster.splice(i, 1);
            }
        }
        this.prepareData();
    }

    /**
     * 要渲染的聚合之后的要素
     * @param {hmap.feature.Vector} feature
     * @private
     */
    _addClusterFeature(feature) {
        super.addFeature(feature);
    }

    /**
     * 将聚合计算之后生成的聚合点添加到聚合图层，这些要素也是最终要展示的要素
     * @param {Array<hmap.feature.Vector>} features
     * @private
     */
    _addClusterFeatures(features) {
        this._featureMap.clear();
        for (let i = 0, len = features.length; i < len; i++) {
            const feature = features[i];
            this._featureMap.set(feature.getFid(), feature);
            this._addClusterFeature(feature);
        }
        if (this.enableHashCode) {
            const extent = this._map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft());
            let maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx);
            let max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }
    }

    /**
     * 通过计算将原始数据转换为要渲染的聚合数据,并添加到图层上
     * @private
     */
    _mesher() {
        if (!this._disableClusteringAtZoom || this._map.getZoom() < this._disableClusteringAtZoom) {
            this._disableClustered = false;
            let features = this._featuresToCluster;
            const gridSize = this._gridSize;
            let mExtent = this._map.getExtent();
            let mapDivSize = this._map.getSize();
            let resolution = (mExtent.getRight() - mExtent.getLeft()) / mapDivSize._width;
            let gridLength = gridSize * resolution;
            let startR = Math.floor(mExtent.getLeft() / gridLength);
            let endR = Math.floor(mExtent.getRight() / gridLength);
            let startC = Math.floor(mExtent.getBottom() / gridLength);
            let endC = Math.floor(mExtent.getTop() / gridLength);
            this._clusterFeatures = [];
            //聚合点使用图层的样式
            let textSymbolsTemplate = this._clusterStyle.getTextSymbols();
            let markerSymbolsTemplate = this._clusterStyle.getMarkerSymbols();
            //非聚合点使用自己的样式
            if (features.length > 0) {
                let featureMarkerSymbols;
                if (features[0].getStyle() && features[0].getStyle().getMarkerSymbols()) {
                    featureMarkerSymbols = features[0].getStyle().getMarkerSymbols();
                } else {
                    featureMarkerSymbols = hmap.style.Style.getDefault().getMarkerSymbols();
                }
                let featuresIn = {};

                for (let i = 0, len = features.length; i < len; i++) {
                    const feature = features[i].clone();
                    const point = feature.getGeometry();
                    const coor = point.getCentroid();
                    let coordRow = Math.floor(coor._x / gridLength);
                    let coordCol = Math.floor(coor._y / gridLength);
                    if (startR <= coordRow && coordRow <= endR && startC <= coordCol && coordCol <= endC) {
                        let ranks = coordRow + "-" + coordCol;
                        if (!featuresIn[ranks]) {
                            featuresIn[ranks] = [];
                        }
                        featuresIn[ranks].push(feature); //统计行列号相同的点，构成数组
                    }
                }
                for (let ranks in featuresIn) {
                    let textNumber = String(featuresIn[ranks].length);
                    let textSymbols = textSymbolsTemplate.map(textSymbol => {
                        let cloneSymbol = textSymbol.clone();
                        if (textNumber > 1 || this._clusterOne) {
                            cloneSymbol.setText(textNumber);
                        }
                        return cloneSymbol;
                    });

                    let styleCluster = new hmap.style.Style({
                        textSymbols: textSymbols,
                        markerSymbols: textNumber > 1 || this._clusterOne ? markerSymbolsTemplate : featureMarkerSymbols
                    });

                    if (textNumber > 1) {

                        let points = featuresIn[ranks].map(feature => {
                            return feature.clone().getGeometry();
                        })
                        let multiPoint = new hmap.geom.MultiPoint(points);
                        let centroid = multiPoint.getCentroid();
                        //直接以质心为聚合点（更加合理，聚合效果看的就是一个整体分布）
                        let point = new hmap.geom.Point(centroid);
                        let pointcluster = new hmap.feature.Vector(point, {}, styleCluster);
                        pointcluster.setAttributes(Object.assign(pointcluster.getAttributes(), {
                            clusterCount: textNumber,
                            clusterFeaturesArray: featuresIn[ranks]
                        }));
                        this._clusterFeatures.push(pointcluster);
                    } else {
                        let feature = featuresIn[ranks][0].clone(); //操作副本，不要影响原始的数据
                        if (this._showText) {
                            feature.setStyle(styleCluster);
                            this._clusterFeatures.push(feature);
                        } else {
                            const style = styleCluster.clone();
                            style.setTextSymbols([]);
                            feature.setStyle(style);
                            this._clusterFeatures.push(feature);
                        }
                    }
                }
            }
        } else { //如果级别大于disableClusterAtZoom 直接将要聚合的数据展示到聚合图层
            this._disableClustered = true;
            this._clusterFeatures = this._featuresToCluster.map(item => {
                const feature = item.clone();
                if (this._showText) {
                    return feature;
                } else {
                    const style = feature.getStyle() ? feature.getStyle().clone() : hmap.style.Style.getDefault();
                    style.setTextSymbols([]);
                    feature.setStyle(style);
                    return feature;
                }
            })

        }
    }

    /**
     * 当数据更新的时候重新执行聚合渲染
     * @private
     */
    prepareData() {
        //super.prepareData();
        //如果当前zoom已经达到disableClusteringAtZoom,不再重新添加数据
        if (this._disableClustered && this._map.getZoom() >= this._disableClusteringAtZoom) {
            return;
        }
        if (!this._featuresToCluster.length == 0) {
            this._removeAllClusterFeatures();
            this._mesher();
            const _this = this;
            this._af.run(function () {
                _this._addClusterFeatures(_this._clusterFeatures);
            });
        }
    }

    /**
     * 获取所有聚合后的要素
     * @returns {Array<hmap.feature.Vector>} 聚合后的要素
     */
    getAllFeatures() {
        return this._clusterFeatures;
    }

    /**
     * 删除所有已经渲染的聚合点
     * @private
     */
    _removeAllClusterFeatures() {
        this._featureMap.clear();
        this._featuresToAdd = [];
        this.painters.forEach((value, key) => {
            value.removeAll();
        });
    }

    /**
     * 通过聚合点要素的id获取该聚合点所聚合的所有要素
     * @param {String} fid 聚合点要素的id
     * @return {Array<hmap.feature.Vector>} 返回要素数组
     */
    getClusterFeaturesByFid(fid) {
        if (!this._featureMap.get(fid) || !this._featureMap.get(fid).getAttributes()) {
            return [];
        } else {
            return this._featureMap.get(fid).getAttributes().clusterFeaturesArray;
        }
    }
};;"use strict";
hmap.layer = hmap.layer || {};
/**
 * Obj图层。obj是一种常见的三维数据格式。 本图层用于表达OBJ格式的三维建模数据。
 * @type {hmap.layer.ObjModelLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.ObjModelLayer = class extends hmap.layer.Layer {
    /**
     * 构造一个Obj模型图层.
     * @param {String} name 图层名称
     * @param {json} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @param {Boolean} options.visibility（可选项） 设置图层的可见性，true为可见，false为不可见。
     * @param {Number} options.opacity（可选项） 设置图层的透明度，取值可为1到1之间，0为透明，1为完全不透明。
     * @param {Boolean} options.isBaseLayer（可选项） 设置图层是否是baseLayer，即是否为地图底图，若不传，默认为false。
     * @example
     * let options = {
        visibility:true,//可见性
        opacity:1, //透明度
        style:hmap.style.Style.getDefault()//设置图层样式
     * };
     * let modelLayer = new hmap.layer.ObjModelLayer("矢量图层",options);
     */
    constructor(name, options={}) {
        super(options);
        this.CLASS_NAME = "hmap.layer.ObjModelLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.name = name;
        this._map = null;
        this._visibility = true;
        this._opacity = 1;
        this._isBaseLayer = false;
        options = options ? options : null;
        if (options) {
            this._visibility = options.hasOwnProperty("visibility") ? options['visibility'] : true;
            this._opacity = options.hasOwnProperty("opacity") ? options['opacity'] : 1;
            this._isBaseLayer = options.hasOwnProperty("_isBaseLayer") ? options['_isBaseLayer'] : false;
        }
        this._modelMap = new Map();
        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : this.enableHashCode;
        this.strict = options.hasOwnProperty("strict") ? options.strict : false; //是否采用高精确拾取（当前无效）
    }

    /**
     * 获取图层类型
     * @return {String} 图层类型
     * @example
     * let layerType = modelLayer.getLayerType();
     */
    getLayerType() {
        return this.CLASS_NAME;
    }

    /**
     * 将图层绑定到指定的map上
     * @private
     * @param {hmap.Map} 地图对象
     */
    setMap(map) {
        super.setMap(map);
        const rendererOptions = {
            mapUnit: map.getCrs().getUnit(),
            isRTE: this._isRTE,
            isLGD:this._isLGD,
            event:this.event,
        };
        this._objRender = new hmap.renderer.ObjRender(this.gl, rendererOptions);
        if (map && this.enableHashCode) {
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }
    }

    /**
     * 克隆图层,包括该图层中所有的数据
     * @return {hmap.layer.ObjModelLayer} 返回模型图层的新的实例
     * @example
     * let newModelLayer = modelLayer.clone();
     */
    clone() {
        const objModelLayer = new hmap.layer.ObjModelLayer(this.name, {
            visibility: this._visibility,
            opacity: this._opacity,
            isRTE: this._isRTE,
            isLGD: this._isLGD
        });
        //拷贝数据Map数据
        for (let [key, value] of this._modelMap.entries()) {
            objModelLayer._modelMap.set(key, value);
        }
        return objModelLayer;
    }

    /**
     * 获取图层的所有模型
     * @return {Array<hmap.model.Obj>} 返回图层的所有模型
     * @example
     * let allModels = modelLayer.getAllModels();
     */
    getAllModels() {
        return [...this._modelMap.values()];
    }

    /**
     * 获取屏幕坐标附近在容差范围内的要素(该方法暂未实现)
     * @private
     * @param {hmap.basetype.Pixel} pixel 像素坐标
     * @param {Number} tolerance 容差，以像素为单位
     */
    getModelsByPixel(pixel, tolerance) {

    }

    /**
     * 根据坐标获取要素（该方法暂未实现）
     * @private
     * @param {hmap.basetype.Coordinate} coord 坐标
     * @returns {Array}
     * @example
     * let coord = new hmap.basetype.Coordinate(120.24,30.18,0.0);
     * let features = modelLayer.getFeaturesByCoord(coord);
     */
    getModelsByCoord(coord) {
    }

    /**
     * 删除图层的所有模型
     * @return {hmap.layer.ObjModelLayer} 返回图层对象
     * @example
     * modelLayer.removeAllModels();
     */
    removeAllModels() {
        this._modelMap.clear();
        if(this.enableHashCode){
            this.layerOctree.clear();
        }
        return this;
    }

    /**
     * 删除单个模型
     * @param {hmap.model.Obj} model 要删除的模型
     * @return {hmap.layer.ObjModelLayer} 返回图层对象
     * @example
     * modelLayer.removeModel(model);
     */
    removeModel(model) {
        this._modelMap.delete(model._getMid());
        if(this.enableHashCode){
            this.layerOctree.removeById(model._getMid())
        }
        return this;
    }

    /**
     * 添加单个模型
     * @param {hmap.model.Obj} model 要添加的模型
     * @return {hmap.layer.ObjModelLayer} 返回图层对象
     * @example
     * modelLayer.addModel(model);
     */
    addModel(model) {
        if (!model.mesh) {
            model.readModel().then(() => {
                // this._modelMap.set(model._getMid(), model);
                // if(model.isImmediate) {
                //     this._objRender.createVAO(model);
                // }
                this.addModel(model)
            });
        } else {
            this._modelMap.set(model._getMid(), model);
            if(model.isImmediate) {
                this._objRender.createVAO(model);
            }
            if(this.enableHashCode){
                model.mesh._id = model._getMid();
                this.layerOctree.put(model.mesh)
            }
            if(this._map){
                this._map.af.active();
            }
        }
        return this;
    }

    /**
     * 图层重绘
     * @private
     */
    draw() {
        super.draw();
        this._drawModel();
    }

    /**
     * 图层重绘
     * @private
     */
    _drawModel() {
        // 视图矩阵的平移部分
        const viewTranslation = new hmap.util.Matrix4().translate(
            -this._map._camera._eyeX,
            -this._map._camera._eyeY,
            -this._map._camera._eyeZ
        );
        this._objRender.setFogColor(this._map.getFogColor());
        this._objRender.setFogDist(this._map.getFogDist());
        this._objRender.setOpacity(this._opacity);
        const cameraCoord = this._map.getCamera().getCoordinate();
        const cameraPositionVec = new hmap.util.Vector3(cameraCoord.getOrdinate("X"), cameraCoord.getOrdinate("Y"), cameraCoord.getOrdinate("Z"));
        const cameraPosition = viewTranslation.multiplyVector3(cameraPositionVec).getElements()
        this._objRender.setCameraPosition(cameraPosition);
        this._objRender.setLightPosition(cameraPosition);
        const pMatrix = this._map.getProjMatrix();
        const vMatrix = this._map._camera._rotateXMatrix.clone().multiply(this._map._camera._rotateZMatrix);

        this._modelMap.forEach((value, key, mapv) => {
            const modelMatrix = new hmap.util.Matrix4();
            modelMatrix.multiply(viewTranslation.clone());
            modelMatrix.multiply(value.modelMatrix);
            
            modelMatrix.multiply(value.axisExchangeMatrix);
            this._objRender.setMatrices(modelMatrix, vMatrix, pMatrix);
            this._objRender.draw(value);
        });
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * WMS是Web Map Service的缩写，即网络地图服务，其是OGC的网络地图服务标准。WMSLayer即可以加载并显示WMS服务地图的一类图层。
 * 如果缩放过程中出现图片模糊的情况，建议把地图创建时的参数zoomInterval设置为1。
 * @type {hmap.layer.WMSLayer}
 * @extends hmap.layer.GridLayer
 */
hmap.layer.WMSLayer = class extends hmap.layer.TMSLayer {
    /**
     * @param {String} name 图层名字
     * @param {String} url 图层的服务地址 比如：http://ip:port/arcgis/services/Zhe_96/MapServer/WMSServer?
     * @param {Object} params 键值对对象，获取地图时必须的字符串参数和对应的参数值。params中的key不区分大小写。
     * @param {String} params.layers 地图图层列表，必设参数，图层之间以半角英文逗号隔开。最左边的图层在最下面，其后的图层依次在其上面。
     *                  图层名称必须是GetCapabilities操作返回的文档中声明的Name元素的值。
     * @param {String} params.format(可选) 地图的输出格式。格式类型可以是PNG、GIF、JPEG等。如：”image/png“。
     * @param {String} params.version(可选) 请求版本号。现支持"1.1.1"和"1.3.0"。
     * @param {Boolean} params.transparent(可选)  图层是否透明，默认为true，即透明。
     * @param {Object} options 在该类及其父类中开放的属性。
     * @example
     * const wmsUrl = "http://ip:port/arcgis/services/Zhe_96/MapServer/WMSServer?";//如有跨域问题，需设置为代理前的地址
     * const wmsParams ={
     *   CRS:"EPSG:4326",//坐标系，当WMS版本小于1.3时，key为SRS。
     *   VERSION:"1.3.0",//WMS的版本
     *   LAYERS:"1,2,3,4,5",//图层的id或名称，可以是多个，中间用逗号（,）分割。
     *   STYLES:"default,default,default,default,default",//样式和LAYERS中的layer一一对应
     *   FORMAT:"image/png",//图片格式为png
     *  TRANSPARENT:false,//图层是不透明的
     * };
     *  let wmsLayer = new hmap.layer.WMS("WMS图层",wmsUrl,wmsParams);
     *  map.addLayer(wmsLayer);
     */
    constructor(name, url, params = {}, options = {}) {
        super(name, url, options);
        this.CLASS_NAME = "hmap.layer.WMSLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成id
        this._tileSize = options.gridSize ? options.gridSize : new hmap.basetype.Size(512, 512);
        this.layerUrl = url;
        this._groupSideLength = 1;
        this._isBaseLayer = false;
        this._params = {
            SERVICE: "WMS",
            VERSION: "1.1.1",
            REQUEST: "GetMap",
            STYLES: "",
            FORMAT: "image/jpeg",
            TRANSPARENT: true
        };
        //转为大写
        params = this._upperCaseObject(params);
        //合并参数
        this._params = Object.assign(this._params, params);
    }

    /**
     * 获取图层类型
     * @returns {string} "hmap.layer.WMSLayer"
     */
    getLayerType() {
        return "hmap.layer.WMSLayer";
    }

    /**
     * 添加到地图上
     * @private
     * @param {hmap.Map} map 地图对象
     */
    setMap(map) {
        super.setMap(map);
    }

    /**
     * 设置标识，防止纹理ID重复
     * @param x
     * @param y
     * @param z
     * @return {string}
     * @private
     */
    _getXYZ(x, y, z) {
        return x + "-" + y + "-" + z + "-WMS";//补充图层标识，防止纹理id重复
    }

    /**
     * 组装URL
     * @param xyz
     * @return {string}
     * @private
     */
    setTileUrl(xyz) {
        let [x, y, z] = xyz.split("-");//行列号标识
        if (this.layerZFunc) {
            z = this.layerZFunc(z, this.maxLevel);
        }
        const tileExt = this.getTileExt(x*1, y*1, z*1, this.getTileSize().getWidth(), this.getTileSize().getHeight());
        const url = this._assemblyRequestUrl(tileExt, this.getTileSize().getWidth(), this.getTileSize().getHeight());
        return url;
    }

    /**
     * 重绘方法
     */
    draw() {
        super.draw();
    }

    /**
     * 获取瓦片url
     * @return {String}
     */
    getTileUrl() {
        return this.layerUrl;
    }

    /**
     *
     * @param tile
     * @private
     */
    _createTextureFill(tiles) {
        const tile = tiles.get('subXYZ')[0];
        const url = tile.url,
            texFill = new hmap.style.TextureFill(url, {
                texture_wrap_s: 'CLAMP_TO_EDGE',
                texture_wrap_t: 'CLAMP_TO_EDGE',
                texture_mag_filter: 'NEAREST',
                texture_min_filter: 'NEAREST',
            });
        tile.texFill = texFill;
    }

    /**
     * 获取完整的进行WMS的GetMap请求的Url
     * @param ext 要请求的图层的范围
     * @param width 要请求的地图的宽度，单位是像素
     * @param height 要请求的地图的高度，单位是像素
     * @returns {string} 完整的请求地图的Url
     * @private
     */
    _assemblyRequestUrl(ext, width = 560, height = 350) {
        //return "http://127.0.0.1:8081/arcgis/services/Zhe_96/MapServer/WMSServer?VERSION=1.1.0&REQUEST=GetMap&" + "SRS=EPSG:4326&BBOX=118.023,27.047,122.9,31.18&WIDTH=560&HEIGHT=350&LAYERS=1,2,3,4,5&" + "STYLES=default,default,default,default,default&FORMAT=image/png";
        //return "/arcgis/services/Zhe_96/MapServer/WMSServer?VERSION=1.1.0&REQUEST=GetMap&" + "SRS=EPSG:4326&BBOX=118.023,27.047,122.9,31.18&WIDTH=560&HEIGHT=350&LAYERS=1,2,3,4,5&" + "STYLES=default,default,default,default,default&FORMAT=image/png";
        this._params.WIDTH = width;
        this._params.HEIGHT = height;

        const projectionCode = this.getCrs() ? "EPSG:" + this.getCrs().getSrid() : "EPSG:4326";
        //1.3版本及以上坐标系的key为CRS，BBOX中顺序中ymin,xmin,ymax,xmax。即x和y顺序相反。
        if (parseFloat(this._params.VERSION) >= 1.3 && this._params.CRS === undefined) {
            this._params.CRS = projectionCode;
            delete this._params.SRS;
        } else if (this._params.SRS === undefined) {
            this._params.SRS = projectionCode;
            delete this._params.CRS;
        }
        this._params.BBOX = ext.toString();
        let url = this.layerUrl + "REQUEST=GetMap";
        for (let key in this._params) {
            url = url + "&" + key + "=" + this._params[key];
        }

        return url;
    }

    /**
     * 创建一个新的Object，但是新的object的键值统一大写。
     * @param object
     * @private
     */
    _upperCaseObject(object) {
        let uObject = {};
        for (let key in object) {
            uObject[key.toUpperCase()] = object[key];
        }
        return uObject;
    }
};
;"use strict";
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 矢量切片图层。以分块的矢量格式来存储和渲染地理要素。
 * @type {hmap.layer.VectorTileLayer}
 * @extends hmap.layer.GridLayer
 */
hmap.layer.VectorTileLayer = class extends hmap.layer.GridLayer {
    /**
     * VectorTile 图层构造函数，在options参数中指定render的个数 默认1个
     * @param {String} name 矢量切片图层的名称
     * @param {String} url 矢量切片数据文件(hvt)的路径
     * @param {Object} options
     * @param {String} options.styleUrl 样式文件（json）的路径
     * @param {Number} options.roadLabelLimiteAngle 一个阈值，当地图倾斜超过这个阈值时地图道路注记不显示，缺省值为40度。
     * @param {Array<Number>} options.resolutions 分辨率数组
     * @param {Boolean} options.enableHashCode 启用要素拾取，默认不启用
     * @param {Boolean} options.labelOn 启用地图注记，默认false
     * @param {Number} options.dataMaxLevel 矢量切片服务器端数据的最大级别，默认为地图最大放大级别。如果地图放大级别超过此级别，此时屏幕绘制的数据为此级别的数据。
     * @example
     * let vOptions = {
        matrixOrigin: new hmap.basetype.Coordinate(-180, 90),
        dataFormat: "hvt",
        styleUrl:"mapStyle.json"
     * };
     * let vectileLayer = new hmap.layer.VectorTile("矢量瓦片图层", "http://10.20.84.15:8080/GeoData/hvt/", vOptions);
     */
    constructor(name, url, options = {}) {
        super(name, url, options);
        this.CLASS_NAME = "hmap.layer.VectorTileLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._styleRuleMgr = null;
        this._styleJsonPromise = this._getStyleJson(options.styleUrl);
        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : false;
        this._isBaseLayer = options.isBaseLayer !== false;//不传则为true。传true则为true，传false则为false
        this.roadLabelLimiteAngle = options.roadLabelLimiteAngle ? -options.roadLabelLimiteAngle : -40;
        this.iconWeight = 500;//图标权重
        this.spriteText = 500;//点文字权重
        this.polyText = 400;//线文字权重
        this._groupSideLength = options.groupSideLength || 1;//一次绘制的tile结构
        this._vtGroupCache = new Map();//所有数据的url和painterKey映射
        this._vtGroupToDraw = new Set();//绘制数据的url

        this._painters = [];//排序后的painter
        this._layersPaintersMap = new Map();//排序前的painter

        this._geoJSON = new hmap.format.GeoJSON();

        this._labelOn = options.labelOn ? options.labelOn : false;//注记
        this.url = url;
        this.iconUrl = options.styleUrl.substring(0, options.styleUrl.lastIndexOf("/") + 1);
        this.charsUrl = options.styleUrl.substring(0, options.styleUrl.lastIndexOf("/") + 1);
        this._dataMaxLevel = options.dataMaxLevel;
    }

    /**
     * 开启注记
     * @param {Boolean} flag
     */
    setLabelOn(flag) {
        const v = flag == true
        this._labelOn = v;
        if (this._layersPaintersMap.get("Label_Icon"))
            this._layersPaintersMap.get("Label_Icon").visibility = v;
        if (this._layersPaintersMap.get("Label_Line"))
            this._layersPaintersMap.get("Label_Line").visibility = v;
        if (this._layersPaintersMap.get("Label_Point"))
            this._layersPaintersMap.get("Label_Point").visibility = v;
        this.getMap().af.active();
    }

    /**
     * 获取注记显示状态
     * @return {Boolean}
     */
    getLabelOn() {
        return this._labelOn;
    }

    /**
     * 更新图标图集
     * @param url 图集的路径：图标图集包含icons.png和icons.json 两部分
     *             比如：http://localhost/tj/icons.png 和 http://localhost/tj/icons.json
     *             那么url=http://localhost/tj/
     */
    updateIcons(url, updateTexture = true) {
        this.iconUrl = url;
        if (updateTexture) {
            this.updateTexture();
        }
        return this;
    }

    /**
     * 更新字体图集
     * @param url 图集的路径：字体图集包含sdf.png和sdf.json 两部分
     *             比如：http://localhost/tj/sdf.png 和 http://localhost/tj/sdf.json
     *             那么url=http://localhost/tj/
     */
    updateChars(url, updateTexture = true) {
        this.charsUrl = url;
        if (updateTexture) {
            this.updateTexture();
        }
        return this;
    }

    /**
     * 更新字符图集和图标图集，仅在字体图集和图标图集任一个有变更才有效，可以调用updateIcons(更新图标图集的路径)/updateChars(更新字体图集的样式）；
     */
    updateTexture() {
        this.iconTexture = this.iconUrl + "/icons.png";
        this.iconJson = this.iconUrl + "/icons.json";
        this.textTexture = this.charsUrl + "/chars.png";
        this.textJson = this.charsUrl + "/chars.json";
        this.textInfo = {};
        this.textInfo = {};
        this.iconInfo = {};
        this.iconInfo = {};
        const me = this;
        let qc = 0;
        let iconImage = hmap.util.Ajax.get(this.iconTexture, 'blob',
            blob => {
                const img = new Image(),
                    url = URL.createObjectURL(blob);
                img.onload = () => {
                    me.iconInfo.w = img.width;
                    me.iconInfo.h = img.height;
                    const painter = me.getPainterByKey("Label_Icon", "Label_Icon", me.iconWeight);
                    painter.glHelper.getTextureObject(me.iconTexture, 0).bufferImage(img, true);
                    qc++;
                    if (qc === 4) {
                        me.resourceLoaded = true;
                        this.prepareData();
                    }
                }
                img.src = url;

            });
        let textImage = hmap.util.Ajax.get(this.textTexture, 'blob',
            blob => {
                const img = new Image(),
                    url = URL.createObjectURL(blob);
                img.onload = () => {
                    me.textInfo.w = img.width;
                    me.textInfo.h = img.height;
                    const painter = me.getPainterByKey("Label_Point", "Label_Point", me.spriteText);
                    painter.glHelper.getTextureObject(me.textTexture, 0, {min_filter: "NEAREST"}).bufferImage(img, true);
                    qc++;
                    if (qc === 4) {
                        me.resourceLoaded = true;
                        me.prepareData();
                    }
                }
                img.src = url;

            });
        hmap.util.Ajax.get(this.textJson, 'json',
            text => {
                me.textJson = text;
                me.textInfo.buffer = text.buffer;
                me.textInfo.fontSize = text.fontSize;
                qc++;
                if (qc === 4) {
                    this.resourceLoaded = true;
                    this.prepareData();
                }

            });
        hmap.util.Ajax.get(this.iconJson, 'json',
            text => {
                qc++;
                me.iconJson = text;
                if (qc === 4) {
                    this.resourceLoaded = true;
                    this.prepareData();
                }

            });
    }

    /**
     * 获取地物大类对应的painter
     * @param key
     * @param styleType
     * @param weight
     * @return {any}
     * @private
     */
    getPainterByKey(key, styleType, weight) {
        if (!this._layersPaintersMap.get(key)) {//没有
            let painter;
            switch (styleType) {
                case "LineWidth":
                    painter = new hmap.core.painter.LinePainter(this, this._mergeExtra(this.extra, {
                        wideSolid: 0,
                        colorI: 0,
                        offset: 0
                    }));
                    break;
                case "DashLineWidth":
                    painter = new hmap.core.painter.LinePainter(this, this._mergeExtra(this.extra, {
                        dash: 0,
                        wideSolid: 0,
                        colorI: 0,
                        offset: 0
                    }));
                    break;
                case "Line":
                    painter = new hmap.core.painter.LinePainter(this, this._mergeExtra(this.extra, {
                        colorI: 0,
                        offset: 0
                    }));
                    break;
                case "DashLine":
                    painter = new hmap.core.painter.LinePainter(this, this._mergeExtra(this.extra, {
                        colorI: 0,
                        offset: 0,
                        dash: 0
                    }));
                    break;
                case 'Stretch':
                    painter = new hmap.core.painter.StretchPainter(this, this._mergeExtra(this.extra, {colorI: 0}));
                    break;
                case 'FillPolygon':
                    painter = new hmap.core.painter.FillPainter(this, this._mergeExtra(this.extra, {
                        fog: 0,
                        offset: 0,
                        colorI: 0
                    }));
                    break;
                case 'Label_Icon':
                    weight = this.iconWeight;
                    painter = new hmap.core.painter.SDFIconPainter(this, this._mergeExtra(this.extra, {
                        fog: 0,
                        offset: 1,
                        sprite: 0
                    }), {"textAtlas": this.textJson, "drawType": "drawArrays"});
                    break;
                case "Label_Line":
                    weight = this.polyText;
                    painter = new hmap.core.painter.SDFLineTextPainter(this, this._mergeExtra(this.extra, {
                        coordOffset: 0,
                        fog: 0,
                        texture2D: 0,
                        sdftext: 0,
                        colorI: 0
                    }), {"textAtlas": this.textJson, "painterType": "fill"});
                    break;
                case "Label_Point":
                    weight = this.spriteText;
                    painter = new hmap.core.painter.SDFPointTextPainter(this, this._mergeExtra(this.extra, {
                        fog: 0,
                        offset: 1,
                        sprite: 0,
                        sdftext: 0,
                        colorI: 0
                    }), {"textAtlas": this.textJson, "drawType": "drawArrays"});
                    break;
            }
            this._layersPaintersMap.set(key, painter);
            this._insertPainter(painter, weight);
            let ev = new hmap.event.Event("VectorTile_AddLayer");
            ev.key = key;
            this.event.dispatch(ev);
        }
        return this._layersPaintersMap.get(key);
    }

    /**
     * @private
     */
    _getStyleJson(url) {
        return new Promise(function (res, rej) {
            hmap.util.Ajax.get(url, "json",
                function (result) {
                    res(result);
                },
                function (error) {
                    rej(error);
                }
            );
        })
            .then(styleJson => {
                this._styleRuleMgr = new hmap.style.StyleRuleManager(styleJson);
            });
    }

    /**
     * 请求、组织瓦片数据
     * @private
     */
    prepareData() {
        //资源未加载完成不进行处理
        if (this._labelOn && !this.resourceLoaded) {
            return;
        }

        this._vtGroupToDraw.clear();//要绘制的tile数据池清空
        this.zoom = this.getServerZoomByRes();//this.getMap().getZoom();
        this.zoom = this.zoom <= this._dataMaxLevel ? this.zoom : this._dataMaxLevel;
        this.setXYZ(this.zoom);//组装XYZ网格标识
        this.addExterInfo();//为每个瓦片补充的信息
        let xyzs = [];

        // const zoom=this._map.getZoom();
        for (let i = 0, tileCount = this._tileBuffer.length; i < tileCount; i++) {
            const tile = this._tileBuffer[i],
                vtGroupUrl = tile.get('xyz'),
                subTiles = tile.get('subXYZ');
            this._vtGroupToDraw.add(vtGroupUrl);//准备绘制数据
            xyzs.push(vtGroupUrl);

            if (!this._vtGroupCache.has(vtGroupUrl)) {
                this._vtGroupCache.set(vtGroupUrl, new Set());

                for (let j = 0, l = subTiles.length; j < l; j++) {
                    const suburl = subTiles[j].url;
                    this._startOneRequestTask(suburl, this.zoom, vtGroupUrl);
                }
            } else {
                const painters = this._vtGroupCache.get(vtGroupUrl);
                this._vtGroupCache.delete(vtGroupUrl);
                this._vtGroupCache.set(vtGroupUrl, painters)
            }
        }
        // let a = new Date()
        // console.log(`${this._map.getZoom()}   ${a.getSeconds()}   ${a.getMilliseconds()}   ${xyzs}`)
        //检查缓存是否已满
        this.checkCacheSize();
    }

    /**
     * 发送一次ajax请求，取到返回的数据,封装成同步语法,将一个hvt资源请求回来-->解析-->绘制
     * @private
     */
    _startOneRequestTask(url, zoom, vtGroupUrl) {
        return fetch(url, {
            signal: this.signal,
            mode: 'cors',
            method: 'GET',
        })
            .then((response) => {
                if (response.status === 200) {
                    return response.arrayBuffer();
                }
            })
            .then((data) => {
                const vtile = hmap.format.Hvt.read(data);
                if (vtile) {
                    this.addVTile(vtile, zoom, vtGroupUrl);
                    //解析注记
                    if (this._labelOn) {
                        if (vtile.labels)
                            this._addLabel(vtile.labels, vtGroupUrl, zoom);
                    }
                    let ev = new hmap.event.Event(EventType.LAYEREVENT_LOADEND);
                    this._map.event.dispatch(ev);
                }
            })
            .catch(err => {
                // console.log(url + '   error   ' + err)
            })
    }

    /**
     * 添加注记信息
     * @param labels
     * @param key
     * @param zoom
     * @private
     */
    _addLabel(labels, key, zoom) {
        this.labels = JSON.parse(labels);
        this.renderLabel(key, zoom);
        this._filterLabel();
    }

    /**
     * 渲染注记
     * @param key
     * @param zoom
     * @private
     */
    renderLabel(key, zoom) {
        const label = this.labels;
        if (label.points.length > 0) {
            //this._addTexts(label.points,key,zoom);
            this._addIcons(label.points, key, zoom);
        }
        if (label.lines.length > 0) {
            this._addLineLabels(label.lines, key, zoom);
        }
        if (label.polygons.length > 0) {
            this._addTexts(label.polygons, key, zoom);
        }
    }

    /**
     * 图标和文字
     * @param icons
     * @param key
     * @param zoom
     * @private
     */
    _addIcons(icons, key, zoom) {
        for (let i = 0; i < icons.length; i++) {
            const text = icons[i];
            if (!text) {
                continue;
            }
            const attributes = {
                "featureType": text.featureType,
                "extent": text.extent,
                "text": text.text,
                "offset": text.offset,
                "weight": text.weight,
                showLabel: true,
                showIcon: true
            };
            const featureGeoJson = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: text.coord
                },
                properties: attributes,
            };
            featureGeoJson.id = text.id;
            const feature = this._geoJSON.readFeatureFromObject(featureGeoJson);
            const style = this._styleRuleMgr.getStyleByTypeLevel(text.featureType, zoom);
            if (!style) {
                continue;
            }
            feature.setStyle(style);
            feature.url = key;
            //添加文字
            const painterKey = "Label_Point";
            const styleType = "Label_Point";
            this._vtGroupCache.get(key).add(painterKey);
            const painter = this.getPainterByKey(painterKey, styleType, 400);
            painter.add(feature);
            //添加图标
            const painterKey1 = "Label_Icon";
            const styleType1 = "Label_Icon";
            this._vtGroupCache.get(key).add(painterKey1);
            const painter1 = this.getPainterByKey(painterKey1, styleType1, 500);
            painter1.add(feature);
        }
    }

    /**
     *  点文字
     * @param texts
     * @param key
     * @param zoom
     * @private
     */
    _addTexts(texts, key, zoom) {
        for (let i = 0; i < texts.length; i++) {
            const text = texts[i];
            // console.log(text)
            if (!text) {
                continue;
            }
            const attributes = {
                "extent": text.extent,
                "text": text.text,
                "offset": text.offset,
                "weight": text.weight,
                showLabel: true
            };
            const featureGeoJson = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: text.coord
                },
                properties: attributes,
            };
            featureGeoJson.id = text.id;
            const feature = this._geoJSON.readFeatureFromObject(featureGeoJson);
            const style = this._styleRuleMgr.getStyleByTypeLevel(text.featureType, zoom);
            if (!style) {
                continue;
            }
            feature.setStyle(style);
            feature.url = key;
            const painterKey = "Label_Point";
            const styleType = "Label_Point";
            this._vtGroupCache.get(key).add(painterKey);
            const painter = this.getPainterByKey(painterKey, styleType, 400);
            painter.add(feature);
        }
    }

    /**
     * 线文字
     * @param lineLables
     * @param key
     * @param zoom
     * @private
     */
    _addLineLabels(lineLables, key, zoom) {
        for (let i = 0; i < lineLables.length; i++) {
            const text = lineLables[i];
            const attributes = {
                "extent": text.extent,
                "text": text.text,
                "offset": text.offset,
                "angle": text.rotate,
                "weight": text.weight,
                showLabel: true
            };
            const featureGeoJson = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: text.coord
                },
                properties: attributes,
            };
            // featureGeoJson.id = text.id;
            const feature = this._geoJSON.readFeatureFromObject(featureGeoJson);

            const style = this._styleRuleMgr.getStyleByTypeLevel(text.featureType, zoom);
            if (!style) {
                continue;
            }
            feature.setStyle(style);
            feature.url = key;
            const painterKey = "Label_Line";
            const styleType = "Label_Line";
            this._vtGroupCache.get(key).add(painterKey);
            const painter = this.getPainterByKey(painterKey, styleType, feature.weight);
            painter.add(feature);
        }
    }

    /**
     * 添加一张矢量切片原始数据
     * @param {Object} vTile，矢量切片数据
     * @param {Number} zoom，当前显示级别
     * @param {String} vtGroupUrl   矢量切片的url
     * @private
     * @returns {Array}
     */
    addVTile(vTile, zoom, vtGroupUrl) {
        const result = [];

        //获取各种要素集合
        const layers = vTile.layers;
        //额外的配置信息,标识返回的要素类型，
        this._extraFlags = {featureType: {POINT: 1, LINE: 2, POLYGON: 3}};
        const types = this._extraFlags.featureType;
        for (let i = layers.length - 1; i >= 0; i--) {
            const features = layers[i].features;
            const keys = layers[i].keys;
            const values = layers[i].values;
            let layerName = layers[i].name;
            const style = this._styleRuleMgr.getStyleByTypeLevel(layers[i].name, zoom);
            if (!style) {
                continue;
            }

            //先判断layer类型，再处理具体的features
            if (features.length > 0) {
                const type = features[0].type;
                switch (type) {
                    case types.POINT://矢量切片hvt中已无icon和文字信息
                        break;
                    case types.LINE:
                        this._addvtLines(features, style, keys, values, layerName, vtGroupUrl);
                        break;
                    case types.POLYGON:
                        this._addvtPolygons(features, style, keys, values, vtGroupUrl, layerName);
                        break;
                    default:
                        break;
                }
            }
        }
        return result;
    }

    /**
     * 线数据解析
     * @param features
     * @param style
     * @param keys
     * @param values
     * @param layerName
     * @param vtGroupUrl
     * @private
     */
    _addvtLines(features, style, keys, values, layerName, vtGroupUrl) {
        const lineSymbols = style.getLineSymbols();
        for (let i = lineSymbols.length - 1; i >= 0; i--) {
            let lineSymbol = lineSymbols[i];

            if (!lineSymbol.display) { //隐藏了线
                continue;
            }
            const lineWidth = lineSymbol.getWidth();
            const lineStyle = lineSymbol.getLineStyle();
            let painter;
            let styleType;
            if (lineWidth > 1) {
                styleType = (lineStyle === 'solid') ? "LineWidth" : "DashLineWidth";
            } else {
                styleType = (lineStyle === 'solid') ? "Line" : "DashLine";
                // continue;//先不绘制细线
            }
            const painterKey = layerName + '_' + styleType;
            this._vtGroupCache.get(vtGroupUrl).add(painterKey);
            const weight = lineSymbol.weight;
            painter = this.getPainterByKey(painterKey, styleType, weight);
            for (let j = 0, jlen = features.length; j < jlen; j++) {
                const feature = features[j];
                this._addvtLine(painter, feature, style, vtGroupUrl, keys, values);
            }
        }
    }

    /**
     * 线要素解析
     * @param painter
     * @param feature
     * @param style
     * @param vtGroupUrl
     * @param keys
     * @param values
     * @private
     */
    _addvtLine(painter, feature, style, vtGroupUrl, keys, values) {
        const attributes = this._getFeatureAttributes(feature, keys, values),
            featureGeoJson = {
                type: "Feature",
                geometry: {
                    type: "LineString",
                    coordinates: []
                },
                properties: attributes,
            };
        featureGeoJson.geometry.coordinates = this._convertFlatToCoordArr(feature.geometry);
        featureGeoJson.id = feature.id;
        feature = this._geoJSON.readFeatureFromObject(featureGeoJson);
        feature.setStyle(style);
        feature.url = vtGroupUrl;
        painter.add(feature, false);
    }

    /**
     * 解析矢量切片中所有面数据
     * @param features
     * @param style
     * @param keys
     * @param values
     * @param url
     * @private
     */
    _addvtPolygons(features, style, keys, values, vtGroupUrl, layerName) {
        const polygonSymbol = style.getFillSymbols()[0];
        if (polygonSymbol) {
            const weight = polygonSymbol.weight;
            for (let j = 0, jLen = features.length; j < jLen; j++) {
                const feature = features[j],
                    attributes = this._getFeatureAttributes(feature, keys, values),
                    featureGeoJson = {
                        type: "Feature",
                        geometry: {
                            type: "Polygon",
                            coordinates: []
                        },
                        properties: attributes,
                    },
                    geometryArr = feature.geometry,
                    holeIndex = feature.holeIndex;

                if (holeIndex.length == 0) {
                    featureGeoJson.geometry.coordinates.push(this._convertFlatToCoordArr(geometryArr));
                } else {
                    //外环
                    featureGeoJson.geometry.coordinates.push(this._convertFlatToCoordArr(geometryArr.slice(0, holeIndex[0] * 3)));

                    //除外环和最后一个洞之外的洞
                    const l = holeIndex.length - 2;
                    for (let i = 0; i < l; i++) {
                        const fromIndex = holeIndex[i] * 3,
                            toIndex = holeIndex[i + 1] * 3;
                        featureGeoJson.geometry.coordinates.push(this._convertFlatToCoordArr(geometryArr.slice(fromIndex, toIndex)));
                    }

                    //最后一个洞
                    featureGeoJson.geometry.coordinates.push(this._convertFlatToCoordArr(geometryArr.slice((holeIndex[l + 1]) * 3)));
                }
                featureGeoJson.id = feature.id;
                // featureGeoJson.properties = attributes;

                const tempFeature = this._geoJSON.readFeatureFromObject(featureGeoJson);
                tempFeature.setStyle(style);
                tempFeature.url = vtGroupUrl;

                let styleType;
                //todo:当前矢量切片多边形，除了解析为拉伸体外，只有纯色填充，没有宽边框、纹理面等其他类型，如果以后有增加，需要补充
                if (style.stretch && attributes.hasOwnProperty('floor') && attributes.floor > 0) {
                    attributes.height = attributes.floor * 4;
                    attributes.surfaceColor = style.getFillSymbols()[0].getColor();
                    styleType = 'Stretch';
                } else {
                    styleType = 'FillPolygon';
                }
                tempFeature._painterType = hmap.core.painterType.STRETCH;
                const painterKey = layerName + '_' + styleType;
                this._vtGroupCache.get(vtGroupUrl).add(painterKey);

                const painter = this.getPainterByKey(painterKey, styleType, weight);
                painter.add(tempFeature, false);
            }
        }
    }

    _convertFlatToCoordArr(arr) {
        const res = [];
        for (let i = 0, l = arr.length / 3; i < l; i++) {
            res[i] = [arr[i * 3], arr[i * 3 + 1], arr[i * 3 + 2]];
        }
        return res;
    }

    _getFeatureAttributes(feature, keys, values) {
        //key和对应规则是直接从历史版本传下来的
        const tags = feature.tags,
            attr = {};
        for (let k = 0, kLen = tags.length / 2; k < kLen; k++) {
            const key = keys[tags[2 * k]];
            attr[key] = values[tags[2 * k + 1]].string_value;
        }
        return attr;
    }

    /**
     * 获取图层的分辨率
     * @returns {Array} 返回图层的分辨率数组
     * @example
     * vectileLayer.getResolutions();
     */
    getResolutions() {
        return this.getMap().getResolutions();
    }

    /**
     * 返回地图当前缩放级别的分辨率
     * @returns {Number} 地图在当前缩放级别的分辨率
     */
    getResolution() {
        return this.getMap().getResolution();
    }

    /**
     * 获取图层的类型hmap.layer.VectorTile
     * @returns {String} 返回图层的类型
     */
    getClassType() {
        return this.CLASS_NAME;
    }

    /**
     * 更新矢量切片图层的样式风格。
     * @param {String} styleUrl 样式文件地址,【Json格式】。
     * @param {Function} callback 矢量切片图层样式风格更新后的回调函数。
     * @example
     * vectilelayer.updateStyle("http://10.20.84.15:8080/mapStyle.json",function(){
     * });
     */
    updateStyle(styleUrl, callback = null) {
        this._styleJsonPromise = this._getStyleJson(styleUrl);
        const me = this;
        this._styleJsonPromise.then(function () {
            //设置背景色
            me._updateData();
            me.redraw(0);
            if (callback) {
                callback();
            }
        });
    }

    /**
     * 准备数据重绘
     * @private
     */
    _updateData() {
        this._updateMapData();
        for (let [vtGroupUrl, painterSet] of this._vtGroupCache.entries()) {
            for (let key of painterSet.keys()) {
                this._layersPaintersMap.get(key)._removeAll();
            }
            this._vtGroupCache.delete(vtGroupUrl);
        }
    }

    /**
     * 根据subType的值和是否选中的状态值，更新属性中的checked的值。
     * @param {String} subType
     * @param {Number} checkStatus
     */
    updateStatusBySubType(subType, checkStatus = 0) {
    }

    /**
     * 通过fid高亮点图标和文字
     * @private
     */
    updatePointStatusByFid(fid, checkStatus = 1) {
    }

    /**
     * 根据 级别 要素类更新styleMap对象(该方法暂未实现)
     * @private
     * @param subTypeArr
     * @param symbolsJson
     * @param level
     */
    updateStyleMapBySubtypes(subTypeArr, symbolsJson, level) {
    }

    /**
     * 更改要素样式(该方法暂未实现)
     * @private
     * @param feature
     * @param {Style} style 要素的样式对象
     */
    setStyle(feature, style) {

    }

    /**
     * 获取要素的样式（该方法暂未实现）
     * @private
     * @param  {hmap.layer.Vector} feature
     */
    getFeatureStyle() {

    }

    /**
     * 高亮要素（该方法暂未实现）
     * @param {hmap.feature.Vector} feature
     * @private
     */
    hightLightFeature(feature) {

    }

    /**
     * 根据像素位置拾取要素(该方法暂未实现)
     * @private
     * @param {hmap.basetype.Pixel} pixel
     */
    pickFeatureByPixel(pixel) {

    }

    /**
     * 根据地理坐标拾取要素，推荐使用Map.detectFeatureByPixel
     * @param {hmap.basetype.Coordinate} coord 地理坐标
     * @returns {Array} 多个地理要素的数组
     * @private
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30);
     * let features = vectilelayer.getFeaturesByCoord(coord);
     */
    getFeaturesByCoord(coord) {

        //TODO 拾取方案替换

    }

    /**
     * 设置矢量切片地址
     * @param {String} tile
     * @returns {string}
     */
    setTileUrl(xyz) {
        const [x, y, z] = xyz.split("-");//行列号标识
        return this.layerUrl + z + "\/" + x + "\/" + y + "." + this.dataFormat;
    }

    /**
     * @private
     */
    _updateMapData() {
        const data = this._styleRuleMgr.getStyleMap();
        const c = data.get("FOG").getFillSymbols()[0].getColor();
        const d = data.get("LAND").getFillSymbols()[0].getColor();
        this._map.setFogColor(c);
        this._map.setLandColor(d);
        // this.redraw();
    }

    /**
     * 将图层绑定到指定的map上
     * @private
     * @param {hmap.Map} map hmap的map对象
     * @example
     * vectilelayer.setMap(map); 功能和map.addLayer(vectilelayer)相同
     */
    setMap(map) {
        super.setMap(map);
        if (this._labelOn) {
            this.updateTexture();
            this._collisionLabel = new hmap.strategy.CollisionLabel(this._map);
            this._map.event.addListener(EventType.MAPEVENT_ROTATING, this._filterLabel.bind(this));
            this._map.event.addListener(EventType.MAPEVENT_EXTENTCHANGED, this._filterLabel.bind(this));
        }
        //图层extra
        this.extra = this._layerExtra();
        // this._vaoPoolCapacity = Math.ceil(this._vaoPoolCapacity / Math.pow(this._groupSideLength, 2));
        // this._vaoToDeleteOnce = Math.floor(this._vaoToDeleteOnce / Math.pow(this._groupSideLength, 2));
        //图层extra
        if (map.getCrs().getUnit() === "m") {
            this.heightFactor = 1;
        } else {
            this.heightFactor = 1 / 111000;
        }
        // this.getDepthStatus().setEnable(false);

        this._styleJsonPromise.then(() => {
            this._updateData();
            let ev = new hmap.event.Event(EventType.VECTORTILE_STYLELOADED);
            this.event.dispatch(ev);
            this.redraw(0);
        });
        this._dataMaxLevel = this._dataMaxLevel || this._map.getMaxZoom();
    }


    /**
     * 文字避让
     * @private
     */
    _filterLabel() {
        if (!this._map) return;
        this._collisionLabel.updateView(this._vtGroupToDraw, this._map.getZoom());
        const self = this;
        const painters = this._layersPaintersMap;
        painters.doTask = 1;
        hmap.core.TaskManager.instance().addFilterTask(this._collisionLabel, function (painters) {
            self._collisionLabel.filter(painters);
        }, painters);
        this._map.af.active();
    }

    /**
     * 绘制
     */
    draw() {
        if (!this._map) {
            return;
        }
        super.draw();
        this._draw();
    }

    /**
     * 绘制，重新设置参数
     * @private
     */
    _draw() {
        this.getDepthStatus().setEnable(false);
        super.draw();
        for (let i = 0, l = this._painters.length; i < l; i++) {
            const painter = this._painters[i];
            if (painter.visibility)
                painter.draw(this._vtGroupToDraw);
        }
    }

    /**
     * 获取图层类型
     * @returns {String} 图层类型
     * @example
     * let layerType = vectortileLayer.getLayerType();
     */
    getLayerType() {
        return "hmap.layer.VectorTileLayer";
    }

    /**
     * 检查_vtGroupCache是否已满，满则删除
     */
    checkCacheSize() {
        if (this._vtGroupCache.size < this._vaoPoolCapacity) {
            return;
        }
        let i = 0;
        for (let [vtGroupUrl, painterKeys] of this._vtGroupCache.entries()) {
            for (let painterKey of painterKeys.keys()) {
                const painter = this._layersPaintersMap.get(painterKey);
                painter.removeBlockById(vtGroupUrl);
            }
            this._vtGroupCache.delete(vtGroupUrl);
            if (++i === this._vaoToDeleteOnce) {
                break;
            }
        }
    }

    /**
     * painter排序
     * @param painter
     * @param weight
     * @private
     */
    _insertPainter(painter, weight) {
        painter.weight = weight;
        this._painters.push(painter);
        this._painters.sort((p1, p2) => {
            return p1.weight - p2.weight;
        });
    }

    /**
     * 射线法拾取
     * @param ray
     * @private
     */
    raycasterIntersect(ray) {
        const features = [];
        const hitCoord = ray.getHitCoordinate();
        const tileInfo = this.getTileInfo(hitCoord);
        if (!tileInfo) return features;
        let [x, y, z] = [tileInfo.col * 1, tileInfo.row * 1, this.zoom];
        if (this._groupSideLength > 1) {
            x = Math.floor(x / this._groupSideLength);
            y = Math.floor(y / this._groupSideLength);
        }
        const id = this._getXYZ(x, y, z);
        this._layersPaintersMap.forEach((value, key) => {
            const block = value.getBlockById(id);
            if (block) {
                features.push.apply(features, block.features);
            }
        });
        return features;
    }

    /**
     * 设置图层不透明度。
     * 0表示完全透明，1表示完全不透明。从0到1，越来越不透明。
     * @param {Number} opacity 图层透明度，介于0~1之间。
     */
    setOpacity(opacity = 1) {
        this._opacity = opacity;

        for (let value of this._layersPaintersMap.values()) {
            value.opacity = this._opacity;
        }

        this.redraw();
    }

    /**
     * 计算瓦片标识
     * @private
     */
    setXYZ(z) {
        //因图层重绘的需要，清空tileBuffer内容,重新计算
        this._tileBuffer = [];
        const arrY = this.rangeRow(z);
        const arrX = this.rangeCol(z);
        //为X列Y行个瓦片配置标识
        for (let x = arrX.maxX - 1; x >= arrX.minX; x--) {
            for (let y = arrY.maxY - 1; y >= arrY.minY; y--) {
                let tile = new Map();
                let {subXYZ} = this._getSubXYZ(x, y, z);
                tile.set("xyz", this._getXYZ(x, y, z));
                tile.set('subXYZ', subXYZ);
                this._tileBuffer[this._tileBuffer.length] = tile;
            }
        }
    }
};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 地图叠加物图层。随着叠加物数量增多，渲染性能会有明显下降。
 * @type {hmap.layer.OverlayLayer}
 */
hmap.layer.OverlayLayer = class{
    /**
     * 构造函数。用来创建一个地图叠加物图层
     * @param {String} name 图层名称
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @param {hmap.Map} options.map 可选项。地图对象，该参数设置将叠加物图层绑定到指定的map上，若不传则默认为空。
     * @param {Boolean} options.visibility  可选项。图层显示或隐藏。显示设置true；隐藏设置false。
     * @example
     * let overlayLayer = new hmap.layer.OverlayLayer("叠加物图层");
     */
    constructor (name, options) {
        options = options || {};
        this.CLASS_NAME = "hmap.layer.OverlayLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.name = name;
        this._map = null;
        this._overlayMap = new Map();
        this._overlayToAdd = [];//保存没有地图时，预加载的弹框
        this.container = null;
        this._visibility = options.hasOwnProperty("visibility") ? options['visibility'] : true;
    }

    /**
     * 获取图层名称
     *  
     */
    getName(){
        return this.name;
    }
    /**
     * 获取叠加图层的id
     * @returns {*}
     */
    getId(){
        return this._id;
    }
    /**
     * 添加单个叠加物
     * @param {hmap.overlay.Overlay} overlay 要添加的叠加物
     * @returns {hmap.layer.OverlayLayer} 返回设置后的叠加物图层
     * @throws 当参数不是hmap.overlay.Overlay时发生
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content
     * });
     * overlayLayer.addOverlay(overlay);
     */
    addOverlay (overlay) {
        if (overlay instanceof hmap.overlay.Overlay) {
            //判断：如果叠加物已经存在图层上，则不能重复添加
            for(let item of this._overlayMap.values()) {
                if (overlay === item) {
                    return this;
                }
            }
            if(this._map){
                overlay.setLayer(this);
                this._overlayMap.set(overlay._id, overlay);                
            }else{
                this._overlayToAdd.push(overlay);
            }

        } else {
            throw new TypeError("The parameter must be hmap.overlay.Overlay");
        }
        return this;
    }

    /**
     * 添加多个叠加物
     * @param {Array<hmap.overlay.Overlay>} overlays 要添加的叠加物数组
     * @returns {hmap.layer.OverlayLayer} 返回设置后的叠加物图层
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content
     * });
     * let overlayLayer = overlayLayer.addOverlays([overlay]);
     */
    addOverlays(overlays){
        if(overlays && overlays.length>0){
            for(let overlay of overlays){
                this.addOverlay(overlay);
            }
        }
        return this;
    }

    /**
     * 根据属性值里的domId值获取overlay,
     * @param {string} domId 叠加物id
     * @returns {Array<hmap.overlay.Overlay>} 返回叠加物数组
     * @throws 当参数不是字符串时发生
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content
     * });
     * overlayLayer.addOverlays([overlay]);
     * let overlays = overlayLayer.getOverlaysByDomId("domId")；
     */
    getOverlaysByDomId (domId) {
        if (typeof domId === "string") {
            let overlayArr = [];
            const values = this._map?this._overlayMap.values():this._overlayToAdd;
            for(let value of values) {
                if (value.getDomId() === domId) {
                    overlayArr.push(value);
                }
            }
            return overlayArr;
        } else {
            throw new TypeError("The parameter must be String");
        }
    }

    /**
     * 根据自定义属性获取overlay
     * @param {string} key 键
     * @param {string} value 键对应的值
     * @returns {Array} overlay数组
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content,
     *      "name":"popup1"//自定义key-value
     * });
     * overlayLayer.addOverlays([overlay]);
     * let overlays = overlayLayer.getOverlayByAttribute("name","popup1")；
     */
    getOverlayByAttribute (key, value) {
        const values = this._map?this._overlayMap.values():this._overlayToAdd;
        let overlayArr = [];
        for(let item of values) {
            if (item.get(key) === value) {
                overlayArr.push(item);
            }
        }
        return overlayArr;
    }

    /**
     * 获取图层上所有的叠加物对象
     * @returns {Array<hmap.overlay.Overlay>} 所有叠加物对象的数组
     * @example
     * let overlayArr = overlayLayer.getAllOverlays();
     */
    getAllOverlays () {
        return this._map?[...this._overlayMap.values()]:this._overlayToAdd;
    }

    /**
     * 移除图层上所有的叠加物对象
     * @returns {Number} 返回移除的叠加物数量
     * @example
     * overlayLayer.removeAllOverlays();
     */
    removeAllOverlays () {
        let count = 0;
        const values = this._overlayMap.values();
        for(let value of values) {
            count++;
            this.container.removeChild(value._container);
            value._layer = null;
        }
        this._map._onMap = true;
        this._overlayMap.clear();

        count += this._overlayToAdd.length;
        this._overlayToAdd = [];
        return count;
    }

    /**
     * 移除图层上单个叠加物对象
     * @param {hmap.overlay.Overlay} overlay 叠加物对象
     * @returns {Number} 返回移除的叠加物数量
     * @throws 当用户传的值不属于hmap.overlay.Overlay时发生
     * @example
     * overlayLayer.removeOverlay(overlay);
     */
    removeOverlay (overlay) {
        if (overlay instanceof hmap.overlay.Overlay) {
            const id = overlay._id;
            if (this._overlayMap.has(id)) {
                this._overlayMap.delete(id);
                this.container.removeChild(overlay._container);
                overlay._layer = null;

                //删除预加载叠加物
                const index = this._overlayToAdd.indexOf(overlay);
                if (index > -1) {
                    this._overlayToAdd.splice(index, 1);
                }
                return 1;
            }
            return 0;
        } else {
            throw new TypeError("The parameter must be hmap.overlay.Overlay");
        }
    }

    clearFogAndLand(){

    }

    /**
     * 根据自定义属性删除叠加物对象
     * @param {string} key 键
     * @param {string} value 键对应的值
     * @returns {Number} 返回删除的叠加物数量
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content,
     *      "name":"popup1"//自定义key-value
     * });
     * overlayLayer.addOverlays([overlay]);
     * overlayLayer.removeOverlaysByAttribute("name","popup1");
     */
    removeOverlaysByAttribute (key, value) {
        const overlays = this._map?this._overlayMap.values():this._overlayToAdd;
        let count = 0;
        for(let item of overlays) {
            if (item.get(key) === value) {
                count++;
                this.container.removeChild(item._container);
                this._overlayMap.delete(item._id);
                item._layer = null;
            }
        }
        return count;
    }

    /**
     * 根据过滤方法删除叠加物对象
     * @param {Function} filterFunction 过滤方法
     * @returns {Number} 返回删除的叠加物数量
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let overlay = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content,
     *      "name":"popup1"//自定义key-value
     * });
     * overlayLayer.addOverlays([overlay]);
     * overlayLayer.removeOverlaysByFilter (function(overlay){
     *       if(overlay.get("name") == "popup1"){
     *           return true;//返回true，表示删除；
     *       }
     * });
     */
    removeOverlaysByFilter (filterFunction) {
        const overlays = this._map?this._overlayMap.values():this._overlayToAdd;
        let count = 0;
        for(let item of overlays) {
            let result = filterFunction(item);
            if (result === true) {
                count++;
                this.container.removeChild(item._container);
                this._overlayMap.delete(item._id);
                item._layer = null;
            }
        }
        return count;
    }
    refresh(){
        this.redraw();
    }

    /**
     * 重新绘制
     */
    redraw(){
        this.draw();
    }
    /**
     * 叠加物图层重绘
     * @private
     */
    draw () {
        if(this._map){
            const items = this._overlayMap.values();
            for(let item of items) {
                item._reAdjust();
            }
        }else{
            throw new TypeError("The map must be set");
        }
    }

    /**
     * 设置图层的map属性，将图层添加到map上
     * @private
     * @param {hmap.Map} map 地图对象
     */
    setMap (map) {
        if (!(map instanceof hmap.Map)) {
            throw new TypeError("The parameter must be hmap.Map");
        }
        this._map = map;
        this.container = document.createElement("div");
        this.container.style.position = "absolute";
        this.container.style.width = "100%";
        this.container.style.height = "100%"; 
        this.container.style.display = (this._visibility===true)?"block":"none";
        this.container.addEventListener("mouseover", function(event) {
            window.getSelection ? window.getSelection().removeAllRanges() : this._popupDom.selection.empty();
            this.container.style.userSelect = "none";
        }.bind(this));
        map.container.appendChild(this.container);

        // 添加预加载的overlay
        for(let overlay of this._overlayToAdd){
            overlay.setLayer(this);
            this._overlayMap.set(overlay._id, overlay);  
        }
        this._overlayToAdd=[];
    }

    /**
     * 获取拥有该图层的地图对象。
     * @return {hmap.Map} 地图对象
     * @example
     * let map = overlayLayer.getMap();
     */
    getMap () {
        return this._map;
    }

    /**
     * 设置图层的可见性。
     * 仅设置该图层是否可见，而图层本身依然存在。
     * @param {Boolean} visible 是否可见.可见设置true;不可见设置false
     * @returns {hmap.layer.OverlayLayer} 返回设置后的叠加物图层
     * @example
     * overlayLayer.setVisibility(false);
     */
    setVisibility(visible = true) {
        if (!(typeof(visible) === "boolean")) {
            throw new TypeError("visible must be boolean type!");
        }
        if(this._visibility !== visible){
            this._visibility = visible;
            if(this._map){
                this.container.style.display = (visible===true)?"block":"none";
            }
        }
        return this;
    }

    setLayerZIndex(zindex){
        if(this.container){
            this.container.style.zIndex = zindex;
        }
    }

    getLayerZIndex(){
        if(this.container){
            return this.container.style.zIndex;
        }
    }
    destroy(){

    }

};
;"use strict";
hmap.layer = hmap.layer || {};

/**
 * 3D矢量图层，可以添加矢量3D模型，暂时只支持添加拉伸体模型，后续会根据需要添加对其他矢量3D模型的支持。
 * 由于hmap.model.Stretch对象的特殊性，该图层暂时支持添加10万个Stretch，数据量更大时，可能会内存溢出导致页面崩溃，请谨慎使用。
 * @type {hmap.layer.Vector3dLayer}
 * @extends hmap.layer.Layer
 * @private
 */
hmap.layer.Vector3dLayer = class extends hmap.layer.Layer {

    /**
     * 构造函数
     * @param options 选项，包含构造hmap.layer.Layer时的options选项
     * @param {Boolean} options.cached 是否启用WebGl缓存
     */
    constructor(options = {}) {
        super(options);
        this._cached = options.cached !== false;
        this.CLASS_NAME = 'hmap.layer.Vector3dLayer';
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : this.enableHashCode;
        this.strict = options.hasOwnProperty("strict") ? options.strict : false; //是否采用高精确拾取（暂不公开）
        this._vector3dsToAdd = new Map();

        this.renders = {
            stretchRender: null,
        };
    }

    /**
     * 添加多个3d矢量要素 包含：拉伸体，参见{hmap.model.Stretch}。
     * @param {Array<Object>} vector3ds 由支持的3D要素类型构成的数组。
     * @example
     * let stretch1 = new hmap.model.Stretch(vector1)
     * let stretch2 = new hmap.model.Stretch(vector2)
     * let vector3dLayer = new hmap.layer.Vector3dLayer()
     * vector3dLayer.addVector3ds([stretch1, stretch2])
     */
    addVector3ds(vector3ds) {
        vector3ds.forEach(vector3d => this.addVector3d(vector3d));
    }

    /**
     * 添加一个3d矢量要素，包含：拉伸体，参见{hmap.model.Stretch}。
     * @param {Object} vector3d 支持{hmap.model.Stretch}。
     * @example
     * let stretch1 = new hmap.model.Stretch(vector1)
     * let vector3dLayer = new hmap.layer.Vector3dLayer()
     * vector3dLayer.addVector3d(stretch1)
     */
    addVector3d(vector3d) {
        let id = vector3d.getId();

        if (!this._map) {
            this._vector3dsToAdd.set(id, vector3d);
        } else {
            if (vector3d instanceof hmap.model.Stretch) {
                this.renders.stretchRender.addStretch(vector3d.dataMap);
                if (this.enableHashCode) {
                    this.layerOctree.put({box: vector3d.getBBox(), id: vector3d.getId()})
                }
            }
        }
    }

    /**
     * 删除所有3D对象
     * @example
     * let stretch1 = new hmap.model.Stretch(vector1)
     * let stretch2 = new hmap.model.Stretch(vector2)
     * let vector3dLayer = new hmap.layer.Vector3dLayer()
     * vector3dLayer.addVector3ds([stretch1, stretch2])
     * vector3dLayer.removeAll()
     */
    removeAll() {
        this._vector3dsToAdd.clear();
        this.renders.stretchRender.removeAllFeatures();
        if (this.enableHashCode) {
            this.layerOctree.clear()
        }
    }

    /**
     * 删除多个3D对象
     * @example
     * let stretch1 = new hmap.model.Stretch(vector1);
     * let stretch2 = new hmap.model.Stretch(vector2);
     * let stretch3 = new hmap.model.Stretch(vector3);
     * let vector3dLayer = new hmap.layer.Vector3dLayer();
     * vector3dLayer.addVector3ds([stretch1, stretch2, stretch3]);
     * vector3dLayer.removeVector3ds([stretch1, stretch2]);
     */
    removeVector3ds(vector3ds) {
        vector3ds.forEach(vector3d => this.removeVector3d(vector3d));
    }

    /**
     * 移除指定的3D对象
     * @param {hmap.feature.Vector} vector3d 地理要素对象
     * @example
     * let stretch1 = new hmap.model.Stretch(vector1)
     * let stretch2 = new hmap.model.Stretch(vector2)
     * let vector3dLayer = new hmap.layer.Vector3dLayer()
     * vector3dLayer.addVector3ds([stretch1, stretch2])
     * vector3dLayer.removeVector3d(stretch1)
     */
    removeVector3d(vector3d) {
        let id = vector3d.getId();
        if (this._vector3dsToAdd.has(id)) {
            this._vector3dsToAdd.delete(id);
            if (this.enableHashCode) {
                this.layerOctree.remove({box: vector3d.getBBox(), id: id})
            }
        } else {
            if (vector3d instanceof hmap.model.Stretch) {
                this.renders.stretchRender.deleteFeatureByFid(id);
            }
        }
    }

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} map 地图对象
     */
    setMap(map) {
        super.setMap(map);
        // const posSize = this._isRTE ? 6 : 3;
        if (this.enableHashCode) {
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }

        // 地理坐标和深度的精度补偿
        const rendererOptions = {
            mapUnit: map.getCrs().getUnit(),
            isRTE: this._isRTE,
            isLGD: this._isLGD,
            event: this.event,
            cached: this._cached,
        };
        // 暂时只实例hmap.renderer.StretchRender
        // 如果有其他Render时，在此创建出来
        this.renders.stretchRender = new hmap.renderer.StretchRender(this.gl, rendererOptions);
        this._vector3dsToAdd.forEach(vector3d => {
            if (vector3d instanceof hmap.model.Stretch) {
                this.renders.stretchRender.addStretch(vector3d.dataMap);
                if (this.enableHashCode) {
                    this.layerOctree.put({box: vector3d.getBBox(), id: vector3d.getId()})
                }
            }
        })
        this._vector3dsToAdd.clear();
    }

    /**
     * 重绘
     * @private
     */
    draw() {
        super.draw();
        const vpMatrix = this._map.getVPMatrix();
        let rteOptions = {
            camera: this._map.getCamera().getCoordinate(),
            mvMatrix: this._map.getViewMatrix(),
            projMatrix: this._map.getProjMatrix()
        };
        let farPlaneD = this._map.getCamera().getFPlaneDistance();
        for (let renderName in this.renders) {
            this.renders[renderName].setVpMatrix(vpMatrix);
            this.renders[renderName].setRTE(rteOptions);
            this.renders[renderName].setLGD({farPlaneD});
            this.renders[renderName].setOpacity(this._opacity);
            this.renders[renderName].setFogColor(this._map.getFogColor());
            this.renders[renderName].setFogDist(this._map.getFogDist());
        }
        if (this._visibility) {     //可见状态
            for (let renderName in this.renders) {
                this.renders[renderName].render();
            }
        }
    }

    /**
     * 获取图层类型
     * @returns {String} 图层类型
     * @example
     * let layerType = vector3dLayer.getLayerType();
     */
    getLayerType() {
        return "hmap.layer.Vector3dLayer";
    }
}
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * FBX模型图层
 * @type {hmap.layer.FbxModelLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.FbxModelLayer = class extends hmap.layer.Layer {
    /**
     * 构造一个图层.
     * @param {String} name 图层名称
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @example
     * let fbxModelLayer = new hmap.layer.FbxModelLayer("FBX模型图层");
     */
    constructor(name, options={}) {
        super(options);
        this.CLASS_NAME = "hmap.layer.FbxModelLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.name = name;
        this._map = null;
        this._modelMap = new Map();//保存model对象
        this._modelToAdd = new Map();//在没有设置map属性时，临时存放的model元素
        this._modelPromises = [];
        this._isLGD = false;
        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : this.enableHashCode;//是否拾取
        this.strict = options.hasOwnProperty("strict") ? options.strict : false; //是否采用高精确拾取（暂不公开）
    }

    /**
     * 返回该类的类型
     * @returns {String} 返回图层类型
     * @example
     * fbxModelLayer.getLayerType()
     */
    getLayerType() {
        return this.CLASS_NAME;
    }

    /**
     * 将图层绑定到指定的map上
     * @private
     * @param {hmap.Map} map 地图对象
     * @example
     * fbxModelLayer.setMap(map);
     */
    setMap(map) {
        super.setMap(map);

        // 地理坐标和深度的精度补偿
        const rendererOptions = {
            mapUnit: map.getCrs().getUnit(),
            isRTE: this._isRTE,
            isLGD: this._isLGD,
            event: this.event,
            layer: this,
        };
        if (map && this.enableHashCode) {
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }

        this._fbxRender = new hmap.renderer.FbxRender(this.gl, rendererOptions);

        // 添加临时存放的model元素
        this._storedModels();
    }

    _storedModels() {
        this._modelToAdd.forEach(function (model, index, models) {
            this._modelMap.set(model.getMid(), model);
            this._addModel(model);
        });
        this._modelToAdd.clear();
    }

    // 可以将obj模型和fbx模型合并到一个renderer类下，不同的program来管理
    _addModel(model) {
        let modelPromise=this._fbxRender.addFbxModel(model);
        this._modelPromises.push(modelPromise);
        let flag=this;
        modelPromise.then(function () {
            if (flag.enableHashCode) {
                for (let i = 0, len = model.modelData.length; i < len; i++) {
                    let mesh = model.modelData[i];
                    mesh._id=model._id;
                    if (mesh._bbox) {
                        flag.layerOctree.put(mesh)
                    }
                }
            }
        })
    }

    /**
     * 添加单个模型
     * @param {hmap.model.FbxModel} model 单个模型对象
     * @example
     * fbxModelLayer.addModel(model);
     */
    addModel(model) {
        if (this._map) {
            this._modelMap.set(model.getMid(), model);
            this._addModel(model);
        } else {
            this._modelToAdd.set(model.getMid(), model);
        }
        if(this._map){
            this._map.af.active();
        }
    }

    /**
     * 删除所有fbx模型
     * @example
     * fbxModelLayer.removeAllModels();
     */
    removeAllModels() {
        this._modelMap.clear();
        this._modelToAdd.clear();
        this._fbxRender.removeAllModels();
        if (this.enableHashCode) {
            this.layerOctree.clear();
        }
        if(this._map){
            this._map.af.active();
        }
    }

    /**
     * 删除单个fbx模型
     * @param {hmap.model.FbxModel} model 要删除的模型对象
     * @example
     * fbxModelLayer.removeModel(model);
     */
    removeModel(model) {
        let mid = model.getMid();
        this._modelMap.delete(mid);
        this._modelToAdd.delete(mid);
        this._fbxRender.removeModelById(mid);
        if (this.enableHashCode) {
            this.layerOctree.removeById(mid)
        }
        if(this._map){
            this._map.af.active();
        }
    }

    /**
     * 执行图层的绘制
     * @private
     */
    draw() {
        super.draw();
        Promise.all(this._modelPromises).then(function () {
            this._fbxRender.setVpMatrix(this._map.getVPMatrix());//this.uniformPublic.u_mvpMatrix
            this._fbxRender.setOpacity(this._opacity);
            this._fbxRender.setRTE({
                camera: this._map.getCamera().getCoordinate(),
                mvMatrix: this._map.getViewMatrix(),
                projMatrix: this._map.getProjMatrix(),
            });
            this._fbxRender.setLGD({"farPlaneD":this._map.getCamera().getFPlaneDistance()});
            this._fbxRender.render();
        }.bind(this));
    }

};
;"use strict";
hmap.layer = hmap.layer || {};
/**
 * GLTF模型图层
 * @type {hmap.layer.GLTFLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.GLTFLayer = class extends hmap.layer.Layer {
    /**
     * 构造一个图层.
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @example
     * let options = {
            enableHashCode:false,//是否开启拾取
            isRTE:false, //是否对地理坐标进行精度补偿
     * };
     * let gltfModelLayer = new hmap.layer.GLTFLayer(options);
     */
    constructor(options={}) {
        super(options);
        this.CLASS_NAME = "hmap.layer.GLTFLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._map = null;
        this._render = null;
        this._flag = {add: false, end: true, promises: [], promiseCount: 0};//用来存储使用promise的状态
        this.enableHashCode = options.hasOwnProperty("enableHashCode") ? options.enableHashCode : this.enableHashCode;
        this.strict = options.hasOwnProperty("strict") ? options.strict : false; //是否采用高精确拾取（当前无效）
    }

    /**
     * 获取图层类型
     * @return {String} 图层类型
     * @example
     * let layerType = gltfModelLayer.getLayerType();
     */
    getLayerType(){
        return this.CLASS_NAME;
    }

    /**
     * 将图层绑定到指定的map上
     * @private
     * @param {hmap.Map} _map 地图对象
     * @example
     * gltfModelLayer.setMap(map);
     */
    setMap(_map) {
        super.setMap(_map);
        this._render = new hmap.renderer.GLTFRender(this.gl);
        if (map && this.enableHashCode) {
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }
    }

    /**
     * @private
     */
    addGLTF3Dtile(gltf,modelMatrixOpts){
        if(!this._map)return;
        let modelMatrix;
        if(modelMatrixOpts instanceof hmap.util.Matrix4){
            modelMatrix=modelMatrixOpts;
        }else{
            modelMatrix=this._setModelMatrix(modelMatrixOpts.trans,modelMatrixOpts.scale,modelMatrixOpts.rotate);
        }
        this._render.addGLTF(gltf,modelMatrix);
    }

    /**
     * 图层上添加gltf模型
     * @param {hmap.model.gltf.GLTF} gltf 模型对象
     * @return {hmap.layer.GLTFLayer} 返回图层对象
     * @example
     * let gltf = new hmap.model.gltf.GLTF("model.gltf");
     * gltfModelLayer.addGLTF(gltf);
     */
    addGLTF(gltf) {
        if (!this._map) return;
        const modelMatrix = gltf.modelMatrix;

        const promise = gltf.getPromiseGLTF();
        this._flag.add = true;
        this._flag.end = false;
        this._flag.promises.push(promise);
        this._flag.promiseCount++;
        promise.then((gltfData) => {
            this._render.addGLTF(gltfData, modelMatrix,this.layerOctree);
            this._flag.promiseCount--;
            if (this._flag.promiseCount === 0) {
                this._flag.add = false;
                this._flag.end = true;
            }
            if(this._map){
                this._map.af.active();
            }
        });
        return this;
    }

    /**
     * 通过id删除图层上的gltf模型
     * @param {String} id 模型对象的id值
     * @return {hmap.layer.GLTFLayer} 返回图层对象
     * @example
     * let id = gltf.getId();
     * gltfModelLayer.removeGLTFById(id);
     */
    removeGLTFById(id){
        // if(this._render.gltfMap.has(id)){
            this._render.gltfMap.delete(id);
            this._render.modelMap.delete(id);
            this.layerOctree.removeById(id);
            return this;
        // }
    }

    /**
     * 通过id获取图层上的gltf模型对象
     * @param {String} id 模型对象的id值
     * @return {hmap.model.gltf.GLTF} 返回模型对象
     * @example
     * let id = gltf.getId();
     * gltfModelLayer.getGLTFById(id);
     */
    getGLTFById(id){
        if(this._render.gltfMap.has(id)){
            return this._render.gltfMap.get(id);
        }
        return null;
    }

    /**
     * 删除图层上所有的gltf模型
     * @return {hmap.layer.GLTFLayer} 返回图层对象
     * @example
     * gltfModelLayer.removeAll();
     */
    removeAll(){
        this._render.gltfMap.clear();
        this._render.modelMap.clear();
        this.layerOctree.clear();
        return this;
    }

    /**
     * @private
     */
    _setModelMatrix(trans = [0, 0, 0], scale = [1, 1, 1], rotate = [0, 0, 0]) {
        return new hmap.util.Matrix4()
            .translate(trans[0], trans[1], trans[2])
            .scale(scale[0], scale[1], scale[2])
            .rotate(rotate[0], 1,0,0).rotate(rotate[1],0,1,0).rotate(rotate[2],0,0,1);
    }

    /**
     * 通过id获取图层上的gltf模型对象，重置该模型的变换矩阵
     * @private
     * @param {String} id 模型对象的id值
     * @param {hmap.util.Matrix4} modelMatrixOpts 模型对象的变换矩阵
     * @return {hmap.layer.GLTFLayer} 返回图层对象
     * @example
     * gltfModelLayer.resetModelMatrixById(id, modelMatrixOpts);
     */
    resetModelMatrixById(id, modelMatrixOpts) {
        const flag = this._render.modelMap.has(id);
        if (flag) {
            let modelMatrix;
            if (modelMatrixOpt instanceof hmap.util.Matrix4) {
                modelMatrix = modelMatrixOpts;
            } else {
                modelMatrix = this._setModelMatrix(modelMatrixOpts.trans, modelMatrixOpts.scale, modelMatrixOpts.rotate);
            }
            this._render.modelMap.set(id, modelMatrix);
        }
        return this;
    }

    /**
     * 图层绘制
     * @private
     */
    draw() {
        super.draw();
        this._render.setVPMatrix(this._map.getVPMatrix());
        this._render.setOpacity(this._opacity);
        let me = this;
        if (this._flag.add && !this._flag.end) {
            return Promise.all(me._flag.promises).then(function (datas) {
                me.redraw();
            });
        } else {
            me._render.render();
        }
    }
};
;"use strict";
hmap.layer=hmap.layer||{};
/**
 * 支持3dtiles数据格式的显示，但该类是实验功能，请谨慎使用。
 * @type {hmap.layer.Tile3DLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.Tile3DLayer=class extends hmap.layer.Layer{
    /**
     * @param {String} name 图层名称
     * @param {String} tilesetUrl tileset文件的路径
     * @param {Object} options 可选项
     */
    constructor(name,tilesetUrl,options={}){
        super(options);
        this.CLASS_NAME="hmap.layer.Tile3DLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        this.name = name;
        this._tilesetUrl=tilesetUrl;
        this.matrix = options.matrix ? options.matrix : new hmap.util.Matrix4();
        this.tileset = undefined;           //初始化tileset为undefined

        this._b3dms=[];
        let matrixArr = this.matrix.getElements(),position = [matrixArr[12],matrixArr[13],matrixArr[14]];
        let maxZoom = options.maxZoom,minZoom = options.minZoom;
        this.tilesetPromise = new hmap.format.Tile3DLoader({url: this._tilesetUrl,center:position,maxZoom:maxZoom,minZoom:minZoom}).load();
        this.tileBranches = [];

        this.initTileBranches();                //初始化切片分支

        this.tileTree = new Map();             //保存切片分支下需要请求的切片

        this.rootInit = false;              //根节点是否已经缓存
        this.rootRequest = false;           //根节点是否开始请求
        this.rootCache = new Map();         //根节点的缓存，区别于切片缓存，根节点缓存不会删除

        this.tileCache = new Map();         //切片缓存，缓存上一屏和当前屏
        this.gltfQuene = [];                //表示gltf的缓存顺序，保存的是gltf的id

        this.cacheCapacity = 100;           //可以缓存的gltf的最大数量
    }

    setMap(map){
        super.setMap(map);
        this._renderer=new hmap.renderer.GLTFRender(this.gl);
    }

    // 得到所有的tiles
    getTileBranches(){
        this.tileBranches = [];//记录所有切片
    }

    clearFogAndLand(){

    }

    setFogAndLand(){

    }

    /**
     *  初始化切片分支
     * */
    initTileBranches(){
        let me = this;
        me.tilesetPromise.then(function(tileset){
            me.tileset = tileset;
            let tileTree = tileset.getTileTree();
            for(let i =0;i<tileTree.children.length;i++){
                let branch = tileTree.children[i];
                me.tileBranches.push(branch);
            }
        })
    }

    /**
     * 获取所有需要请求的切片
     * */
    getRequestTiles(){
        let requestDepth = this.tileset.getRequestDepth(map.getZoom());       //请求的深度
        let branches = this.getTileBranches();      //内容为tileset格式的Tile3D
        for(let i=0;i<branches.length;i++){
            let branch = branches[i],tiles = [];
            branch.getRequestTiles(requestDepth,tiles);
        }
    }

    /**
     * 根据gltf的id删除切片
     * */
    deleteTileByGltfId(){

    }

    /**
     * 清除缓存
     * */
    clearCache(){

    }

    deletePartCache(){

    }

    /**
     * 初始化每张切片的根节点的切片
     * */
    initRootTile(){
        let me = this, imagePromises = [];
        const tiles = this.tileBranches;
        for(let tile of tiles){
            let features = [],tileUrl = tile.tileUrl;
            tile.getRequestTiles(0,features);
            features.map(function(feature){
                let imagePromise = new Promise(function(resolve){
                    feature.requestContent();
                    feature.hasRequest = true;
                    feature.tileContentReadyPromise.then(function(b3dm){
                        /*let modelMatrix = b3dm.getModelMatrix();
                        matrix.setPosition(new hmap.util.Vector3(120.1884,30.18251,0))
                        matrix.scale(0.00001,0.00001,0.00001);
                        matrix.rotate(-90,0,1,0);*/
                        let matrix = me.matrix;
                        let gltfJson = b3dm.getGltf();
                        let gltfLoader = new hmap.model.gltf.GLTF("3dtile0627");
                        let gltf = gltfLoader.parse3DtileGltf(gltfJson);
                        Promise.all(gltf.images).then(function () {
                            me._renderer.addGLTF(gltf,matrix);
                            feature.parsedGltf = gltf;
                            feature.parsedMatrix = matrix;
                            feature.gltfId = gltfLoader._id;
                            me.rootCache.set(feature.gltfId,feature)
                            me._renderer.render();
                            resolve();
                        });
                    })
                });
                imagePromises.push(imagePromise);
            })
            me.tileTree.set(tileUrl,features);
        }
        return imagePromises;
    }

    // 分级分范围请求，先不考虑缓存？？？
    addScreenTiles(){
        // 图层的模型清空，this._b3dms清空，this._tileZoom重新设置
        // 重新分析范围.
        const tiles = this.tileBranches;
        const extentOut = this._map.getExtent();
        let requestDepth = this.tileset.getRequestDepth(this._map.getZoom());       //请求的深度
        for(let tile of tiles){
            let extentIn = tile.getExtent(),contain = false;//切片范围
            if(extentIn){
                let center = this.tileset.center;
                let extentCenterCoordinate = extentIn.getCenter();
                extentIn._left += center[0] - extentCenterCoordinate.getOrdinate("X");extentIn._bottom += center[1] - extentCenterCoordinate.getOrdinate("Y");
                extentIn._right += center[0] - extentCenterCoordinate.getOrdinate("X");extentIn._top += center[1] - extentCenterCoordinate.getOrdinate("Y");
                contain = extentOut.intersects(extentIn)
            }

            //let lineGeom = new hmap.geom.Line([new hmap.geom.Point(new hmap.basetype.Coordinate(extentIn._left,extentIn._bottom,0)),new hmap.geom.Point(new hmap.basetype.Coordinate(extentIn._right,extentIn._top,0))])
            //let line = new hmap.feature.Vector(lineGeom);
            //vectorLayer.addFeatures([line]);                    //临时显示范围线
            if(!extentIn || contain){                    //tile在屏幕范围内,则请求该切片的所有b3dm
                let me = this, tileUrl = tile.tileUrl, features = [],
                    allImagesPromises = [];             //保存gltf纹理的异步请求
                let numFromCache = 0;
                tile.getRequestTiles(requestDepth,features);
                features.map((feature)=>{
                    if(!feature.hasRequest){
                        let imagePromise = new Promise(function(resolve){
                            feature.requestContent();
                            feature.hasRequest = true;
                            feature.tileContentReadyPromise.then(function(b3dm){
                                /*let modelMatrix = b3dm.getModelMatrix();
                                 matrix.setPosition(new hmap.util.Vector3(120.1884,30.18251,0))
                                 matrix.scale(0.00001,0.00001,0.00001);
                                 matrix.rotate(-90,0,1,0);*/
                                let matrix = me.matrix;
                                let gltfJson = b3dm.getGltf();
                                let gltfLoader = new hmap.model.gltf.GLTF("3dtile0627");
                                let gltf = gltfLoader.parse3DtileGltf(gltfJson);
                                Promise.all(gltf.images).then(function () {
                                    me._renderer.addGLTF(gltf,matrix);
                                    feature.parsedGltf = gltf;
                                    feature.parsedMatrix = matrix;
                                    feature.gltfId = gltfLoader._id;
                                    resolve();
                                });
                            })
                        });
                        allImagesPromises.push(imagePromise);
                    }else{                                          //已经请求过
                        if(feature.gltfId){
                            let id = feature.gltfId;
                            let cached =  me.tileCache.get(id);
                            if(cached){
                                let gltfCache = cached.parsedGltf,modelCache = cached.parsedMatrix;
                                me._renderer.gltfMap.set(id,gltfCache);
                                me._renderer.modelMap.set(id,modelCache);
                                me._renderer._IsRender.set(id,true);
                                numFromCache++;
                            }else{
                                let rootCached = this.rootCache.get(id);
                                if(rootCached){
                                    let gltfCache = rootCached.parsedGltf,modelCache = rootCached.parsedMatrix;
                                    //me._renderer.gltfMap.set(id,gltfCache);
                                    //me._renderer.modelMap.set(id,modelCache);
                                    me._renderer._IsRender.set(id,true);
                                    numFromCache++;
                                }
                            }
                        }
                    }
                });
                me._renderer.render();
                /*if(numFromCache > 0){
                    me._renderer.render();
                }*/
                if(allImagesPromises.length != 0){
                    Promise.all(allImagesPromises).then(function(){
                        let prevTiles = me.tileTree.get(tileUrl);           //上一帧 该张切片中所有的切片
                        if(prevTiles){
                            for(let i=0;i<prevTiles.length;i++){
                                let tile = prevTiles[i],id = tile.gltfId;
                                if(me.tileCache.get(id)){
                                    me.releaseFromCache(tile);
                                }else{
                                    if(me.rootCache.get(id)){
                                        me._renderer._IsRender.set(id,false);
                                    }
                                }
                            }
                            me.tileTree.delete(tileUrl);
                        }
                        for(let i=0;i<features.length;i++){
                            let feature = features[i],fid = feature.gltfId;
                            if(!me.rootCache.get(fid) && !me.tileCache.get(fid)){
                                me.addTileToCache(feature);
                            }
                        }
                        me.tileTree.set(tileUrl,features);                      //缓存所有的切片
                        me._renderer.render();
                    })
                }
            }
        }
    }

    /**
     * 从缓存中释放内存
     * */
    releaseFromCache(tile){
        const id = tile.gltfId, cacheTile = this.tileCache.get(id);
        if(cacheTile){
            this.destroyTile(cacheTile);                    //从缓存中移除，并拆解
            this.tileCache.delete(id);
        }
    }

    /**
     * 将切片加入到缓存
     * @private
     * */
    addTileToCache(tile){
        const id = tile.gltfId;
        if(!this.tileCache.get(id)){
            this.tileCache.set(id, tile);
            this.gltfQuene.push(id);
        }
    }

    /**
     * 将切片加入到缓存
     * @private
     * */
    addTileToCache_bak(tile){
        let id = tile.gltfId;
        if(this.gltfQuene.length + 1 > this.cacheCapacity){
            let idToDel = this.gltfQuene.shift();           //需要删除的id
            let cacheTile = this.tileCache.get(idToDel);
            this.destroyTile(cacheTile);                    //从缓存中移除，并拆解
            this.tileCache.delete(idToDel);
        }
        if(!this.tileCache.get(id)){
            this.tileCache.set(id, tile);
            this.gltfQuene.push(id);
        }
    }

    /**
     * 切片从已请求状态，拆解并回收内存
     * @private
     * */
    destroyTile(tile){
        let id = tile.gltfId;
        this._renderer._deleteWebGLBufferAndTexture(id);       //从render中删除数据
        this._renderer.gltfMap.delete(id);
        this._renderer.modelMap.delete(id);
        this._renderer._IsRender.delete(id);
        tile.unloadContent();
    }

    draw(){
        super.draw();
        let me = this;
        me.tilesetPromise.then(function(){
            me._renderer.setVPMatrix(me._map.getVPMatrix());
            me._renderer.setOpacity(me._opacity);
            if(!me.rootRequest){
                me.rootRequest = true;
                let promises = me.initRootTile();
                Promise.all(promises).then(function(){
                    me.rootInit = true;
                    me.addScreenTiles();
                })
            }else{
                if(me.rootInit){
                    me.addScreenTiles();
                }
            }
        });
    }
}
;"use strict";
hmap.layer=hmap.layer||{};
/**
 * 加载S3M格式的图层，目前支持S3M格式的倾斜摄影和点云，要求纹理选项为压缩DDS格式,暂时只支持3857坐标系下地图環境
 * @type {hmap.layer.S3MLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.S3MLayer=class extends hmap.layer.Layer{
    /**
     * s3m图层，当前支持倾斜摄影和点云模型
     * @param {String} name 图层名称
     * @param {String} url  描述文件url，对应的是描述文件.scp的路径
     * @param {Object} options 构造选项
     * @param {Number} options.rangeRatio 渲染参数，默认为1，值越大，理论上图层显示越清晰，但同时消耗的内存也越多，建议不调或者微调
     */
    constructor(name,url,options={}){
        super(name,url,options);
        this.CLASS_NAME="hmap.layer.S3MLayer";
        this._url=url;
        this._shaderOpts=null;
        this._json=null;
        this.modeAdd = true;                          //层级细化方式add默认为true

        this._existTiles = new Map();
        this._rootTiles = new Map();                    //根节点切片，后面移到render中
        this._currTileToDb = new Map();                 //用于保存当前传输到indexDb的数据，不能重复
        this._processTileFromDb = new Map();            //保存从indexDB进程中获取的切片
        this._rootPromises = [];
        this._screenPixelD = undefined;                  //相机与中心点的像素距离，与相机的fovy和容器的高度有关
        this._rangeRatio = (options.rangeRatio != null && options.rangeRatio != undefined) ? options.rangeRatio:1;
        this._rootHasInit = false;
        this._rootParent = new Map();
        this._loadingDom = new hmap.util.AnimateDiv();

        this.curScreenPromises = new Map();
        this.frameNum = 0;
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        const me = this;
        me._initIndexDB();
        me.indexDb.init().then(res=>{
            if(res.code===1){
                me.indexDbReady = true;
                me._initUrl();
            }
        }).catch(error=>{
            console.error(error.msg);
        });
        me.rootReadyPromise = new Promise(function(resolve,reject){
            me.rootReadyResolve = resolve;
        })
    }

    /**
     * 初始化indexDB
     * @private
     */
    _initIndexDB(){
        this.indexDbReady = false;
        this.TileStore = new hmap.util.DataStore('tiles', {keyPath: 'tileName'});
        this.TileStore.setIndex('tileName', 'tileName', {});
        this.indexDb = new hmap.util.IndexedDB('s3mCache', 1, {storeList: [this.TileStore]});
    }

    /**
     * 将数据保存到indexDB
     * @param tileName 主键
     * @param resData 数据
     * @returns {Promise}
     * @private
     */
    insertIndexDb(tileName,resData){
        return this.indexDb.addData('tiles', {tileName,resData});
    }

    /**
     * 根据切片名称获取切片
     * @param tileName
     * @returns {*}
     * @private
     */
    getFromIndexDb(tileName){
        return this.indexDb.getData('tiles', tileName);
    }

    setMap(_map){
        super.setMap(_map);
        //添加container（即GL的设置）。因重绘和基类存在差异，无调用resize接口，故初始化时进行设置。如果不设置，hmap初始化代码中canvas.height和canvas.width为300*500（即无canvas高度和宽度设置的默认值）
        this.container.height=this.container.clientHeight;
        this.container.width=this.container.clientWidth;
        this.gl.viewport(0,0,this.container.width,this.container.height);
        this._unit=_map.getCrs().getUnit();
        this._renderer=new hmap.renderer.S3MTileRenderer(this.gl,{mapUint:_map.getCrs().getUnit(),isRTE:this._isRTE,proMatrix:_map.getProjMatrix()});
        this.draw();
    }

    /**
     * 初始化根节点的切片
     * @private
     */
    _initUrl(){
        let json=this._loadJSON();
        json.then((data)=>{
            this._json=data;
            if(this._json!==null||this._json!==undefined){
                this._dataType=this._json.dataType;//数据类型
                let lodType = this._json.lodType;             //"Replace"
                if(lodType == "Replace"){
                    this.modeAdd = false;
                }
                const units=this._json.position.units;
                if(units.toUpperCase()===this._unit.toUpperCase()){
                    this._trans=new hmap.basetype.Coordinate(this._json.position.x,this._json.position.y,this._json.position.z);
                }else{
                    this._trans=hmap.proj.Transformer.transform(new hmap.basetype.Coordinate(this._json.position.x, this._json.position.y, this._json.position.z),4326,3857)
                }
                this._baseUrl=new URL(this._url,location.href);
                this._getTile();
            }
        });

    }

    /**
     * 加载
     * @private
     */
    async _loadJSON(){
        const response=await fetch(this._url);
        return await response["json"]();
    }

    /**
     * 根据数据构建shader使用
     * @param attrLocations
     * @param material
     * @private
     */
    _buildShader(attrLocations,material){
        //如果没有构建shader
        if(!this._shaderOpts){
            this._shaderOpts=hmap.util.AssembleShader.getShaderOptions(hmap.shader.S3MShader.vsShader, hmap.shader.S3MShader.fsShader);
            const vsOpts=this._shaderOpts.vsOpts;
            const fsOpts=this._shaderOpts.fsOpts;
            // if(attrLocations.aNormal){                   //暂时不要光照
            //     vsOpts.defines.push("VertexNormal");
            //     fsOpts.defines.push("VertexNormal");
            // }
            if(material){
                if(material.textures.length>0){
                    vsOpts.defines.push("TexCoord");
                    fsOpts.defines.push("TexCoord");
                }
                if(material.textures.length===2){
                    vsOpts.push("TexCoord2");
                    fsOpts.push("TexCoord2");
                }
            }
            const vs=hmap.util.AssembleShader.combineShaderOptions(vsOpts,false);
            const fs=hmap.util.AssembleShader.combineShaderOptions(fsOpts,true);
            this._renderer._initProgram(vs,fs);
        }

    }

    /**
     * 获取根切片，并开始遍历其子级
     * @private
     */
    _getTile(){
        this.updateScreenPixelD();
        const transMatrix=new hmap.util.Matrix4().setTranslate(this._trans.getOrdinate("X"),this._trans.getOrdinate("Y"),this._trans.getOrdinate("Z"));
        const tiles = this._json.tiles;
        const me = this;
        if(me._loadingDom){
            me._loadingDom.startAnimate();
        }
        for(let i=0,len=tiles.length;i<len;i++){
            //此处调用tile解析接口，并返回解析数据
            const tileUrl=new URL(tiles[i].url,this._baseUrl.href);
            const tile=new hmap.format.s3m.S3MTile(tileUrl,transMatrix,tiles[i].url,this._rangeRatio);
            tile.depth = 0;
            let promise = me._addRootTile(tile);
            this._rootPromises.push(promise);
        }
        Promise.all(this._rootPromises).then(function(){
            me._rootHasInit = true;
            if(me._loadingDom){
                me._loadingDom.stopAnimate();
            }
            me.redraw();
            me.rootReadyResolve();
            const rootTiles = me._rootTiles;
            for(let [key, tile] of rootTiles){
                me._traversal(tile);
            }
        })
    }

    /**
     *  添加根切片
     * @private
     */
    _addRootTile(tile){
        const me=this, tileName = tile._tileName;
        if(!this._rootTiles.get(tileName)){
            let rootPromise = new Promise(function(rootResolve,rootReject){
                let promiseFromDb = me.getFromIndexDb(tileName);
                promiseFromDb.then(function(res){
                    let result = res.result, promise;
                    if(!result){
                        promise = new Promise(function(resolve,reject){
                            tile.requestContent();
                            tile.contentReadyPromise.then(function(tileData){
                                me.insertIndexDb(tileName, tileData).then(function(){
                                    resolve(tileData);
                                })
                            })
                        })
                    }else{
                        let data = result.resData;
                        tile.getContentFromData(data);
                        promise = Promise.resolve(data);
                    }
                    promise.then(resData=>{
                        if(resData){
                            for(let j=0,len=resData.length;j<len;j++){
                                const datas=resData[j].datas;
                                if(datas.length != 0){
                                    me._buildShader(datas[0].vertexPackage.attrLocation,datas[0].material);
                                    me._renderer.createDrawData(datas,tileName);             //此处为调用数据组织方法
                                }
                            }
                            me._renderer.addRootCache(tileName);
                            me._rootTiles.set(tileName,tile);
                            me._existTiles.set(tileName,tile);
                        }
                        rootResolve();
                    })
                })
            })
            return rootPromise;
        }else{
            return Promise.resolve();           //完成状态的Promise
        }
    }

    /**
     *  检查并遍历一张切片的子切片,当前在用
     *  @private
     */
    _traversal(tile){
        const me = this, extent = me._map.getExtent();
        if(!tile.fitMapExtent(extent)) return;
        let childrenPromises = [], childrens = tile.children;
        for(let i=0;i<childrens.length;i++){
            let child = childrens[i],childName = child._tileName;
            let requestPromise;
            if(!me._processTileFromDb.get(childName)){          //需要请求
                requestPromise = new Promise(function(requestResolve,reject){
                    let promiseFromDb = me.getFromIndexDb(childName);
                    promiseFromDb.then(function(res){
                        let result = res.result, promise;
                        if(!result){
                            promise = new Promise(function(resolve,reject){
                                child.requestContent();
                                child.contentReadyPromise.then(function(tileData){
                                    if(!me._currTileToDb.get(childName)){
                                        me._currTileToDb.set(childName,true);
                                        me.insertIndexDb(childName, tileData).then(function(){
                                            resolve(tileData);
                                        })
                                    }else{
                                        resolve(tileData);
                                    }
                                })
                            })
                        }else{
                            let data = result.resData;
                            if(!child.hasContentInit){
                                child.getContentFromData(data);
                            }
                            promise = Promise.resolve(data);
                        }
                        promise.then(resData=>{
                            let cache = me._renderer.hasCache(childName);
                            if(!cache){
                                for(let j=0,len=resData.length;j<len;j++){
                                    const datas = resData[j].datas;
                                    if(datas.length != 0){
                                        me._buildShader(datas[0].vertexPackage.attrLocation,datas[0].material);
                                        me._renderer.createDrawData(datas,childName);             //此处为调用数据组织方法
                                    }
                                }
                                me._releaseData(resData);
                                me._existTiles.set(childName,child);
                                me.addTileToCache(child);
                            }
                            me._renderer.addToDrawList(childName);
                            requestResolve();
                            if(child.fitMapExtent(extent)){
                                child.updateScreenError(me.screenPixelD,me._map._camera);
                                if(child.canTraverse()){                //继续细化
                                    me._traversal(child);
                                }
                            }
                        })
                    })
                })
                me._processTileFromDb.set(childName,requestPromise);
            }else{                          //已缓存或者已请求
                if(me._renderer.hasCache(childName)){
                    me._renderer.addToDrawList(childName);
                    requestPromise = Promise.resolve();
                    if(child.fitMapExtent(extent)){
                        child.updateScreenError(me.screenPixelD,me._map._camera);
                        if(child.canTraverse()){                //继续细化
                            me._traversal(child);
                        }
                    }
                }else{
                    me._renderer.addToDrawList(childName);
                    requestPromise = me._processTileFromDb.get(childName);
                }
            }
            childrenPromises.push(requestPromise);
        }
        const tileName = tile._tileName;
        if(childrenPromises.length != 0){
            Promise.all(childrenPromises).then(function(){
                if(!me.modeAdd){
                    me._renderer.addToNoShow(tileName);
                }
            })
        }
    }

    /**
     * 释放数据的内存
     * @private
     */
    _releaseData(res){
        for(let item of res){
            let datas = item.datas;
            for(let data of datas){
                let attrs = data.vertexPackage.vertexAttributes;
                for(let attr of attrs){
                    attr.typedArray = null;
                }
                let vertexColor = data.vertexPackage.vertexColor;
                if(vertexColor){
                    vertexColor = null;
                }
                let indicesArray = data.arrIndexPackage;
                for(let indice of indicesArray){
                    indice.indicesTypedArray = null;
                }
            }
        }
    }

    /**
     * 更新相机与相机中心点的像素距离，与相机的fovy以及gl绘制像素高有关
     * @private
     */
    updateScreenPixelD(){
        if(!this._map) return;
        let camera = this._map._camera, context = this.getLayerContainer().getContext();
        let height = context.canvas.clientHeight;
        let theta = (camera._fovy * Math.PI / 180) * 0.5;
        let screenYPix = height * 0.5;
        this.screenPixelD = screenYPix / Math.tan(theta);
    }

    /**
     * 发起一次请求
     * @private
     */
    _startOneRequestTask(){
        let roots = this._rootTiles,
            extent = this._map.getExtent();
        for(let [key,tile] of roots){
            if(tile.fitMapExtent(extent)){
                this._renderer.addToDrawList(tile._tileName);
                this._traversal(tile);
            };
        }
    }

    /**
     * 将切片加入到缓存
     * @private
     * */
    addTileToCache(tile){
        let render = this._renderer, currTileNum = render._drawInfos.size;
        while((render.tileNameQuene.length - currTileNum) + 1 > render.capacity){
            let tileName = render.tileNameQuene.shift();
            if(!render._drawInfos.get(tileName)){
                let cacheTile = this._getTileByName(tileName);
                this._destroyTile(cacheTile);
                render.tileCache.delete(tileName);
                if(this._processTileFromDb.get(tileName)){
                    this._processTileFromDb.delete(tileName);
                }
            }else{
                render.tileNameQuene.push(tileName);
            }
        }
        this._renderer.addTileCache(tile);
    }

    /**
     * 切片从已请求状态，拆解并回收内存
     * @private
     * */
    _destroyTile(tile){
        let tileName = tile._tileName;
        this._renderer._deleteDrawInfo(tileName);
        tile.unloadContent();
    }

    /**
     *  根据切片名称获取切片对象
     *  @private
     */
    _getTileByName(tileName){
        return this._existTiles.get(tileName);
    }

    /**
     * 请求、组织瓦片数据
     * @private
     */
    prepareData() {
        this.updateScreenPixelD();
        this._renderer.clearDrawInfos();
        this._startOneRequestTask();
    }


    /**
     * 一次绘制
     * @private
     */
    draw(){
        if(!this._map)return;
        super.draw();
        this._draw();
        const me = this;
        if(me._rootHasInit){
            if(me.timer){
                cancelAnimationFrame(me.timer);
                me.timer = null;
            }
            me.timer = requestAnimationFrame(()=>{
                me.redraw();
            });
        }
    }

    /**
     * 绘制
     * @private
     */
    _draw(){
        if(this._json===null||this._json===undefined)return;
        const trans={
            x:this._trans._x-this._map._camera._eyeX,
            y:this._trans._y-this._map._camera._eyeY,
            z:this._trans._z-this._map._camera._eyeZ,
        };
        const uniforms={
            uProjMatrix:this._map.getProjMatrix(),
            uViewMatrix:this._map.getCamera().getViewRotate().multiply(new hmap.util.Matrix4().setTranslate(trans.x,trans.y,trans.z)),
        };
        const currZoom = this._map.getZoom();
        this._renderer.draw(uniforms,currZoom);
    }
};;"use strict";
hmap.layer = hmap.layer || {};
/**
 * 点云图层，用于展现大量点的整体形态，理论上点云数量可以达到2千万。
 * @type {hmap.layer.PointCloudLayer}
 * @extends hmap.layer.Layer
 */
hmap.layer.PointCloudLayer = class extends hmap.layer.Layer {

    /**
     * 构造一个矢量图层.
     * @param {String} name 图层名称
     * @param {Object} options 可选项。给出的属性都将被绑定到该图层对象上。
     * @param {Number} options.pointSize 可选项。点云像素大小，范围在[1,10],默认为2，
     * @param {Number} options.blockSize 可选项。块大小，默认为50000，
     * @param {Boolean} options.isCircle 可选项。块样式（理论上矩形块效率更高），false为矩形，true为圆形，默认为false，
     * @param {Boolean} options.enableHashCode 可选项。是否支持拾取，目前支持最多200万数据拾取，大于200万请关闭拾取，默认为false
     */
    constructor(name, options = {}) {
        super(options);
        this.CLASS_NAME = "hmap.layer.PointCloudLayer";
        this.name = name;
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._map = null;
        this.pointSize = options.pointSize ? options.pointSize : 2;
        if (this.pointSize > 10) this.pointSize = 10;
        else if (this.pointSize < 1) this.pointSize = 1;
        this.blockSize = options.blockSize ? options.blockSize : 50000;
        this.isCircle = options.isCircle ? options.isCircle : false;
        this.enableHashCode = options.enableHashCode ? options.enableHashCode : false;
        this.count = 0;
    }

    /**
     * 绑定地图
     * @param map
     */
    setMap(map) {
        super.setMap(map);
        this.getDepthStatus().setEnable(false);

        //拾取相关
        if (this.enableHashCode) {
            //TODO，拾取替换
            const extent = map.getCrs().getWorldExtent();
            let minEx = Math.min(extent.getBottom(), extent.getLeft()),
                maxEx = Math.max(extent.getTop(), extent.getRight());
            let min = new hmap.util.Vector3(minEx, minEx, minEx),
                max = new hmap.util.Vector3(maxEx, maxEx, maxEx);
            this.layerOctree = new hmap.strategy.RayLayerOctree(min, max);
        }
        //放在拾取声明之后
        this.painter = new hmap.core.painter.PointCloudPainter(this, this.blockSize, this.isCircle);
    }

    /**
     * 图层类型标识
     * @return {String}
     */
    getLayerType() {
        return "hmap.layer.PointCloudLayer";
    }

    /**
     * 点云像素大小,范围[1,10]
     * @param {Number} size 像素大小
     * @return {hmap.layer.PointCloudLayer}
     */
    setPointSize(size) {
        if (!(Number.isFinite(size) && size <= 10 && size >= 1)) {
            throw ("parameter size must be a number not greater than 10 and no less than 1 !")
        }
        this.pointSize = size;
        return this;
    }

    /**
     * 添加点数据，z值默认0，颜色默认（255,0，0,1），
     * @param {Number} x 坐标值
     * @param {Number} y 坐标值
     * @param {Number} z 坐标值
     * @param {Number} r 颜色分量
     * @param {Number} g 颜色分量
     * @param {Number} b 颜色分量
     * @param {Number} a 颜色透明度
     * @param {Object} data 绑定的数据
     * @example
     * layer.addPoint(120.1,30.5,0,255,255,255,1)
     *
     */
    addPoint(x, y, z = 0, r = 255, g = 0, b = 0, a = 1,data=null) {
        if (!(r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255&& a >= 0 && a <= 1)) {
            throw("parameters r g b a out of range,rgb must be a number in [0,255], a must be a number in [0,1]")
        }
        this.painter.add([x, y, z, r, g, b, a,data]);
        this.count++;
    }

    /**
     * 添加数据组
     * @param {Array} arr 点云数据组[xyzrgba...]Array
     * @param {Number} num 每组的长度 2-8
     */
    addPoints(arr, num) {
        if (!Number.isInteger(num) || num < 2 || num > 8) {
            console.warn("the array length must be a interger number between 2 and 8")
            return;
        }
        for (let i = 0, len = arr.length / num; i < len; i += 1) {
            let point = arr.slice(i * num, i * num + num);
            this.addPoint(...point);
        }
    }

    /**
     * 移除所有数据
     */
    removeAllPoints(){
        this.painter.removeAll();
        this.draw();
    }

    /**
     * 点云数量
     * @return {Number}
     */
    getPointCount() {
        return this.count;
    }

    /**
     * 销毁
     */
    destroy() {
        this.painter.clear();
        super.destroy();
    }

    /**
     * 图层数据绘制
     */
    draw() {
        super.draw();
        //draw
        this.painter.draw();
    }
};
;"use strict";
hmap.strategy=hmap.strategy || {};
/**
 * 待删除，缓存类
 * @type {hmap.strategy.Cache}
 * @private
 */
hmap.strategy.Cache = class {
    /**
     * 缓存限制的数量
     * @param {Number} limit 缓存限制数,取值为>1的整数。如果不限制大小,设置limit=0,不建议使用。
     */
    constructor(limit){
        this.size = 0;
        this.limit = limit;
        this.head = this.tail = undefined;
        this._keymap = Object.create(null);
        this.CLASS_NAME = "hmap.strategy.Cache";

    }

    /**
     * 填充数据
     * @param {String} key 缓存对象的key值
     * @param {*} value 缓存对象的value值
     * @returns {Entry|undefined} 当添加超过缓存对象的容量时，返回从缓存中剔除的对象，否则反没有移除对象，此时返回undefined
     */
    put(key, value) {
        var removed;

        var entry = this.get(key, true);
        if (!entry) {
            if (this.size === this.limit) {
                removed = this.shift();
            }
            entry = {
                key: key
            };
            this._keymap[key] = entry;
            if (this.tail) {
                this.tail.newer = entry;
                entry.older = this.tail;
            } else {
                this.head = entry;
            }
            this.tail = entry;
            this.size++;
        }
        entry.value = value;
        return removed;
    }

    /**
     * 清除最近使用（最旧）的条目，如果缓存是空的这返回Undentifi
     * @private
     */
    shift() {
        var entry = this.head;
        if (entry) {
            this.head = this.head.newer;
            this.head.older = undefined;
            entry.newer = entry.older = undefined;
            this._keymap[entry.key] = undefined;
            this.size--;
        }
        return entry;
    }

    /**
     * 根据key值获取缓存中的对象实体
     * @param {String} key
     * @param {Boolean} returnEntry 默认值为false 如果为true则返回实体对象:entry，否则返回实体对象的值:entry.value
     * @return {Entry|*} 返回实体或者内容
     */
    get(key, returnEntry=false) {
        var entry = this._keymap[key];
        if (entry === undefined) {
            return;
        }
        if (entry === this.tail) {
            return returnEntry? entry: entry.value;
        }
        // HEAD--------------TAIL
        //   <.older   .newer>
        //  <--- add direction --
        //   A  B  C  <D>  E
        if (entry.newer) {
            if (entry === this.head) {
                this.head = entry.newer;
            }
            entry.newer.older = entry.older; // C <-- E.
        }
        if (entry.older) {
            entry.older.newer = entry.newer; // C. --> E
        }
        entry.newer = undefined; // D --x
        entry.older = this.tail; // D. --> E
        if (this.tail) {
            this.tail.newer = entry; // E. <-- D
        }
        this.tail = entry;
        return returnEntry ? entry: entry.value;
    }
};;"use strict";
hmap.strategy=hmap.strategy || {};
/**
 * 待删除，数据存储已替换
 * @type {hmap.strategy.DataBook}
 * @private
 */
hmap.strategy.DataBook=class {
    /**
     * 构造函数
     * 一个实例包含一个目录，目录是章节的索引
     */
    constructor(){
        this.CLASS_NAME = "hmap.strategy.DataBook";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.directory=new Map();
        this.featurePageMap =  new Map();				//feature和page的关联，一个feature可能对应多个page
    }

    /**
     * 创建一个章节
     * 包括：
     *    1 将章节放进目录里，
     *    2 给该章节添加一个空页，空页保存的数据属性由attribute指定
     */
    createChapter(cName,attrsLayout,extraAttrs){
        const directory=this.directory;
        const chapter={curPageIndex:-1,pages:[]};
        directory.set(cName,chapter);
        this._addPage(chapter,attrsLayout,extraAttrs);
        return cName;
    }

    /**
     * 获取指定的章节,暂时先返回该章节下所有的页
     * 章节数据包括：
     *     1、所有的页
     *     2、一些描述性的其它数据todo-------------待讨论补充
     */
    getChapter(cName){
        //包含page和当前在使用的page的索引
        return this.directory.get(cName);
    }

    getChapterPages(cName){
        //包含pages
        return this.directory.get(cName).pages;
    }

    //待定
    getChapterMetadata(){

    }

    /**
     *	 将数据条目插入指定program名称对应的章节
     *   insert前，判断章节的当前page能否容纳
     *	 如果能容纳，则插入章节的当前页，返回false；如果不能，新建页，再插入新的当前页，返回true
     *   @param  {String} pName program的名称
     *   @param  {String} dataEntries 需要插入的数据条目
     *   @param {String} isVTile 是否是矢量切片，矢量切片无视容量大小
     */
    insertChapter(pName,dataEntries,isVTile = false){
        const chapter=this.directory.get(pName);		//根据program名称获取章节，同一个章节下的page的attributes是相同的，对应着色器属性
        const curIndex=chapter.curPageIndex;
        let curPage=chapter.pages[curIndex];
        let isFullfill;						//章节是否已满
        if(isVTile || curPage.canBeInsert()){			//未满
            isFullfill = false;
        }else{			//已满，需要创建新的page
            isFullfill = true;
            this._addPage(chapter,curPage.attrsLayout,curPage.extraAttrs);
            curPage = chapter.pages[chapter.curPageIndex];
        }
        curPage.insert(dataEntries);

        const fid = dataEntries['fid'][0];
        this._setFeaturePage(fid,curPage);		        //创建feature和page的关联
        return isFullfill;
    }

    /**
     * 	创建book中 feature和page的绑定
     * */
    _setFeaturePage(fid,page){
        if(this.featurePageMap.get(fid)){
            this.featurePageMap.get(fid).push(page);			//增加关联
        }else{
            this.featurePageMap.set(fid,[page]);		//创建关联
        }
    }

    /**
     * 删除featurePageMap中所有的元素
     * */
    clearFeaturePage(){
        this.featurePageMap.clear();
    }

    /**
     * 	解除book中，feature和page的绑定
     * */
    _unsetFeaturePage(fid){
        this.featurePageMap.delete(fid);
    }

    /**
     * 	根据fid获取page，同一个fid可能对应多个page
     * 	@param {String} fid 要素id
     * 	@return {Array<hmap.strategy.DataPage>} 数据页数组
     * */
    getPagesByFid(fid){
        return this.featurePageMap.get(fid) ? this.featurePageMap.get(fid) : [];
    }

    /**
     * 	从数据页中 删除指定fid对应的数据
     * 	@param {String} fid 要素id
     * */
    deleteByFid(fid){
        let pages = this.getPagesByFid(fid);		//多个page
        for(let i=0;i<pages.length;i++){
            const page = pages[i];
            page.deleteByFid(fid);			    //存储页删除
        }
        this._unsetFeaturePage(fid);
    }


    /**
     * 删除dataBook中所有的page
     * */
    clear(){
        let directory = this.directory;
        let pagesToDel = [];
        for(let cName in directory){
            let chapter = directory.get(cName);     //获取一个program下的所有的page
            pagesToDel.push(...chapter);
        }
        for(let i=0;i<pagesToDel.length;i++){
            let page = pagesToDel[i];
            page.clearData();
        }
        this.directory=new Map();
        this.featurePageMap =  new Map();
    }

    /**
     * 删除名为cName的章节
     * 清除里面所有的页
     */
    deleteChapter(cName){

    }

    /**
     * 更新章节内容
     *  	1、根据entries中的id，找到指定的页，删除页内对应的数据；（注意删除方式有两种，可以先实现直接删除，，，标记删除放后续版本处理）
     *   2、然后将新的数据添加的章节内
     *
     */
    updateChapter(cName,entries){

    }

    /**
     * 根据章节名称获取当前活动页，兼容矢量切片
     */
    getCurPage(cName){
        const chapter=this.getChapter(cName);
        return chapter.pages[chapter.curPageIndex];
    }


    /**
     * 根据章节名称获取当前活动页的上一页，兼容矢量切片
     */
    getPrePage(cName){
        const chapter=this.getChapter(cName);
        const curPageIndex=chapter.curPageIndex;
        if(curPageIndex===0){
            return 0;
        }
        return chapter.pages[curPageIndex-1];
    }

    /**
     *  重新使用program对应的存储章节，将章节中第一个page重置
     * */
    reuseChapter(cName){
        const chapter=this.getChapter(cName);
        const pages=chapter.pages;
        if(pages && pages.length != 0){
            pages[0].clearData();
            chapter.curPageIndex = 0;
        }
    }


    /**
     *  获取指定章节内所有的活动页
     *  产生需求：
     *      1 针对update和delete之后，可以立即进行vao数据更新
     *      2 针对图层若未绑定map，而先添加数据，可以快速的在绑定map时进行vao创建和绑定
     */
    getActivePages(cName){
        const result=[];
        const chapter=this.getChapter(cName);
        for(let page of chapter){
            if(page.isActive){
                result.push(page);
            }
        }
        return result;
    }

    /**
     *  在指定章节中新增页，或者清空一个已经的页
     * */
    _addPage(chapter,attrsLayout,extraAttrs){
        const curPageIndex=chapter.curPageIndex;
        const pagesLen=chapter.pages.length;
        if(pagesLen===0 || curPageIndex===pagesLen-1){//没有可用的已存在的page时
            const page = new hmap.strategy.DataPage(attrsLayout,extraAttrs);
            //添加新page
            chapter.pages.push(page);
            //更新当前page的索引
            chapter.curPageIndex=curPageIndex+1;
        }else{              //存在可用的已存在的page时
            chapter.curPageIndex = curPageIndex+1;
            chapter.pages[chapter.curPageIndex].clearData();
        }
    }

    //获取该数据库块的元数据
    getMetadata(){
    }

    //获取当前使用的page
    getCurPageWithData(){
        const directory = this.directory;
        for(let [key,value] of directory){
            const page=value.pages[0];
            if(page.getIndexCount()>0){
                return {page:page,programName:key};
            }
        }
        return null;
    }
}
;"use strict";
hmap.strategy=hmap.strategy || {};
/**
 * 待删除，数据存储已替换
 * @type {hmap.strategy.DataPage}
 * @private
 */
hmap.strategy.DataPage=class {
    /**
     * 构造函数
     * 一个实例代表某个program所绘制数据的某一块，在外部与一个vao对应
     */
    constructor(attrsLayout,extraAttrs,maxFeatureCount){
        this.CLASS_NAME = "hmap.strategy.DataPage";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.isActive=true;				//当前page是否为活跃状态，活跃状态表示该page数据要更新到vao中
        this.bucket=new Map();			//存储具体的数据{a_position:[],a_color:[],fid:[]}

        this.maxFeatureCount = maxFeatureCount ? maxFeatureCount:100;		//一个数据块存储的最大容量的xyz点数量,a_position类型化数组的最大长度为30000
        this._dataView = new Map();             //fid,positionCount,indexCount的数组，以及其他属性的个数

        this.attrsLayout = attrsLayout; 		//program绘制所有需要的逐顶点信息（不包括fid等辅助性数据）
        this.extraAttrs = extraAttrs; 			//program绘制所有需要的fid等辅助性数据
        this._initBucket(); //初始化
    }

    /**
     * 	初始化数据块，extraAttrs对应feature的非逐顶点数据
     * */
    _initBucket(){
        let attrsLayout = this.attrsLayout;
        for(let key in attrsLayout){
            this.bucket.set(key,[]);            //逐顶点属性为数组
        }
        let extraAttrs = this.extraAttrs;
        for(let key in extraAttrs){
            this.setDataView(key,[]);		    //extraAttrs中的非逐顶点数据，初始化为普通数组
        }
    }

    /**
     * 获取当前page数据视图中 数据项的值
     * */
    getDataView(key){
        return this._dataView[key];
    }

    /**
     * 设置page的数据视图中
     * */
    setDataView(key,value){
        this._dataView[key] = value;
    }

    /**
     *  获取当前page中index的索引数量用于绘制
     * */
    getIndexCount(){
        return this.bucket.get('index').length;     //数组长度
    }

    /**
     *   给当前页插入数据条目
     *  @param {Object} dataEntries 数据条目
     *  @param {Object} extraAttrs 额外的属性，即要素属性
     */
    insert(dataEntries){
        if(!dataEntries['index'] || dataEntries['index'].length == 0){
            return;
		}
        const prevXyzCount = this.bucket.get('a_position').length/3;          	//已保存的a_position的xyzCount数量
        if(prevXyzCount){
            const dataIndexCount=dataEntries['index'].length;
            for(let i=0;i<dataIndexCount;i++){
                dataEntries['index'][i] = dataEntries['index'][i] + prevXyzCount;       	//插入数据前，重新计算数据中的索引
            }
        }
        for(let key in this.attrsLayout){
            const data = dataEntries[key];
            if(data){
                this.bucket.get(key).push(...data);
            }
        }
        for(let key in this.extraAttrs){									//处理非逐顶点数据
            const data = dataEntries[key];
            this.getDataView(key).push(...data);
        }
        this.activate();
    }

    /**
     *  插入数据之前判断插入后，当前page是否会满载
     *  @return {Boolean} true 不会满载，可以插入 false 会满载，不可插入
     * */
    canBeInsert(){
        return this.getDataView("fid").length + 1 <= this.maxFeatureCount;
    }

    /**
     * 	使用Array的indexOf的方法，获取page中一个fid对应的所有数据
     * 	@param {String} fid 要素的唯一标识
     * */
    deleteByFid(fid){
        this.deleteByOrder(fid);
        this.activate();
    }

    /**
     *  根据id遍历删除所有要素fid
     * */
    deleteByOrder(fid,startIndex){
        let curIndex = startIndex ? startIndex : 0;
        const resultIndex = this.getDataView('fid').indexOf(fid,curIndex);
        if(resultIndex != -1){
            this._deleteOne(resultIndex);           //删除之后 fid数组已经减少1
            this.deleteByOrder(fid,resultIndex)
        }
    }

    /**
	 * 	根据索引删除对应的数据块数据
	 * */
    _deleteOne(index){
        const indexCountArray = this._dataView['indexCount'];
        const positionCountArray = this._dataView['positionCount'];

		let prevPositionCount = 0,prevIndexCount = 0;
        for(let i=0;i<index;i++){
            prevPositionCount += positionCountArray[i];
            prevIndexCount += indexCountArray[i];					//计算当前索引前的positionCount和indexCount
        }

        const prevCountPerUnit = prevPositionCount;     					//逐顶点数据中，顶点的个数
        const curPositionCount = positionCountArray[index];			//当前数据的positionCount
        const curIndexCount = indexCountArray[index];				//当前数据的indexCount
        for(let name in this.attrsLayout){								//处理逐顶点数据 包括index
            const times = this.attrsLayout[name].count
            let attrDataArray = this.bucket.get(name);         //普通数组
            if(name != 'index'){
                attrDataArray.splice(prevCountPerUnit*times,curPositionCount*times);
            }else{          //索引属性
                for(let i=prevIndexCount,len = attrDataArray.length-curIndexCount;i<len;i++){	//重新计算索引
                    attrDataArray[i] = attrDataArray[i+curIndexCount] - curPositionCount;
                }
                attrDataArray.splice(attrDataArray.length-curIndexCount,curIndexCount);			//删除部分index数组
            }
        }

        for(let name in this.extraAttrs){									//处理非逐顶点数据 比如fid
            this._dataView[name].splice(index,1);
        }
    }

    /**
     *  获取数据块中全部数据
     */
    getRenderData(){
        return this.bucket;
    }


    /**
     *  清空page中的数据视图
     */
    clearData(){
        for(let key in this.attrsLayout){
            this.bucket.set(key,[]);	                            //重新初始化index
        }
        for(let key in this.extraAttrs){									//重新初始化非逐顶点数据
            this.setDataView(key,[]);
        }
    }

    /**
     * 获取当前页保存的数据
     */
    getBucket(){
        return this.bucket;
    }

    /**
     * 删除当前页的数据块中的某条数据（难点）
     * 根据id找到对应的index，position 等内容位置进行删除，并更新index的值(标记删除先不考虑)
     *
     *  eg:
     *           id:[id1,id2,id3,...]
     * 	indexCount:[ic1,ic2,ic3,...]
     *positionCount:[pc1,pc2,pc3,...]
     *        index:[ i1, i2, i3,...]
     *     position:[xyz xyz xyz ...]
     *        color:[rgba rgba rgba ...]
     *   + isDelete:[0,    0,   0,  ...] //谁来维护------------
     */
    delete(entries,flag){

    }
    //直接删除方式
    _delete1(entries){

    }
    //标记删除方式---得提供一个根据标记数据再次更新的接口
    _delete2(entries){

    }

    /**
     * 清除垃圾----即将isDelete标记为删除的数据进行真正的删除
     */
    purge(){

    }

    //先删除再添加
    update(entries){

    }

    /**
     * 获取该数据库块的元数据
     *
     */
    getMetadata(){
        //return
    }

    /**
     * 使得该数据块为活跃状态
     *
     */
    activate(){
        this.isActive=true;
    }

    /**
     * 使得该数据块为非活跃状态
     *
     */
    inactivate(){
        this.isActive=false;
    }

    getStatus(){
        return this.isActive;
    }

    /**
     * 获取本页的id
     */
    getId(){
        return this._id;
    }
}
;'use strict';

hmap.strategy = hmap.strategy || {};
hmap.strategy.EarCut = class {

    //根据传入的多边形坐标序列数组拆分多边形，得到着色器所需的坐标数组
    static triangulatePolygon(coordSeqs) {
        const dim = 3;
        const earCutData = this.getCoordDataFromCoordSeq(coordSeqs);
        const triIndices = this.earcut(earCutData.coordData, earCutData.holeIndices, dim);
        return this.getTriCoords(earCutData.coordData, triIndices, dim);
    }

    static polygonCentroid(coordSeqs) {
        //首先进行三角剖分
        //计算每个三角形的面积,并求和
        const dim = 3;
        const earCutData = this.getCoordDataFromCoordSeq(coordSeqs);
        const triIndices = this.earcut(earCutData.coordData, earCutData.holeIndices, dim);
        let totalArea = 0, totalX = 0, totalY = 0, totalZ = 0;
        const p = {}, q = {}, r = {};
        let x, y, z, area;
        for (let i = 0; i < triIndices.length; i += 3) {
            p.x = earCutData.coordData[triIndices[i] * dim];
            p.y = earCutData.coordData[triIndices[i] * dim + 1];
            p.m = earCutData.coordData[triIndices[i] * dim + 2];

            q.x = earCutData.coordData[triIndices[i + 1] * dim];
            q.y = earCutData.coordData[triIndices[i + 1] * dim + 1];
            q.m = earCutData.coordData[triIndices[i + 1] * dim + 2];

            r.x = earCutData.coordData[triIndices[i + 2] * dim];
            r.y = earCutData.coordData[triIndices[i + 2] * dim + 1];
            r.m = earCutData.coordData[triIndices[i + 2] * dim + 2];

            x = (p.x + q.x + r.x) / 3;
            y = (p.y + q.y + r.y) / 3;
            z = (p.m + q.m + r.m) / 3;
            area = Math.abs(this.area(p, q, r))/2;
            totalX += area * x;
            totalY += area * y;
            totalZ += area * z;
            totalArea += area;
        }
        // totalArea = Math.abs(totalArea);
        if (totalArea === 0) {
            const firstCoordSeqCount = coordSeqs[0].getCoordCount();
            if (firstCoordSeqCount === 0) {
                throw 'Empty coordinate sequence!';
            }
            const firstCoord = coordSeqs[0].getFirstCoordinate();
            return [firstCoord.getOrdinate("X"), firstCoord.getOrdinate("Y"), firstCoord.getOrdinate("Z")];
        }
        return [totalX / totalArea, totalY / totalArea, totalZ / totalArea];
    }

    //根据传入的多边形坐标序列数组计算多边形面积
    static polygonArea(coordSeqs) {
        //首先进行三角剖分
        //计算每个三角形的面积,并求和
        const dim = 3;
        const earCutData = this.getCoordDataFromCoordSeq(coordSeqs);
        const triIndices = this.earcut(earCutData.coordData, earCutData.holeIndices, dim);
        let totalDoubleArea = 0;
        const p = {}, q = {}, r = {};
        for (let i = 0; i < triIndices.length; i += 3) {
            p.x = earCutData.coordData[triIndices[i] * dim];
            p.y = earCutData.coordData[triIndices[i] * dim + 1];
            p.m = earCutData.coordData[triIndices[i] * dim + 2];

            q.x = earCutData.coordData[triIndices[i + 1] * dim];
            q.y = earCutData.coordData[triIndices[i + 1] * dim + 1];
            q.m = earCutData.coordData[triIndices[i + 1] * dim + 2];

            r.x = earCutData.coordData[triIndices[i + 2] * dim];
            r.y = earCutData.coordData[triIndices[i + 2] * dim + 1];
            r.m = earCutData.coordData[triIndices[i + 2] * dim + 2];

            totalDoubleArea += Math.abs(this.area(p, q, r));
        }
        return totalDoubleArea / 2;
    }

    //将坐标序列转换为earcut方法所需的参数
    static getCoordDataFromCoordSeq(coordSeqs) {
        const coordData = [];
        const holeIndices = [];
        let coordSeqLastIndex = (coordSeqs[0].getCoordCount());
        coordData.push(...this.getXyzOfCoordSeq(coordSeqs[0]));
        for (let i = 1; i < coordSeqs.length; i++) {
            holeIndices.push(coordSeqLastIndex);
            coordSeqLastIndex += coordSeqs[i].getCoordCount();
            coordData.push(...this.getXyzOfCoordSeq(coordSeqs[i]));
        }
        return {coordData, holeIndices};
    }

    //根据earcut方法返回的三角形索引返回着色器所需的坐标数组
    static getTriCoords(coordData, triIndices, dim) {
        const triCoords = triIndices.map(i => [coordData[i * dim], coordData[i * dim + 1], coordData[i * dim + 2]]);
        if (triCoords.length === 0) {
            return triCoords;
        }
        return triCoords.reduce((x, y) => x.concat(y));
    }

    static getXyzOfCoordSeq(coordSeq) {
        const xyz = coordSeq.extractCoords().map(c => [c.getOrdinate("X"), c.getOrdinate("Y"), c.getOrdinate("Z")]);
        if (xyz.length === 0) {
            return xyz;
        }
        return xyz.reduce((x, y) => x.concat(y));
    }

    static earcut(data, holeIndices, dim) {

        dim = dim || 2;

        let hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = this.linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) return triangles;

        let minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) {
            outerNode = this.eliminateHoles(data, holeIndices, outerNode, dim);
        }

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (let i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }

            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }

        this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

        return triangles;
    }

    // create a circular doubly linked list from polygon points in the specified winding order
    static linkedList(data, start, end, dim, clockwise) {
        let i, last;

        if (clockwise === (this.signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = this.insertNode(i, data[i], data[i + 1], data[i + 2], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = this.insertNode(i, data[i], data[i + 1], data[i + 2], last);
        }

        if (last && this.equals(last, last.next)) {
            this.removeNode(last);
            last = last.next;
        }

        return last;
    }

    // eliminate colinear or duplicate points
    static filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        let p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (this.equals(p, p.next) || this.area(p.prev, p, p.next) === 0)) {
                this.removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) {
            return;
        }

        // interlink polygon nodes in z-order
        if (!pass && invSize) {
            this.indexCurve(ear, minX, minY, invSize);
        }

        let stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);

                this.removeNode(ear);

                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;
            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                    // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = this.cureLocalIntersections(ear, triangles, dim);
                    this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                    // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    this.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }

                break;
            }
        }
    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    static isEar(ear) {
        let a = ear.prev,
            b = ear,
            c = ear.next;

        if (this.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        let p = ear.next.next;

        while (p !== ear.prev) {
            if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                this.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }

        return true;
    }

    static isEarHashed(ear, minX, minY, invSize) {
        let a = ear.prev,
            b = ear,
            c = ear.next;

        if (this.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear

        // triangle bbox; min & max are calculated like this for speed
        let minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

        // z-order range for the current triangle bbox;
        let minZ = this.zOrder(minTX, minTY, minX, minY, invSize),
            maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);

        let p = ear.prevZ,
            n = ear.nextZ;

        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                this.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;

            if (n !== ear.prev && n !== ear.next &&
                this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                this.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }

        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                this.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }

        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                this.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }

        return true;
    }

    // go through all polygon nodes and cure small local self-intersections
    static cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
            let a = p.prev,
                b = p.next.next;

            if (!this.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) &&
                this.locallyInside(b, a)) {

                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);

                // remove two nodes involved
                this.removeNode(p);
                this.removeNode(p.next);

                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return p;
    }

    // try splitting polygon into two and triangulate them independently
    static splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        let a = start;
        do {
            let b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && this.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    let c = this.splitPolygon(a, b);

                    // filter colinear points around the cuts
                    a = this.filterPoints(a, a.next);
                    c = this.filterPoints(c, c.next);

                    // run earcut on each half
                    this.earcutLinked(a, triangles, dim, minX, minY, invSize);
                    this.earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    static eliminateHoles(data, holeIndices, outerNode, dim) {
        let queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = this.linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(this.getLeftmost(list));
        }

        queue.sort(this.compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            this.eliminateHole(queue[i], outerNode);
            outerNode = this.filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
    }

    static compareX(a, b) {
        return a.x - b.x;
    }

    // find a bridge between vertices that connects hole with an outer ring and and link it
    static eliminateHole(hole, outerNode) {
        outerNode = this.findHoleBridge(hole, outerNode);
        if (outerNode) {
            const b = this.splitPolygon(outerNode, hole);
            this.filterPoints(b, b.next);
        }
    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    static findHoleBridge(hole, outerNode) {
        let p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) {
            return null;
        }

        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        let stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m.next;

        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && this.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        }

        return m;
    }

    // interlink polygon nodes in z-order
    static indexCurve(start, minX, minY, invSize) {
        let p = start;
        do {
            if (p.z === null) p.z = this.zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        this.sortLinked(p);
    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    static sortLinked(list) {
        let i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) {
                        tail.nextZ = e;
                    } else {
                        list = e;
                    }

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    // z-order of a point given coords and inverse of the longer side of data bbox
    static zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;

        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        let p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    // check if a point lies within a convex triangle
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    static isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) &&
            this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b);
    }

    // signed area of a triangle
    static area(p, q, r) {
        // return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        const xy = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        return xy !== 0 ? xy : function () {
            const yz = (q.m - p.m) * (r.y - q.y) - (q.y - p.y) * (r.m - q.m);
            return yz !== 0 ? yz : (q.m - p.m) * (r.x - q.x) - (q.x - p.x) * (r.m - q.m);
        }();
    }

    // check if two points are equal
    static equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    // check if two segments intersect
    static intersects(p1, q1, p2, q2) {
        if ((this.equals(p1, q1) && this.equals(p2, q2)) ||
            (this.equals(p1, q2) && this.equals(p2, q1))) {
            return true;
        }
        return this.area(p1, q1, p2) > 0 !== this.area(p1, q1, q2) > 0 &&
            this.area(p2, q2, p1) > 0 !== this.area(p2, q2, q1) > 0;
    }

    // check if a polygon diagonal intersects any polygon segments
    static intersectsPolygon(a, b) {
        let p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                this.intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);

        return false;
    }

    // check if a polygon diagonal is locally inside the polygon
    static locallyInside(a, b) {
        return this.area(a.prev, a, a.next) < 0 ?
            this.area(a, b, a.next) >= 0 && this.area(a, a.prev, b) >= 0 :
            this.area(a, b, a.prev) < 0 || this.area(a, a.next, b) < 0;
    }

    // check if the middle point of a polygon diagonal is inside the polygon
    static middleInside(a, b) {
        let p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);

        return inside;
    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    static splitPolygon(a, b) {
        let a2 = new hmap.strategy.EarCut.Node(a.i, a.x, a.y, a.z),
            b2 = new hmap.strategy.EarCut.Node(b.i, b.x, b.y, b.z),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    static insertNode(i, x, y, z, last) {
        let p = new hmap.strategy.EarCut.Node(i, x, y, z);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    static removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    static deviation(data, holeIndices, dim, triangles) {
        let hasHoles = holeIndices && holeIndices.length;
        let outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        let polygonArea = Math.abs(this.signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (let i = 0, len = holeIndices.length; i < len; i++) {
                let start = holeIndices[i] * dim;
                let end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(this.signedArea(data, start, end, dim));
            }
        }

        let trianglesArea = 0;
        for (let i = 0; i < triangles.length; i += 3) {
            let a = triangles[i] * dim;
            let b = triangles[i + 1] * dim;
            let c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    }

    static signedArea(data, start, end, dim) {
        let sum = 0;
        let flag = 0;
        while (sum === 0 && flag < 3) {
            sum = 0
            for (let i = start, j = end - dim; i < end; i += dim) {
                sum += (data[flag + j] - data[flag + i]) * (data[i + (flag + 1) % 3] + data[j + (flag + 1) % 3]);
                j = i;
            }
            flag++;
        }
        if(flag === 3)  sum = -sum;
        return sum;
    }

    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    static flatten(data) {
        let dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;

        for (let i = 0; i < data.length; i++) {
            for (let j = 0; j < data[i].length; j++) {
                for (let d = 0; d < dim; d++) {
                    result.vertices.push(data[i][j][d]);
                }
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    }
}

hmap.strategy.EarCut.Node = class {
    constructor(i, x, y, z) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;
        this.m = z;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }
};;"use strict";
hmap.strategy = hmap.strategy || {};
/**
 * 本类用于计算几何体缓冲区（限于X-Y平面类）
 * @private
 * @type {hmap.strategy.LineBuffer}
 * @example
 * let buffer = hmap.strategy.LineBuffer(line,0.01)
 * buffer.build()
 */
hmap.strategy.LineBuffer = class {

    /**
     * 构造函数
     * @param line 线
     * @param dist 缓冲距离，单位与line的单位相同
     * @param endCap 端点类型。"ROUND"：圆角，"FLAT":平角。默认圆角
     * @param sideSign 缓冲模式（当前版本仅支持双向缓冲 0，不支持单边缓冲）。1：左缓冲，-1：右缓冲，0：双向缓冲。默认为双向缓冲
     */
    constructor(line, dist, endCap = "ROUND", sideSign = 0) {
        if (!line instanceof hmap.geom.Line || !line instanceof hmap.geom.LinearRing) {
            throw new TypeError("the line Parameter must be hmap.basetype.Line！");
        }
        this.quadrantSegments = 50;// 用来表示圆弧的线段数
        this.line = line;
        if (!(Number.isFinite(dist) && dist > 0)) {
            throw new Error()
        }
        this.dist = dist;
        if (sideSign !== 0 && sideSign !== -1 && sideSign !== 1) {
            throw new TypeError("parameter sideSign only  -1 ,0 or 1 is valid,")
        }
        this.endCap = endCap.toUpperCase();
        if (this.endCap != "ROUND" && this.endCap != "FLAT") {
            throw new TypeError("parameter endCap only  'ROUND' or 'FLAT' is valid !")
        }
        this.sideSign = sideSign;
        this.CLASS_NAME = "hmap.strategy.LineBuffer";
    }

    /**
     * 构建简单线缓冲区
     * @return {hmap.geom.Polygon}
     */
    build() {
        switch (this.line.getType()) {
            case hmap.geom.GeometryType.Line:
                return this._buildLine();
                break;
            case hmap.geom.GeometryType.LinearRing:
                return this._buildLinearRing();
                break;
        }
    }

    /**
     * 构建线环双侧缓冲区，TODO 线环单边缓冲有缺陷，sideSign=1
     * @return {hmap.geom.Polygon}
     * @private
     */
    _buildLinearRing() {
        let coords = this.line.getCoordSeq();
        const count = coords.getCoordCount();
        //判断是否需要反转坐标序列
        const bAntiClosewise = hmap.strategy.BufferUtil._antiClockCheck(coords, count);
        let rings = [];
        if (this.sideSign === 1) {
            rings.push(hmap.geom.LinearRing.fromCoordSeq(coords));
            if (bAntiClosewise) {
                coords = coords.reverse();
            }
            const ring2 = this._buildRingBuffer(coords, count);
            if (ring2) rings.push(ring2);
        } else if (this.sideSign === -1) {
            if (!bAntiClosewise) {
                coords = coords.reverse();
            }
            const ring1 = this._buildRingBuffer(coords, count);
            if (ring1) rings.push(ring1);
            rings.push(this.line);
        } else {
            //外侧缓冲
            if (!bAntiClosewise) {
                coords = coords.reverse();
            }
            const ring1 = this._buildRingBuffer(coords, count);
            if (ring1) rings.push(ring1);
            //内侧缓冲
            coords = coords.reverse();
            const ring2 = this._buildRingBuffer(coords, count);
            if (ring2) rings.push(ring2);
        }
        if (rings.length < 1) return null;
        return new hmap.geom.Polygon(rings);
    }

    /**
     * 线环缓冲区，
     * @param coords
     * @param count
     * @param bClosewise
     * @return {hmap.geom.LinearRing|null}
     * @private
     */
    _buildRingBuffer(coords, count) {
        let coordArr = [];
        //添加首/尾所在拐点的弧
        const c1 = coords.getCoordinate(count - 2);
        const c2 = coords.getCoordinate(0);
        const c3 = coords.getCoordinate(1);
        coordArr = coordArr.concat(
            hmap.strategy.BufferUtil._computeCap(c1, c2, c3, this.dist, this.sideSign, this.quadrantSegments)
        );
        //循环计算第i个拐点的弧或点
        for (let i = 1; i < count - 1; i++) {
            const c1 = coords.getCoordinate(i - 1);
            const c2 = coords.getCoordinate(i);
            const c3 = coords.getCoordinate(i + 1);
            coordArr = coordArr.concat(
                hmap.strategy.BufferUtil._computeCap(c1, c2, c3, this.dist, this.sideSign, this.quadrantSegments)
            )
        }

        if (coordArr.length < 3) return null;

        const coordSeq = new hmap.basetype.CoordSeq(coordArr);
        const ring = hmap.geom.LinearRing.fromCoordSeq(coordSeq);
        return ring;
    }

    /**
     * 构建简单线缓冲区
     * @return {hmap.geom.Polygon}
     * @private
     */
    _buildLine() {
        let coords = this.line.getCoordSeq();
        const count = coords.getCoordCount();
        let coordArr = [];

        if (this.sideSign === 1) {
            if (!hmap.strategy.BufferUtil._antiClockCheck(coords, count)) {
                coords = coords.reverse();
            }
            coordArr = coordArr.concat(this._buildSimpleBuffer(coords, count));
        } else if (this.sideSign === -1) {
            if (hmap.strategy.BufferUtil._antiClockCheck(coords, count)) {
                coords = coords.reverse();
            }
            coordArr = coordArr.concat(this._buildSimpleBuffer(coords, count));
        } else {
            coordArr = coordArr.concat(this._buildSimpleBuffer(coords, count));
            coordArr.length -= 1;//这里解决连接点重复问题，
            coords = coords.reverse();
            coordArr = coordArr.concat(this._buildSimpleBuffer(coords, count));
        }

        const coordSeq = new hmap.basetype.CoordSeq(coordArr);
        return new hmap.geom.Polygon([hmap.geom.LinearRing.fromCoordSeq(coordSeq)]);
    }

    /**
     * 简单线 节点序列
     * @param {hmap.basetype.CoordSeq}coords
     * @param {Number}count
     * @param {Boolean}anti
     * @return {Array}
     * @private
     */
    _buildSimpleBuffer(coords, count, anti) {
        let coordArr = [];
        //头点缓冲
        const c1 = coords.getCoordinate(0);
        const c2 = coords.getCoordinate(1);
        coordArr = coordArr.concat(
            hmap.strategy.BufferUtil._computeStartCap(c1, c2, this.dist, this.sideSign, this.quadrantSegments, this.endCap)
        );
        //循环计算第i个拐点的弧或点
        for (let i = 1; i < count - 1; i++) {
            const c11 = coords.getCoordinate(i - 1);
            const c12 = coords.getCoordinate(i);
            const c13 = coords.getCoordinate(i + 1);
            coordArr = coordArr.concat(
                hmap.strategy.BufferUtil._computeCap(c11, c12, c13, this.dist, this.sideSign, this.quadrantSegments)
            )
        }
        //尾点缓冲
        const c3 = coords.getCoordinate(count - 2);
        const c4 = coords.getCoordinate(count - 1);
        coordArr = coordArr.concat(
            hmap.strategy.BufferUtil._computeEndCap(c3, c4, this.dist, this.sideSign, this.quadrantSegments, this.endCap)
        );

        //倒叙拐点节点（不包含起始点），注意：只有单侧缓冲才需要添加拐点
        if (this.sideSign != 0 && this.line instanceof hmap.geom.Line) {
            for (let i = count - 2; i > 0; i--) {
                const c12 = coords.getCoordinate(i);
                coordArr.push(c12)
            }
        }
        //左侧缓冲
        return coordArr
    }
};
/**
 * 简单多边形的缓冲区（限于X-Y平面类）
 * @type {hmap.strategy.PolygonBuffer}
 * @example
 * let buffer = hmap.strategy.PolygonBuffer(line,0.01)
 * buffer.build()
 * @private
 */
hmap.strategy.PolygonBuffer = class {
    /**
     * 构造函数
     * @param {hmap.geom.Polygon} polygon 简单面
     * @param {Number} dist 缓冲距离，单位与line的单位相同
     * @param {String} sideType 面缓冲类型，"FULL"为包含原几何体，"OUTSIDE"不包含原有几何体。当前仅支持"FULL"
     */
    constructor(polygon, dist, sideType = "FULL") {
        if (!(polygon instanceof hmap.geom.Polygon)) {
            throw new TypeError("the polygon Parameter must be hmap.geom.Polygon！");
        }
        this.quadrantSegments = 30;// 用来表示圆弧的线段数
        this.polygon = polygon;
        this.dist = dist;
        this.sideType = sideType.toUpperCase();
        if (this.sideType != "FULL" && this.sideType != "OUTSIDE") {
            throw new TypeError("parameter sideType only  'FULL' or 'OUTSIDE' is valid !")
        }

        this.sideSign = -1;
        this.CLASS_NAME = "hmap.strategy.PolygonBuffer";
        this.topo = new hmap.strategy.TopologyBoolean();
        this.toolGeoJSON = new hmap.format.GeoJSON();
    }

    /**
     * 构建缓冲区
     * @return {hmap.geom.Geometry}
     */
    build() {
        let coords = this.polygon.getLinearRing(0).getCoordSeq();
        const count = coords.getCoordCount();
        let rings = [];
        //外环
        rings.push(this._buildBufferRing(coords, count, true));
        //内环
        if (this.polygon.getLinearRingCount() > 1) {
            for (let i = 1, len = this.polygon.getLinearRingCount(); i < len; i++) {
                const coordInner = this.polygon.getLinearRing(i).getCoordSeq();
                const countInner = coordInner.getCoordCount();
                let ring = this._buildBufferRing(coordInner, countInner, false);
                if (ring) rings.push(ring);
            }
        }
        //缓冲区对象
        const polyBuffer = new hmap.geom.Polygon(rings);
        //解除自相交
        const polyJSON = this.topo.dealSelfIntersect(this.toolGeoJSON.writeGeometry(polyBuffer));
        if (this.sideType === "FULL") {
            return this.toolGeoJSON.readGeometry(polyJSON, null);
        } else {
            const result = this.topo.difference(polyJSON, this.toolGeoJSON.writeGeometry(this.polygon));
            return this.toolGeoJSON.readGeometry(result, null);
        }
    }

    /**
     * 构造线环缓冲区，
     * @param {hmap.basetype.CoordSeq}coords
     * @param {Number}count
     * @param {Boolean}flag 方向，true为右侧缓冲，false为左侧缓冲
     * @return {hmap.geom.LinearRing}
     * @private
     */
    _buildBufferRing(coords, count, flag) {
        if (coords.getCoordCount() < 3) return null;
        //判断是否需要反转坐标序列
        if (!hmap.strategy.BufferUtil._antiClockCheck(coords, count) == flag) {
            coords = coords.reverse();
        }
        let coordArr = [];
        //循环计算第i个拐点的弧或点
        for (let i = 1; i < count - 1; i++) {
            const c1 = coords.getCoordinate(i - 1);
            const c2 = coords.getCoordinate(i);
            const c3 = coords.getCoordinate(i + 1);
            coordArr = coordArr.concat(
                hmap.strategy.BufferUtil._computeCap(c1, c2, c3, this.dist, this.sideSign, this.quadrantSegments)
            )
        }
        //添加首/尾所在拐点的弧
        const c1 = coords.getCoordinate(count - 2);
        const c2 = coords.getCoordinate(0);
        const c3 = coords.getCoordinate(1);
        coordArr = coordArr.concat(
            hmap.strategy.BufferUtil._computeCap(c1, c2, c3, this.dist, this.sideSign, this.quadrantSegments)
        );

        let coordSeq = new hmap.basetype.CoordSeq(coordArr);
        if (coordSeq.getCoordCount() < 3) return null;
        return hmap.geom.LinearRing.fromCoordSeq(coordSeq);
    }
};

/**
 * 缓冲区帮助类
 * @type {hmap.strategy.BufferUtil}
 * @private
 */
hmap.strategy.BufferUtil = class {
    /**
     * 起点处理
     * @param coordStart
     * @param coordEnd
     * @return {Array}
     * @private
     */
    static _getOffsetStart(coordStart, coordEnd) {
        const offsetStartX0 = 2 * coordStart.getOrdinate("X") - coordEnd.getOrdinate("X");
        const offsetStartY0 = 2 * coordStart.getOrdinate("Y") - coordEnd.getOrdinate("Y");
        const offsetStart0 = new hmap.basetype.Coordinate(offsetStartX0, offsetStartY0);
        return [offsetStart0, coordStart];
    }

    /**
     * 线段头处理
     * @param coord1
     * @param coord2
     * @param dist
     * @param sideSign
     * @param quadrantSegments
     * @param endCap
     * @return {Array}
     * @private
     */
    static _computeStartCap(coord1, coord2, dist, sideSign, quadrantSegments, endCap) {
        let coordArr = [];
        const seg2 = this._computeOffsetSeg(coord1, coord2, dist, sideSign);
        if (endCap === "FLAT") {
            coordArr.push(coord1);
            coordArr.push(seg2[0]);
        } else {
            const segTemp = this._getOffsetStart(coord1, seg2[0]);
            const seg1 = this._computeOffsetSeg(segTemp[0], segTemp[1], dist, sideSign);
            let orientation = hmap.strategy.Topology.checkCollinear(segTemp[0], coord1, coord2);
            if (orientation == 1) {
                let cornerCoords = this._addCornerFillet(coord1, seg1[1], seg2[0], orientation, dist, quadrantSegments);
                coordArr = coordArr.concat(cornerCoords);
            }
        }
        return coordArr;
    }

    /**
     * 末端点处理
     * @param coordStart
     * @param coordEnd
     * @return {Array}
     * @private
     */
    static _getOffsetEnd(coordStart, coordEnd) {
        const offsetStartX0 = 2 * coordEnd.getOrdinate("X") - coordStart.getOrdinate("X");
        const offsetStartY0 = 2 * coordEnd.getOrdinate("Y") - coordStart.getOrdinate("Y");
        const offsetEnd0 = new hmap.basetype.Coordinate(offsetStartX0, offsetStartY0);
        return [coordEnd, offsetEnd0];
    }

    /**
     * 处理线段结尾
     * @param coord1
     * @param coord2
     * @param dist
     * @param sideSign
     * @param quadrantSegments
     * @return {Array}
     * @private
     */
    static _computeEndCap(coord1, coord2, dist, sideSign, quadrantSegments, endCap) {
        let coordArr = [];
        const seg1 = this._computeOffsetSeg(coord1, coord2, dist, sideSign);
        if (endCap === "FLAT") {
            coordArr.push(seg1[1])
            coordArr.push(coord2)
        } else {
            const segTemp = this._getOffsetEnd(seg1[1], coord2);
            const seg2 = this._computeOffsetSeg(segTemp[0], segTemp[1], dist, sideSign);

            let orientation = hmap.strategy.Topology.checkCollinear(coord1, coord2, segTemp[1]);
            if (orientation == 1) {
                let cornerCoords = this._addCornerFillet(coord2, seg1[1], seg2[0], orientation, dist, quadrantSegments);
                coordArr = coordArr.concat(cornerCoords);
            }
        }
        return coordArr;
    }

    /**
     * 拐点填充序列
     * @param coord1
     * @param coord2
     * @param coord3
     * @param dist
     * @param sideSign
     * @param quadrantSegments
     * @return {Array}
     * @private
     */
    static _computeCap(coord1, coord2, coord3, dist, sideSign, quadrantSegments) {
        let coordArr = [];
        const seg1 = this._computeOffsetSeg(coord1, coord2, dist, sideSign);
        const seg2 = this._computeOffsetSeg(coord2, coord3, dist, sideSign);

        // coordArr.push(...seg1),  添加会有冗余，本方法下同
        let orientation = hmap.strategy.Topology.checkCollinear(coord1, coord2, coord3);
        if (orientation == -1) {
            let intersection = hmap.geom.Line.segmentsIntersect(seg1, seg2, {point: true});
            if (intersection)
                coordArr.push(intersection.getCoordinate());
        } else {
            let cornerCoords = this._addCornerFillet(coord2, seg1[1], seg2[0], orientation, dist, quadrantSegments);
            coordArr = coordArr.concat(cornerCoords);
        }
        // coordArr.push(...seg2)
        return coordArr;
    }

    /**
     * 格林公式，判断点序列顺时针还是逆时针
     * @param coords
     * @param count
     * @return {Boolean}
     * @private
     */
    static _antiClockCheck(coords, count) {
        //沿着多边形的边求曲线积分,若积分为正,则是沿着边界曲线正方向(逆时针),反之为顺时针
        let d = 0;
        for (let i = 0; i < count - 1; i++) {
            d += -0.5 * (coords.getCoordinate(i + 1).getOrdinate("Y") + coords.getCoordinate(i).getOrdinate("Y"))
                * (coords.getCoordinate(i + 1).getOrdinate("X") - coords.getCoordinate(i).getOrdinate("X"));
        }
        //小于零为顺时针，大于零为逆时针
        return d > 0 ? true : false;
    }

    /**
     * 为反射角周围的圆形圆角添加点
     * @param midCoord
     * @param coordStart
     * @param coordEnd
     * @param orientation
     * @param dist
     * @param quadrantSegments
     * @return {*}
     * @private
     */
    static _addCornerFillet(midCoord, coordStart, coordEnd, orientation, dist, quadrantSegments) {
        const dx0 = coordStart.getOrdinate("X") - midCoord.getOrdinate("X"),
            dy0 = coordStart.getOrdinate("Y") - midCoord.getOrdinate("Y");
        const dx1 = coordEnd.getOrdinate("X") - midCoord.getOrdinate("X"),
            dy1 = coordEnd.getOrdinate("Y") - midCoord.getOrdinate("Y");

        let startAngle = Math.atan2(dy0, dx0),
            endAngle = Math.atan2(dy1, dx1);

        if (orientation == -1) {//顺时针
            if (startAngle <= endAngle) {
                startAngle += 2.0 * Math.PI;
            }
        } else { //逆时针
            if (startAngle >= endAngle) {
                startAngle -= 2.0 * Math.PI;
            }
        }
        const coordArr = this._genDirectedFillet(midCoord, startAngle, endAngle, orientation, dist, quadrantSegments);
        return coordArr;
    }

    /**
     * 计算偏移线段
     * @param coordStart
     * @param coordEnd
     * @param dist
     * @param sideSign
     * @return {hmap.basetype.Coordinate[]}
     * @private
     */
    static _computeOffsetSeg(coordStart, coordEnd, dist, sideSign) {
        const dx = coordEnd.getOrdinate("X") - coordStart.getOrdinate("X");
        const dy = coordEnd.getOrdinate("Y") - coordStart.getOrdinate("Y");
        const len = Math.sqrt(dx * dx + dy * dy);
        let uy = -dist * dx / len;
        let ux = -dist * dy / len;

        const offsetStartX = coordStart.getOrdinate("X") - ux;
        const offsetStartY = coordStart.getOrdinate("Y") + uy;
        const offsetEndX = coordEnd.getOrdinate("X") - ux;
        const offsetEndY = coordEnd.getOrdinate("Y") + uy;

        const offsetCoordStart = new hmap.basetype.Coordinate(offsetStartX, offsetStartY);
        const offsetCoordEnd = new hmap.basetype.Coordinate(offsetEndX, offsetEndY);
        return [offsetCoordStart, offsetCoordEnd];
    }

    /**
     * 端点弧段中添加点状数据
     * @param coord
     * @param startAngle
     * @param endAngle
     * @param orientation
     * @param dist
     * @param quadrantSegments
     * @return {any[]}
     * @private
     */
    static _genDirectedFillet(coord, startAngle, endAngle, orientation, dist, quadrantSegments) {
        let coordArr = new Array();
        const totalAngle = Math.abs(startAngle - endAngle);
        const nSegs = Math.floor((totalAngle * quadrantSegments) / (2 * Math.PI) + 0.5) + 1;
        const currAngleInc = totalAngle / nSegs;
        const x0 = coord.getOrdinate("X"), y0 = coord.getOrdinate("Y");
        let currAngle = 0.0;
        while (currAngle <= totalAngle) {
            let angle = startAngle + orientation * currAngle;
            const x = x0 + dist * Math.cos(angle);
            const y = y0 + dist * Math.sin(angle);
            const coordx = new hmap.basetype.Coordinate(x, y, 0);
            coordArr.push(coordx);
            currAngle += currAngleInc;
        }
        //由于精度问题，最后一个弧度可能没有执行，导致缓冲区偏离，在此解决
        if (Math.abs(currAngle - totalAngle) < currAngleInc) {
            const x = x0 + dist * Math.cos(endAngle);
            const y = y0 + dist * Math.sin(endAngle);
            const coordLast = coordArr[coordArr.length - 1];
            //补充，如果为与序列最后一点重复则不需要添加
            if (coordLast._x !== x || coordLast._y !== y) {
                const coordx = new hmap.basetype.Coordinate(x, y, 0);
                coordArr.push(coordx);
            }
        }
        return coordArr;
    }
};"use strict"

/**
 * 本类用于几何体的拓扑计算
 * @type {hmap.strategy.Topology}
 * @private
 */
hmap.strategy.Topology = class {
    /**
     * 检测点与线段的关系。线段被认为是由两个坐标点构成的，其中coordStart表示起点，coordEnd表示终点。
     * @param {hmap.basetype.Coordinate} coordStart 线段起点
     * @param {hmap.basetype.Coordinate} coordEnd 线段终点
     * @param {hmap.basetype.Coordinate} coord 检测点
     * @return {Number} -1表示coord在线段右侧；1表示coord在线段左侧；0表示coord在线段上，即三点共线。
     */
    static checkCollinear(coordStart, coordEnd, coord) {
        const dx1 = coordEnd.getOrdinate("X") - coordStart.getOrdinate("X");
        const dy1 = coordEnd.getOrdinate("Y") - coordStart.getOrdinate("Y");
        const dx2 = coord.getOrdinate("X") - coordEnd.getOrdinate("X");
        const dy2 = coord.getOrdinate("Y") - coordEnd.getOrdinate("Y");
        let flag = dx1 * dy2 - dy1 * dx2;
        if (flag > 0) {
            flag = 1;
        } else if (flag < 0) {
            flag = -1;
        } else {
            flag = 0;
        }
        return flag;
    }

    /**
     * 获取凸包
     * @param coordArray 点集
     * @param reverse
     * @return {Array<hmap.basetype.Coordinate>}
     */
    static getConvexHull(coordArray, reverse = false) {
        let anchorPoint = undefined;
        for (let i = 0, len = coordArray.length; i < len; i++) {
            if (!coordArray[i] instanceof hmap.basetype.Coordinate) {
                throw new TypeError("parameter 'pointArray' should be an array of hmap.basetype.Coordinate instance")
            }
            if (anchorPoint === undefined) {
                anchorPoint = coordArray[i].clone();
            } else {
                let xa = anchorPoint.getOrdinate("X"),
                    ya = anchorPoint.getOrdinate("Y"),
                    x = coordArray[i].getOrdinate("X"),
                    y = coordArray[i].getOrdinate("Y");
                if (ya > y || (ya == y && xa > x)) {
                    anchorPoint = coordArray[i].clone();
                }
            }
        }
        let hullPoints = [], points, pointsLength;
        reverse = coordArray.every(function (point) {
            return (point.x < 0 && point.y < 0);
        });
        points = this._sortPoints(coordArray, anchorPoint, reverse);
        pointsLength = points.length;

        //If there are less than 3 points, joining these points creates a correct hull.
        if (pointsLength < 3) {
            points.unshift(anchorPoint);
            return points;
        }

        //move first two points to output array
        hullPoints.push(points.shift(), points.shift());

        //scan is repeated until no concave points are present.
        while (true) {
            let p0, p1, p2;

            hullPoints.push(points.shift());
            p0 = hullPoints[hullPoints.length - 3];
            p1 = hullPoints[hullPoints.length - 2];
            p2 = hullPoints[hullPoints.length - 1];

            if (this._checkPoints(p0, p1, p2, reverse)) {
                hullPoints.splice(hullPoints.length - 2, 1);
            }

            if (points.length == 0) {
                if (pointsLength == hullPoints.length) {
                    //check for duplicate anchorPoint edge-case, if not found, add the anchorpoint as the first item.
                    //remove any udefined elements in the hullPoints array.
                    hullPoints = hullPoints.filter(function (p) {
                        return !!p;
                    });
                    if (!hullPoints.some(function (p) {
                        return (p.getOrdinate("X") == anchorPoint.getOrdinate("X")
                            && p.getOrdinate("Y") == anchorPoint.getOrdinate("Y"));
                    })) {
                        hullPoints.unshift(anchorPoint);
                    }
                    return hullPoints;
                }
                points = hullPoints;
                pointsLength = points.length;
                hullPoints = [];
                hullPoints.push(points.shift(), points.shift());
            }
        }
        return hullPoints;
    }

    /**
     * 凸包，极角计算
     * @param a
     * @param b
     * @param reverse
     * @return {number}
     * @private
     */
    static _findPolarAngle(a, b, reverse) {
        let ONE_RADIAN = 57.295779513082;
        let deltaX, deltaY;

        //if the points are undefined, return a zero difference angle.
        if (!a || !b) return 0;

        deltaX = (b.getOrdinate("X") - a.getOrdinate("X"));
        deltaY = (b.getOrdinate("Y") - a.getOrdinate("Y"));

        if (deltaX == 0 && deltaY == 0) {
            return 0;
        }

        let angle = Math.atan2(deltaY, deltaX) * ONE_RADIAN;

        if (reverse) {
            if (angle <= 0) {
                angle += 360;
            }
        } else {
            if (angle >= 0) {
                angle += 360;
            }
        }
        return angle;
    }

    /**
     * 凸包，按照极角排序
     * @param points
     * @param anchorPoint
     * @param reverse
     * @return {hmap.basetype.CoordSeq|this|this|this|this|this|this|this|this|this|this|this|this|void}
     * @private
     */
    static _sortPoints(points, anchorPoint, reverse) {
        let self = this;
        return points.sort(function (a, b) {
            let polarA = self._findPolarAngle(anchorPoint, a, reverse);
            let polarB = self._findPolarAngle(anchorPoint, b, reverse);

            if (polarA < polarB) {
                return -1;
            }
            if (polarA > polarB) {
                return 1;
            }
            return 0;
        });
    }

    /**
     * 凸包，前进点方向计算
     * @param p0
     * @param p1
     * @param p2
     * @param reverse
     * @return {Boolean}
     * @private
     */
    static _checkPoints(p0, p1, p2, reverse) {
        let difAngle;
        let cwAngle = this._findPolarAngle(p0, p1, reverse);
        let ccwAngle = this._findPolarAngle(p0, p2, reverse);

        if (cwAngle > ccwAngle) {
            difAngle = cwAngle - ccwAngle;
            return !(difAngle > 180);
        } else if (cwAngle < ccwAngle) {
            difAngle = ccwAngle - cwAngle;
            return (difAngle > 180);
        }
        return true;
    }
}

;"use strict";
hmap.strategy = hmap.strategy || {};
/**
 * 多边形拓扑运算（交集，并集，差集，异或），参数/输出格式统一为GeoJSON,，（可以开放）
 * @type {hmap.strategy.TopologyBoolean}
 * @example
 * let topo=new TopologyBoolean()
 * let result = topo.union(poly1,poly2)
 * @private
 */
hmap.strategy.TopologyBoolean = class {
    constructor() {
        this.CLASS_NAME = "hmap.strategy.TopologyBoolean";
        this.eps = 0.000000001;
        this._epsilon = this._epsilonHandler(this.eps); //点坐标容差
        this._segmentSelector = this._createSegmentSelector();
        this._linkList = this._createLinkedList();
        this._geojsonHandler = this._handleGeoJSON();
    }

    /**
     * GeoJSON格式转换为特定格式
     * @param poly1
     * @param poly2
     * @return {Array}
     * @private
     */
    _handleToGeoJSON(poly) {
        return this._geojsonHandler.toPolygon(poly);
    }

    /**
     * 处理自相交问题
     * @param geojson
     * @return {{coordinates, type}}
     */
    dealSelfIntersect(geojson) {
        const poly = this._geojsonHandler.toPolygon(geojson);
        poly.regions.forEach((regs) => {
            regs.forEach((item, index) => {
                let arrRep = [];
                if (regs.indexOf(item) != index) { // 匹配数组元素第一个item位置和当前循环的index
                    arrRep.push(regs.indexOf(item), index);
                }
                if (arrRep.length > 0) {
                    regs.splice(arrRep[0], arrRep[1] - arrRep[0]);
                }
            });
        });
        return this._geojsonHandler.fromPolygon(poly);
    }

    /**
     * 并集
     * @param {Object} polygon1 GeoJSON对象
     * @param {Object} polygon2 GeoJSON对象
     * @return {Object} GeoJOSN格式
     */
    union(polygon1, polygon2) {
        const poly1 = this._handleToGeoJSON(polygon1);
        const poly2 = this._handleToGeoJSON(polygon2);
        const poly = this._union(poly1, poly2);
        return this._geojsonHandler.fromPolygon(poly);
    }

    getOutRing(polygon) {
        const poly1 = this._handleToGeoJSON(polygon);
        return this._geojsonHandler.fromPolygon(poly1);
    }

    /**
     * 并集
     * @param {Object} polygon1 GeoJSON对象
     * @param {Object} polygon2 GeoJSON对象
     * @return {Object} GeoJSON格式
     */
    unionPolygons(polys) {
        let poly = this._handleToGeoJSON(polys[0]);
        for (let i = 1, len = polys.length; i < len; i++) {
            let poly2 = this._handleToGeoJSON(polys[i]);
            poly = this._union(poly, poly2);
        }
        return this._geojsonHandler.fromPolygon(poly);
    }

    /**
     * 格式
     * @param poly1
     * @param poly2
     * @return {*}
     * @private
     */
    _union(poly1, poly2) {
        const self = this;
        const func = function (combined) {
            return {
                segments: self._segmentSelector.union(combined.combined),
                inverted: combined.inverted1 || combined.inverted2
            }
        };
        return this._operater(poly1, poly2, func);
    }


    /**
     * 交集
     * @param {Object} polygon1 GeoJSON对象
     * @param {Object} polygon2 GeoJSON对象
     * @return {Object} GeoJSON对象
     */
    intersect(polygon1, polygon2) {
        const poly1 = this._handleToGeoJSON(polygon1);
        const poly2 = this._handleToGeoJSON(polygon2);
        const self = this;
        const func = function (combined) {
            return {
                segments: self._segmentSelector.intersect(combined.combined),
                inverted: combined.inverted1 && combined.inverted2
            }
        };
        return this._geojsonHandler.fromPolygon(this._operater(poly1, poly2, func));
    }

    /**
     * 差集
     * @param {Object} polygon1 GeoJSON对象
     * @param {Object} polygon2 GeoJSON对象
     * @return {Object} 返回( polygon1 - polygon2 )的GeoJSON对象
     */
    difference(polygon1, polygon2) {
        const poly1 = this._handleToGeoJSON(polygon1);
        const poly2 = this._handleToGeoJSON(polygon2);
        const self = this;
        const func = function (combined) {
            return {
                segments: self._segmentSelector.difference(combined.combined),
                inverted: combined.inverted1 && !combined.inverted2
            }
        };
        return this._geojsonHandler.fromPolygon(this._operater(poly1, poly2, func));
    };

    /**
     * 异或
     * @param {Object} polygon1 GeoJSON对象
     * @param {Object} polygon2 GeoJSON对象
     * @return {Object}  GeoJSON对象
     */
    xor(polygon1, polygon2) {
        const poly1 = this._handleToGeoJSON(polygon1);
        const poly2 = this._handleToGeoJSON(polygon2);
        const self = this;
        const func = function (combined) {
            return {
                segments: self._segmentSelector.xor(combined.combined),
                inverted: combined.inverted1 !== combined.inverted2
            }
        };
        return this._geojsonHandler.fromPolygon(this._operater(poly1, poly2, func));
    }

    /**
     * 运算入口
     * @param {Object} poly1
     * @param {Object} poly2
     * @param {Function} selector
     * @private
     */
    _operater(poly1, poly2, selector) {
        const seg1 = this._segments(poly1);
        const seg2 = this._segments(poly2);
        const comb = this._combine(seg1, seg2);
        const seg3 = selector(comb);
        return this._polygon(seg3);
    }

    /**
     * 将对象切分为线段
     * @param {Object} poly
     * @private
     */
    _segments(poly, selfIntersection = true) {
        const hi = this._intersecter(selfIntersection, this._epsilon);
        poly.regions.forEach(hi.addRegion);
        return {
            segments: hi.calculate(poly.inverted),
            inverted: poly.inverted
        };
    }

    /**
     * 所有线段合并为双向链表，
     * @param {Object} segments1
     * @param {Object} segments2
     * @private
     */
    _combine(segments1, segments2, selfIntersection = false) {
        const hi = this._intersecter(selfIntersection, this._epsilon);
        return {
            combined: hi.calculate(
                segments1.segments, segments1.inverted,
                segments2.segments, segments2.inverted
            ),
            inverted1: segments1.inverted,
            inverted2: segments2.inverted
        };
    }

    /**
     * 计算结果重新组合为Poly
     * @param {Object} segments
     * @private
     */
    _polygon(segments) {
        return {
            regions: this._segmentChainer(segments.segments, this._epsilon),
            inverted: segments.inverted
        };
    }

    /**
     * 合并
     * @param {Object} segments
     * @param {Object} eps
     * @private
     */
    _segmentChainer(segments, eps) {
        const chains = [];
        const regions = [];

        segments.forEach(function (seg) {
            let pt1 = seg.start;
            let pt2 = seg.end;
            if (eps.pointsSame(pt1, pt2)) {
                console.warn('Zero-length segment detected; your epsilon is probably too small or too large');
                return;
            }

            // search for two chains that this segment matches
            const first_match = {
                index: 0,
                matches_head: false,
                matches_pt1: false
            };
            const second_match = {
                index: 0,
                matches_head: false,
                matches_pt1: false
            };
            let next_match = first_match;

            function setMatch(index, matches_head, matches_pt1) {
                // return true if we've matched twice
                next_match.index = index;
                next_match.matches_head = matches_head;
                next_match.matches_pt1 = matches_pt1;
                if (next_match === first_match) {
                    next_match = second_match;
                    return false;
                }
                next_match = null;
                return true; // we've matched twice, we're done here
            }

            for (let i = 0; i < chains.length; i++) {
                const chain = chains[i];
                const head = chain[0];
                const head2 = chain[1];
                const tail = chain[chain.length - 1];
                const tail2 = chain[chain.length - 2];
                if (eps.pointsSame(head, pt1)) {
                    if (setMatch(i, true, true))
                        break;
                } else if (eps.pointsSame(head, pt2)) {
                    if (setMatch(i, true, false))
                        break;
                } else if (eps.pointsSame(tail, pt1)) {
                    if (setMatch(i, false, true))
                        break;
                } else if (eps.pointsSame(tail, pt2)) {
                    if (setMatch(i, false, false))
                        break;
                }
            }

            if (next_match === first_match) {
                // we didn't match anything, so create a new chain
                chains.push([pt1, pt2]);
                return;
            }

            if (next_match === second_match) {
                // we matched a single chain

                // add the other point to the apporpriate end, and check to see if we've closed the
                // chain into a loop
                const index = first_match.index;
                const pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc
                const addToHead = first_match.matches_head; // if we matched at head, then add to the head

                let chain = chains[index];
                let grow = addToHead ? chain[0] : chain[chain.length - 1];
                let grow2 = addToHead ? chain[1] : chain[chain.length - 2];
                let oppo = addToHead ? chain[chain.length - 1] : chain[0];
                let oppo2 = addToHead ? chain[chain.length - 2] : chain[1];

                if (eps.pointsCollinear(grow2, grow, pt)) {
                    // grow isn't needed because it's directly between grow2 and pt:
                    // grow2 ---grow---> pt
                    if (addToHead) {
                        chain.shift();
                    } else {
                        chain.pop();
                    }
                    grow = grow2; // old grow is gone... new grow is what grow2 was
                }

                if (eps.pointsSame(oppo, pt)) {
                    // we're closing the loop, so remove chain from chains
                    chains.splice(index, 1);

                    if (eps.pointsCollinear(oppo2, oppo, grow)) {
                        // oppo isn't needed because it's directly between oppo2 and grow:
                        // oppo2 ---oppo--->grow
                        if (addToHead) {
                            chain.pop();
                        } else {
                            chain.shift();
                        }
                    }

                    // we have a closed chain!
                    regions.push(chain);
                    return;
                }

                // not closing a loop, so just add it to the apporpriate side
                if (addToHead) {
                    chain.unshift(pt);
                } else {
                    chain.push(pt);
                }
                return;
            }

            // otherwise, we matched two chains, so we need to combine those chains together

            function reverseChain(index) {
                chains[index].reverse(); // gee, that's easy
            }

            function appendChain(index1, index2) {
                // index1 gets index2 appended to it, and index2 is removed
                const chain1 = chains[index1];
                const chain2 = chains[index2];
                let tail = chain1[chain1.length - 1];
                const tail2 = chain1[chain1.length - 2];
                const head = chain2[0];
                const head2 = chain2[1];

                if (eps.pointsCollinear(tail2, tail, head)) {
                    // tail isn't needed because it's directly between tail2 and head
                    // tail2 ---tail---> head
                    chain1.pop();
                    tail = tail2; // old tail is gone... new tail is what tail2 was
                }

                if (eps.pointsCollinear(tail, head, head2)) {
                    // head isn't needed because it's directly between tail and head2
                    // tail ---head---> head2
                    chain2.shift();
                }
                chains[index1] = chain1.concat(chain2);
                chains.splice(index2, 1);
            }

            let F = first_match.index;
            let S = second_match.index;

            let reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed
            if (first_match.matches_head) {
                if (second_match.matches_head) {
                    if (reverseF) {
                        // <<<< F <<<< --- >>>> S >>>>
                        reverseChain(F);
                        // >>>> F >>>> --- >>>> S >>>>
                        appendChain(F, S);
                    } else {
                        // <<<< F <<<< --- >>>> S >>>>
                        reverseChain(S);
                        // <<<< F <<<< --- <<<< S <<<<   logically same as:
                        // >>>> S >>>> --- >>>> F >>>>
                        appendChain(S, F);
                    }
                } else {
                    // <<<< F <<<< --- <<<< S <<<<   logically same as:
                    // >>>> S >>>> --- >>>> F >>>>
                    appendChain(S, F);
                }
            } else {
                if (second_match.matches_head) {
                    // >>>> F >>>> --- >>>> S >>>>
                    appendChain(F, S);
                } else {
                    if (reverseF) {
                        // >>>> F >>>> --- <<<< S <<<<
                        reverseChain(F);
                        // <<<< F <<<< --- <<<< S <<<<   logically same as:
                        // >>>> S >>>> --- >>>> F >>>>
                        appendChain(S, F);
                    } else {
                        // >>>> F >>>> --- <<<< S <<<<
                        reverseChain(S);
                        // >>>> F >>>> --- >>>> S >>>>
                        appendChain(F, S);
                    }
                }
            }
        });

        return regions;
    }

    /**
     *
     * @param {*} selfIntersection
     * @param {*} eps
     * @private
     */
    _intersecter(selfIntersection, eps) {
        let self = this;
        // selfIntersection is true/false depending on the phase of the overall algorithm
        //
        // segment creation
        //
        function segmentNew(start, end) {
            return {
                start: start,
                end: end,
                myFill: {
                    above: null, // is there fill above us?
                    below: null  // is there fill below us?
                },
                otherFill: null
            };
        }

        function segmentCopy(start, end, seg) {
            return {
                start: start,
                end: end,
                myFill: {
                    above: seg.myFill.above,
                    below: seg.myFill.below
                },
                otherFill: null
            };
        }

        //
        // event logic
        //
        let event_root = this._linkList.create();

        function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {
            // compare the selected points first
            let comp = eps.pointsCompare(p1_1, p2_1);
            if (comp !== 0)
                return comp;
            // the selected points are the same

            if (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...
                return 0; // then the segments are equal

            if (p1_isStart !== p2_isStart) // if one is a start and the other isn't...
                return p1_isStart ? 1 : -1; // favor the one that isn't the start

            // otherwise, we'll have to calculate which one is below the other manually
            return eps.pointAboveOrOnLine(p1_2,
                p2_isStart ? p2_1 : p2_2, // order matters
                p2_isStart ? p2_2 : p2_1
            ) ? 1 : -1;
        }

        function eventAdd(ev, other_pt) {
            event_root.insertBefore(ev, function (here) {
                // should ev be inserted before here?
                let comp = eventCompare(
                    ev.isStart, ev.pt, other_pt,
                    here.isStart, here.pt, here.other.pt
                );
                return comp < 0;
            });
        }

        function eventAddSegmentStart(seg, primary) {
            let ev_start = self._linkList.node({
                isStart: true,
                pt: seg.start,
                seg: seg,
                primary: primary,
                other: null,
                status: null
            });
            eventAdd(ev_start, seg.end);
            return ev_start;
        }

        function eventAddSegmentEnd(ev_start, seg, primary) {
            let ev_end = self._linkList.node({
                isStart: false,
                pt: seg.end,
                seg: seg,
                primary: primary,
                other: ev_start,
                status: null
            });
            ev_start.other = ev_end;
            eventAdd(ev_end, ev_start.pt);
        }

        function eventAddSegment(seg, primary) {
            let ev_start = eventAddSegmentStart(seg, primary);
            eventAddSegmentEnd(ev_start, seg, primary);
            return ev_start;
        }

        function eventUpdateEnd(ev, end) {
            // slides an end backwards
            //   (start)------------(end)    to:
            //   (start)---(end)
            ev.other.remove();
            ev.seg.end = end;
            ev.other.pt = end;
            eventAdd(ev.other, ev.pt);
        }

        function eventDivide(ev, pt) {
            const ns = segmentCopy(pt, ev.seg.end, ev.seg);
            eventUpdateEnd(ev, pt);
            return eventAddSegment(ns, ev.primary);
        }

        function calculate(primaryPolyInverted, secondaryPolyInverted) {
            // if selfIntersection is true then there is no secondary polygon, so that isn't used

            //
            // status logic
            //
            let status_root = self._linkList.create();

            function statusCompare(ev1, ev2) {
                const a1 = ev1.seg.start;
                const a2 = ev1.seg.end;
                const b1 = ev2.seg.start;
                const b2 = ev2.seg.end;

                if (eps.pointsCollinear(a1, b1, b2)) {
                    if (eps.pointsCollinear(a2, b1, b2))
                        return 1;//eventCompare(true, a1, a2, true, b1, b2);
                    return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
                }
                return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
            }

            function statusFindSurrounding(ev) {
                return status_root.findTransition(function (here) {
                    const comp = statusCompare(ev, here.ev);
                    return comp > 0;
                });
            }

            function checkIntersection(ev1, ev2) {
                // returns the segment equal to ev1, or false if nothing equal

                const seg1 = ev1.seg;
                const seg2 = ev2.seg;
                const a1 = seg1.start;
                const a2 = seg1.end;
                const b1 = seg2.start;
                const b2 = seg2.end;

                const i = eps.linesIntersect(a1, a2, b1, b2);

                if (i === false) {
                    // segments are parallel or coincident

                    // if points aren't collinear, then the segments are parallel, so no intersections
                    if (!eps.pointsCollinear(a1, a2, b1))
                        return false;
                    // otherwise, segments are on top of each other somehow (aka coincident)

                    if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
                        return false; // segments touch at endpoints... no intersection

                    let a1_equ_b1 = eps.pointsSame(a1, b1);
                    let a2_equ_b2 = eps.pointsSame(a2, b2);

                    if (a1_equ_b1 && a2_equ_b2)
                        return ev2; // segments are exactly equal

                    let a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
                    let a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);

                    // handy for debugging:
                    if (a1_equ_b1) {
                        if (a2_between) {
                            //  (a1)---(a2)
                            //  (b1)----------(b2)
                            eventDivide(ev2, a2);
                        } else {
                            //  (a1)----------(a2)
                            //  (b1)---(b2)
                            eventDivide(ev1, b2);
                        }
                        return ev2;
                    } else if (a1_between) {
                        if (!a2_equ_b2) {
                            // make a2 equal to b2
                            if (a2_between) {
                                //         (a1)---(a2)
                                //  (b1)-----------------(b2)
                                eventDivide(ev2, a2);
                            } else {
                                //         (a1)----------(a2)
                                //  (b1)----------(b2)
                                eventDivide(ev1, b2);
                            }
                        }

                        //         (a1)---(a2)
                        //  (b1)----------(b2)
                        eventDivide(ev2, a1);
                    }
                } else {
                    // otherwise, lines intersect at i.pt, which may or may not be between the endpoints

                    // is A divided between its endpoints? (exclusive)
                    if (i.alongA === 0) {
                        if (i.alongB === -1) // yes, at exactly b1
                            eventDivide(ev1, b1);
                        else if (i.alongB === 0) // yes, somewhere between B's endpoints
                            eventDivide(ev1, i.pt);
                        else if (i.alongB === 1) // yes, at exactly b2
                            eventDivide(ev1, b2);
                    }

                    // is B divided between its endpoints? (exclusive)
                    if (i.alongB === 0) {
                        if (i.alongA === -1) // yes, at exactly a1
                            eventDivide(ev2, a1);
                        else if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)
                            eventDivide(ev2, i.pt);
                        else if (i.alongA === 1) // yes, at exactly a2
                            eventDivide(ev2, a2);
                    }
                }
                return false;
            }

            //
            // main event loop
            //
            const segments = [];
            while (!event_root.isEmpty()) {
                let ev = event_root.getHead();
                if (ev.isStart) {
                    let surrounding = statusFindSurrounding(ev);
                    let above = surrounding.before ? surrounding.before.ev : null;
                    let below = surrounding.after ? surrounding.after.ev : null;

                    let eve = function () {
                        if (above) {
                            let eve = checkIntersection(ev, above);
                            if (eve)
                                return eve;
                        }
                        if (below)
                            return checkIntersection(ev, below);
                        return false;
                    }();
                    if (eve) {
                        // ev and eve are equal
                        // we'll keep eve and throw away ev

                        // merge ev.seg's fill information into eve.seg
                        if (selfIntersection) {
                            let toggle; // are we a toggling edge?
                            if (ev.seg.myFill.below === null)
                                toggle = true;
                            else
                                toggle = ev.seg.myFill.above !== ev.seg.myFill.below;

                            // merge two segments that belong to the same polygon
                            // think of this as sandwiching two segments together, where `eve.seg` is
                            // the bottom -- this will cause the above fill flag to toggle
                            if (toggle)
                                eve.seg.myFill.above = !eve.seg.myFill.above;
                        } else {
                            // merge two segments that belong to different polygons
                            // each segment has distinct knowledge, so no special logic is needed
                            // note that this can only happen once per segment in this phase, because we
                            // are guaranteed that all self-intersections are gone
                            eve.seg.otherFill = ev.seg.myFill;
                        }

                        ev.other.remove();
                        ev.remove();
                    }

                    if (event_root.getHead() !== ev) {
                        // something was inserted before us in the event queue, so loop back around and
                        // process it before continuing
                        continue;
                    }

                    //
                    // calculate fill flags
                    //
                    if (selfIntersection) {
                        let toggle; // are we a toggling edge?
                        if (ev.seg.myFill.below === null) // if we are a new segment...
                            toggle = true; // then we toggle
                        else // we are a segment that has previous knowledge from a division
                            toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle

                        // next, calculate whether we are filled below us
                        if (!below) { // if nothing is below us...
                            // we are filled below us if the polygon is inverted
                            ev.seg.myFill.below = primaryPolyInverted;
                        } else {
                            // otherwise, we know the answer -- it's the same if whatever is below
                            // us is filled above it
                            ev.seg.myFill.below = below.seg.myFill.above;
                        }

                        // since now we know if we're filled below us, we can calculate whether
                        // we're filled above us by applying toggle to whatever is below us
                        if (toggle)
                            ev.seg.myFill.above = !ev.seg.myFill.below;
                        else
                            ev.seg.myFill.above = ev.seg.myFill.below;
                    } else {
                        // now we fill in any missing transition information, since we are all-knowing
                        // at this point

                        if (ev.seg.otherFill === null) {
                            // if we don't have other information, then we need to figure out if we're
                            // inside the other polygon
                            let inside;
                            if (!below) {
                                // if nothing is below us, then we're inside if the other polygon is
                                // inverted
                                inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;
                            } else { // otherwise, something is below us
                                // so copy the below segment's other polygon's above
                                if (ev.primary === below.primary)
                                    inside = below.seg.otherFill.above;
                                else
                                    inside = below.seg.myFill.above;
                            }
                            ev.seg.otherFill = {
                                above: inside,
                                below: inside
                            };
                        }
                    }
                    // insert the status and remember it for later removal
                    ev.other.status = surrounding.insert(self._linkList.node({ev: ev}));
                } else {
                    let st = ev.status;

                    if (st === null) {
                        throw new Error('zero-length segment detected; your epsilon is probably too small or too large');
                    }

                    // removing the status will create two new adjacent edges, so we'll need to check
                    // for those
                    if (status_root.exists(st.prev) && status_root.exists(st.next))
                        checkIntersection(st.prev.ev, st.next.ev);
                    // remove the status
                    st.remove();

                    // if we've reached this point, we've calculated everything there is to know, so
                    // save the segment for reporting
                    if (!ev.primary) {
                        // make sure `seg.myFill` actually points to the primary polygon though
                        let s = ev.seg.myFill;
                        ev.seg.myFill = ev.seg.otherFill;
                        ev.seg.otherFill = s;
                    }
                    segments.push(ev.seg);
                }

                // remove the event and continue
                event_root.getHead().remove();
            }
            return segments;
        }

        // return the appropriate API depending on what we're doing
        if (!selfIntersection) {
            // performing combination of polygons, so only deal with already-processed segments
            return {
                calculate: function (segments1, inverted1, segments2, inverted2) {
                    // segmentsX come from the self-intersection API, or this API
                    // invertedX is whether we treat that list of segments as an inverted polygon or not
                    // returns segments that can be used for further operations
                    segments1.forEach(function (seg) {
                        eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
                    });
                    segments2.forEach(function (seg) {
                        eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
                    });
                    return calculate(inverted1, inverted2);
                }
            };
        }

        // otherwise, performing self-intersection, so deal with regions
        return {
            addRegion: function (region) {
                // regions are a list of points:
                //  [ [0, 0], [100, 0], [50, 100] ]
                // you can add multiple regions before running calculate
                let pt1;
                let pt2 = region[region.length - 1];
                for (let i = 0; i < region.length; i++) {
                    pt1 = pt2;
                    pt2 = region[i];

                    let forward = eps.pointsCompare(pt1, pt2);
                    if (forward === 0) // points are equal, so we have a zero-length segment
                        continue; // just skip it

                    eventAddSegment(
                        segmentNew(
                            forward < 0 ? pt1 : pt2,
                            forward < 0 ? pt2 : pt1
                        ),
                        true
                    );
                }
            },
            calculate: function (inverted) {
                // is the polygon inverted?
                // returns segments
                return calculate(inverted, false);
            }
        };
    }

    /**
     * 双向链表
     * @private
     */
    _createLinkedList() {
        return {
            create: function () {
                const my = {
                    root: {root: true, next: null},
                    exists: function (node) {
                        return !(node === null || node === my.root);
                    },
                    isEmpty: function () {
                        return my.root.next === null;
                    },
                    getHead: function () {
                        return my.root.next;
                    },
                    insertBefore: function (node, check) {
                        let last = my.root;
                        let here = my.root.next;
                        while (here !== null) {
                            if (check(here)) {
                                node.prev = here.prev;
                                node.next = here;
                                here.prev.next = node;
                                here.prev = node;
                                return;
                            }
                            last = here;
                            here = here.next;
                        }
                        last.next = node;
                        node.prev = last;
                        node.next = null;
                    },
                    findTransition: function (check) {
                        let prev = my.root;
                        let here = my.root.next;
                        while (here !== null) {
                            if (check(here))
                                break;
                            prev = here;
                            here = here.next;
                        }
                        return {
                            before: prev === my.root ? null : prev,
                            after: here,
                            insert: function (node) {
                                node.prev = prev;
                                node.next = here;
                                prev.next = node;
                                if (here !== null)
                                    here.prev = node;
                                return node;
                            }
                        };
                    }
                };
                return my;
            },
            node: function (data) {
                data.prev = null;
                data.next = null;
                data.remove = function () {
                    data.prev.next = data.next;
                    if (data.next)
                        data.next.prev = data.prev;
                    data.prev = null;
                    data.next = null;
                };
                return data;
            }
        };
    }

    /**
     * 线段运算标识
     * @private
     */
    _createSegmentSelector() {
        //
        // filter a list of segments based on boolean operations
        //
        function select(segments, selection) {
            let result = [];
            segments.forEach(function (seg) {
                let index =
                    (seg.myFill.above ? 8 : 0) +
                    (seg.myFill.below ? 4 : 0) +
                    ((seg.otherFill && seg.otherFill.above) ? 2 : 0) +
                    ((seg.otherFill && seg.otherFill.below) ? 1 : 0);
                if (selection[index] !== 0) {
                    // copy the segment to the results, while also calculating the fill status
                    result.push({
                        id: -1,
                        start: seg.start,
                        end: seg.end,
                        myFill: {
                            above: selection[index] === 1, // 1 if filled above
                            below: selection[index] === 2  // 2 if filled below
                        },
                        otherFill: null
                    });
                }
            });
            return result;
        }

        return {
            union: function (segments) { // primary | secondary
                // above1 below1 above2 below2    Keep?               Value
                //    0      0      0      0   =>   no                  0
                //    0      0      0      1   =>   yes filled below    2
                //    0      0      1      0   =>   yes filled above    1
                //    0      0      1      1   =>   no                  0
                //    0      1      0      0   =>   yes filled below    2
                //    0      1      0      1   =>   yes filled below    2
                //    0      1      1      0   =>   no                  0
                //    0      1      1      1   =>   no                  0
                //    1      0      0      0   =>   yes filled above    1
                //    1      0      0      1   =>   no                  0
                //    1      0      1      0   =>   yes filled above    1
                //    1      0      1      1   =>   no                  0
                //    1      1      0      0   =>   no                  0
                //    1      1      0      1   =>   no                  0
                //    1      1      1      0   =>   no                  0
                //    1      1      1      1   =>   no                  0
                return select(segments, [
                    0, 2, 1, 0,
                    2, 2, 0, 0,
                    1, 0, 1, 0,
                    0, 0, 0, 0
                ]);
            },
            intersect: function (segments) { // primary & secondary
                // above1 below1 above2 below2    Keep?               Value
                //    0      0      0      0   =>   no                  0
                //    0      0      0      1   =>   no                  0
                //    0      0      1      0   =>   no                  0
                //    0      0      1      1   =>   no                  0
                //    0      1      0      0   =>   no                  0
                //    0      1      0      1   =>   yes filled below    2
                //    0      1      1      0   =>   no                  0
                //    0      1      1      1   =>   yes filled below    2
                //    1      0      0      0   =>   no                  0
                //    1      0      0      1   =>   no                  0
                //    1      0      1      0   =>   yes filled above    1
                //    1      0      1      1   =>   yes filled above    1
                //    1      1      0      0   =>   no                  0
                //    1      1      0      1   =>   yes filled below    2
                //    1      1      1      0   =>   yes filled above    1
                //    1      1      1      1   =>   no                  0
                return select(segments, [
                    0, 0, 0, 0,
                    0, 2, 0, 2,
                    0, 0, 1, 1,
                    0, 2, 1, 0
                ]);
            },
            difference: function (segments) { // primary - secondary
                // above1 below1 above2 below2    Keep?               Value
                //    0      0      0      0   =>   no                  0
                //    0      0      0      1   =>   no                  0
                //    0      0      1      0   =>   no                  0
                //    0      0      1      1   =>   no                  0
                //    0      1      0      0   =>   yes filled below    2
                //    0      1      0      1   =>   no                  0
                //    0      1      1      0   =>   yes filled below    2
                //    0      1      1      1   =>   no                  0
                //    1      0      0      0   =>   yes filled above    1
                //    1      0      0      1   =>   yes filled above    1
                //    1      0      1      0   =>   no                  0
                //    1      0      1      1   =>   no                  0
                //    1      1      0      0   =>   no                  0
                //    1      1      0      1   =>   yes filled above    1
                //    1      1      1      0   =>   yes filled below    2
                //    1      1      1      1   =>   no                  0
                return select(segments, [
                    0, 0, 0, 0,
                    2, 0, 2, 0,
                    1, 1, 0, 0,
                    0, 1, 2, 0
                ]);
            },
            xor: function (segments) { // primary ^ secondary
                // above1 below1 above2 below2    Keep?               Value
                //    0      0      0      0   =>   no                  0
                //    0      0      0      1   =>   yes filled below    2
                //    0      0      1      0   =>   yes filled above    1
                //    0      0      1      1   =>   no                  0
                //    0      1      0      0   =>   yes filled below    2
                //    0      1      0      1   =>   no                  0
                //    0      1      1      0   =>   no                  0
                //    0      1      1      1   =>   yes filled above    1
                //    1      0      0      0   =>   yes filled above    1
                //    1      0      0      1   =>   no                  0
                //    1      0      1      0   =>   no                  0
                //    1      0      1      1   =>   yes filled below    2
                //    1      1      0      0   =>   no                  0
                //    1      1      0      1   =>   yes filled above    1
                //    1      1      1      0   =>   yes filled below    2
                //    1      1      1      1   =>   no                  0
                return select(segments, [
                    0, 2, 1, 0,
                    2, 0, 0, 1,
                    1, 0, 0, 2,
                    0, 1, 2, 0
                ]);
            }
        };
    }

    /**
     * 线段几何运算
     * @param {Number} eps
     * @private
     */
    _epsilonHandler(eps) {
        if (typeof eps !== 'number')
            eps = 0.0000000001; // sane default? sure why not
        const my = {
            // epsilon: function (v) {
            // 	if (typeof v === 'number')
            // 		eps = v;
            // 	return eps;
            // },
            pointAboveOrOnLine: function (pt, left, right) {
                const Ax = left[0];
                const Ay = left[1];
                const Bx = right[0];
                const By = right[1];
                const Cx = pt[0];
                const Cy = pt[1];
                return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
            },
            pointBetween: function (p, left, right) {
                // p must be collinear with left->right
                // returns false if p == left, p == right, or left == right
                const d_py_ly = p[1] - left[1];
                const d_rx_lx = right[0] - left[0];
                const d_px_lx = p[0] - left[0];
                const d_ry_ly = right[1] - left[1];

                const dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
                // if `dot` is 0, then `p` == `left` or `left` == `right` (reject)
                // if `dot` is less than 0, then `p` is to the left of `left` (reject)
                if (dot < eps)
                    return false;

                const sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
                // if `dot` > `sqlen`, then `p` is to the right of `right` (reject)
                // therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)
                if (dot - sqlen > -eps)
                    return false;
                return true;
            },
            pointsSameX: function (p1, p2) {
                return Math.abs(p1[0] - p2[0]) < eps;
            },
            pointsSameY: function (p1, p2) {
                return Math.abs(p1[1] - p2[1]) < eps;
            },
            pointsSame: function (p1, p2) {
                return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
            },
            pointsCompare: function (p1, p2) {
                // returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal
                if (my.pointsSameX(p1, p2))
                    return my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);
                return p1[0] < p2[0] ? -1 : 1;
            },
            pointsCollinear: function (pt1, pt2, pt3) {
                // does pt1->pt2->pt3 make a straight line?
                // essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)
                // if slopes are equal, then they must be collinear, because they share pt2
                const dx1 = pt1[0] - pt2[0];
                const dy1 = pt1[1] - pt2[1];
                const dx2 = pt2[0] - pt3[0];
                const dy2 = pt2[1] - pt3[1];
                return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
            },
            linesIntersect: function (a0, a1, b0, b1) {
                // returns false if the lines are coincident (e.g., parallel or on top of each other)
                //
                // returns an object if the lines intersect:
                //   {
                //     pt: [x, y],    where the intersection point is at
                //     alongA: where intersection point is along A,
                //     alongB: where intersection point is along B
                //   }
                //
                //  alongA and alongB will each be one of: -2, -1, 0, 1, 2
                //
                //  with the following meaning:
                //
                //    -2   intersection point is before segment's first point
                //    -1   intersection point is directly on segment's first point
                //     0   intersection point is between segment's first and second points (exclusive)
                //     1   intersection point is directly on segment's second point
                //     2   intersection point is after segment's second point
                const adx = a1[0] - a0[0];
                const ady = a1[1] - a0[1];
                const bdx = b1[0] - b0[0];
                const bdy = b1[1] - b0[1];

                const axb = adx * bdy - ady * bdx;
                if (Math.abs(axb) < eps)
                    return false; // lines are coincident

                const dx = a0[0] - b0[0];
                const dy = a0[1] - b0[1];

                const A = (bdx * dy - bdy * dx) / axb;
                const B = (adx * dy - ady * dx) / axb;

                const ret = {
                    alongA: 0,
                    alongB: 0,
                    pt: [
                        a0[0] + A * adx,
                        a0[1] + A * ady
                    ]
                };

                // categorize where intersection point is along A and B

                if (A <= -eps)
                    ret.alongA = -2;
                else if (A < eps)
                    ret.alongA = -1;
                else if (A - 1 <= -eps)
                    ret.alongA = 0;
                else if (A - 1 < eps)
                    ret.alongA = 1;
                else
                    ret.alongA = 2;

                if (B <= -eps)
                    ret.alongB = -2;
                else if (B < eps)
                    ret.alongB = -1;
                else if (B - 1 <= -eps)
                    ret.alongB = 0;
                else if (B - 1 < eps)
                    ret.alongB = 1;
                else
                    ret.alongB = 2;

                return ret;
            },
            pointInsideRegion: function (pt, region) {
                const x = pt[0];
                const y = pt[1];
                let last_x = region[region.length - 1][0];
                let last_y = region[region.length - 1][1];
                let inside = false;
                for (let i = 0; i < region.length; i++) {
                    const curr_x = region[i][0];
                    const curr_y = region[i][1];

                    // if y is between curr_y and last_y, and
                    // x is to the right of the boundary created by the line
                    if ((curr_y - y > eps) !== (last_y - y > eps) &&
                        (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
                        inside = !inside;

                    last_x = curr_x;
                    last_y = curr_y;
                }
                return inside;
            }
        };
        return my;
    }

    /**
     * GeoJSON转换
     * @private
     */
    _handleGeoJSON() {
        let me = this;

        // convert a GeoJSON object to a PolyBoolean polygon
        function toPolygon(geojson, flag) {
            // converts list of LineString's to segments
            function selectDifference(combined) {
                return {
                    segments: me._segmentSelector.difference(combined.combined),
                    inverted: combined.inverted1 && !combined.inverted2
                }
            }

            function selectUnion(combined) {
                return {
                    segments: me._segmentSelector.union(combined.combined),
                    inverted: combined.inverted1 && !combined.inverted2
                }
            }

            function GeoPoly(coords) {
                // check for empty coords
                if (coords.length <= 0)
                    return me._segments({inverted: false, regions: []});

                // convert LineString to segments
                function LineString(ls) {
                    // remove tail which should be the same as head
                    let reg = ls.slice(0, ls.length - 1);
                    return me._segments({inverted: false, regions: [reg]});
                }

                // the first LineString is considered the outside
                let out = LineString(coords[0]);
                // the rest of the LineStrings are considered interior holes, so subtract them from the
                // current result
                for (let i = 1; i < coords.length; i++)
                    out = selectDifference(me._combine(out, LineString(coords[i])));

                return out;
            }

            if (geojson.type === 'Polygon') {
                // single polygon, so just convert it and we're done
                return me._polygon(GeoPoly(geojson.coordinates));
            } else if (geojson.type === 'MultiPolygon') {
                // multiple polygons, so union all the polygons together
                let out = me._segments({inverted: false, regions: []});
                for (let i = 0; i < geojson.coordinates.length; i++)
                    out = selectUnion(me._combine(out, GeoPoly(geojson.coordinates[i])));
                return me._polygon(out);
            }
            throw new Error('Cannot convert GeoJSON object to TopologyBoolean polygon');
        }

        // convert a PolyBoolean polygon to a GeoJSON object
        function fromPolygon(poly) {
            // make sure out polygon is clean
            poly = me._polygon(me._segments(poly));

            // test if r1 is inside r2
            function regionInsideRegion(r1, r2) {
                // we're guaranteed no lines intersect (because the polygon is clean), but a vertex
                // could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the
                // edge of the first line, which cannot be on an edge
                return me._epsilon.pointInsideRegion([
                    (r1[0][0] + r1[1][0]) * 0.5,
                    (r1[0][1] + r1[1][1]) * 0.5
                ], r2);
            }

            // calculate inside heirarchy
            //
            //  _____________________   _______    roots -> A       -> F
            // |          A          | |   F   |            |          |
            // |  _______   _______  | |  ___  |            +-- B      +-- G
            // | |   B   | |   C   | | | |   | |            |   |
            // | |  ___  | |  ___  | | | |   | |            |   +-- D
            // | | | D | | | | E | | | | | G | |            |
            // | | |___| | | |___| | | | |   | |            +-- C
            // | |_______| |_______| | | |___| |                |
            // |_____________________| |_______|                +-- E

            function newNode(region) {
                return {
                    region: region,
                    children: []
                };
            }

            let roots = newNode(null);

            function addChild(root, region) {
                // first check if we're inside any children
                for (let i = 0; i < root.children.length; i++) {
                    let child = root.children[i];
                    if (regionInsideRegion(region, child.region)) {
                        // we are, so insert inside them instead
                        addChild(child, region);
                        return;
                    }
                }

                // not inside any children, so check to see if any children are inside us
                let node = newNode(region);
                for (let i = 0; i < root.children.length; i++) {
                    let child = root.children[i];
                    if (regionInsideRegion(child.region, region)) {
                        // oops... move the child beneath us, and remove them from root
                        node.children.push(child);
                        root.children.splice(i, 1);
                        i--;
                    }
                }

                // now we can add ourselves
                root.children.push(node);
            }

            // add all regions to the root
            for (let i = 0; i < poly.regions.length; i++) {
                let region = poly.regions[i];
                if (region.length < 3) // regions must have at least 3 points (sanity check)
                    continue;
                addChild(roots, region);
            }

            // with our heirarchy, we can distinguish between exterior borders, and interior holes
            // the root nodes are exterior, children are interior, children's children are exterior,
            // children's children's children are interior, etc

            // while we're at it, exteriors are counter-clockwise, and interiors are clockwise

            function forceWinding(region, clockwise) {
                // first, see if we're clockwise or counter-clockwise
                // https://en.wikipedia.org/wiki/Shoelace_formula
                let winding = 0;
                let last_x = region[region.length - 1][0];
                let last_y = region[region.length - 1][1];
                let copy = [];
                for (let i = 0; i < region.length; i++) {
                    const curr_x = region[i][0];
                    const curr_y = region[i][1];
                    copy.push([curr_x, curr_y]); // create a copy while we're at it
                    winding += curr_y * last_x - curr_x * last_y;
                    last_x = curr_x;
                    last_y = curr_y;
                }
                // this assumes Cartesian coordinates (Y is positive going up)
                let isclockwise = winding < 0;
                if (isclockwise !== clockwise)
                    copy.reverse();
                // while we're here, the last point must be the first point...
                copy.push([copy[0][0], copy[0][1]]);
                return copy;
            }

            let geopolys = [];

            function addExterior(node) {
                let poly = [forceWinding(node.region, false)];
                geopolys.push(poly);
                // children of exteriors are interior
                for (let i = 0; i < node.children.length; i++)
                    poly.push(getInterior(node.children[i]));
            }

            function getInterior(node) {
                // children of interiors are exterior
                for (let i = 0; i < node.children.length; i++)
                    addExterior(node.children[i]);
                // return the clockwise interior
                return forceWinding(node.region, true);
            }

            // root nodes are exterior
            for (let i = 0; i < roots.children.length; i++)
                addExterior(roots.children[i]);

            // lastly, construct the approrpriate GeoJSON object

            if (geopolys.length <= 0) // empty GeoJSON Polygon
                return {type: 'Polygon', coordinates: []};
            if (geopolys.length == 1) // use a GeoJSON Polygon
                return {type: 'Polygon', coordinates: geopolys[0]};
            return { // otherwise, use a GeoJSON MultiPolygon
                type: 'MultiPolygon',
                coordinates: geopolys
            };
        }

        return {
            fromPolygon: fromPolygon,
            toPolygon: toPolygon,
        };
    };
};"use strict";
hmap.strategy = hmap.strategy || {};
hmap.strategy.Intersect = class {

    /**
     * 判断两点是否相交
     * @param point1
     * @param point2
     * @private
     */
    static pointIntersectPoint2D(point1, point2) {
        return Math.abs(point1.getCoordinate().getOrdinate("X") - point2.getCoordinate().getOrdinate("X")) === 0 &&
            Math.abs(point1.getCoordinate().getOrdinate("Y") - point2.getCoordinate().getOrdinate("Y")) === 0;
    }

    static pointIntersectPoint3D(point1, point2) {
        return point1.equals(point2);
    }

    static pointIntersectMultiPoint2D(point, multiPoint) {
        const pArr = multiPoint.getPoints();
        for (let i = 0, len = pArr.length; i < len; i++) {
            if (this.pointIntersectPoint2D(point, pArr[i])) {
                return true;
            }
        }
        return false;
    }

    static pointIntersectMultiPoint3D(point, multiPoint) {
        const pArr = multiPoint.getPoints();
        for (let i = 0, len = pArr.length; i < len; i++) {
            if (this.pointIntersectPoint3D(point, pArr[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断点跟线段是否相交
     * @param point
     * @param segment 两点构成的数组
     * @private
     */
    static pointIntersectSegment2D(point, segment) {
        return this._between2D(segment[0].getCoordinate(), segment[1].getCoordinate(), point.getCoordinate());
    }

    static pointIntersectSegment3D(point, segment) {
        const points = segment;
        const vLine = this.formatVectorFromPoints(points[0], points[1]);
        const vPoint = this.formatVectorFromPoints(points[0], point);
        const coord0 = points[0].getCoordinate();
        const coord1 = points[1].getCoordinate();
        const coord = point.getCoordinate();
        //共线
        if (vLine.cross(vPoint).equals(new hmap.util.Vector3())) {
            const xMin = Math.min(coord0.getOrdinate("X"), coord1.getOrdinate("X"));
            const xMax = Math.max(coord0.getOrdinate("X"), coord1.getOrdinate("X"));
            const yMin = Math.min(coord0.getOrdinate("Y"), coord1.getOrdinate("Y"));
            const yMax = Math.max(coord0.getOrdinate("Y"), coord1.getOrdinate("Y"));
            const zMin = Math.min(coord0.getOrdinate("Z"), coord1.getOrdinate("Z"));
            const zMax = Math.max(coord0.getOrdinate("Z"), coord1.getOrdinate("Z"));
            return (xMin <= coord.getOrdinate("X") && xMax >= coord.getOrdinate("X")) &&
                (yMin <= coord.getOrdinate("Y") && yMax >= coord.getOrdinate("Y")) &&
                (zMin <= coord.getOrdinate("Z") && zMax >= coord.getOrdinate("Z"));
        } else {
            return false;
        }
    }

    static pointIntersectLine2D(point, line) {
        const points = line.getVertices();
        const seg = new Array(2);
        for (let i = 0; i < points.length - 1; i++) {
            seg[0] = points[i];
            seg[1] = points[i + 1];
            if (this.pointIntersectSegment2D(point, seg)) {
                return true;
            }
        }
        return false;
    }

    static pointIntersectLine3D(point, line) {
        const points = line.getVertices();
        const seg = new Array(2);
        for (let i = 0, len = points.length; i < len - 1; i++) {
            seg[0] = points[i];
            seg[1] = points[i + 1];
            if (this.pointIntersectSegment3D(point, seg)) {
                return true;
            }
        }
        return false;
    }

    static pointIntersectMultiLine2D(point, multiLine) {
        const lines = multiLine.getLines();
        for (let i = 0, len = lines.length; i < len; i++) {
            if (this.pointIntersectLine2D(point, lines[i])) {
                return true;
            }
        }
        return false;
    }

    static pointIntersectMultiLine3D(point, multiLine) {
        const lines = multiLine.getLines();
        for (let i = 0, len = lines.length; i < len; i++) {
            if (this.pointIntersectLine3D(point, lines[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * 判断点与多边形是否相交
     * @param point
     * @param polygon
     * @private
     */
    static pointIntersectPolygon2D(point, polygon) {
        const coordSeqs = polygon.getCoordSeqs();
        const pointCoord = point.getCoordinate();
        let coordSeq, coordSeqLength, coordCur, coordPre;
        let coordPreOffset, coordCurOffset;
        let rStrad, lStrad;
        let rCross = 0,
            lCross = 0;
        let x;
        for (let i = 0, len = coordSeqs.length; i < len; i++) {
            coordSeq = coordSeqs[i];
            coordSeqLength = coordSeq.getCoordCount();
            for (let j = 0; j < coordSeqLength; j++) {
                coordCur = coordSeq.getCoordinate(j);
                if (coordCur.equals(pointCoord)) {
                    return true;
                } //在顶点重合
                coordPre = coordSeq.getCoordinate((j + coordSeqLength - 1) % coordSeqLength);

                coordPreOffset = coordPre.minus(pointCoord);
                coordCurOffset = coordCur.minus(pointCoord);

                //跨立测试
                rStrad = coordCurOffset.getValue("Y") > 0 !== coordPreOffset.getValue("Y") > 0; //右侧跨立测试
                lStrad = coordCurOffset.getValue("Y") < 0 !== coordPreOffset.getValue("Y") < 0; //左侧跨立测试

                if (rStrad || lStrad) {
                    x = (coordCurOffset.getValue("X") * coordPreOffset.getValue("Y") -
                            coordPreOffset.getValue("X") * coordCurOffset.getValue("Y")) /
                        (coordPreOffset.getValue("Y") - coordCurOffset.getValue("Y")); //与射线所在直线相交的x坐标值
                    if (rStrad && x > 0) {
                        rCross++;
                    } //右侧射线交点
                    if (lStrad && x < 0) {
                        lCross++;
                    } //左侧射线交点
                }
            }
        }
        if (rCross % 2 !== lCross % 2) return true; //在边界上

        if (rCross % 2 === 1) return true; //在内部

        return false; //在外部
    }

    /**
     * todo
     * @param {hmap.geom.Point} point
     * @param {hmap.geom.Polygon} convexPolygon
     * @private
     */
    static pointIntersectPolygon3D(point, convexPolygon) {
        //方案一：首先判断点在不在面所在平面，然后再判断在线内外
        const pCoord = point.getCoordinate();

        //判断是否共面,求向量的混合积是否为0
        const coordSeq = convexPolygon.getCoordSeqs()[0];
        const v1 = this.getVectorFromCoords(pCoord, coordSeq.getCoordinate(0));
        const v2 = this.getVectorFromCoords(pCoord, coordSeq.getCoordinate(1));
        const v3 = this.getVectorFromCoords(pCoord, coordSeq.getCoordinate(2));

        const isPlanar = v1.cross(v2).dot(v3);
        if (Math.abs(isPlanar) > Number.EPSILON) {
            return false;
        }

        //判断是否包含，求向量的叉乘是否同号
        let ipVector = this.getVectorFromCoords(pCoord, coordSeq.getCoordinate(0));
        let ijVector = this.getVectorFromCoords(coordSeq.getCoordinate(0), coordSeq.getCoordinate(1));

        for (let i = 0, len = coordSeq.getCoordCount(); i < len; i++) {
            ipVector = this.getVectorFromCoords(pCoord, coordSeq.getCoordinate(i));
            ijVector = this.getVectorFromCoords(coordSeq.getCoordinate(i), coordSeq.getCoordinate(i + 1));
            //计算。。。

        }
    }

    static pointIntersectMultiPolygon2D(point, multiPolygon) {
        const polygons = multiPolygon.getPolygons();
        for (let i = 0, len = polygons.length; i < len; i++) {
            if (this.pointIntersectPolygon2D(point, polygons[i])) {
                return true;
            }
        }
        return false;
    }

    static pointIntersectMultiPolygon3D(point, multiPolygon) {
        const polygons = multiPolygon.getPolygons();
        for (let i = 0, len = polygons.length; i < len; i++) {
            if (this.pointIntersectPolygon3D(point, polygons[i])) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectMultiPoint2D(multiPoint1, multiPoint2) {
        const mp1Arr = multiPoint1.getPoints();
        for (let i = 0, len = mp1Arr.length; i < len; i++) {
            if (this.pointIntersectMultiPoint2D(mp1Arr[i], multiPoint2)) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectMultiPoint3D(multiPoint1, multiPoint2) {}

    static multiPointIntersectLine2D(multiPoint, line) {
        const pArr = multiPoint.getPoints();
        for (let i = 0, len = pArr.length; i < len; i++) {
            if (this.pointIntersectLine2D(pArr[i], line)) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectLine3D(multiPoint, line) {}

    static multiPointIntersectMultiLine2D(multiPoint, multiLine) {
        const pArr = multiPoint.getPoints();
        for (let i = 0, len = pArr.length; i < len; i++) {
            if (this.pointIntersectMultiLine2D(pArr[i], multiLine)) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectMultiLine3D(multiPoint, multiLine) {}

    static multiPointIntersectPolygon2D(multiPoint, polygon) {
        const points = multiPoint.getPoints();
        for (let i = 0; i < points.length; i++) {
            if (this.pointIntersectPolygon2D(points[i], polygon)) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectPolygon3D(multiPoint, polygon) {}

    static multiPointIntersectMultiPolygon2D(multiPoint, multiPolygon) {
        const pArr = multiPoint.getPoints();
        for (let i = 0, len = pArr.length; i < len; i++) {
            if (this.pointIntersectMultiPolygon2D(pArr[i], multiPolygon)) {
                return true;
            }
        }
        return false;
    }

    static multiPointIntersectMultiPolygon3D(multiPoint, multiPolygon) {}

    /**
     * 线段与线段相交
     * @param {Array<Coordinate>} seg1
     * @param {Array<Coordinate>} seg2
     * @returns {Boolean} 是否相交
     * @private
     */
    static segmentIntersectSegment2D(seg1, seg2) {
        const a = seg1[0],
            b = seg1[1],
            c = seg2[0],
            d = seg2[1];
        if (this._segmentIntersectSegmentProp2D(a, b, c, d)) {
            return true;
        } else if (this._between2D(a, b, c) ||
            this._between2D(a, b, d) ||
            this._between2D(c, d, a) ||
            this._between2D(c, d, b)) {
            return true;
        } else {
            return false;
        }
    }

    static segmentIntersectSegment3D(seg1, seg2) {
        //共面判断、相交判断
    }

    // 在不共线的情况下计算线段之间是否相交
    static _segmentIntersectSegmentProp2D(a, b, c, d) {
        if (this._collinear2D(a, b, c) ||
            this._collinear2D(a, b, d) ||
            this._collinear2D(c, d, a) ||
            this._collinear2D(c, d, b)) {
            return false;
        }
        return this._xor(this._left2D(a, b, c), this._left2D(a, b, d)) &&
            this._xor(this._left2D(c, d, a), this._left2D(c, d, b));
    }

    //判断abc三个点的顺序是否为逆时针方向，即c是否在向量ab左边
    static _left2D(a, b, c) {
        return this._doubleArea2D(a, b, c) > 0;
    }

    //判断abc三个点的顺序是否为逆时针方向或共线，即c是否在向量ab左边或共线
    static _leftOn2D(a, b, c) {
        return this._doubleArea2D(a, b, c) >= 0;
    }

    //计算abc三个点是否共线（测试三点的面积是否为0）
    static _collinear2D(a, b, c) {
        const doubleArea = this._doubleArea2D(a, b, c);
        return -hmap.initState.EPSILON <= doubleArea && doubleArea <= hmap.initState.EPSILON;
    }

    //在abc共线的前提下，计算c是否在线段ab上
    static _between2D(a, b, c) {
        if (!this._collinear2D(a, b, c)) {
            return false;
        }

        if (a.getOrdinate("X") !== b.getOrdinate("X")) {
            return ((a.getOrdinate("X") <= c.getOrdinate("X") && (c.getOrdinate("X") <= b.getOrdinate("X")))) ||
                ((a.getOrdinate("X") >= c.getOrdinate("X") && (c.getOrdinate("X") >= b.getOrdinate("X"))));
        } else {
            return ((a.getOrdinate("Y") <= c.getOrdinate("Y") && (c.getOrdinate("Y") <= b.getOrdinate("Y")))) ||
                ((a.getOrdinate("Y") >= c.getOrdinate("Y")) && (c.getOrdinate("Y") >= b.getOrdinate("Y")));
        }
    }

    //计算三角形abc的有符号面积的两倍，即二维向量bc叉乘向量ba的标量值
    static _doubleArea2D(a, b, c) {
        return ((c.getOrdinate("X") - b.getOrdinate("X")) * (a.getOrdinate("Y") - b.getOrdinate("Y"))) -
            ((a.getOrdinate("X") - b.getOrdinate("X")) * (c.getOrdinate("Y") - b.getOrdinate("Y")));
    }

    //异或
    static _xor(x, y) {
        return !x ^ !y;
    }

    static segmentIntersectLine2D(seg, line) {
        const lineCoordSeq = line.getCoordSeq();
        const lineSeg = new Array(2);
        for (let i = 0; i < lineCoordSeq.getCoordCount() - 1; i++) {
            lineSeg[0] = lineCoordSeq.getCoordinate(i);
            lineSeg[1] = lineCoordSeq.getCoordinate((i + 1));
            if (this.segmentIntersectSegment2D(seg, lineSeg)) {
                return true;
            }
        }
        return false;
    }

    static lineIntersectLine2D(line1, line2) {
        if (!line1.getExtent().intersects(line2.getExtent())) {
            return false;
        }
        const lineCoordSeq = line1.getCoordSeq();
        const lineSeg = new Array(2);
        for (let i = 0; i < lineCoordSeq.getCoordCount() - 1; i++) {
            lineSeg[0] = lineCoordSeq.getCoordinate(i);
            lineSeg[1] = lineCoordSeq.getCoordinate((i + 1));
            if (this.segmentIntersectLine2D(lineSeg, line2)) {
                return true;
            }
        }
        return false;
    }

    static lineIntersectMultiLine2D(line, multiLine) {
        if (!line.getExtent().intersects(multiLine.getExtent())) {
            return false;
        }
        const lines = multiLine.getLines();
        for (let i = 0; i < lines.length; i++) {
            if (this.lineIntersectLine2D(line, lines[i])) {
                return true;
            }
        }
        return false;
    }

    static multiLineIntersectMultiLine2D(multiLine1, multiLine2) {
        if (!multiLine1.getExtent().intersects(multiLine2.getExtent())) {
            return false;
        }
        const lines = multiLine1.getLines();
        for (let i = 0; i < lines.length; i++) {
            if (this.lineIntersectMultiLine2D(lines[i], multiLine2)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 折线是否与面相交
     * @param line
     * @param polygon
     * @private
     */
    static lineIntersectPolygon2D(line, polygon) {
        //外框
        if (!line.getExtent().intersects(polygon.getExtent())) {
            return false;
        }

        //线与面的边界是否相交
        const linearRings = polygon.getLinearRings();
        for (let i = 0; i < linearRings.length; i++) {
            if (this.lineIntersectLine2D(line, linearRings[i])) {
                return true;
            }
        }

        // 如果有一个顶点与多边形相交，则线与多边形相交，否则不相交
        const vertices = line.getVertices();
        if (vertices.length > 0) {
            return this.pointIntersectPolygon2D(vertices[0], polygon);
        }

        return false;
    }

    static lineIntersectPolygon3D(line, polygon) {}

    /**
     * 折线是否与多面相交
     * @param line
     * @param multiPolygon
     * @private
     */
    static lineIntersectMultiPolygon2D(line, multiPolygon) {
        if (!line.getExtent().intersects(multiPolygon.getExtent())) {
            return false;
        }

        const polygons = multiPolygon.getPolygons();
        for (let i = 0, len = polygons.length; i < len; i++) {
            if (this.lineIntersectPolygon2D(line, polygons[i])) {
                return true;
            }
        }
        return false;
    }

    static lineIntersectMultiPolygon3D(line, multiPolygon) {}

    static multiLineIntersectMultiLine3D(multiLine1, multiLine2) {}

    static multiLineIntersectPolygon2D(multiLine, polygon) {
        const lineArr = multiLine.getLines();
        for (let i = 0, len = lineArr.length; i < len; i++) {
            if (this.lineIntersectPolygon2D(lineArr[i], polygon)) {
                return true;
            }
        }
        return false;
    }

    static multiLineIntersectPolygon3D(multiLine, polygon) {}

    static multiLineIntersectMultiPolygon2D(multiLine, multiPolygon) {
        const lineArr = multiLine.getLines();
        for (let i = 0, len = lineArr.length; i < len; i++) {
            if (this.lineIntersectMultiPolygon2D(lineArr[i], multiPolygon)) {
                return true;
            }
        }
        return false;
    }

    static multiLineIntersectMultiPolygon3D(multiLine, multiPolygon) {}

    /**
     * 判断两个面是否相交
     * @param polygon1
     * @param polygon2
     * @private
     */
    static polygonIntersectPolygon2D(polygon1, polygon2) {
        if (!polygon1.getExtent().intersects(polygon2.getExtent())) {
            return false;
        }
        const linearRings1 = polygon1.getLinearRings();
        const linearRings2 = polygon2.getLinearRings();
        //测试边界是否相交
        for (const linearRing1 of linearRings1) {
            for (const linearRing2 of linearRings2) {
                if (this.lineIntersectLine2D(linearRing1, linearRing2)) {
                    return true;
                }
            }
        }
        //测试一个多边形的点是否在另一个多边形内，如果边界不相交的情况下，任意一个点与多边形相交，则两个多边形相交
        if (linearRings1.length > 0) {
            const vertices = linearRings1[0].getVertices();
            if (this.pointIntersectPolygon2D(vertices[0], polygon2)) {
                return true;
            }
        }
        if (linearRings2.length > 0) {
            const vertices = linearRings2[0].getVertices();
            if (this.pointIntersectPolygon2D(vertices[0], polygon1)) {
                return true;
            }
        }
        return false;
    }

    static polygonIntersectPolygon3D(polygon1, polygon2) {}

    static polygonIntersectMultiPolygon2D(polygon, multiPolygon) {
        if (!polygon.getExtent().intersects(multiPolygon.getExtent())) {
            return false;
        }
        const polygons = multiPolygon.getPolygons();
        for (let i = 0; i < polygons.length; i++) {
            if (this.polygonIntersectPolygon2D(polygon, polygons[i])) {
                return true;
            }
        }
        return false;
    }

    static polygonIntersectMultiPolygon3D(polygon, multiPolygon) {}

    static multiPolygonIntersectMultiPolygon2D(multiPolygon1, multiPolygon2) {
        if (!multiPolygon1.getExtent().intersects(multiPolygon2.getExtent())) {
            return false;
        }
        const polygons = multiPolygon1.getPolygons();
        for (let i = 0; i < polygons.length; i++) {
            if (this.polygonIntersectMultiPolygon2D(polygons[i], multiPolygon2)) {
                return true;
            }
        }
        return false;
    }

    static multiPolygonIntersectMultiPolygon3D(multiPolygon1, multiPolygon2) {}

    //从coord1到coord2的向量
    static getVectorFromCoords(coord1, coord2) {
        return new hmap.util.Vector3(coord2.getOrdinate("X") - coord1.getOrdinate("X"),
            coord2.getOrdinate("Y") - coord1.getOrdinate("Y"),
            coord2.getOrdinate("Z") - coord1.getOrdinate("Z"));
    }

    //从p1到p2的向量
    static formatVectorFromPoints(p1, p2) {
        return this.getVectorFromCoords(p1.getCoordinate(), p2.getCoordinate());
    }

    /**
     * 线段与圆是否相交
     * @param seg
     * @param {hmap.geom.Circle} circle
     */
    static segmentIntersectCircle2D(seg, circle) {
        const radius = circle.getRadius(),
            center = circle.getCenter(),
            coord1 = seg[0],
            coord2 = seg[1];
        let point1X = coord1.getOrdinate("X"),
            point1Y = coord1.getOrdinate("Y"),
            point2X = coord2.getOrdinate("X"),
            point2Y = coord2.getOrdinate("Y"),
            centerX = center.getCoordinate().getOrdinate("X"),
            centerY = center.getCoordinate().getOrdinate("Y"),
            intersectX, intersectY;
        if (point1X == point2X) {
            intersectX = point1X;
            intersectY = centerY;
        } else {
            let A = (point1Y - point2Y) / (point1X - point2X)
            let B = point1Y - A * point1X
            let m = centerX + A * centerY
            intersectX = (m - A * B) / (A * A + 1);
            intersectY = A * intersectX + B;
        }
        let distance = Math.sqrt(Math.pow(intersectX - centerX, 2) + Math.pow(intersectY - centerY, 2));
        const d1 = center.distanceTo(new hmap.geom.Point(coord1));
        const d2 = center.distanceTo(new hmap.geom.Point(coord2));
        if ((d1 - radius) * (d2 - radius) <= 0) {
            return true; //插入或者相切
        } else {
            if (d1 > radius) {
                if(distance <= radius&&(intersectX - point1X) * (intersectX - point2X) <= 0 && (intersectY - point1Y) * (intersectY - point2Y) <= 0){
                    return true //穿过
                }
            } else {
                return false; //包含
            }
        }
    }

    static segmentIntersectCircle3D(seg, circle3D) {

    }

    /**
     * 判断点几何和圆相交,通过判断点和圆心的距离
     * @param {hmap.geom.Point} point 点几何
     * @param {hmap.geom.Circle} circle 圆几何
     * @returns {Boolean}
     */
    static pointIntersectCircle2D(point, circle) {
        let radius = circle.getRadius(),
            center = circle.getCenter();
        const x0 = point.getCoordinate().getOrdinate("X"),
            y0 = point.getCoordinate().getOrdinate("Y"),
            x1 = center.getCoordinate().getOrdinate("X"),
            y1 = center.getCoordinate().getOrdinate("Y");
        return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2)) <= radius;
    }

    /**
     *  判断多点几何和圆相交
     *  @param {hmap.geom.MultiLine} multipoint
     *  @param {hmap.geom.Circle} circle
     * */
    static multiPointIntersectCircle2D(multipoint, circle) {
        const points = multipoint.getPoints();
        for (let i = 0, length = points.length; i < length; i++) {
            const point = points[i];
            if (this.pointIntersectCircle2D(point, circle)) {
                return true;
            }
        }
        return false;
    }

    /**
     *  判断线几何和和圆相交
     *  @param {hmap.geom.Line} line
     *  @param {hmap.geom.Circle} circle
     * */
    static lineIntersectCircle2D(line, circle) {
        const lineCoordSeq = line.getCoordSeq();
        const lineSeg = new Array(2);
        for (let i = 0; i < lineCoordSeq.getCoordCount() - 1; i++) {
            lineSeg[0] = lineCoordSeq.getCoordinate(i);
            lineSeg[1] = lineCoordSeq.getCoordinate((i + 1));
            if (this.segmentIntersectCircle2D(lineSeg, circle)) {
                return true;
            }
        }
        return false;
    }

    /**
     *  判断多线几何和和圆相交
     *  @param {hmap.geom.MultiLine} multiline
     *  @param {hmap.geom.Circle} circle
     * */
    static multiLineIntersectCircle2D(multiline, circle) {
        const lineArr = multiline.getLines();
        for (let i = 0, len = lineArr.length; i < len; i++) {
            if (this.lineIntersectCircle2D(lineArr[i], circle)) {
                return true;
            }
        }
        return false;
    }

    /**
     *  判断面几何和和圆相交
     *  @param {hmap.geom.Polygon} polygon
     *  @param {hmap.geom.Circle} circle
     * */
    static polygonIntersectCircle2D(polygon, circle) {
        const linearRings = polygon.getLinearRings(),
            center = circle.getCenter();
        //测试边界是否相交
        for (let linearRing of linearRings) {
            if (this.lineIntersectCircle2D(linearRing, circle)) {
                return true;
            }
        }
        if (this.pointIntersectPolygon2D(center, polygon)) { //圆心在圆内
            return true;
        }
        return false;
    }

    /**
     *  判断多面几何和和圆相交
     *  @param {hmap.geom.MultiPolygon} multipolygon
     *  @param {hmap.geom.Circle} circle
     * */
    static multiPolygonIntersectCircle2D(multipolygon, circle) {
        const polygons = multipolygon.getPolygons();
        for (let polygon of polygons) {
            if (this.polygonIntersectCircle2D(polygon, circle)) {
                return true;
            }
        }
        return false;
    }

    /**
     *  判断圆几何和和圆相交，通过判断圆心距离
     *  @param {hmap.geom.Circle} circleSrc
     *  @param {hmap.geom.Circle} circleDes
     * */
    static circle2DIntersectCircle2D(circleSrc, circleDes) {
        const centerSrc = circleSrc.getCenter(),
            radiusSrc = circleSrc.getRadius(),
            centerDes = circleDes.getCenter(),
            radiusDes = circleDes.getRadius();
        let distance = centerSrc.distanceTo(centerDes);
        return distance <= radiusSrc + radiusDes;
    }
};;"use strict";
hmap.strategy=hmap.strategy || {};
//专门为矢量切片服务
hmap.strategy.VaoBook=class {
	//以url为索引来标识
	constructor(programs,capacity=1000,deleteCount=10){
        this.CLASS_NAME = "hmap.strategy.VaoBook";
        this.directory=new Map();//以url来标识
        this.urlQuene=[];//表示url进入顺序
        this.capacity=capacity;
        this.deleteCount=deleteCount;
        this.programs=programs;
    }

     /**
     * 将一张切片的VaoInfo包括VAO存入缓存池
     * */
    setUrl(url,vaoInfo,type){
        if(!this.directory.get(url)){
            this.directory.set(url,this._initUrlPage());
        }
        this.directory.get(url)[type].push(vaoInfo);
    }

    //添加新的数据
    addTile(url,vaoInfo,type){
        if(!this.directory.get(url)){
            // this.directory.set(url,this._initUrlPage());
            this.directory.set(url, {})
            this.urlQuene.push(url);
        }
        if (!this.directory.get(url).hasOwnProperty(type)) {
            this.directory.get(url)[type] = [];
        }
        this.directory.get(url)[type].push(vaoInfo);
    }

    //检查是否已满，满则删除内容
    update(){
        if(this.urlQuene.length>this.capacity){
            for(let i=0;i<this.deleteCount;i++){
                const url=this.urlQuene.shift();
                this.deleteTile(url);
            }
        }
    }
    deleteAllTile(){
        this.directory.forEach(function (value, key, map) {
            this.deleteTile(key);
        }.bind(this));
    }

    deleteTile(url){
        const vaoInfoObj = this.directory.get(url);
        for(let layerName in vaoInfoObj){
            const vaoInfos = vaoInfoObj[layerName];
            if (vaoInfos.length == 0) {
                continue;
            }
            let pName = vaoInfos[0].pName;
            const program = this.programs[pName];
            for(let vaoInfo of vaoInfos){
                this._deleteVaoInfo(vaoInfo,program);
            }
        }
        this.directory.delete(url);
    }

    _deleteVaoInfo(vaoInfo,program){
        const vbos = vaoInfo.vbos;
        for(let key in vbos){
            //先释放显存空间，再删除vbo
            program.setVBO(key, vbos[key], null);
            program.deleteVBO(vbos[key]);
            vbos[key] = null;
        }
        program.deleteVAO(vaoInfo.vao);
        vaoInfo.vao = null;
    }

    /**
    * 当前vaoInfo池是否存在与某一个url对应的vaoInfo
    * */
    hasUrl(url){
        return this.directory.get(url) ? true : false;
    }

    /**
     *  根据url获取缓存池的数据
     * */
    getDataFromUrl(url){
        if(this.hasUrl(url)){
            return this.directory.get(url);
        }
    }

    //初始化一个vaoPage的结构
    _initUrlPage(){
    	const vaoPage={};
    	const programs=this.programs;
        for(let programName in programs){
            vaoPage[programName]=[];
        }
        return vaoPage;
    }
}
;"use strict";
hmap.strategy = hmap.strategy || {};
hmap.strategy.Intersect3D = class extends hmap.strategy.Intersect {
    /**
     * 点到射线的距离以及最近点
     * @param coord 空间点
     * @param coord1  射线起点
     * @param coord2  射线终点
     * @param offset 样式偏移（地图单位）
     * @return {Object}
     */
    static pointToSegment(coord, coord1, coord2,offset=[0,0,0]) {
        let distance = 0;
        const x = coord._x+offset[0], y = coord._y+offset[1], z = coord._z+offset[2],
            x1 = coord1._x, y1 = coord1._y, z1 = coord1._z,
            x2 = coord2._x, y2 = coord2._y, z2 = coord2._z;
        const dot = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1) + (z2 - z1) * (z - z1);
        if (dot < 0) return null;
        const d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);
        if (dot > d2) {
            distance = Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2) + (z - z2) * (z - z2));
            return {
                distance: distance,
                point: new hmap.basetype.Coordinate(x2, y2, z2)
            }
        }
        // //交点在相机方向线段内部
        const r = dot / d2;
        const px = x1 + (x2 - x1) * r;
        const py = y1 + (y2 - y1) * r;
        const pz = z1 + (z2 - z1) * r;
        distance = Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
        return {
            distance: distance,
            point: new hmap.basetype.Coordinate(px, py, pz)
        }
    }

    /**
     * 线到线的最小距离
     * @param line1 线
     * @param line2 线
     * @returns {Object} 返回对象 {distance:Number,point:point}
     */
    static lineToLine(line1, line2,offset=[0,0,0]) {
        const coord1 = line2.getVertices()[0].getCoordinate(), coord2 = line2.getVertices()[1].getCoordinate();
        const results = [];//每个线段到射线的距离结果,
        const points = line1.getVertices();
        for (let i = 0, len = points.length; i < len - 1; i++) {
            let lineCoord3 = points[i].getCoordinate(),
                lineCoord4 = points[i + 1].getCoordinate();
            //考虑偏移重置lineCoord3和lineCoord4，数组直接相加，数字的计算线段法向量并相加
            if (offset instanceof Array) {
                lineCoord3 = new hmap.basetype.Coordinate(lineCoord3._x + offset[0], lineCoord3._y + offset[1], lineCoord3._z + offset[2]);
                lineCoord4 = new hmap.basetype.Coordinate(lineCoord4._x + offset[0], lineCoord4._y + offset[1], lineCoord4._z + offset[2]);
            } else if (Number.isFinite(offset)&&offset !== 0) {
                //计算法向量（在xy平面，正值在右侧，负值在左侧）
                const normal = new hmap.util.Vector3(lineCoord4._y - lineCoord3._y, -(lineCoord4._x - lineCoord3._x), 0);
                normal.normalize().multiplyScalar(offset);
                const e = normal.getElements();
                lineCoord3 = new hmap.basetype.Coordinate(lineCoord3._x + e[0], lineCoord3._y + e[1], lineCoord3._z + e[2]);
                lineCoord4 = new hmap.basetype.Coordinate(lineCoord4._x + e[0], lineCoord4._y + e[1], lineCoord4._z + e[2]);
            }
            let result = this.segmentToSegment(coord1, coord2, lineCoord3, lineCoord4);
            if (result) {
                results.push(result)
            }
        }
        return results;
    }

    /**
     * 线段到线段的最小距离
     * @param coord1,coord2 射线线段起点终点
     * @param coord3,coord4 线段起点终点
     * @returns {Object} 返回对象{distance:Number,point:point}
     */
    static segmentToSegment(coord1, coord2, coord3, coord4) {
        let vLine43 = this.formatVectorFromCoords(coord4, coord3),
            vLine12 = this.formatVectorFromCoords(coord1, coord2),
            vLine13 = this.formatVectorFromCoords(coord1, coord3);
        const a1 = vLine12.dot(vLine12),
            a2 = vLine43.dot(vLine43),
            b = vLine12.dot(vLine43),
            c1 = vLine12.dot(vLine13),
            c2 = vLine13.dot(vLine43);
        const temp = a1 * a2 - b * b;
        let result;
        if (temp == 0) {
            //共线，从线段上找一点（z最大的点）到射线的最小距离
            let maxCoord = coord3.getOrdinate("Z") > coord4.getOrdinate("Z") ? coord3 : coord4;
            //计算拾取高程最大点到射线的距离,TODO 这里不是通用方式
            result = this.pointToSegment(maxCoord, coord1, coord2);
        } else {
            let t = (a1 * c2 - b * c1) / temp,
                s = (a2 * c1 - b * c2) / temp;
            //如果s在0-1内说明最近点在射线内部，t同理
            if (s >= 0 && s <= 1) {
                if (t >= 0 && t <= 1) {
                    //射线上的交点
                    const x1 = coord1.getOrdinate("X") + s * vLine12.getElement(0),
                        y1 = coord1.getOrdinate("Y") + s * vLine12.getElement(1),
                        z1 = coord1.getOrdinate("Z") + s * vLine12.getElement(2);
                    const intersectCoord = new hmap.basetype.Coordinate(x1, y1, z1);
                    //线段上的交点
                    const x2 = coord3.getOrdinate("X") - t * vLine43.getElement(0),
                        y2 = coord3.getOrdinate("Y") - t * vLine43.getElement(1),
                        z2 = coord3.getOrdinate("Z") - t * vLine43.getElement(2);
                    //最近距离
                    const distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
                    result = {
                        distance: distance,
                        point: intersectCoord
                    };
                } else {
                    const result3 = this.pointToSegment(coord3, coord1, coord2),
                        result4 = this.pointToSegment(coord4, coord1, coord2);
                    result = result3 && result4 && result3.distance > result4.distance ? result4 : result3;
                }
            } else {
                result = null;
            }
        }
        return result;
    }

    /**
     * 射线与多边形相交
     * @param origin
     * @param direction
     * @param polygon
     */
    static rayIntersectMultiPolygon(origin, direction, multiPolygon,offset=[0,0,0]) {
        let arrResult = [];
        for (let i = 0, len = multiPolygon.getPolygonCount(); i < len; i++) {
            let result = hmap.strategy.Intersect3D.rayIntersectPolygon(origin, direction, multiPolygon.getPolygon(i));
            arrResult.push(...result)
        }
        return arrResult;
    }

    /**
     * 射线与多边形相交
     * @param origin
     * @param direction
     * @param polygon
     */
    static rayIntersectPolygon(origin, direction, polygon,offset=[0,0,0]) {
        //三角剖分，earcut
        const arr = hmap.strategy.EarCut.triangulatePolygon(polygon.getCoordSeqs());
        //射线与三角形相交，rayIntersectTrianle
        let arrResult = [];
        for (let i = 0, len = arr.length; i < len; i += 9) {
            const v1 = new hmap.util.Vector3(arr[i + 0] + offset[0], arr[i + 1] + offset[1], arr[i + 2] + offset[2]),
                v2 = new hmap.util.Vector3(arr[i + 3] + offset[0], arr[i + 4] + offset[1], arr[i + 5] + offset[2]),
                v3 = new hmap.util.Vector3(arr[i + 6] + offset[0], arr[i + 7] + offset[1], arr[i + 8] + offset[2]);
            const coord = this.rayIntersectTriangle(origin.clone(), direction.clone(), [v1, v2, v3]);
            if (coord) {
                arrResult.push(coord)
            }
        }
        return arrResult;
    }

    /**
     * 射线三角形相交
     * @param origin
     * @param direction
     * @param triangle
     * @return {*}
     */
    static rayIntersectTriangle(origin, direction, triangle) {
        let kz = this.getMaxAxis(direction);
        let kx = kz + 1;
        if (kx === 3) {
            kx = 0
        }
        let ky = kx + 1;
        if (ky === 3) {
            ky = 0
        }

        // Swap kx and ky dimension to preserve winding direction of triangle
        if (direction.getElement(kz) < 0) {
            const swap = ky;
            ky = kx;
            kx = swap
        }

        // 处理特殊情况避免避免除数为零
        // components is zero.
        // example rays that breaks -> [3, 4, 0] ... [10, 0, 10]... any ray with a 0 in it
        if (direction.getElement(kz) === 0) {
            direction.setElement(kz, 0.0000000001);
        }

        // 计算剪切参数
        const Sz = 1.0 / direction.getElement(kz),
            Sx = direction.getElement(kx) * Sz,
            Sy = direction.getElement(ky) * Sz;

        // 计算相对于射线原点的顶点坐标
        const A = triangle[0].substract(origin);
        const B = triangle[1].substract(origin);
        const C = triangle[2].substract(origin);

        //执行顶点剪切和缩放
        const Ax = A.getElement(kx) - Sx * A.getElement(kz);
        const Ay = A.getElement(ky) - Sy * A.getElement(kz);
        const Bx = B.getElement(kx) - Sx * B.getElement(kz);
        const By = B.getElement(ky) - Sy * B.getElement(kz);
        const Cx = C.getElement(kx) - Sx * C.getElement(kz);
        const Cy = C.getElement(ky) - Sy * C.getElement(kz);

        // 计算缩放的重心坐标
        const U = Cx * By - Cy * Bx;
        const V = Ax * Cy - Ay * Cx;
        const W = Bx * Ay - By * Ax;

        /**
         We aren't implementing the fallback that uses double precision at the
         triangle's edges because JavaScript numbers always use double precision
         if (U === 0 || V === 0 || W === 0) {
        }
         */
        // Abort early if we know that we have not intersected our triangle
        if ((U < 0 || V < 0 || W < 0) && (U > 0 || V > 0 || W > 0)) return null;

        // Calculate determinant
        const det = U + V + W;
        if (det === 0) return null;

        // 计算顶点的缩放z坐标并使用它们来计算命中距离
        const Az = Sz * A.getElement(kz);
        const Bz = Sz * B.getElement(kz);
        const Cz = Sz * C.getElement(kz);
        const T = U * Az + V * Bz + W * Cz;
        const inverseDet = 1.0 / det;

        //射线原点到交点的参数距离
        const t = T * inverseDet;

        const x = t * direction.getElement(0) + origin.getElement(0),
            y = t * direction.getElement(1) + origin.getElement(1),
            z = t * direction.getElement(2) + origin.getElement(2);
        return new hmap.basetype.Coordinate(x, y, z);
    }

    /**
     * 计算射线最大方向
     */
    static getMaxAxis(direction) {
        const x = Math.abs(direction.getElement(0)),
            y = Math.abs(direction.getElement(1)),
            z = Math.abs(direction.getElement(2));
        if (x > y) {
            if (x > z) {
                // X component of ray is largest
                return 0
            } else {
                // Z component of ray is largest
                return 2
            }
        } else {
            if (y > z) {
                // Y component of ray is lragest
                return 1
            } else {
                // Z component of ray is largest
                return 2
            }
        }
    }

    /**
     * 从coord1到coord2的向量
     */
    static formatVectorFromCoords(coord1, coord2) {
        return new hmap.util.Vector3(coord2.getOrdinate("X") - coord1.getOrdinate("X"),
            coord2.getOrdinate("Y") - coord1.getOrdinate("Y"),
            coord2.getOrdinate("Z") - coord1.getOrdinate("Z"));
    }

    /**
     * 从p1到p2的向量
     */
    static formatVectorFromPoints(p1, p2) {
        return this.formatVectorFromCoords(p1.getCoordinate(), p2.getCoordinate());
    }

    /**
     * 计算面积
     */
    static _getArea(coords) {
        return hmap.strategy.EarCut.polygonArea([new hmap.basetype.CoordSeq(coords)]);
    }

    /**
     * 计算角度
     */
    static _getAngle(v1, v2) {
        v1.normalize();
        v2.normalize();
        let cos = v1.dot(v2);
        return cos;
    }

    /**
     * 拾取包围盒
     * @param {hmap.basetype.BBox}  box 包围盒对象
     * @param {hmap.util.Vector3} origin 射线起点
     * @param {hmap.util.Vector3} direction 摄线方向
     * @return {hmap.geom.Point|null} 返回相交点
     */
    static rayIntersectBox(box, origin, direction) {
        const t = this._rayCrossOctant(box, origin.clone(), direction.clone());
        if (t) {
            const x = origin.getElement(0) + t * direction.getElement(0),
                y = origin.getElement(1) + t * direction.getElement(1),
                z = origin.getElement(2) + t * direction.getElement(2);
            let closePoint = new hmap.geom.Point(new hmap.basetype.Coordinate(x, y, z));
            return closePoint;
        }
        return null;
    }

    /**
     * Finds the octants that intersect with the given ray.
     *
     * @param {hmap.basetype.BBox} box -  包围盒
     * @param {hmap.util.Vector3} origin - 起点.
     * @param {hmap.util.Vector3} direction - 方向
     * @param {Number} intersects - A list to be filled with intersecting octants.
     */
    static _rayCrossOctant(box, origin, direction) {
        // Translate the octree extents to the scene origin.
        const min = new hmap.util.Vector3(0, 0, 0);
        const max = new hmap.util.Vector3(box.getMaxX() - box.getMinX(), box.getMaxY() - box.getMinY(), box.getMaxZ() - box.getMinZ());
        const dimensions = max.clone();
        const halfDimensions = dimensions.clone().multiplyScalar(0.5);
        direction.normalize();

        let invDirX, invDirY, invDirZ;
        let tx0, tx1, ty0, ty1, tz0, tz1;

        // Translate the ray to the center of the octree.
        let center = new hmap.util.Vector3((box.getMaxX() + box.getMinX()) / 2, (box.getMaxY() + box.getMinY()) / 2, (box.getMaxZ() + box.getMinZ()) / 2);
        origin.substract(center).add(halfDimensions);

        // Handle rays with negative directions.
        if (direction.getElement(0) < 0.0) {
            origin.setElement(0, dimensions.getElement(0) - origin.getElement(0));
            direction.setElement(0, -direction.getElement(0));
        }
        if (direction.getElement(1) < 0.0) {
            origin.setElement(1, dimensions.getElement(1) - origin.getElement(1));
            direction.setElement(1, -direction.getElement(1))
        }
        if (direction.getElement(2) < 0.0) {
            origin.setElement(2, dimensions.getElement(2) - origin.getElement(2));
            direction.setElement(2, -direction.getElement(2))
        }

        // Improve IEEE double stability.
        invDirX = 1.0 / direction.getElement(0);
        invDirY = 1.0 / direction.getElement(1);
        invDirZ = 1.0 / direction.getElement(2);

        // Project the ray to the octant
        tx0 = (min.getElement(0) - origin.getElement(0)) * invDirX;
        tx1 = (max.getElement(0) - origin.getElement(0)) * invDirX;
        ty0 = (min.getElement(1) - origin.getElement(1)) * invDirY;
        ty1 = (max.getElement(1) - origin.getElement(1)) * invDirY;
        tz0 = (min.getElement(2) - origin.getElement(2)) * invDirZ;
        tz1 = (max.getElement(2) - origin.getElement(2)) * invDirZ;

        // Check if the ray hits the octant.
        let t0 = Math.max(Math.max(tx0, ty0), tz0), t1 = Math.min(Math.min(tx1, ty1), tz1);
        //hit
        if (t0 <= t1) {
            return t0;
        }
        //none
        return null;
    }
};
;'use strict';
hmap.strategy = hmap.strategy || {};

/**
 * 体素，父类.
 * @private
 */
hmap.strategy.Octant = class {
    /**
     * 构造体素
     *
     * @param {hmap.util.Vector3} [min] - 左下.
     * @param {hmap.util.Vector3} [max] - 右上.
     */
    constructor(min = new hmap.util.Vector3(), max = new hmap.util.Vector3()) {
        this.min = min;
        this.max = max;

        this.children = null;
    }

    /**
     * 体素中心点
     * @return {hmap.util.Vector3}
     */
    getCenter() {
        return this.min.clone().add(this.max).multiplyScalar(0.5);
    }

    /**
     * 体素大小
     * @return {hmap.util.Vector3}
     */
    getDimensions() {
        return this.max.clone().substract(this.min);
    }

    /**
     * 将该体素划分为八个子体素
     */
    split() {
        const min = this.min;
        const max = this.max;
        const mid = this.getCenter();
        const children = this.children = [
            null, null,
            null, null,
            null, null,
            null, null
        ];
        let i, combination;
        for (i = 0; i < 8; ++i) {
            combination = hmap.strategy.pattern[i];
            children[i] = new this.constructor(
                new hmap.util.Vector3(
                    (combination[0] === 0) ? min.getElement(0) : mid.getElement(0),
                    (combination[1] === 0) ? min.getElement(1) : mid.getElement(1),
                    (combination[2] === 0) ? min.getElement(2) : mid.getElement(2)
                ),
                new hmap.util.Vector3(
                    (combination[0] === 0) ? mid.getElement(0) : max.getElement(0),
                    (combination[1] === 0) ? mid.getElement(1) : max.getElement(1),
                    (combination[2] === 0) ? mid.getElement(2) : max.getElement(2)
                )
            );
        }
    }
}

/**
 * 八叉树，父类
 * @private
 */
hmap.strategy.Octree = class {
    /**
     * 构造八叉树
     *
     * @param {hmap.util.Vector3} min 左下
     * @param {hmap.util.Vector3} max 右上
     */
    constructor(min, max) {
        this.root = (min !== undefined && max !== undefined) ? new Octant(min, max) : null;
    }

    /**
     * 左下
     * @return {hmap.util.Vector3}
     */
    get min() {
        return this.root.min;
    }

    /**
     * 右上
     * @return {Vector3}
     */
    get max() {
        return this.root.max;
    }

    /**
     * 子节点
     *
     * @return {Octant[]}
     */
    get children() {
        return this.root.children;
    }

    /**
     * 八叉树中心点
     *
     * @param {hmap.util.Vector3}
     * @return {hmap.util.Vector3}
     */
    getCenter() {
        return this.root.getCenter();
    }

    /**
     * 八叉树的大小
     *
     * @return {hmap.util.Vector3}
     */
    getDimensions() {
        return this.root.getDimensions();
    }

    /**
     * 树的深度
     *
     * @return {Number} The depth.
     */
    getDepth() {
        return this.getDepth(this.root);
    }

    /**
     * 通过找到所有和指定射线相交的体素
     *
     * @param {hmap.strategy.Raycaster} raycaster 射线
     * @param {hmap.strategy.RayLayerOctant[]} intersects 结果数组
     * @return {hmap.strategy.RayLayerOctant[]}
     */
    raycast(raycaster, intersects = []) {
        hmap.strategy.OctreeRaycaster.intersectOctree(this, raycaster, intersects);
        return intersects;
    }


    /**
     * 查找指定深度下的体素
     *
     * @param {Number} levelThe depth level.
     * @return {hmap.strategy.RayLayerOctant[]}
     */
    findOctantsByLevel(level) {
        const result = [];
        this.findOctantsByLevel(this.root, level, 0, result);
        return result;
    }

    /**
     * 自定八叉树的深度
     * @private
     * @param {hmap.strategy.RayLayerOctant} octant
     * @return {Number}
     */
    getDepth(octant) {
        const children = octant.children;
        let result = 0;
        let i, l, d;
        if (children !== null) {
            for (i = 0, l = children.length; i < l; ++i) {
                d = 1 + this.getDepth(children[i]);
                if (d > result) {
                    result = d;
                }
            }
        }
        return result;
    }

    /**
     *  自定八叉树的深度
     *
     * @private
     * @param {hmap.strategy.RayLayerOctant} octant
     * @param {Number} level
     * @param {Number} depth
     * @param {hmap.strategy.RayLayerOctant[]} result
     */
    findOctantsByLevel(octant, level, depth, result) {
        const children = octant.children;
        let i, l;
        if (depth === level) {
            result.push(octant);
        } else if (children !== null) {
            ++depth;
            for (i = 0, l = children.length; i < l; ++i) {
                this.findOctantsByLevel(children[i], level, depth, result);
            }
        }
    }
}

/**
 * 射线相交八叉树的计算
 *
 * 原理来源:"An Efficient Parametric Algorithm for Octree Traversal" by J. Revelles et al. (2000).
 * @private
 */
hmap.strategy.OctreeRaycaster = class {
    /**
     * 查找和射线相交的节点，距离排序
     *
     * @param {hmap.strategy.Octree} octree
     * @param {hmap.strategy.Raycaster} raycaster
     * @param {Array} intersects
     */
    static intersectOctree(octree, raycaster, intersects) {
        // Translate the octree extents to the scene origin.
        const min = new hmap.util.Vector3(0, 0, 0);
        const max = octree.max.clone().substract(octree.min);
        const dimensions = octree.getDimensions();
        const halfDimensions = dimensions.clone().multiplyScalar(0.5);

        const origin = raycaster.origin.clone();
        const direction = raycaster.direction.clone().normalize();

        let invDirX, invDirY, invDirZ;
        let tx0, tx1, ty0, ty1, tz0, tz1;

        // Translate the ray to the center of the octree.
        origin.substract(octree.getCenter()).add(halfDimensions);

        // A byte that stores raycasting flags,Reset all flags.
        let flags = 0;

        // Handle rays with negative directions.
        if (direction.getElement(0) < 0.0) {
            origin.setElement(0, dimensions.getElement(0) - origin.getElement(0));
            direction.setElement(0, -direction.getElement(0));
            flags |= 4;
        }
        if (direction.getElement(1) < 0.0) {
            origin.setElement(1, dimensions.getElement(1) - origin.getElement(1))
            direction.setElement(1, -direction.getElement(1))
            flags |= 2;
        }
        if (direction.getElement(2) < 0.0) {
            origin.setElement(2, dimensions.getElement(2) - origin.getElement(2))
            direction.setElement(2, -direction.getElement(2))
            flags |= 1;
        }

        // Improve IEEE double stability.
        invDirX = 1.0 / direction.getElement(0);
        invDirY = 1.0 / direction.getElement(1);
        invDirZ = 1.0 / direction.getElement(2);

        // Project the ray to the root's boundaries.
        tx0 = (min.getElement(0) - origin.getElement(0)) * invDirX;
        tx1 = (max.getElement(0) - origin.getElement(0)) * invDirX;
        ty0 = (min.getElement(1) - origin.getElement(1)) * invDirY;
        ty1 = (max.getElement(1) - origin.getElement(1)) * invDirY;
        tz0 = (min.getElement(2) - origin.getElement(2)) * invDirZ;
        tz1 = (max.getElement(2) - origin.getElement(2)) * invDirZ;

        // Check if the ray hits the octree.
        if (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {
            // Find the intersecting octants.
            this.raycastOctant(flags, octree.root, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects);
        }
    }

    /**
     * 和射线的相交判断并递归计算
     *
     * @private
     * @param {Octant} octant - The current octant.
     * @param {Number} tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.
     * @param {Number} ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.
     * @param {Number} tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.
     * @param {Number} tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.
     * @param {Number} ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.
     * @param {Number} tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.
     * @param {Raycaster} raycaster - The raycaster.
     * @param {Array} intersects - An array to be filled with the intersecting octants.
     */
    static raycastOctant(flags, octant, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects) {
        const children = octant.children;
        let currentOctant;
        let txm, tym, tzm;
        if (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {
            if (children === null) {
                // Leaf.
                intersects.push(octant);
            } else {
                // Compute means.
                txm = 0.5 * (tx0 + tx1);
                tym = 0.5 * (ty0 + ty1);
                tzm = 0.5 * (tz0 + tz1);
                currentOctant = this.findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);
                do {
                    /* The possibilities for the next node are passed in the same respective
                     * order as the t-values. Hence, if the first value is found to be the
                     * greatest, the fourth one will be returned. If the second value is the
                     * greatest, the fifth one will be returned, etc.
                     */
                    // console.log(flags)
                    switch (currentOctant) {
                        case 0:

                            this.raycastOctant(flags, children[flags], tx0, ty0, tz0, txm, tym, tzm, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, txm, tym, tzm);
                            break;

                        case 1:
                            this.raycastOctant(flags, children[flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, txm, tym, tz1);
                            break;

                        case 2:
                            this.raycastOctant(flags, children[flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, txm, ty1, tzm);
                            break;

                        case 3:
                            this.raycastOctant(flags, children[flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, txm, ty1, tz1);
                            break;

                        case 4:
                            this.raycastOctant(flags, children[flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, tx1, tym, tzm);
                            break;

                        case 5:
                            this.raycastOctant(flags, children[flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, tx1, tym, tz1);
                            break;

                        case 6:
                            this.raycastOctant(flags, children[flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, raycaster, intersects);
                            currentOctant = this.findNextOctant(currentOctant, tx1, ty1, tzm);
                            break;

                        case 7:
                            this.raycastOctant(flags, children[flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, raycaster, intersects);
                            // Far top right octant. No other octants can be reached from here.
                            currentOctant = 8;
                            break;
                    }
                } while (currentOctant < 8);
            }
        }
    }

    /**
     * 射线相交的入口面
     *
     * Determining the first octant requires knowing which of the t0s is the
     * largest. The tms of the other axes must also be compared against that
     * largest t0.
     *
     * @private
     * @param {Number} tx0 - Ray projection parameter.
     * @param {Number} ty0 - Ray projection parameter.
     * @param {Number} tz0 - Ray projection parameter.
     * @param {Number} txm - Ray projection parameter mean.
     * @param {Number} tym - Ray projection parameter mean.
     * @param {Number} tzm - Ray projection parameter mean.
     * @return {Number} The index of the first octant that the ray travels through.
     */
    static findEntryOctant(tx0, ty0, tz0, txm, tym, tzm) {
        let entry = 0;
        // Find the entry plane.
        if (tx0 > ty0 && tx0 > tz0) {
            // YZ-plane.
            if (tym < tx0) {
                entry |= 2;
            }
            if (tzm < tx0) {
                entry |= 1;
            }
        } else if (ty0 > tz0) {
            // XZ-plane.
            if (txm < ty0) {
                entry |= 4;
            }
            if (tzm < ty0) {
                entry |= 1;
            }
        } else {
            // XY-plane.
            if (txm < tz0) {
                entry |= 4;
            }
            if (tym < tz0) {
                entry |= 2;
            }
        }
        return entry;
    }

    /**
     * 根据当前射线的出射平面找到与射线相交的下一个八叉树
     *
     * @private
     * @param {Number} currentOctant - The index of the current octant.
     * @param {Number} tx1 - Ray projection parameter.
     * @param {Number} ty1 - Ray projection parameter.
     * @param {Number} tz1 - Ray projection parameter.
     * @return {Number} The index of the next octant that the ray travels through.
     */
    static findNextOctant(currentOctant, tx1, ty1, tz1) {
        let min;
        let exit = 0;
        // Find the exit plane.
        if (tx1 < ty1) {
            min = tx1;
            exit = 0; // YZ-plane.
        } else {
            min = ty1;
            exit = 1; // XZ-plane.
        }
        if (tz1 < min) {
            exit = 2; // XY-plane.
        }
        return hmap.strategy.octantTable[currentOctant][exit];
    }
}

/**
 * 描述标准八叉树布局的二进制模式：
 *
 * ```text
 *    3____7
 *  2/___6/|
 *  | 1__|_5
 *  0/___4/
 * ```
 * This common layout is crucial for positional assumptions.
 * @type {Uint8Array[]}
 * @private
 */
hmap.strategy.pattern = [
    new Uint8Array([0, 0, 0]),
    new Uint8Array([0, 0, 1]),
    new Uint8Array([0, 1, 0]),
    new Uint8Array([0, 1, 1]),

    new Uint8Array([1, 0, 0]),
    new Uint8Array([1, 0, 1]),
    new Uint8Array([1, 1, 0]),
    new Uint8Array([1, 1, 1])
];

/**
 * 包含八进制ID的查找表。 用于确定八叉树的出口平面。
 *
 * @type {Uint8Array[]}
 * @final
 * @private
 */
hmap.strategy.octantTable = [
    new Uint8Array([4, 2, 1]),
    new Uint8Array([5, 3, 8]),
    new Uint8Array([6, 8, 3]),
    new Uint8Array([7, 8, 8]),
    new Uint8Array([8, 6, 5]),
    new Uint8Array([8, 7, 8]),
    new Uint8Array([8, 8, 7]),
    new Uint8Array([8, 8, 8])
];
;"use strict";
hmap.strategy = hmap.strategy || {};
/**
 * 体素，与节点一对一关系
 * @type {hmap.strategy.RayLayerOctant}
 * @private
 */
hmap.strategy.RayLayerOctant = class extends hmap.strategy.Octant {

    /**
     * 体素.
     * @param {hmap.util.Vector3} [min] - 右下.
     * @param {hmap.util.Vector3} [max] - 左上.
     */
    constructor(min, max) {
        super(min, max);
        //The datas.{Array}
        this.data = null;
    }

    /**
     * 要素包围盒是否与体素相交
     * @param {hmap.basetype.BBox} box 包围盒.
     * @return {Boolean} .
     */
    intersect(box) {
        // const thatMin = box.min;
        // const thatMax = box.max;
        const min = this.min;
        const max = this.max;
        return (
            box.getMaxX() >= min.getElement(0) && box.getMinX() <= max.getElement(0) &&
            box.getMaxY() >= min.getElement(1) && box.getMinY() <= max.getElement(1) &&
            box.getMaxZ() >= min.getElement(2) && box.getMinZ() <= max.getElement(2)
        );
    }

    /**
     * 将本体素的内容分配到子体素
     */
    redistribute() {
        const children = this.children;
        const data = this.data;

        let i, j, il, jl;
        let child, box, entry;

        if (children !== null && data !== null) {
            for (i = 0, il = data.length; i < il; ++i) {
                entry = data[i];
                box = entry._bbox;
                for (j = 0, jl = children.length; j < jl; ++j) {
                    child = children[j];
                    if (child.intersect(box)) {
                        if (child.data === null) {
                            child.data = [];
                        }
                        child.data.push(entry);
                    }
                }
            }
        }
        this.data = null;
    }

    /**
     * 将子体素的数据聚合到本体素，并将子节点删除
     */
    merge() {
        const children = this.children;
        let i, l, k, kl;
        let child;
        if (children !== null) {
            this.data = [];
            for (i = 0, l = children.length; i < l; ++i) {
                child = children[i];
                if (child.data !== null) {
                    for (k = 0, kl = child.data.length; k < kl; ++k) {
                        if (!this.data.includes(child.data[k])) {
                            this.data.push(child.data[k]);
                        }
                    }
                }
            }
            this.children = null;
        }
    }

    /**
     * 重置体素
     */
    reset() {
        this.children = null;
        this.data = null;
    }
}

/**
 * 管理数据的八叉树
 * @private
 */
hmap.strategy.RayLayerOctree = class extends hmap.strategy.Octree {

    /**
     * 节点
     *
     * @param {hmap.util.Vector3} [min] - 左下
     * @param {hmap.util.Vector3} [max] - 右上.
     * @param {Number} [bias=0.0] - 边界容差.
     * @param {Number} [maxBoxes=8] - 节点最大数据数量.
     * @param {Number} [maxDepth=8] - 最大节点深度.
     */
    constructor(min, max, maxBoxes = 50, maxDepth = 18, bias = 0.0) {
        //translate  Coordinate to Vector3
        super();
        //The root octant.
        this.root = new hmap.strategy.RayLayerOctant(min, max);

        //An octant boundary bias.(The octree is considered "loose" with a bias greater than 0.)
        this.bias = Math.max(0.0, bias);

        //Number of objects per octant before a split occurs.
        this.maxBoxes = Math.max(1, Math.round(maxBoxes));

        // The maximum tree depth level.
        this.maxDepth = Math.max(0, Math.round(maxDepth));

        this.dataCount = 0;
    }

    /**
     * 重置
     */
    reset() {
        this.root.reset();
        this.boxCount = 0;
    }

    /**
     * 获取数据数量
     *
     * @param {hmap.strategy.RayLayerOctant} octant - 关联体素.
     * @return {Number}
     * @private
     */
    countData(octant) {
        const children = octant.children;
        let result = 0;
        let i, l;
        if (children !== null) {
            for (i = 0, l = children.length; i < l; ++i) {
                result += this.countData(children[i]);
            }
        } else if (octant.data !== null) {
            result = octant.data.length;
        }
        return result;
    }

    /**
     * 射线相交，并返回所有数据
     *
     * @param {hmap.strategy.Raycaster} raycaster - 射线.
     * @param {Array} [intersects] - 结果数组.
     * @return {intersects[]} .
     */
    raycast(raycaster, intersects = []) {
        const octants = super.raycast(raycaster);
        //return all data in every octant
        let arr = [];
        for (let i = 0, len = octants.length; i < len; i++) {
            if (octants[i].data) {
                arr.push(...octants[i].data);
            }
        }
        //unique the array
        let result = arr.reduce((pre, cur) => {
            if (undefined === pre.find(item => {
                //模型文件有为有mesh的区别  id相同可能是不同的mesh对象
                if ((item._id.indexOf(".model.") < 0) && item._id === cur._id) return pre
            })) {
                return pre.concat(cur)
            } else {
                return pre
            }
        }, []);
        // intersects = Array.from(new Set(arr));
        return result;
    }


    /**
     * 将数据数组放到八叉树内
     *
     * @param {Array<Object>} array - 数据集合.
     */
    putArray(array) {
        for (let i = array.length-1; i >=0; i--) {
            this.put(array[i]);
        }
    }

    /**
     * 对象放到八叉树
     *
     * @param {Object} object - 对象，格式{_id:"",_bBbox:box}
     * @return {Boolean}
     */
    put(object) {
        if (!object || !object._bbox) {
            throw new Error("object or object._bbox undefind!")
        }

        return this._put(object, this, this.root, 0);
    }

    /**
     * 从八叉树移除
     *
     * @param {Object} object - 对象.
     * @return {Object} 移除的数据.
     */
    remove(object) {
        if (!object) {
            throw new Error("object undefind!")
        }
        return this._remove(object, this, this.root, null);
    }

    /**
     * 移除
     *
     * @param {Object} object - 对象
     * @return {Object}
     */
    removeArray(array) {

        for (let i = array.length-1; i >=0; i--) {
            this.remove(array[i]);
        }
    }

    /**
     * 通过id移除对象
     * @param id
     */
    removeById(id) {
        this._removeById(id, this, this.root, null);
    }


    /**
     * 重置八叉树
     */
    clear() {
        this.root.reset();
        this.data = null;
        this.dataCount = 0;
    }

    /**
     * 查找数据
     *
     * @param {hmap.util.Vector3} object - 对象.
     * @return {Object}
     */
    find(object) {
        if (!object) {
            throw new Error("object undefind!")
        }
        return this._find(object, this, this.root);
    }

    /**
     * 更新数据
     *
     * @param {Array<Object>} array 数据数组
     * @return {Object}
     * @private
     */
    updateArray(array) {
        if (array.length < 1) {
            return
        }
        for (let i = 0, len = array.length; i < len; i++) {
            let feature = array[i];
            this.remove(feature);
            this.put(feature);
        }
    }

    /**
     * 更新数据
     *
     * @param {Object} object 数据对象.
     * @return {Object}
     * @private
     */
    update(object) {
        if (!object) {
            throw new Error("object undefind!")
        }
        return this._update(object, this, this.root, null, 0);
    }


    /**
     * 添加
     *
     * @private
     * @param {Object} object 对象.
     * @param {hmap.strategy.RayLayerOctree} octree 八叉树.
     * @param {hmap.strategy.RayLayerOctant} octant 体素.
     * @param {Number} depth 深度
     * @return {Boolean}
     */
    _put(object, octree, octant, depth) {
        let box = object._bbox;
        let children = octant.children;
        // let exists = false;
        let done = false;
        let i, l;
        if (octant.intersect(box)) {
            if (children === null) {
                if (octant.data === null) {
                    octant.data = [];
                }
                if (octant.data.length < octree.maxBoxes || depth === octree.maxDepth) {
                    octant.data.push(object);
                    ++octree.dataCount;
                    done = true;
                } else {
                    octant.split();
                    octant.redistribute();
                    children = octant.children;
                }
            }
            if (children !== null) {
                ++depth;
                for (i = 0, l = children.length; i < l; ++i) {
                    done = this._put(object, octree, children[i], depth);
                    // console.log(done)
                }
            }
        }
        return done;
    }

    /**
     * 移除
     *
     * @private
     * @param {Object} object(_bbox，_id)
     * @param {hmap.strategy.RayLayerOctree} octree
     * @param {hmap.strategy.RayLayerOctant} octant
     * @param {hmap.strategy.RayLayerOctant} parent
     * @return {Object}
     */
    _remove(object, octree, octant, parent) {
        let box = object._bbox;
        const children = octant.children;
        let result = null;
        let i, l;
        let data, last;
        if (octant.intersect(box)) {
            if (children !== null) {
                for (i = 0, l = children.length; i < l; ++i) {
                    result = this._remove(object, octree, children[i], octant);
                }
            } else if (octant.data !== null) {
                data = octant.data;
                for (i = 0, l = data.length; i < l; ++i) {
                    let obj = data[i];
                    if (obj._id === object._id) {
                        last = l - 1;
                        result = data[i];
                        // If the point is NOT the last one in the array:
                        if (i < last) {
                            // Overwrite with the last point and data entry.
                            data[i] = data[last];
                        }
                        // Drop the last entry.
                        data.pop();
                        //reset the boxes length
                        l--;
                        --octree.dataCount;
                        if (parent !== null && this.countData(parent) <= octree.maxBoxes) {
                            parent.merge();
                        }
                        // break;
                    }
                }
            }
        }
        return result;
    }

    /**
      * 移除，通过id
      * @param {String} fid
      * @param {hmap.strategy.RayLayerOctree} octree
      * @param {hmap.strategy.RayLayerOctant} octant
      * @param {hmap.strategy.RayLayerOctant} parent
      * */
    _removeById(fid, octree, octant, parent) {
        const children = octant.children;
        let i, l;
        let data, last;

        if (children !== null) {
            for (i = 0, l = children.length; i < l; ++i) {
                this._removeById(fid, octree, children[i], octant);
            }
        } else if (octant.data !== null) {
            // No divergence - the point can be updated in place.
            data = octant.data;
            for (i = 0, l = data.length; i < l; ++i) {
                if (data[i].getFid()===fid) {
                    last = l - 1;
                    // If the point is NOT the last one in the array:
                    if (i < last) {
                        // Overwrite with the last point and data entry.
                        data[i] = data[last];
                    }
                    // Drop the last entry.
                    data.pop();
                    //short the boxes length
                    l--;
                    //reset box count
                    --octree.boxCount;
                    //merge octant if count of feature is less than maxBoxes
                    if (parent !== null && this.countData(parent) <= octree.maxBoxes) {
                        parent.merge();
                    }
                }
            }
        }
        return true;
    }

    /**
     * 查找
     *
     * @private
     * @param {Object} object
     * @param {hmap.strategy.RayLayerOctree} octree
     * @param {hmap.strategy.RayLayerOctant} octant
     * @return {Object}
     */
    _find(object, octree, octant) {
        const box = object._bbox;
        const children = octant.children;
        let result = null;
        let i, l, data;
        if (octant.intersect(box)) {
            if (children !== null) {
                for (i = 0, l = children.length; result === null && i < l; ++i) {
                    result = this._find(object, octree, children[i]);
                }
            } else if (octant.data !== null) {
                data = octant.data;
                for (i = 0, l = data.length; result === null && i < l; ++i) {
                    if (data[i]._id===object._id) {
                        result = octant.data[i];
                    }
                }
            }
        }
        return result;
    }

    /**
     * 更新
     *
     * @private
     * @param {Object} object
     * @param {hmap.strategy.RayLayerOctree} octree
     * @param {hmap.strategy.RayLayerOctant} octant
     * @param {hmap.strategy.RayLayerOctant} parent
     * @param {Number} depth
     * @return {Object}
     */
    _update(object, octree, octant, parent, depth) {
        this._remove(object, octree, octant, parent);
        this._put(object,octree, octant,depth);
    }
}
;"use strict";
hmap.strategy = hmap.strategy || {};
/**
 * 射线法拾取类
 * @type {hmap.strategy.Raycaster}
 * @private
 */
hmap.strategy.Raycaster = class {
    /**
     * @param {hmap.Map} option.map 地图对象，必选
     * @param {Number} option.tolerance 拾取容差，可选，缺省值为2,只对线和点有效
     * @example
     * let ray = new Raycaster({map:this.map,tolerance:5})
     */
    constructor(option) {
        if (!option || !option.map) {
            throw new Error("'.map' is not valid!")
        }
        this._map = option.map;
        this._camera = this._map.getCamera();

        this._tolerancePixel = (option && option.tolerance) ? option.tolerance : 5;  //拾取容差(像素单位)
        this.origin = new hmap.util.Vector3();//起点
        this.end = new hmap.util.Vector3();//线段终点
        this.direction = new hmap.util.Vector3();//方向向量
        this._line = null;              //在透视空间的线段（这里直接采用相机到拾取点的线段）
        this._hitCoord = null;
        this.CLASS_NAME = "hmap.util.Raycaster";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
    }

    /**
     * 获取射线对应的屏幕点击坐标
     * @return {hmap.basetype.Coordinate|Null}
     */
    getHitCoordinate() {
        return this._hitCoord;
    }

    /**
     * 点坐标和宽线因为有半径的像素缓冲，需要在此基础上进行计算容差
     * @private
     */
    _getFeatureTolerance(feature) {
        let size = 0;
        let tolearance = this._tolerancePixel;
        switch (feature.getGeometry().getType()) {
            case hmap.geom.GeometryType.Point:
            case hmap.geom.GeometryType.MultiPoint:
                let markerSymbols = feature.getStyle().getMarkerSymbols();
                let symbol = markerSymbols[0];
                if (symbol instanceof hmap.style.Icon) {
                    let iconSize = symbol.getSize();
                    tolearance = 0;
                    size = (iconSize.getHeight() + iconSize.getWidth()) / 4
                } else if (symbol instanceof hmap.style.IconFont) {
                    size = symbol.getFontSize() / 2;
                    tolearance = 0;
                } else if (symbol instanceof hmap.style.Circle) {
                    size = symbol.getRadius();
                    tolearance = 0;
                }
                break;
            case hmap.geom.GeometryType.Line:
            case hmap.geom.GeometryType.LinearRing:
                let lineSymbols = feature.getStyle().getLineSymbols();
                size = lineSymbols[0].getWidth() / 2;
                size = size < 3 ? 3 : size;
                break;
            case hmap.geom.GeometryType.Polygon:
            case hmap.geom.GeometryType.MultiPolygon:
                break;
        }
        return this._getToleranceFromSize(tolearance + size);
    }

    /**
     * 从对象大小获取拾取容差
     * @private
     */
    _getToleranceFromSize(size) {
        let pointTolerance = this._map.getResolution(this._map.getZoomWithInterval()) * size;     //拾取容差(像素转地图单位）
        return pointTolerance;
    }

    /**
     *
     * @param coord
     * @return {*}
     * @private
     */
    distanceSquare(coord) {
        return (this.origin._elements[0] - coord._x) * (this.origin._elements[0] - coord._x)
            + (this.origin._elements[1] - coord._y) * (this.origin._elements[1] - coord._y)
            + (this.origin._elements[2] - coord._z) * (this.origin._elements[2] - coord._z)
    }

    /**
     * coord为点击的地面坐标，求出近切面坐标即可
     * @param {hmap.basetype.Coordinate} coord 点击位置
     * @return {Boolean}
     * @example
     * if(ray.setFromCoordinate(coordinate)){
     *     ...
     * }
     */
    setFromCoordinate(coord) {
        if (!coord instanceof hmap.basetype.Coordinate) {
            throw new TypeError("coord must be an instance of hmap.basetype.Coordinate!")
        }
        this._hitCoord = coord;
        //相机位置
        const cameraCoord = this._camera.getCoordinate();
        this.direction.set(coord.getOrdinate("X") - cameraCoord.getOrdinate("X"), coord.getOrdinate("Y") - cameraCoord.getOrdinate("Y"),
            coord.getOrdinate("Z") - cameraCoord.getOrdinate("Z"));
        let len = this.direction.length();
        //近裁面
        const far = this._map.getCamera().getFPlaneDistance();
        const rn = far / (50 * len);
        let nx = cameraCoord.getOrdinate("X") + rn * this.direction.getElement(0),
            ny = cameraCoord.getOrdinate("Y") + rn * this.direction.getElement(1),
            nz = cameraCoord.getOrdinate("Z") + rn * this.direction.getElement(2);
        this.origin.set(nx, ny, nz);
        //远裁面(延伸三倍)
        const rf = far * 3 / len;
        let fx = cameraCoord.getOrdinate("X") + rf * this.direction.getElement(0),
            fy = cameraCoord.getOrdinate("Y") + rf * this.direction.getElement(1),
            fz = cameraCoord.getOrdinate("Z") + rf * this.direction.getElement(2);
        this.end.set(fx, fy, fz);

        //方向向量
        this.direction.set(fx - nx, fy - ny, fz - nz);

        // this.segement=new hmap.geom.Segment(new hmap.basetype.Coordinate(...this.origin.getElements()),new hmap.basetype.Coordinate(...this.end.getElements()))
        //可视空间内的线段
        this._line = new hmap.geom.Line([
            new hmap.geom.Point(new hmap.basetype.Coordinate(...this.origin.getElements())),
            new hmap.geom.Point(new hmap.basetype.Coordinate(...this.end.getElements()))
        ]);
        return true;
    }

    /**
     * 相交判定，返回拾取结果
     * @param {Array<hmap.layer.Layer>} layers 图层数组，默认拾取所有图层
     * @param {Boolean} resort 是否按照距离进行排序，默认为true。
     * @returns {Array} [{distance:Number,feature:Object}] 结果数组。
     * @example
     * let results = ray.intersect();
     */
    intersect(layers = [], resort = true) {
        let pickResults = [];
        if (!this._line || layers.length < 1) return pickResults;
        for (let i = 0, len = layers.length; i < len; i++) {
            const layer = layers[i];
            if (!layer.enableHashCode) {
                continue;
            }
            let objectResults = null;
            switch (layer.getLayerType()) {
                case "hmap.layer.VectorLayer":
                case "hmap.layer.VectorTileLayer":
                    objectResults = layer.raycasterIntersect(this);
                    // console.log(objectResults);
                    for (let feature of objectResults) {
                        const tolerance = this._getFeatureTolerance(feature);
                        const disToCamera = feature.intersectRay(this, tolerance, this._map);
                        if (disToCamera) {
                            pickResults.push({
                                distance: disToCamera,
                                feature: feature
                            });
                        }
                    }
                    break;
                case "hmap.layer.GLTFLayer":
                case "hmap.layer.FbxModelLayer":
                case "hmap.layer.ObjModelLayer":
                    objectResults = layer.raycasterIntersect(this);
                    for (let obj of objectResults) {
                        const disToCamera = obj._bbox.intersectRay(this);
                        // if(layer.strict){
                        //     //TODO 高精度拾取
                        // }
                        if (disToCamera) {
                            pickResults.push({
                                distance: disToCamera,
                                feature: obj
                            });
                        }
                    }
                    break;
                case "hmap.layer.PointCloudLayer":
                    objectResults = layer.raycasterIntersect(this);
                    const tolerance = this._getToleranceFromSize(this._tolerancePixel);
                    console.log(tolerance);
                    for (let coord of objectResults) {
                        const disToCamera = new hmap.geom.Point(coord).intersectRay(this, tolerance);
                        if (disToCamera) {
                            pickResults.push({
                                distance: disToCamera,
                                feature: coord
                            });
                        }
                    }
                    break;
            }
        }

        if (resort && pickResults.length > 1) {
            this._resortByDistance(pickResults);
        }
        //屏蔽distance，只返回要素对象数组
        const features = [];
        for (let i = 0, len = pickResults.length; i < len; i++) {
            features.push(pickResults[i].feature);
        }
        return features;
    }

    /**
     * 排序
     * @param {Array} listResult 要排序的数组
     * @private
     */
    _resortByDistance(listResult) {
        return listResult.sort(function (a, b) {
            return a.distance - b.distance;
        });
    }

}

;"use strict";
hmap.strategy = hmap.strategy || {};
/**
 * 注记碰撞检测，基于Extent和Circle
 * @type {hmap.strategy.CollisionLabel}
 * @private
 */
hmap.strategy.CollisionLabel = class {
    constructor(map, tolerance = 10) {
        this.map = map;
        this.level = 0;
        this.tolerance = tolerance;
        this.CLASSNAME = "hmap.strategy.CollisionLabel";
        this.id = this.CLASSNAME;
    }

    // //todo 测试代码   待删除
    // addToLayer(x1, y1, x2, y2) {
    //     if (!this.layer) {
    //         this.layer = new hmap.layer.VectorLayer();
    //         this.map.addLayer(this.layer, 100, "default");
    //     }
    //     let coord1 = this.map.getCoordinateFromPixel(new hmap.basetype.Pixel(x1, y1));
    //     let coord2 = this.map.getCoordinateFromPixel(new hmap.basetype.Pixel(x1, y2));
    //     let coord3 = this.map.getCoordinateFromPixel(new hmap.basetype.Pixel(x2, y2));
    //     let coord4 = this.map.getCoordinateFromPixel(new hmap.basetype.Pixel(x2, y1));
    //
    //     const polygon = new hmap.geom.Polygon([new hmap.geom.LinearRing([
    //         new hmap.geom.Point(coord1),
    //         new hmap.geom.Point(coord2),
    //         new hmap.geom.Point(coord3),
    //         new hmap.geom.Point(coord4),
    //
    //     ])]);
    //     const lineRing = polygon.getLinearRing(0);
    //     let lineStyle = new hmap.style.Style({
    //         lineSymbols: [new hmap.style.LineSymbol({
    //             color: new hmap.style.Color(255, 0, 0),
    //             lineStyle: 'solid',
    //             width: 1
    //         }),]
    //     });
    //     const lineFeature = new hmap.feature.Vector(lineRing, {name: "line"}, lineStyle);
    //     this.layer.addFeature(lineFeature);
    // }

    /**
     * 重置视图等级和视图范围
     * @param set
     * @param level
     * @param tolerance
     */
    updateView(set, level, tolerance) {
        // if (this.layer) {
        //     this.layer.removeAllFeatures();
        // }
        this.set = set;
        this.level = level;
        if (tolerance)
            this.tolerance = tolerance;
    }

    /**
     * 注记避让过滤，
     * @param paintersMap
     */
    filter(paintersMap) {
        const pointTextPainter = paintersMap.get("Label_Point");
        // const lineTextPainter = paintersMap.get("Label_Line");
        const IconPainter = paintersMap.get("Label_Icon");
        const [minX, minY, maxX, maxY] = this._getTileRange(this.set);
        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                const id = this._getXYZ(x, y, this.level);
                //点注记检测（点避让点），需要优先处理
                if (pointTextPainter) {
                    this.pointTextFilter(x, y, maxX, maxY, pointTextPainter);
                    //重组数据(文字)
                    const block = pointTextPainter.getBlockById(id);
                    if (block && block.buffer) {
                        pointTextPainter._parser._dealBlockData(block);
                    }
                    //重组数据(图标)
                    const blockIcon = IconPainter.getBlockById(id);
                    if (blockIcon && blockIcon.buffer) {
                        IconPainter._parser._dealBlockData(blockIcon);
                    }
                }
                //todo 线线注记检测（线避让点），当前为临时解决方案，最终需要放到后台进行处理
                // if (lineTextPainter&&!lineTextPainter.verifyLimitAngle()) {
                //     this.lineTextFilter(x, y, maxX, maxY, lineTextPainter);
                //     const blockLine = lineTextPainter.getBlockById(id);
                //     if (blockLine && blockLine.buffer) {
                //         lineTextPainter._parser._dealBlockData(lineTextPainter.getBlockById(id));
                //     }
                // }
            }
        }
    }

    /**
     * 点注记避让
     * @param x
     * @param y
     * @param maxX
     * @param maxY
     * @param pointTextPainter
     */
    pointTextFilter(x, y, maxX, maxY, pointTextPainter) {
        //  根据块划分规则进行比对，
        //  --------------------------
        //              b0    block1
        //  block4   block2   block3
        //  --------------------------
        //  若存在,每次比对块 b0-b0;b0-b1;b0-b2;b0-b3
        //  todo 这里存在问题，(x+1,y+1)分别于（maxX,maxY）进行比对可以适当减少计算量

        let id = this._getXYZ(x, y, this.level);
        const block0 = pointTextPainter.getBlockById(id);
        if (!block0) return;
        //右
        id = this._getXYZ(x + 1, y, this.level);
        const block1 = pointTextPainter.getBlockById(id);
        //下
        id = this._getXYZ(x, y + 1, this.level);
        const block2 = pointTextPainter.getBlockById(id);
        //右下
        id = this._getXYZ(x + 1, y + 1, this.level);
        const block3 = pointTextPainter.getBlockById(id);
        //左下
        id = this._getXYZ(x - 1, y + 1, this.level);
        const block4 = pointTextPainter.getBlockById(id);

        const features = [];
        features.push(...block0.features);
        if (block1) features.push(...block1.features);
        if (block2) features.push(...block2.features);
        if (block3) features.push(...block3.features);
        if (block4) features.push(...block4.features);
        this._collideFeatures(block0.features, features);
    }

    /**
     * 组装标识
     * @param x
     * @param y
     * @param z
     * @return {string}
     * @private
     */
    _getXYZ(x, y, z) {
        return `${x}-${y}-${z}`;
    }

    /**
     * 线注记避让
     * @param x
     * @param y
     * @param maxX
     * @param maxY
     * @param pointTextPainter
     * @param lineTextPainter
     */
    lineTextFilter(x, y, maxX, maxY, lineTextPainter) {
        if (!lineTextPainter) return;
        let id = this._getXYZ(x, y, this.level);
        const block0 = lineTextPainter.getBlockById(id);
        if (!block0) return;
        //右
        id = this._getXYZ(x + 1, y, this.level);
        const block1 = lineTextPainter.getBlockById(id);
        //下
        id = this._getXYZ(x, y + 1, this.level);
        const block2 = lineTextPainter.getBlockById(id);
        //右下
        id = this._getXYZ(x + 1, y + 1, this.level);
        const block3 = lineTextPainter.getBlockById(id);
        //左下
        id = this._getXYZ(x - 1, y + 1, this.level);
        const block4 = lineTextPainter.getBlockById(id);

        //左上
        // id = this._getXYZ(x + 1, y - 1, this.level);
        // const block5 = lineTextPainter.getBlockById(id);

        const features = [];
        features.push(...block0.features);
        if (block1) features.push(...block1.features);
        if (block2) features.push(...block2.features);
        if (block3) features.push(...block3.features);
        if (block4) features.push(...block4.features);
        // if (block5) features.push(...block5.features);
        this._collideLineFeatures(block0.features, features);
    }

    /**
     * 根据字符串获取视图行列号范围
     * @param set
     * @return {number[]}
     * @private
     */
    _getTileRange(set) {
        let minX = Number.POSITIVE_INFINITY,
            minY = Number.POSITIVE_INFINITY,
            maxX = Number.NEGATIVE_INFINITY,
            maxY = Number.NEGATIVE_INFINITY;
        set.forEach(v => {
            //v:   "2384123-65253-12"
            const xyz = v.split("-");
            if (xyz[0] < minX) minX = xyz[0]; else if (xyz[0] > maxX) maxX = xyz[0];
            if (xyz[1] < minY) minY = xyz[1]; else if (xyz[1] > maxY) maxY = xyz[1];
        });
        return [minX * 1, minY * 1, maxX * 1, maxY * 1];
    }

    /**
     * 点注记避让
     * @param fs b0
     * @param os  b0+b1+b2+b3+b4
     * @private
     */
    _collideFeatures(fs, os) {
        for (let i = 0, len = fs.length; i < len; i++) {
            const f = fs[i];
            const fExtent = f._attributes['extent'],
                fWeight = f._attributes['weight'];
            //如果该注记已经作出避让，直接跳出
            if (!f.bufferText || !f._attributes["showLabel"]) {
                continue;
            }
            //根据锚点计算像素范围，
            const fAnchor = this.map.getPixelFromCoordinate(f._geometry.getCoordinate());
            const fxMin = fAnchor.getX() + fExtent[0],
                fyMin = fAnchor.getY() + fExtent[1],
                fxMax = fAnchor.getX() + fExtent[2],
                fyMax = fAnchor.getY() + fExtent[3];
            // this.addToLayer(fxMin, fyMin, fxMax, fyMax)

            for (let k = 0, lenK = os.length; k < lenK; k++) {
                const o = os[k];
                if (!o._attributes["showLabel"] || f._id === o._id) {
                    continue;
                }
                const oExtent = o._attributes['extent'],
                    oWeight = o._attributes['weight'];

                const oAnchor = this.map.getPixelFromCoordinate(o._geometry.getCoordinate());
                const oxMin = oAnchor.getX() + oExtent[0],
                    oyMin = oAnchor.getY() + oExtent[1],
                    oxMax = oAnchor.getX() + oExtent[2],
                    oyMax = oAnchor.getY() + oExtent[3];
                if (this._extentCollide(fxMin, fyMin, fxMax, fyMax, oxMin, oyMin, oxMax, oyMax, 0)) {
                    if (fWeight <= oWeight) {
                        f._attributes['showLabel'] = false;
                        f._attributes['showIcon'] = false;
                    } else {
                        o._attributes['showLabel'] = false;
                        o._attributes['showIcon'] = false;
                    }
                }
            }
        }
    }

    /**
     * 线注记避让
     * @param fs    线注记集合
     * @param os    周围点注记集合
     * @private
     */
    _collideLineFeatures(fs, os) {
        for (let i = 0, len = fs.length; i < len; i++) {
            const f = fs[i];
            const fExtent = f._attributes['extent'];
            const fWeight = f._attributes['weight'];
            //如果该注记已经作出避让，直接跳出
            if (!f.buffer || !f._attributes["showLabel"]) {
                continue;
            }

            //根据锚点计算像素范围，

            const [fxMin, fxMax, fyMin, fyMax] = this._getPixelExtentArray(fExtent);

            // this.addToLayer(fxMin,fyMin,fxMax,fyMax);
            for (let k = 0, lenK = os.length; k < lenK; k++) {
                const o = os[k];
                if (!f.buffer || !o._attributes["showLabel"] || f._id === o._id) {
                    continue;
                }
                const oExtent = o._attributes['extent'];
                const oWeight = o._attributes['weight'];
                const [oxMin, oxMax, oyMin, oyMax] = this._getPixelExtentArray(oExtent);
                if (this._extentCollide(fxMin, fyMin, fxMax, fyMax, oxMin, oyMin, oxMax, oyMax, 20)) {

                    if (fWeight <= oWeight) {
                        f._attributes['showLabel'] = false;
                    } else {
                        o._attributes['showLabel'] = false;
                    }
                }
            }
        }
    }

    _getPixelExtentArray(extent) {
        const [x1, y1] = this.map._camera._getPixelFromXYZ(extent[0], extent[1]);
        const [x2, y2] = this.map._camera._getPixelFromXYZ(extent[0], extent[3]);
        const [x3, y3] = this.map._camera._getPixelFromXYZ(extent[2], extent[3]);
        const [x4, y4] = this.map._camera._getPixelFromXYZ(extent[2], extent[1]);
        const fxMin = Math.min(x1, x2, x3, x4);
        let fxMax = Math.max(x1, x2, x3, x4);
        const fyMin = Math.min(y1, y2, y3, y4);
        let fyMax = Math.max(y1, y2, y3, y4);
        const max = Math.max(fxMax - fxMin, fyMax - fyMin);
        fxMax = fxMin + max;
        fyMax = fyMin + max;

        return [fxMin, fxMax, fyMin, fyMax]
    }

    /**
     * extent相交判断，这里加入容差（并默认补偿上下容差10像素）
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param x3
     * @param y3
     * @param x4
     * @param y4
     * @return {boolean}
     * @private
     */
    _extentCollide(x1, y1, x2, y2, x3, y3, x4, y4, t) {
        const lr = x1 - this.tolerance <= x4 && x2 + this.tolerance >= x3;
        const bt = y1 - this.tolerance - t <= y4 && y2 + this.tolerance >= y3;
        //
        // const lr2 = x4 - this.tolerance <= x1 && x3 + this.tolerance >= x2;
        // const bt2 = y4 - this.tolerance - 10 <= y1 && y3 + this.tolerance >= y2;


        return (lr && bt);
    }

    /**
     * circle相交判断
     * @param x1
     * @param y1
     * @param r1
     * @param x2
     * @param y2
     * @param r2
     * @return {boolean}
     * @private
     */
    _circlesCollide(x1, y1, r1, x2, y2, r2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const radius = r1 + r2;
        return (radius * radius) > (dx * dx + dy * dy);
    }

    /**
     * extent与circle相交
     * @param circleX
     * @param circleY
     * @param radius
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @return {boolean}
     * @private
     */
    _circleAndExtentCollide(circleX, circleY, radius, x1, y1, x2, y2) {
        const halfWidth = (x2 - x1) / 2;
        const distX = Math.abs(circleX - (x1 + halfWidth));
        if (distX > (halfWidth + radius)) {
            return false;
        }

        const halfHeight = (y2 - y1) / 2;
        const distY = Math.abs(circleY - (y1 + halfHeight));
        if (distY > (halfHeight + radius)) {
            return false;
        }

        if (distX <= halfWidth || distY <= halfHeight) {
            return true;
        }

        const dx = distX - halfWidth;
        const dy = distY - halfHeight;
        return (dx * dx + dy * dy <= (radius * radius));
    }

};"use strict";
hmap.format = hmap.format||{};
/**
 * fbx加载器
 * 要求FBX文件的版本为大于等于7.0的ASCII格式 或者大于等于6400的二进制格式
 * 纹理不支持.tga .psd，几何中暂不支持Nurbs曲线、变形、动画
 * @private
 * @type {hmap.format.FBX}
 */
hmap.format.FBX = class {
    constructor(url){
        this.url = url;
        //根据模型路径获取基础路径
        this.path = (this.url.lastIndexOf('/') === -1 ? './': this.url.substr( 0, this.url.lastIndexOf('/') + 1));
    }

    //解析fbx的二进制数据，请求完成后回调
    parse(callback){
        fetch(this.url,{
            method: 'get',
            responseType: 'arraybuffer'         //获取arrayBuffer
        }).then(response =>{
            return response.arrayBuffer();      //二进制
    }).then(arraybuffer => {
            let fbxData = fbxParse(arraybuffer,this.path);
        if(typeof(callback)==='function'){
            callback(fbxData)
        }
    }
    );
    }
}

/**
 * 将arraybuffer解析成fbx信息树
 * @private
 */
function fbxParse(FBXBuffer,sourceDire){
    if ( !isFbxFormatBinary( FBXBuffer ) ){
        console.error("the arraybuffer of parse is not Fbx Format Binary");
        return;
    }
    let fbxTree = new BinaryParser().parse( FBXBuffer );            //fbx信息树
    return new FBXTreeParser(sourceDire,fbxTree).parse();           //解析FBX树数据
}

/**
 * 检查是否是FBX格式的二进制
 * @private
 */
function isFbxFormatBinary( buffer ) {
    var CORRECT = 'Kaydara FBX Binary  \0';
    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );
}

/**
 * 将arrayBuffer转为String
 * @private
 */
function convertArrayBufferToString( buffer, from, to ) {
    if ( from === undefined ) from = 0;
    if ( to === undefined ) to = buffer.byteLength;
    return decodeText( new Uint8Array( buffer, from, to ) );
}

/**
 * 转化解析成二进制文本
 * @private
 */
function decodeText( array ) {
    if ( typeof TextDecoder !== 'undefined' ) {
        return new TextDecoder().decode( array );
    }
    // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.
    var s = '';
    for ( var i = 0, il = array.length; i < il; i ++ ) {
        // Implicitly assumes little-endian.
        s += String.fromCharCode( array[ i ] );
    }
    // Merges multi-byte utf-8 characters.
    return decodeURIComponent( escape( s ) );
}

/**
 * 二进制数据解析器
 * @private
 */
let BinaryParser = class {
    constructor(){}
    //解析
    parse ( buffer ) {
        var reader = new BinaryReader( buffer );
        reader.skip( 23 ); // skip magic 23 bytes
        var version = reader.getUint32();
        var allNodes = {};
        while ( ! this.endOfContent( reader ) ) {
            var node = this.parseNode( reader, version );
            if ( node !== null ) allNodes[node.name] = node;
        }
        return allNodes;
    }

    // Check if reader has reached the end of content.
    endOfContent ( reader ) {

        // footer size: 160bytes + 16-byte alignment padding
        // - 16bytes: magic
        // - padding til 16-byte alignment (at least 1byte?)
        //	(seems like some exporters embed fixed 15 or 16bytes?)
        // - 4bytes: magic
        // - 4bytes: version
        // - 120bytes: zero
        // - 16bytes: magic
        if ( reader.size() % 16 === 0 ) {
            return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();
        } else {
            return reader.getOffset() + 160 + 16 >= reader.size();
        }
    }

    // recursively parse nodes until the end of the file is reached
    parseNode ( reader, version ) {
        var node = {};
        // The first three data sizes depends on version.
        var endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
        var numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

        // note: do not remove this even if you get a linter warning as it moves the buffer forward
        var propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

        var nameLen = reader.getUint8();
        var name = reader.getString( nameLen );

        // Regards this node as NULL-record if endOffset is zero
        if ( endOffset === 0 ) return null;

        var propertyList = [];
        for ( var i = 0; i < numProperties; i ++ ) {
            propertyList.push( this.parseProperty( reader ) );
        }

        // Regards the first three elements in propertyList as id, attrName, and attrType
        var id = propertyList.length > 0 ? propertyList[ 0 ] : '';
        var attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
        var attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

        // check if this node represents just a single property
        // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
        node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

        while ( endOffset > reader.getOffset() ) {
            var subNode = this.parseNode( reader, version );
            if ( subNode !== null ) this.parseSubNode( name, node, subNode );
        }

        node.propertyList = propertyList; // raw property list used by parent

        if ( typeof id === 'number' ) node.id = id;
        if ( attrName !== '' ) node.attrName = attrName;
        if ( attrType !== '' ) node.attrType = attrType;
        if ( name !== '' ) node.name = name;
        return node;
    }

    parseSubNode ( name, node, subNode ) {
        // special case: child node is single property
        if ( subNode.singleProperty === true ) {
            var value = subNode.propertyList[ 0 ];
            if ( Array.isArray( value ) ) {
                node[ subNode.name ] = subNode;
                subNode.a = value;
            } else {
                node[ subNode.name ] = value;
            }
        } else if ( name === 'Connections' && subNode.name === 'C' ) {
            var array = [];
            subNode.propertyList.forEach( function ( property, i ) {
                // first Connection is FBX type (OO, OP, etc.). We'll discard these
                if ( i !== 0 ) array.push( property );
            } );
            if ( node.connections === undefined ) {
                node.connections = [];
            }
            node.connections.push( array );
        } else if ( subNode.name === 'Properties70' ) {
            var keys = Object.keys( subNode );
            keys.forEach( function ( key ) {
                node[ key ] = subNode[ key ];
            } );
        } else if ( name === 'Properties70' && subNode.name === 'P' ) {
            var innerPropName = subNode.propertyList[ 0 ];
            var innerPropType1 = subNode.propertyList[ 1 ];
            var innerPropType2 = subNode.propertyList[ 2 ];
            var innerPropFlag = subNode.propertyList[ 3 ];
            var innerPropValue;

            if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
            if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

            if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {
                innerPropValue = [
                    subNode.propertyList[ 4 ],
                    subNode.propertyList[ 5 ],
                    subNode.propertyList[ 6 ]
                ];
            } else {
                innerPropValue = subNode.propertyList[ 4 ];
            }
            // this will be copied to parent, see above
            node[ innerPropName ] = {
                'type': innerPropType1,
                'type2': innerPropType2,
                'flag': innerPropFlag,
                'value': innerPropValue
            };
        } else if ( node[ subNode.name ] === undefined ) {
            if ( typeof subNode.id === 'number' ) {
                node[ subNode.name ] = {};
                node[ subNode.name ][ subNode.id ] = subNode;
            } else {
                node[ subNode.name ] = subNode;
            }
        } else {
            if ( subNode.name === 'PoseNode' ) {
                if ( ! Array.isArray( node[ subNode.name ] ) ) {
                    node[ subNode.name ] = [ node[ subNode.name ] ];
                }
                node[ subNode.name ].push( subNode );
            } else if ( node[ subNode.name ][ subNode.id ] === undefined ) {
                node[ subNode.name ][ subNode.id ] = subNode;
            }
        }
    }

    parseProperty ( reader ) {
        var type = reader.getString( 1 );
        switch ( type ) {
            case 'C':
                return reader.getBoolean();
            case 'D':
                return reader.getFloat64();
            case 'F':
                return reader.getFloat32();
            case 'I':
                return reader.getInt32();
            case 'L':
                return reader.getInt64();
            case 'R':
                var length = reader.getUint32();
                return reader.getArrayBuffer( length );
            case 'S':
                var length = reader.getUint32();
                return reader.getString( length );
            case 'Y':
                return reader.getInt16();
            case 'b':
            case 'c':
            case 'd':
            case 'f':
            case 'i':
            case 'l':
                var arrayLength = reader.getUint32();
                var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
                var compressedLength = reader.getUint32();
                if ( encoding === 0 ) {
                    switch ( type ) {
                        case 'b':
                        case 'c':
                            return reader.getBooleanArray( arrayLength );

                        case 'd':
                            return reader.getFloat64Array( arrayLength );

                        case 'f':
                            return reader.getFloat32Array( arrayLength );

                        case 'i':
                            return reader.getInt32Array( arrayLength );

                        case 'l':
                            return reader.getInt64Array( arrayLength );
                    }
                }
                if ( typeof hmap.util.Inflate === 'undefined' ) {
                    console.error( 'hmap.util.Inflate required' );
                }
                var inflate = new hmap.util.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef
                var reader2 = new BinaryReader( inflate.decompress().buffer );
                switch ( type ) {
                    case 'b':
                    case 'c':
                        return reader2.getBooleanArray( arrayLength );
                    case 'd':
                        return reader2.getFloat64Array( arrayLength );
                    case 'f':
                        return reader2.getFloat32Array( arrayLength );
                    case 'i':
                        return reader2.getInt32Array( arrayLength );
                    case 'l':
                        return reader2.getInt64Array( arrayLength );
                }
            default:
                throw new Error( 'Unknown property type ' + type );
        }
    }
}

/**
 * 二进制数据读取器
 * @private
 */
let BinaryReader = class {
    constructor(buffer, littleEndian){
        this.dv = new DataView( buffer );
        this.offset = 0;
        this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;           //小端
    }

    getOffset () {
        return this.offset;
    }

    size () {
        return this.dv.buffer.byteLength;
    }

    skip ( length ) {
        this.offset += length;
    }

    // seems like true/false representation depends on exporter.
    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
    // then sees LSB.
    getBoolean () {
        return ( this.getUint8() & 1 ) === 1;
    }

    getBooleanArray ( size ) {
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a.push( this.getBoolean() );
        }
        return a;
    }

    getUint8 () {
        var value = this.dv.getUint8( this.offset );
        this.offset += 1;
        return value;
    }

    getInt16 () {
        var value = this.dv.getInt16( this.offset, this.littleEndian );
        this.offset += 2;
        return value;
    }

    getInt32 () {
        var value = this.dv.getInt32( this.offset, this.littleEndian );
        this.offset += 4;
        return value;
    }

    getInt32Array ( size ) {
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a.push( this.getInt32() );
        }
        return a;
    }

    getUint32 () {
        var value = this.dv.getUint32( this.offset, this.littleEndian );
        this.offset += 4;
        return value;
    }

    // JavaScript doesn't support 64-bit integer so calculate this here
    // 1 << 32 will return 1 so using multiply operation instead here.
    // There's a possibility that this method returns wrong value if the value
    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
    // TODO: safely handle 64-bit integer
    getInt64 () {
        var low, high;
        if ( this.littleEndian ) {
            low = this.getUint32();
            high = this.getUint32();
        } else {
            high = this.getUint32();
            low = this.getUint32();
        }
        // calculate negative value
        if ( high & 0x80000000 ) {
            high = ~ high & 0xFFFFFFFF;
            low = ~ low & 0xFFFFFFFF;
            if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;
            low = ( low + 1 ) & 0xFFFFFFFF;
            return - ( high * 0x100000000 + low );
        }
        return high * 0x100000000 + low;
    }

    getInt64Array ( size ) {
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a.push( this.getInt64() );
        }
        return a;
    }

    // Note: see getInt64() comment
    getUint64 () {
        var low, high;
        if ( this.littleEndian ) {
            low = this.getUint32();
            high = this.getUint32();
        } else {
            high = this.getUint32();
            low = this.getUint32();
        }
        return high * 0x100000000 + low;
    }

    getFloat32() {
        var value = this.dv.getFloat32( this.offset, this.littleEndian );
        this.offset += 4;
        return value;
    }

    getFloat32Array( size ) {
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a.push( this.getFloat32() );
        }
        return a;
    }

    getFloat64() {
        var value = this.dv.getFloat64( this.offset, this.littleEndian );
        this.offset += 8;
        return value;
    }

    getFloat64Array( size ) {
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a.push( this.getFloat64() );
        }
        return a;
    }

    getArrayBuffer( size ) {
        var value = this.dv.buffer.slice( this.offset, this.offset + size );
        this.offset += size;
        return value;
    }

    getString( size ) {
        // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
        var a = [];
        for ( var i = 0; i < size; i ++ ) {
            a[ i ] = this.getUint8();
        }
        var nullByte = a.indexOf( 0 );
        if ( nullByte >= 0 ) a = a.slice( 0, nullByte );
        return decodeText( new Uint8Array( a ) );
    }
}

/**
 * FBX树解析器
 * @private
 */
let FBXTreeParser = class {
    constructor( sourceDire, fbxTree ){
        this.fbxTree = fbxTree;                                         //fbx树数据
        let loadManager = new LoadingManager();                             //加载管理器
        this.textureLoader = new TextureLoader(loadManager).setPath( sourceDire );    //纹理加载器
    }

    /**
     * 解析fbx树
     * */
    parse () {
        this.connections = this.parseConnections();              //模型节点之间的连接关系，保存在Map中，保存的是每个节点对应的父级节点和子级节点
        var images = this.parseImages();                            //图片
        var textures = this.parseTextures( images );                //纹理
        var materials = this.parseMaterials( textures );            //材质
        var geometryMap = new GeometryParser(this.fbxTree,this.connections).parse();             //给每个变形解析geometry，保存在geometryMap中
        let sceneGraph = this.parseScene(geometryMap, materials );             //解析整个fbx场景
        return sceneGraph;
    }

    /**
     *  解析FBXTree.Connections中的父子节点连接关系
     * */
    parseConnections () {
        var connectionMap = new Map();
        if ( 'Connections' in this.fbxTree ) {
            var rawConnections = this.fbxTree.Connections.connections;
            rawConnections.forEach( function ( rawConnection ) {
                var fromID = rawConnection[ 0 ];
                var toID = rawConnection[ 1 ];
                var relationship = rawConnection[ 2 ];
                if ( ! connectionMap.has( fromID ) ) {
                    connectionMap.set( fromID, {
                        parents: [],
                        children: []
                    } );
                }
                var parentRelationship = { ID: toID, relationship: relationship };
                connectionMap.get( fromID ).parents.push( parentRelationship );
                if ( ! connectionMap.has( toID ) ) {
                    connectionMap.set( toID, {
                        parents: [],
                        children: []
                    } );
                }
                var childRelationship = { ID: fromID, relationship: relationship };
                connectionMap.get( toID ).children.push( childRelationship );
            } );
        }
        return connectionMap;
    }

    /**
     *  解析FBXTree.Objects.Video中的所有的图像数据，图像数据和FBXTree.Objects.Textures关联
     */
    parseImages () {
        var images = {};
        var blobs = {};
        if ( 'Video' in this.fbxTree.Objects ) {
            var videoNodes = this.fbxTree.Objects.Video;
            for ( var nodeID in videoNodes ) {
                var videoNode = videoNodes[ nodeID ];
                var id = parseInt( nodeID );
                images[ id ] = videoNode.RelativeFilename || videoNode.Filename;
                // raw image data is in videoNode.Content
                if ( 'Content' in videoNode ) {
                    var arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
                    var base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );
                    if ( arrayBufferContent || base64Content ) {
                        var image = this.parseImage( videoNodes[ nodeID ] );                    //获取图片的数据
                        blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;      //对图片数据进行保存
                    }
                }
            }
        }
        for ( var id in images ) {
            var filename = images[ id ];
            if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];
            else images[ id ] = images[ id ].split( '\\' ).pop();
        }
        return images;
    }

    /**
     *  解析FBXTree.Video.Content中的单个节点。视频本质上是由一帧一帧图片组成的
     */
    parseImage ( videoNode ) {
        var content = videoNode.Content;
        var fileName = videoNode.RelativeFilename || videoNode.Filename;
        var extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();
        var type;
        switch ( extension ) {
            case 'bmp':
                type = 'image/bmp';
                break;
            case 'jpg':
            case 'jpeg':
                type = 'image/jpeg';
                break;
            case 'png':
                type = 'image/png';
                break;
            case 'tif':
                type = 'image/tiff';
                break;
            case 'tga':
                type = 'image/tga';
                break;
            default:
                console.warn( 'Image type "' + extension + '" is not supported.' );
                return;
        }
        if ( typeof content === 'string' ) {            // ASCII format
            return 'data:' + type + ';base64,' + content;
        } else { // Binary Format
            var array = new Uint8Array(content);
            return window.URL.createObjectURL(new Blob([array],{type:type}));     //生成URL
        }
    }

    /**
     *  解析FBXTree.Objects.Texture中的所有节点，包含FBXTree.Objects.Video中的图片的UV缩放、裁剪、旋转等信息
     *  @returns {Map} textureMap
     */
    parseTextures ( images ) {
        var textureMap = new Map();
        if ( 'Texture' in this.fbxTree.Objects ) {
            var textureNodes = this.fbxTree.Objects.Texture;
            for ( var nodeID in textureNodes ) {
                var texture = this.parseTexture( textureNodes[ nodeID ], images );
                textureMap.set( parseInt( nodeID ), texture );
            }
        }
        return textureMap;
    }

    /**
     *  解析FBXTree.Objects.Texture中单个节点的UV缩放、裁剪、旋转等信息
     *  @returns {Object} texture 纹理信息
     *  texture.wrapS 纹理水平方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸
     *  texture.wrapT 纹理垂直方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸
     *  texture.repeat 纹理重复间隔 x:x方向上间隔，y:y方向上间隔
     */
    parseTexture ( textureNode, images ) {
        var texture = this.loadTexture( textureNode, images );
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        var wrapModeU = textureNode.WrapModeU;
        var wrapModeV = textureNode.WrapModeV;

        let valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
        let valueV = wrapModeV !== undefined ? wrapModeV.value : 0;
        // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
        // 0: repeat(default), 1: clamp
        texture.wrapS = valueU === 0 ? "REPEAT":"CLAMP_TO_EDGE";    //"ClampToEdgeWrapping"; //纹理水平方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸
        texture.wrapT = valueV === 0 ? "REPEAT":"CLAMP_TO_EDGE";    //"ClampToEdgeWrapping"; //纹理垂直方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸
        if ( 'Scaling' in textureNode ) {
            var values = textureNode.Scaling.value;
            texture.repeat.x = values[ 0 ];     //纹理重复
            texture.repeat.y = values[ 1 ];
        }
        return texture;
    }

    /**
     *  加载一个纹理作为blob、数据URI或者外部URL，这里是重点
     *  @param {Object} textureNode 纹理节点
     *  @param {Map} images 图片集合
     */
    loadTexture ( textureNode, images ) {
        var fileName;
        var currentPath = this.textureLoader.path;
        var children = this.connections.get( textureNode.id ).children;
        if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {
            fileName = images[ children[ 0 ].ID ];
            if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {
                this.textureLoader.setPath( undefined );
            }
        }
        var texture;
        var extension = textureNode.FileName.slice( - 3 ).toLowerCase();
        if ( extension === 'tga' ) {                    //tga格式，暂时不予支持
            console.warn( 'tga textures are not supported yet');
            /*var loader = THREE.Loader.Handlers.get( '.tga' );
            if ( loader === null ) {
                console.warn( 'TGALoader not found, creating empty placeholder texture for', fileName );     //placeholder 占位符
                texture = new THREE.Texture();
            } else {
                texture = loader.load( fileName );
            }*/
        } else if ( extension === 'psd' ) {             //psd格式 暂时不予支持
            console.warn( 'PSD textures are not supported yet');
            texture = {};//new THREE.Texture();
        } else {
            texture = this.textureLoader.load( fileName );  //加载纹理
        }
        this.textureLoader.setPath( currentPath );
        return texture;
    }

    /**
     *  解析FBXTree.Objects.Material中的全部节点
     *  @returns {Map} 材质map
     */
    parseMaterials ( textureMap ) {
        var materialMap = new Map();
        if ( 'Material' in this.fbxTree.Objects ) {
            var materialNodes = this.fbxTree.Objects.Material;
            for ( var nodeID in materialNodes ) {
                var material = this.parseMaterial( materialNodes[ nodeID ], textureMap );
                if ( material !== null ) materialMap.set( parseInt( nodeID ), material );
            }
        }
        return materialMap;
    }

    /**
     *  解析FBXTree.Objects.Material中的单个节点，fbx中暂时有2种材质：Lambert 受光照影响的材质；Phong 光亮表面材质
     *  @returns {Object} material
     *  主要材质参数：
     *  material.materialType 材质类型，"phong":光亮表面，"lambert":受光照影响
     *  material.map中保存的是纹理信息，material.map.image保存的是纹理图片
     *  其他参数后续再完善
     * */
    parseMaterial ( materialNode, textureMap ) {
        var ID = materialNode.id;
        var name = materialNode.attrName;
        var type = materialNode.ShadingModel;
        // Case where FBX wraps shading model in property object.
        if ( typeof type === 'object' ) {
            type = type.value;
        }
        // Ignore unused materials which don't have any connections.
        if ( ! this.connections.has( ID ) ) return null;
        var parameters = this.parseParameters( materialNode, textureMap, ID );      //材质的参数，可以先不用管很多
        var material = parameters;
        switch ( type.toLowerCase() ) {
            case 'phong':                           //光亮表面
                material.materialType = "phong";
                break;
            case 'lambert':                         //受光照影响
                material.materialType = "lambert";
                break;
            default:
                material.materialType = "phong";        //默认为"phong" 光亮表面
                break;
        }
        material.name = name;
        return material;
    }

    //hmap.style.Light

    /**
     *  解析纹理相关的参数,比如碰撞因子、漫反射、位移因子、自发光、透明度、光亮度等，现阶段可以先不用管
     * */
    parseParameters ( materialNode, textureMap, ID ) {
        var parameters = {},options = {};
        //碰撞因子
        if ( materialNode.BumpFactor ) {
            parameters.bumpScale = materialNode.BumpFactor.value;
        }
        //位移因子
        if ( materialNode.DisplacementFactor ) {
            parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        //透明
        if ( materialNode.Opacity ) {
            parameters.opacity = parseFloat( materialNode.Opacity.value );
        }else{
            parameters.opacity = 1;
        }
        if ( parameters.opacity < 1.0 ) {
            parameters.transparent = true;                      //是否透明
        }
        //反射因子
        if ( materialNode.ReflectionFactor ) {
            parameters.reflectionFactor = materialNode.ReflectionFactor.value;
        }
        //漫反射
        if ( materialNode.Diffuse ) {                                           //漫反射
            options.diffuse = materialNode.Diffuse.value;
        }
        if ( materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color' ) {
            options.diffuseColor = materialNode.DiffuseColor.value;
        }
        if(materialNode.DiffuseFactor){
            options.diffuseFactor = materialNode.DiffuseFactor.value;
        }
        //自发光
            //console.log(materialNode.Emissive);
            //console.log(materialNode.EmissiveColor);
        if ( materialNode.Emissive ) {
            options.emissive = materialNode.Emissive.value;
        }
        if ( materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color' ) {
            options.emissiveColor = materialNode.EmissiveColor.value;
            //console.log("color",options.emissiveColor);
        }
        if ( materialNode.EmissiveFactor ) {
            options.emissiveFactor = parseFloat( materialNode.EmissiveFactor.value );
        }
        //光亮度
        if ( materialNode.Shininess ) {
            options.shininess = materialNode.Shininess.value;
        }
        //镜面反射
        if ( materialNode.Specular ) {
            options.specular = materialNode.Specular.value;
        }
        if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {
            options.specularColor = materialNode.SpecularColor.value;
        }
        if(materialNode.SpecularFactor){
            options.specularFactor = materialNode.SpecularFactor.value;
        }
        parameters.light = new hmap.style.Light(options)
        var self = this;
        this.connections.get( ID ).children.forEach( function ( child ) {
            parameters.map = self.getTexture( textureMap, child.ID );
            /*var type = child.relationship;
            switch ( type ) {
                case 'Bump':
                    parameters.bumpMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'Maya|TEX_ao_map':
                    parameters.aoMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'DiffuseColor':
                case 'Maya|TEX_color_map':
                    parameters.map = self.getTexture( textureMap, child.ID );
                    break;
                case 'DisplacementColor':
                    parameters.displacementMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'EmissiveColor':
                    parameters.emissiveMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'NormalMap':
                case 'Maya|TEX_normal_map':
                    parameters.normalMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'ReflectionColor':
                    parameters.envMap = self.getTexture( textureMap, child.ID );
                    parameters.envMap.mapping = "EquirectangularReflectionMapping";//THREE.EquirectangularReflectionMapping;
                    break;
                case 'SpecularColor':
                    parameters.specularMap = self.getTexture( textureMap, child.ID );
                    break;
                case 'TransparentColor':
                    parameters.alphaMap = self.getTexture( textureMap, child.ID );
                    parameters.transparent = true;
                    break;
                case '3dsMax|VRayBlendMtl parameters|baseMtl':
                    parameters.map = self.getTexture( textureMap, child.ID );
                    break;
                case 'AmbientColor':
                case 'ShininessExponent': // AKA glossiness map
                case 'SpecularFactor': // AKA specularLevel
                case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
                default:
                    console.warn( 'FBXLoader: %s map is not supported in hmap, skipping texture.', type );
                    break;
            }*/
        } );
        return parameters;
    }

    /**
     *  从textureMap中获取材质使用的纹理texture
     * */
    getTexture ( textureMap, id ) {
        if ( 'LayeredTexture' in this.fbxTree.Objects && id in this.fbxTree.Objects.LayeredTexture ) {
            console.warn( 'FBXLoader: layered textures are not supported in yet. Discarding all but first layer.' );
            id = this.connections.get( id ).children[ 0 ].ID;
        }
        let texture = textureMap.get( id );
        // if(texture){
        //     console.log(texture);
        // }
        return texture;
    }

    /**
     *  解析整个fbx场景
     */
    parseScene ( geometryMap, materialMap ) {
        let modelGroup = new ObjectMesh();
        var modelMap = this.parseModels( geometryMap, materialMap );
        let connections = this.connections;
        modelMap.forEach( function ( model ) {
            var parentConnections = connections.get( model.ID ).parents;
            parentConnections.forEach( function ( connection ) {            //父级连接
                var parent = modelMap.get( connection.ID );
                if ( parent !== undefined ) {
                    model.parent = parent;
                    parent.children.push( model );
                }
            } );
            if ( !model.parent ) {
                modelGroup.children.push( model );
            }
        } );
        return modelGroup;
    }

    /**
     * 解析模型节点
     */
    parseModels (geometryMap, materialMap ) {
        var modelMap = new Map();
        var modelNodes = this.fbxTree.Objects.Model;            //模型部位
        for ( var nodeID in modelNodes ) {
            var id = parseInt( nodeID );
            var node = modelNodes[ nodeID ];
            var relationships = this.connections.get( id );
            var modelItem = null;
            switch ( node.attrType ) {
                case 'Camera':
                    //model = this.createCamera( relationships );
                    modelItem = new ObjectMesh();
                    break;
                case 'Light':
                    //model = this.createLight( relationships );
                    modelItem = new ObjectMesh();
                    break;
                case 'Mesh':  
                    //网格,暂时只支持
                    // console.log(relationships);
                    // console.log(geometryMap);
                    // console.log(materialMap);
                    modelItem = this.createMesh( relationships, geometryMap, materialMap );
                    // console.log(modelItem);
                    break;
                case 'NurbsCurve':      //Nurbs曲线
                    //model = this.createCurve( relationships, geometryMap );
                    modelItem = new ObjectMesh();
                    break;
                case 'LimbNode':
                case 'Root':
                    //model = new THREE.Bone();
                    modelItem = new ObjectMesh();
                    break;
                default:
                    modelItem = new ObjectMesh();
                    break;
            }
            if(!modelItem){
                console.warn("type "+ node.attrType +" is not supported yet!");
                continue;
            }
            modelItem.name = node.attrName
            modelItem.ID = id;
            let transformData = this.getTransformData(node);
            let transformMatrix = generateTransform(transformData);
            modelItem.applyMatrix(transformMatrix);                   //自身矩阵
            modelMap.set( id, modelItem );
        }
        return modelMap;
    }

    /**
     *  创建网格mesh
     *  matrix为mesh本身的单位矩阵
     * */
    createMesh ( relationships, geometryMap, materialMap ) {
        var materials = []
        let mesh = new ObjectMesh();
        // get geometry and materials(s) from connections
        relationships.children.forEach( function ( child ) {
            if ( geometryMap.has( child.ID ) ) {
                mesh.geometry = geometryMap.get( child.ID );
            }
            if ( materialMap.has( child.ID ) ) {
                materials.push( materialMap.get( child.ID ) );
            }
        } );

        if ( materials.length > 1 ) {
            mesh.material = materials;
        } else if ( materials.length > 0 ) {
            mesh.material = materials[ 0 ];
        } else {                    //不作处理，material为null
            console.info("there is no material defined! use default");
            mesh.material = {light:new hmap.style.Light(),opacity:1,materialType:"phong"};
        }

        if ( mesh.geometry && mesh.geometry.get('color')) {               //map中有颜色的键
            materials.forEach( function ( material ) {
                mesh.material.vertexColors = "VertexColors";     //THREE.VertexColors;
            } );
        }
        return mesh;
    }

    /**
     *  创建曲线
     * */
    createCurve ( relationships, geometryMap ) {
        var geometry = relationships.children.reduce( function ( geo, child ) {
            if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );
            return geo;
        }, null );
        // FBX does not list materials for Nurbs lines, so we'll just put our own in here.
        var material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );
        return new THREE.Line( geometry, material );
    }

    /**
     *  根据各项转换值，获取模型的转换矩阵
     * */
    getTransformData ( modelNode ) {
        var transformData = {};
        if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = parseInt( modelNode.RotationOrder.value );
        if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;
        if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;
        if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;
        if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;
        if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;
        if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;
        return transformData;
    }


    parsePoseNodes () {
        var bindMatrices = {};
        if ( 'Pose' in this.fbxTree.Objects ) {
            var BindPoseNode = this.fbxTree.Objects.Pose;
            for ( var nodeID in BindPoseNode ) {
                if ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {
                    var poseNodes = BindPoseNode[ nodeID ].PoseNode;
                    if ( Array.isArray( poseNodes ) ) {
                        poseNodes.forEach( function ( poseNode ) {
                            bindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );
                        } );
                    } else {
                        bindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );
                    }
                }
            }
        }
        return bindMatrices;
    }
}

/**
 *  几何解析器
 *  @param {Object} fbxTree
 *  @param {Object} connections
 *  @private
 * */
let GeometryParser = class {

    constructor(fbxTree,connections){
        this.fbxTree = fbxTree;
        this.connections = connections;
    }

    /**
     *  解析FBXTree.Objects.Geometry中所有的节点
     * */
    parse () {
        var geometryMap = new Map();
        if ( 'Geometry' in this.fbxTree.Objects ) {
            var geoNodes = this.fbxTree.Objects.Geometry;                //运动的关键节点
            for ( var nodeID in geoNodes ) {                                        //遍历每个节点
                var relationships = this.connections.get( parseInt( nodeID ) );          //关键节点的关联关系 节点对应的父级和子级
                var geo = this.parseGeometry( relationships, geoNodes[ nodeID ]);
                if(geo) geometryMap.set( parseInt( nodeID ), geo );         //重新生成nodeId对应的几何
            }
        }
        return geometryMap;
    }

    /**
     *  解析FBXTree.Objects.Geometry中单个节点
     * */
    parseGeometry ( relationships, geoNode) {
        switch ( geoNode.attrType ) {
            case 'Mesh':            //网格
                return this.parseMeshGeometry( relationships, geoNode, this.fbxTree);
                break;
            case 'NurbsCurve':      //Nurbs曲线,暂时不管
                //throw new Error( 'NurbsCurve curve is not supported yet.' );
                //return this.parseNurbsGeometry( geoNode );
                break;
        }
    }

    /**
     *  解析FBXTree.Objects.Geometry中单个节点
     * */
    parseMeshGeometry ( relationships, geoNode ) {
        let fbxTreeData = this.fbxTree;
        var modelNodes = relationships.parents.map( function ( parent ) {   //返回节点的FBX树的数据
            return fbxTreeData.Objects.Model[ parent.ID ];
        } );
        // don't create geometry if it is not associated with any models
        if ( modelNodes.length === 0 ) return;

        // Assume one model and get the preRotation from that
        // if there is more than one model associated with the geometry this may cause problems
        var modelNode = modelNodes[ 0 ];

        var transformData = {};

        if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );          //欧拉顺序
        if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );                  //节点继承类型

        if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;        //转译
        if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;             //角度rotation
        if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;                  //级别

        var transform = generateTransform( transformData );
        return this.genGeometry( geoNode,transform);           //获取几何
    }

    /**
     *  为FBXTree.Objects.Geometry单个节点生成几何
     */
    genGeometry ( geoNode, preTransform ) {
        const geoData = new Map();                                 //几何数据
        geoData.group = new Array();
        if ( geoNode.attrName ) geoData.name = geoNode.attrName;
        var geoInfo = this.parseGeoNode( geoNode );
        var buffers = this.genBuffers( geoInfo );

        let vertex = this.dataApplyMatrix4(buffers.vertex, preTransform);
        geoData.set("position",{item:new Float32Array(vertex),itemSize:3});         //位置和法向量需要使用矩阵转换

        if ( buffers.colors.length > 0 ) {
            geoData.set("color",{item:new Float32Array(buffers.colors),itemSize:3});
        }

        if ( buffers.normal.length > 0 ) {
            var normalMatrix = new hmap.util.Matrix3().getNormalMatrix( preTransform );         //法向量 归一化矩阵
            let normal = this.dataApplyMatrix3(buffers.normal,normalMatrix);
            geoData.set("normal",{item:new Float32Array(normal),itemSize:3});
        }

        buffers.uvs.forEach( function ( uvBuffer, i ) {
            var name = 'uv' + ( i + 1 ).toString();
            if ( i === 0 ) {
                name = 'uv';
            }
            geoData.set(name,{item:new Float32Array(buffers.uvs[ i ]),itemSize:2});
        } );

        //材质相关,AllSame表示颜色是一致的
        if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {
            // Convert the material indices of each vertex into rendering groups on the geometry.
            var prevMaterialIndex = buffers.materialIndex[ 0 ];
            var startIndex = 0;
            buffers.materialIndex.forEach( function ( currentIndex, i ) {
                if ( currentIndex !== prevMaterialIndex ) {
                    geoData.group.push({start:startIndex,count:i - startIndex,materialIndex:prevMaterialIndex});
                    prevMaterialIndex = currentIndex;
                    startIndex = i;
                }
            } );
            // the loop above doesn't add the last group, do that here.
            if ( geoData.group.length > 0 ) {
                var lastGroup = geoData.group[ geoData.group.length - 1 ];
                var lastIndex = lastGroup.start + lastGroup.count;
                if ( lastIndex !== buffers.materialIndex.length ) {
                    geoData.group.push({start:lastIndex,count:buffers.materialIndex.length - lastIndex, materialIndex:prevMaterialIndex});
                }
            }
            // case where there are multiple materials but the whole geometry is only
            // using one of them
            if ( geoData.group.length === 0 ) {
                geoData.group.push( {start:0, count:buffers.materialIndex.length, materialIndex:buffers.materialIndex[0]});
            }
        }
        return geoData;
    }

    /**
     *  将解析出来的坐标数据和法向量使用3阶矩阵进行转换
     * */
    dataApplyMatrix3(data,matrix){
        let v1 = new hmap.util.Vector3();
        if(data instanceof Array){      //
            let dataLength = data/3;
            for(let i=0;i<dataLength;i++){
                v1.set(data[3*i], data[3*i+1], data[3*i+2]);
                v1.applyMatrix3(matrix);
                let vElements = v1.getElements();
                data[3*i] = vElements[0],data[3*i+1] = vElements[1],data[3*i+2] = vElements[2];
            }
        }
        return data;
    }

    /**
     *  将解析出来的坐标数据和法向量使用4阶矩阵进行转换
     * */
    dataApplyMatrix4(data,matrix){
        let v1 = new hmap.util.Vector3();
        if(data instanceof Array){      //
            let dataLength = data/3;
            for(let i=0;i<dataLength;i++){
                v1.set(data[3*i], data[3*i+1], data[3*i+2]);
                v1.applyMatrix4(matrix);
                let vElements = v1.getElements();
                data[3*i] = vElements[0],data[3*i+1] = vElements[1],data[3*i+2] = vElements[2];
            }
        }
        return data;
    }

    /**
     *  解析几何节点
     * */
    parseGeoNode ( geoNode) {
        var geoInfo = {};
        geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];
        if ( geoNode.LayerElementColor ) {
            geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );
        }
        if ( geoNode.LayerElementMaterial ) {
            geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );
        }
        if ( geoNode.LayerElementNormal ) {
            geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );
        }
        if ( geoNode.LayerElementUV ) {
            geoInfo.uv = [];
            var i = 0;
            while ( geoNode.LayerElementUV[ i ] ) {
                geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );
                i ++;
            }
        }
        geoInfo.weightTable = {};
        return geoInfo;
    }

    /**
     *  几何信息生成缓冲
     * */
    genBuffers ( geoInfo ) {
        var buffers = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: [],
        };

        var polygonIndex = 0;
        var faceLength = 0;
        var displayedWeightsWarning = false;

        // these will hold data for a single face
        var facePositionIndexes = [];
        var faceNormals = [];
        var faceColors = [];
        var faceUVs = [];
        var faceWeights = [];
        var faceWeightIndices = [];

        var self = this;
        geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {
            var endOfFace = false;
            // Face index and vertex index arrays are combined in a single array
            // A cube with quad faces looks like this:
            // PolygonVertexIndex: *24 {
            //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
            //  }
            // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
            // to find index of last vertex bit shift the index: ^ - 1
            if ( vertexIndex < 0 ) {
                vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1
                endOfFace = true;
            }

            var weightIndices = [];
            var weights = [];

            facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

            if ( geoInfo.color ) {
                var data = getDataFromFBX( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );
                faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );
            }

            if ( geoInfo.normal ) {
                var data = getDataFromFBX( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );
                faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );
            }

            if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {
                var materialIndex = getDataFromFBX( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];
            }
            if ( geoInfo.uv ) {
                geoInfo.uv.forEach( function ( uv, i ) {
                    var data = getDataFromFBX( polygonVertexIndex, polygonIndex, vertexIndex, uv );
                    if ( faceUVs[ i ] === undefined ) {
                        faceUVs[ i ] = [];
                    }
                    faceUVs[ i ].push( data[ 0 ] );
                    faceUVs[ i ].push( data[ 1 ] );
                } );
            }
            faceLength ++;
            if ( endOfFace ) {
                self.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

                polygonIndex ++;
                faceLength = 0;
                // reset arrays for the next face
                facePositionIndexes = [];
                faceNormals = [];
                faceColors = [];
                faceUVs = [];
                faceWeights = [];
                faceWeightIndices = [];
            }
        } );
        return buffers;
    }

    /**
     *  Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
     */
    genFace ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

        for ( var i = 2; i < faceLength; i ++ ) {

            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );

            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );

            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );
            buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );

            if ( geoInfo.skeleton ) {

                buffers.vertexWeights.push( faceWeights[ 0 ] );
                buffers.vertexWeights.push( faceWeights[ 1 ] );
                buffers.vertexWeights.push( faceWeights[ 2 ] );
                buffers.vertexWeights.push( faceWeights[ 3 ] );

                buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );
                buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );
                buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );
                buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );

                buffers.vertexWeights.push( faceWeights[ i * 4 ] );
                buffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );
                buffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );
                buffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );

                buffers.weightsIndices.push( faceWeightIndices[ 0 ] );
                buffers.weightsIndices.push( faceWeightIndices[ 1 ] );
                buffers.weightsIndices.push( faceWeightIndices[ 2 ] );
                buffers.weightsIndices.push( faceWeightIndices[ 3 ] );

                buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );
                buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );
                buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );
                buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );

                buffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );
                buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );
                buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );
                buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );

            }

            if ( geoInfo.color ) {

                buffers.colors.push( faceColors[ 0 ] );
                buffers.colors.push( faceColors[ 1 ] );
                buffers.colors.push( faceColors[ 2 ] );

                buffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );
                buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );
                buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );

                buffers.colors.push( faceColors[ i * 3 ] );
                buffers.colors.push( faceColors[ i * 3 + 1 ] );
                buffers.colors.push( faceColors[ i * 3 + 2 ] );

            }

            if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

                buffers.materialIndex.push( materialIndex );
                buffers.materialIndex.push( materialIndex );
                buffers.materialIndex.push( materialIndex );

            }

            if ( geoInfo.normal ) {

                buffers.normal.push( faceNormals[ 0 ] );
                buffers.normal.push( faceNormals[ 1 ] );
                buffers.normal.push( faceNormals[ 2 ] );

                buffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );
                buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );
                buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );

                buffers.normal.push( faceNormals[ i * 3 ] );
                buffers.normal.push( faceNormals[ i * 3 + 1 ] );
                buffers.normal.push( faceNormals[ i * 3 + 2 ] );

            }

            if ( geoInfo.uv ) {

                geoInfo.uv.forEach( function ( uv, j ) {
                    if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];
                    buffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );
                    buffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );

                    buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );
                    buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );

                    buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );
                    buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );

                } );

            }
        }
    }

    /**
     * a morph geometry node is similar to a standard  node, and the node is also contained
     * in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
     * and a special attribute Index defining which vertices of the original geometry are affected
     * Normal and position attributes only have data for the vertices that are affected by the morph
     * */
    genMorphGeometry ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

        var morphGeo = new THREE.BufferGeometry();
        if ( morphGeoNode.attrName ) morphGeo.name = morphGeoNode.attrName;

        var vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];

        // make a copy of the parent's vertex positions
        var vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];

        var morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];
        var indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];

        for ( var i = 0; i < indices.length; i ++ ) {

            var morphIndex = indices[ i ] * 3;

            // FBX format uses blend shapes rather than morph targets. This can be converted
            // by additively combining the blend shape positions with the original geometry's positions
            vertexPositions[ morphIndex ] += morphPositions[ i * 3 ];
            vertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];
            vertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];

        }

        // TODO: add morph normal support
        var morphGeoInfo = {
            vertexIndices: vertexIndices,
            vertexPositions: vertexPositions,
        };

        var morphBuffers = this.genBuffers( morphGeoInfo );

        var positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );
        positionAttribute.name = name || morphGeoNode.attrName;

        preTransform.applyToBufferAttribute( positionAttribute );

        parentGeo.morphAttributes.position.push( positionAttribute );
    }

    /**
     *  从FBXTree.Objects.Geometry.LayerElementNormal节点中解析法向量数据（如果存在）
     */
    parseNormals ( NormalNode ) {
        var mappingType = NormalNode.MappingInformationType;
        var referenceType = NormalNode.ReferenceInformationType;
        var buffer = NormalNode.Normals.a;
        var indexBuffer = [];
        if ( referenceType === 'IndexToDirect' ) {
            if ( 'NormalIndex' in NormalNode ) {
                indexBuffer = NormalNode.NormalIndex.a;
            } else if ( 'NormalsIndex' in NormalNode ) {
                indexBuffer = NormalNode.NormalsIndex.a;
            }
        }
        return {
            dataSize: 3,
            buffer: buffer,
            indices: indexBuffer,
            mappingType: mappingType,
            referenceType: referenceType
        };
    }

    /**
     *  从FBXTree.Objects.Geometry.LayerElementUV节点中解析纹理坐标（如果存在）
     */
    parseUVs ( UVNode ) {
        var mappingType = UVNode.MappingInformationType;
        var referenceType = UVNode.ReferenceInformationType;
        var buffer = UVNode.UV.a;
        var indexBuffer = [];
        if ( referenceType === 'IndexToDirect' ) {
            indexBuffer = UVNode.UVIndex.a;
        }
        return {
            dataSize: 2,
            buffer: buffer,
            indices: indexBuffer,
            mappingType: mappingType,
            referenceType: referenceType
        };
    }

    /**
     *  从FBXTree.Objects.Geometry.LayerElementColor节点中解析顶点颜色（如果存在）
     */
    parseVertexColors ( ColorNode ) {
        var mappingType = ColorNode.MappingInformationType;
        var referenceType = ColorNode.ReferenceInformationType;
        var buffer = ColorNode.Colors.a;
        var indexBuffer = [];
        if ( referenceType === 'IndexToDirect' ) {
            indexBuffer = ColorNode.ColorIndex.a;
        }
        return {
            dataSize: 4,
            buffer: buffer,
            indices: indexBuffer,
            mappingType: mappingType,
            referenceType: referenceType
        };
    }

    /**
     *  从FBXTree.Objects.Geometry.LayerElementMaterial节点中解析映射和材质数据（如果存在）
     */
    parseMaterialIndices ( MaterialNode ) {
        var mappingType = MaterialNode.MappingInformationType;
        var referenceType = MaterialNode.ReferenceInformationType;
        if ( mappingType === 'NoMappingInformation' ) {
            return {
                dataSize: 1,
                buffer: [ 0 ],
                indices: [ 0 ],
                mappingType: 'AllSame',
                referenceType: referenceType
            };
        }
        var materialIndexBuffer = MaterialNode.Materials.a;
        // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
        // we expect.So we create an intermediate buffer that points to the index in the buffer,
        // for conforming with the other functions we've written for other data.
        var materialIndices = [];
        for ( var i = 0; i < materialIndexBuffer.length; ++ i ) {
            materialIndices.push( i );
        }
        return {
            dataSize: 1,
            buffer: materialIndexBuffer,
            indices: materialIndices,
            mappingType: mappingType,
            referenceType: referenceType
        };
    }

    /**
     *  从FBXTree.Objects.Geometry节点中解析生成nurbs曲线几何
     */
    parseNurbsGeometry ( geoNode ) {
        if ( THREE.NURBSCurve === undefined ) {
            console.error( 'The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );
            return new THREE.BufferGeometry();
        }
        var order = parseInt( geoNode.Order );
        if ( isNaN( order ) ) {
            console.error( 'Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
            return new THREE.BufferGeometry();
        }

        var degree = order - 1;
        var knots = geoNode.KnotVector.a;
        var controlPoints = [];
        var pointsValues = geoNode.Points.a;

        for ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {
            controlPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );
        }

        var startKnot, endKnot;
        if ( geoNode.Form === 'Closed' ) {
            controlPoints.push( controlPoints[ 0 ] );
        } else if ( geoNode.Form === 'Periodic' ) {
            startKnot = degree;
            endKnot = knots.length - 1 - startKnot;
            for ( var i = 0; i < degree; ++ i ) {
                controlPoints.push( controlPoints[ i ] );
            }
        }
        var curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );           //NURBS曲线
        var vertices = curve.getPoints( controlPoints.length * 7 );
        var positions = new Float32Array( vertices.length * 3 );
        vertices.forEach( function ( vertex, i ) {
            vertex.toArray( positions, i * 3 );
        } );

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        return geometry;
    }
}

/**
 * 根据模型Mesh中的数据转换参数，计算mesh相对于模型中心的转换
 * @private
 */
function generateTransform(transformData){
    var tempMat = new hmap.util.Matrix4();
    var tempEuler = new hmap.util.Euler();
    var tempVec = new hmap.util.Vector3();
    var translation = new hmap.util.Vector3();
    var rotation = new hmap.util.Matrix4();

    var transform = new hmap.util.Matrix4();
    translation.set( 0, 0, 0 );
    rotation.setIdentity();

    var order = ( transformData.eulerOrder ) ? getEulerOrder( transformData.eulerOrder ) : getEulerOrder( 0 );

    if ( transformData.translation ) translation.fromArray( transformData.translation );
    if ( transformData.rotationOffset ) translation.add( tempVec.fromArray( transformData.rotationOffset ) );

    if ( transformData.rotation ) {

        var array = transformData.rotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( order );
        rotation.makeRotationFromEuler( tempEuler.fromArray( array ) );

    }

    if ( transformData.preRotation ) {

        var array = transformData.preRotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( order );
        tempMat.makeRotationFromEuler( tempEuler.fromArray( array ) );

        rotation.premultiply( tempMat );

    }

    if ( transformData.postRotation ) {

        var array = transformData.postRotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( order );
        tempMat.makeRotationFromEuler( tempEuler.fromArray( array ) );

        tempMat.setInverseOf( tempMat );

        rotation.multiply( tempMat );

    }

    if ( transformData.scale ) transform.scale(transformData.scale[0],transformData.scale[1],transformData.scale[2]);

    transform.setPosition( translation );
    transform.multiply( rotation );

    return transform;
}

/**
 * 根据模型Mesh中的数据转换参数，计算mesh相对于模型中心的转换
 * @private
 */
function generateTransfor2( transformData ) {
    let tempVec = new hmap.util.Vector3();  //三维向量
    let tempEuler = new hmap.util.Euler();  //欧拉角对象

    let lTranslationM = new hmap.util.Matrix4();
    let lPreRotationM = new hmap.util.Matrix4();
    let lRotationM = new hmap.util.Matrix4();
    let lPostRotationM = new hmap.util.Matrix4();

    let lScalingM = new hmap.util.Matrix4();
    let lScalingPivotM = new hmap.util.Matrix4();
    let lScalingOffsetM = new hmap.util.Matrix4();
    let lRotationOffsetM = new hmap.util.Matrix4();
    let lRotationPivotM = new hmap.util.Matrix4();

    let lParentGX = new hmap.util.Matrix4();
    let lGlobalT = new hmap.util.Matrix4();
    let inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

    if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );
    if ( transformData.preRotation ) {                  //角度
        var array = transformData.preRotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( transformData.eulerOrder );
        lPreRotationM.makeRotationFromEuler( tempEuler.fromArray(array) );
    }

    if ( transformData.rotation ) {
        var array = transformData.rotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( transformData.eulerOrder );
        lRotationM.makeRotationFromEuler( tempEuler.fromArray(array) );           //矩阵适应欧拉角
    }

    if ( transformData.postRotation ) {
        var array = transformData.postRotation.map( function(degree){
            return Math.PI*degree/180
        } );
        array.push( transformData.eulerOrder );
        lPostRotationM.makeRotationFromEuler( tempEuler.fromArray(array) );
    }

    if ( transformData.scale ) lScalingM.scale(transformData.scale[0],transformData.scale[1],transformData.scale[2]);   //缩放矩阵

    // Pivots and offsets
    if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );
    if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );
    if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );
    if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );

    // parent transform
    if ( transformData.parentMatrixWorld ) lParentGX = transformData.parentMatrixWorld;

    // Global Rotation
    let lLRM = lPreRotationM.multiply( lRotationM ).multiply( lPostRotationM );
    let lParentGRM = new hmap.util.Matrix4();
    lParentGX.extractRotation( lParentGRM );

    // Global Shear*Scaling
    let lParentTM = new hmap.util.Matrix4();
    let lLSM,lParentGSM,lParentGRSM;

    lParentTM.copyPosition( lParentGX );
    lParentGRSM = lParentTM.setInverseOf( lParentTM ).multiply( lParentGX );
    lParentGSM = lParentGRM.setInverseOf( lParentGRM ).multiply( lParentGRSM );
    lLSM = lScalingM;

    var lGlobalRS;
    if ( inheritType === 0 ) {
        lGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );
    } else if ( inheritType === 1 ) {
        lGlobalRS = lParentGRM.multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );
    } else {
        var lParentLSM = new hmap.util.Matrix4().copy( lScalingM );
        var lParentGSM_noLocal = lParentGSM.multiply( lParentLSM.setInverseOf( lParentLSM ) );
        lGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );
    }

    // Calculate the local transform matrix
    var lTransform = lTranslationM.multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM.setInverseOf( lRotationPivotM ) ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM.setInverseOf( lScalingPivotM ) );
    var lLocalTWithAllPivotAndOffsetInfo = new hmap.util.Matrix4().copyPosition( lTransform );
    var lGlobalTranslation = lParentGX.multiply( lLocalTWithAllPivotAndOffsetInfo );
    lGlobalT.copyPosition( lGlobalTranslation );
    lTransform = lGlobalT.multiply( lGlobalRS );
    return lTransform;
}

/**
 * 根据索引类型从FBX数组中的正确位置提取数据
 * @private
 */
function getDataFromFBX( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {
    let dataArray = [],index;
    switch ( infoObject.mappingType ) {
        case 'ByPolygonVertex' :
            index = polygonVertexIndex;
            break;
        case 'ByPolygon' :
            index = polygonIndex;
            break;
        case 'ByVertice' :
            index = vertexIndex;
            break;
        case 'AllSame' :
            index = infoObject.indices[ 0 ];
            break;
        default :
            console.warn( 'FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );
    }
    if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];
    var from = index * infoObject.dataSize;
    var to = from + infoObject.dataSize;

    for ( var i = from, j = 0; i < to; i ++, j ++ ) {
        dataArray[ j ] = infoObject.buffer[ i ];
    }
    return dataArray;
}

/**
 * 获取fbx模型中的欧拉角顺序对应的XYZ顺序
 * @private
 */
function getEulerOrder( order ) {
    order = order || 0;
    var enums = [
        'ZYX', // -> XYZ extrinsic
        'YZX', // -> XZY extrinsic
        'XZY', // -> YZX extrinsic
        'ZXY', // -> YXZ extrinsic
        'YXZ', // -> ZXY extrinsic
        'XYZ', // -> ZYX extrinsic
        //'SphericXYZ', // not possible to support
    ];
    if ( order === 6 ) {
        console.warn('unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');
        return enums[ 0 ];
    }
    return enums[ order ];
}

/**
 * 遍历节点直属的全部子节点
 * @private
 */
function getTraverse( objectGroup,callback ) {
    callback( objectGroup );
    var children = objectGroup.children;
    for ( var i = 0, l = children.length; i < l; i ++ ) {
        getTraverse( children[ i ], callback );
    }
}

/**
 * 文件缓存类
 * @private
 */
var imageCache = {

    enabled: false,

    files: {},

    add: function ( key, file ) {

        if ( this.enabled === false ) return;

        this.files[ key ] = file;

    },

    get: function ( key ) {

        if ( this.enabled === false ) return;

        return this.files[ key ];

    },

    remove: function ( key ) {

        delete this.files[ key ];

    },

    clear: function () {

        this.files = {};

    }

};

/**
 *  加载管理器
 *  @private
 * */
let LoadingManager = class {

    constructor(onLoad, onProgress, onError){
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;

        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;

        this.itemStart = function ( url ) {

            itemsTotal ++;

            if ( isLoading === false ) {

                if ( scope.onStart !== undefined ) {

                    scope.onStart( url, itemsLoaded, itemsTotal );

                }

            }

            isLoading = true;

        };

        this.itemEnd = function ( url ) {

            itemsLoaded ++;

            if ( scope.onProgress !== undefined ) {

                scope.onProgress( url, itemsLoaded, itemsTotal );

            }

            if ( itemsLoaded === itemsTotal ) {

                isLoading = false;

                if ( scope.onLoad !== undefined ) {

                    scope.onLoad();

                }

            }

        };

        this.itemError = function ( url ) {

            if ( scope.onError !== undefined ) {

                scope.onError( url );

            }

        };

        this.resolveURL = function ( url ) {

            if ( urlModifier ) {

                return urlModifier( url );

            }

            return url;

        };

        this.setURLModifier = function ( transform ) {

            urlModifier = transform;
            return this;

        };
    }
}

/**
 *  图片加载器
 *  @private
 * */
let ImageLoader = class {

    constructor(manager){
        this.manager = ( manager !== undefined ) ? manager : new LoadingManager(),
            this.crossOrigin = 'Anonymous'
    }

    load ( url, onLoad, onProgress, onError ) {

        if ( url === undefined ) url = '';

        if ( this.path !== undefined ) url = this.path + url;

        url = this.manager.resolveURL( url );

        var scope = this;

        var cached = imageCache.get( url );

        if ( cached !== undefined ) {

            scope.manager.itemStart( url );

            setTimeout( function () {

                if ( onLoad ) onLoad( cached );

                scope.manager.itemEnd( url );

            }, 0 );

            return cached;
        }

        var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
        image.addEventListener( 'load', function () {
            imageCache.add( url, this );
            if ( onLoad ) onLoad( this );
            scope.manager.itemEnd( url );
        }, false );

        image.addEventListener( 'error', function ( event ) {
            if ( onError ) onError( event );
            scope.manager.itemEnd( url );
            scope.manager.itemError( url );
        }, false );

        if ( url.substr( 0, 5 ) !== 'data:' ) {
            if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart( url );
        image.src = url;
        return image;
    }

    setCrossOrigin ( value ) {
        this.crossOrigin = value;
        return this;
    }

    setPath ( value ) {
        this.path = value;
        return this;
    }
}

/**
 *  纹理加载器
 *  @private
 * */
let TextureLoader = class {
    constructor(manager){
        this.manager = ( manager !== undefined ) ? manager : new LoadingManager();
        this.crossOrigin = 'Anonymous';
    }

    load ( url, onLoad, onProgress, onError ) {
        const me = this;
        let texture = new Texture(), loader = new ImageLoader( me.manager );
        loader.setCrossOrigin( me.crossOrigin );
        loader.setPath( me.path );
        texture.loadPromise = new Promise(function(resolve,reject){
            loader.load( url, function ( image ) {
                texture.image = image;
                // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
                texture.format = isJPEG ? "RGB" : "RGBA";//"RGBFormat" : "RGBAFormat";
                texture.needsUpdate = true;
                if ( onLoad !== undefined ) {
                    onLoad( texture );
                }
                resolve();
            }, onProgress, onError );
        })
        return texture;
    }

    setCrossOrigin ( value ) {
        this.crossOrigin = value;
        return this;
    }

    setPath ( value ) {
        this.path = value;
        return this;
    }
}


var textureId = 0;
/**
 *  以图片以及一些纹理参数 创建纹理
 *  @private
 * */
let Texture = class {
    constructor( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ){
        this.id = textureId ++;
        this.name = '';

        this.image = image !== undefined ? image : undefined;
        this.mipmaps = [];

        this.mapping = mapping !== undefined ? mapping : "UVMapping";

        //"CLAMP_TO_EDGE":使用纹理图像边缘值。"MIRRORED_REPEAT":镜像对称式重复。"REPEAT":平铺式。
        this.wrapS = wrapS !== undefined ? wrapS : "CLAMP_TO_EDGE";     //"ClampToEdgeWrapping";       //纹理水平方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸
        this.wrapT = wrapT !== undefined ? wrapT : "CLAMP_TO_EDGE";     //"ClampToEdgeWrapping";       //纹理垂直方向排列方式 RepeatWrapping:纹理平铺 ClampToEdgeWrapping:纹理拉伸

        // 暂不支持金字塔纹理
        //"NEAREST":使用最近的那个像素的颜色值作为新像素颜色值。"LINEAR":使用最近的四个像素颜色值的加权平均，会有较大开销。
        this.magFilter = magFilter !== undefined ? magFilter : "LINEAR";//"LinearFilter";
        this.minFilter = minFilter !== undefined ? minFilter : "LINEAR";//"LinearMipMapLinearFilter";

        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

        // "RGB":红绿蓝；"RGBA":红、绿、蓝、透明度；"ALPHA":（0，0,0，透明度）；"LUMINANCE":L,L,L(1L:流明)；"LUMINANCE_ALPHA":L、L、L，透明度。
        this.format = format !== undefined ? format : "RGBA";//"RGBAFormat";//图像内部格式\纹素数据格式
        // "UNSIGNED_BYTE"(1字节)、"UNSIGNED_SHORT_5_6_5"(比特)、"UNSIGNED_SHORT_4_4_4_4"(比特)、"UNSIGNED_SHORT_5_5_5_1"(比特)
        this.type = type !== undefined ? type : "UNSIGNED_BYTE";//"UnsignedByteType";//纹理数据格式

        this.offset = new Vector2( 0, 0 );             //纹理重复
        this.repeat = new Vector2( 1, 1 );             //纹理偏移
        this.center = new Vector2( 0, 0 );             //纹理中心
        this.rotation = 0;

        this.matrixAutoUpdate = true;
        this.matrix = new hmap.util.Matrix3();          //设置为单位矩阵

        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding !== undefined ? encoding : "LinearEncoding";

        this.version = 0;
        this.onUpdate = null;
    }
}

/**
 * 二维向量
 * @private
 */
function Vector2( x, y ) {
    this.x = x || 0;
    this.y = y || 0;
}

/**
 *  创建mesh
 *  @private
 * */
let ObjectMesh = class{
    constructor(){
        this.name = null;
        this.ID = null;
        this.type = "Mesh";
        this.geometry = null;
        this.material = null;
        this.children = [];       //保存子级mesh
        this.parent = null;         //保存父级mesh
        this.matrix = new hmap.util.Matrix4();          //矩阵
        this.matrixWorld = new hmap.util.Matrix4();     //世界矩阵
        this.position = new hmap.util.Vector3();        //mesh的坐标，默认Vector3(0,0,0)
        this.quaternion = new hmap.util.Quaternion();   //旋转的四元数
        this.scale = new hmap.util.Vector3(1,1,1);       //放缩比例，默认Vector3(1,1,1)
        this.userData = {};
    }

    /**
     *  更新mesh矩阵,包括其子元素的的矩阵
     * */
    updateMatrix() {
        this.matrix.compose( this.position, this.quaternion, this.scale);      //根据position、quaternion、scale 重新组装matrix
        let matrix = this.matrix,matrixWorld = this.matrixWorld;      //父级
        let children = this.children;
        for ( let i = 0, length = children.length; i < length; i ++ ) {
            let item = children[i];
            item.matrixWorld.setIdentity();                                 //设置成单位矩阵
            item.matrixWorld.multiply(matrixWorld).multiply(matrix);        //相对于世界坐标的变换
            item.updateMatrix();
        }
    }

    /**
     *  将参数矩阵应用到当前mesh
     * */
    applyMatrix( matrix4 ) {
        if(matrix4){
            this.matrix.multiply(matrix4);
        }
        this.matrix.decompose( this.position, this.quaternion, this.scale );        //从矩阵中拆解位置、旋转角、放缩比例信息
    }
}
;hmap.format = hmap.format || {};
hmap.format.s3m = hmap.format.s3m || {};
hmap.format.s3m.S3MTile = class {
    /**
     * 构造函数
     * @param {URL} tileUrl 切片URL
     * @param {hmap.util.Matrix4} modelMatrix 统一的模型矩阵
     * @param {String} tileName tile名称包含路径，唯一标识
     * @param {Number} rangeRatio 渲染参数，默认为1
     */
    constructor(tileUrl, modelMatrix, tileName, rangeRatio){
        this.tileUrl = tileUrl;
        this.modelMatrix = modelMatrix;
        this._tileName = tileName;
        this.visible = false;
        this.parent = undefined;
        this.children = [];                     //保存所有的子切片
        this.extents = [];
        this.priority = 0;
        this.rangeList = undefined;             //类似分辨率
        this.boundingSphere = undefined;        //包围球，表示范围
        this.isLeafTile = false;
        this.rangeRatio = rangeRatio ? rangeRatio : 1;
        this.depth = 0;                         //默认为0，根据父节点的深度计算
        this.visible = false;
        this.hasRequest = false;                //请求的标记
        this.hasContent = false;                //切片包含内容
        this.hasContentInit = false;                //切片包含内容
        this.CLASS_NAME = "hmap.format.s3m.S3MTile";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);     //自动生成
        this._initContent();
    }

    /**
     * 初始化切片内容
     * @private
     */
    _initContent(){
        if(!this._tileName){
            this._tileName = this.tileUrl.href.lastIndexOf('/') === -1 ? './': this.tileUrl.href.substr(this.tileUrl.href.lastIndexOf('/')+1, this.tileUrl.href.length)
        }
        this.tileContentState={         //切片状态，暂时留着
            UNLOADED:"unloaded",
            READY:"ready",
            LOADING:"loading",
            PROCESSING:"processing",        //处理进程
            FAILED:"failed"
        }
        this.modelParser = new hmap.format.s3m.S3ModelParser();
        this.contentParser = new hmap.format.s3m.S3MContentParser();

        const me = this;
        this.contentReadyPromise = new Promise(function(resolve,reject){
            me.contentReadyResolve = resolve;
            me.contentReject = reject;          //中断
        })
    }

    /**
     * 拆解切片的内容
     */
    unloadContent(){
        const me = this;
        me.contentReadyPromise = new Promise(function(resolve,reject){
            me.contentReadyResolve = resolve;
            me.contentReject = reject;          //中断
        })
        me.hasContent = false;
        me.hasRequest = false;
    }

    /**
     *  检查当前包围球是否在一个范围内
     *  @param {hmap.basetype.Extent}
     */
    fitMapExtent(extent){
        if(this.extents.length != 0){
            for(let boundingSphere of this.extents){
                let center = boundingSphere.center, radius = boundingSphere.radius;
                let extentIn = (center[0] > extent._left-radius  && center[0] < extent._right+radius && center[1] > extent._bottom-radius && center[1]<extent._left + radius);
                if(extentIn){
                    return extentIn;
                }
            }
            return false;
        }
        else{
            return false;
        }
    }

    /**
     *  当前误差小于误差范围，需要继续细化
     *  @returns {boolean}
     */
    canTraverse(){
        if (this.children.length === 0 || this.isLeafTile) {
            return false;
        }
        if(this.rangeList == null || this.rangeList == undefined) {
            return true;
        }
        return this.screenError * 3.5 * this.rangeRatio > this.rangeList;       //系数增加
    }

    /**
     * 更新屏幕像素误差
     * @private
     */
    updateScreenError(screenPixelD,camera){
        let cPosition=[camera.getCoordinate()._x,camera.getCoordinate()._y,camera.getCoordinate()._z];
        if(this.boundingSphere){
            let center = this.boundingSphere.center,
                radius = this.boundingSphere.radius;
            let distance = Math.sqrt((cPosition[0]-center[0])*(cPosition[0]-center[0]) + (cPosition[1]-center[1])*(cPosition[1]-center[1]) + (cPosition[2]-center[2])*(cPosition[2]-center[2]));
            this.screenError = screenPixelD * radius / distance;
        }else{
            return false;
        }
    }

    /**
     * 请求切片内容
     * @returns {boolean}
     */
    requestContent() {
        let me = this;
        let requestPromise = this.fetchArrayBuffer();
        me.hasRequest = true;
        requestPromise.then(function(arrayBuffer) {
            let content = me.modelParser.parseBuffer(arrayBuffer);
            let pagelods = me.contentParser.parse(me.modelMatrix, content);
            for(let pagelod of pagelods){                   //这里有问题，后期再改
                me.rangeList = pagelod.rangeList;
                me.isLeafTile = pagelod.isLeafTile;
                let datas = pagelod.datas;
                for(let data of datas){
                    me.boundingSphere = data.boundingSphere;        //包围球，表示范围
                    me.extents.push(data.boundingSphere);
                }
            }
            me.createChildren(pagelods);
            me.hasContent = true;
            me.contentReadyResolve(pagelods);
        },function(error){
            throw(error + "arrayBuffer request failed!");
        })
    }

    /**
     * 从已有的数据中构建切片内容,同时标识出切片的状态
     * @private
     */
    getContentFromData(pagelods){
        for(let pagelod of pagelods){
            this.rangeList = pagelod.rangeList;
            this.isLeafTile = pagelod.isLeafTile;
            let data = pagelod.datas[0];
            this.boundingSphere = data.boundingSphere;        //包围球，表示范围
            this.extents.push(data.boundingSphere);
        }
        this.createChildren(pagelods);
        this.hasRequest = true;
        this.hasContent = true;
    }

    /**
     * 请求获得切片的二进制数组
     * @returns {Promise}
     */
    fetchArrayBuffer(){
        const me = this,tileUrl = me.tileUrl;
        let promise = new Promise(function(resolve,reject){
            fetch(tileUrl,{
                method: 'get',
                responseType: 'arraybuffer'         //获取arrayBuffer
            }).then(function(response){
                if(response.ok){
                    return response.arrayBuffer();      //二进制
                }else{
                    reject("tile content error:" + me.tileUrl);
                }
            }).then(function(arraybuffer){
                if(arraybuffer){
                    resolve(arraybuffer);
                }
            }).catch(function(e) {
                reject("failed to load:" + me.tileUrl);
            })
        })
        return promise;
    }

    /**
     * 创建子切片
     * @param datas
     */
    createChildren(datas) {
        let modelMatrix = this.modelMatrix;
        let length = datas.length;
        for(let i = 0;i < length;i++){
            let data = datas[i];
            let fileName = data.rangeDataList;
            if(fileName && fileName != "" && fileName != this._tileName){
                let tileUrl=new URL(fileName,this.tileUrl);
                let tile = new hmap.format.s3m.S3MTile(tileUrl, modelMatrix, fileName, this.rangeRatio);
                tile.depth = this.depth + 1;
                tile.parent = this;
                this.children.push(tile);
            }
        }
        this.hasContentInit = true;
    }
}
;hmap.format = hmap.format || {};
hmap.format.s3m = hmap.format.s3m || {};
/**
 * s3m内容解析器
 * @type {S3MContentParser}
 * @private
 */
hmap.format.s3m.S3MContentParser = class {
    /**
     * 构造函数
     */
    constructor(){

    }

    defined(value){
        return (value != null&& value != undefined);
    }

    parseMaterial(content) {
        let materialTable = {};
        let materials = content.materials.material;
        for(let i = 0,j = materials.length;i < j;i++){
            let material = materials[i].material;
            let materialCode = material.id;
            // let materialPass = new Object();
            let materialPass=hmap.format.s3m.S3MContentParser.getDefaultMaterial();
            // materialPass.textures=[];
            materialTable[materialCode] = materialPass;
            let ambient = material.ambient;
            materialPass.ambientColor = [ambient.r, ambient.g, ambient.b, ambient.a];
            let diffuse = material.diffuse;
            materialPass.diffuseColor = [diffuse.r, diffuse.g, diffuse.b, diffuse.a];
            let specular = material.specular;
            materialPass.specularColor = [specular.r, specular.g, specular.b, specular.a];
            materialPass.shininess = material.shininess;
            materialPass.bTransparentSorting = material.transparentsorting;
            let textureStates = material.textureunitstates;
            let len = textureStates.length;
            // for(let k = 0;k < len;k++){
            //     let textureState = textureStates[k].textureunitstate;
            //     let textureCode = textureState.id;
            //     let wrapS = textureState.addressmode.u === 0 ? "REPEAT" : "CLAMP_TO_EDGE";
            //     let wrapT = textureState.addressmode.v === 0 ? "REPEAT" : "CLAMP_TO_EDGE";
            //     materialPass.texMatrix = textureState.texmodmatrix;         //Cesium.Matrix4.unpack(textureState.texmodmatrix);
            //     let textureInfo = content.texturePackage[textureCode];
            //     if(textureInfo && textureInfo.imageBuffer.byteLength > 0){
            //         textureInfo.wrapS = wrapS;
            //         textureInfo.wrapT = wrapT;
            //         let texture = {textureCode:textureCode, textureInfo:textureInfo};        //new DDSTexture(context, textureCode, textureInfo);        //根据纹理信息创建纹理
            //         materialPass.textures.push(texture);
            //     }
            // }
            for(let k=0;k<len;k++){
                const textureState=textureStates[k].textureunitstate;//texture的状态
                const textureCode=textureState.id;
                const wrapS = textureState.addressmode.u === 0 ? "REPEAT" : "CLAMP_TO_EDGE";
                const wrapT = textureState.addressmode.v === 0 ? "REPEAT" : "CLAMP_TO_EDGE";
                materialPass.texMatrix=textureState.texmodmatrix;
                let textureInfo = content.texturePackage[textureCode];
                if(textureInfo && textureInfo.imageBuffer.byteLength > 0){
                    textureInfo.wrapS = wrapS;
                    textureInfo.wrapT = wrapT;
                    let texture = {textureCode:textureCode, textureInfo:textureInfo};        //new DDSTexture(context, textureCode, textureInfo);        //根据纹理信息创建纹理
                    //let texture=new hmap.format.s3m.DDSTexture(textureCode,textureInfo);
                    materialPass.textures.push(texture);
                }
            }
        }
        return materialTable;
    }

    // calcBoundingVolume(vertexPackage, transform) {
    //     let boundingSphere = new Cesium.BoundingSphere();
    //     let v1 = new Cesium.Cartesian3();
    //     let positionAttr = vertexPackage.vertexAttributes[0];
    //     let dim = positionAttr.componentsPerAttribute;
    //     let isCompress = this.defined(vertexPackage.nCompressOptions) && (vertexPackage.nCompressOptions & VertexCompressOption.SVC_Vertex) === VertexCompressOption.SVC_Vertex;
    //     let normConstant = 1.0;
    //     let minVertex;
    //     let vertexTypedArray;
    //     if(isCompress){
    //         normConstant = vertexPackage.vertCompressConstant;
    //         minVertex = new Cesium.Cartesian3(vertexPackage.minVerticesValue.x, vertexPackage.minVerticesValue.y, vertexPackage.minVerticesValue.z);
    //         vertexTypedArray = new Uint16Array(positionAttr.typedArray.buffer, positionAttr.typedArray.byteOffset, positionAttr.typedArray.byteLength / 2);
    //     }
    //     else{
    //         vertexTypedArray = new Float32Array(positionAttr.typedArray.buffer, positionAttr.typedArray.byteOffset, positionAttr.typedArray.byteLength / 4);
    //     }
    //
    //     let vertexArray = [];
    //     for(let t = 0; t < vertexPackage.verticesCount; t++){
    //         Cesium.Cartesian3.fromArray(vertexTypedArray, dim * t, v1);
    //         if(isCompress){
    //             v1 = Cesium.Cartesian3.multiplyByScalar(v1, normConstant, v1);
    //             v1 = Cesium.Cartesian3.add(v1, minVertex, v1);
    //         }
    //         vertexArray.push(Cesium.Cartesian3.clone(v1));
    //     }
    //
    //     Cesium.BoundingSphere.fromPoints(vertexArray, boundingSphere);
    //     Cesium.BoundingSphere.transform(boundingSphere, transform, boundingSphere);
    //     vertexArray.length = 0;
    //     return boundingSphere;
    // }

    parseGeodes(modelMatrix, content, materialTable, pagelodNode, pagelod) {
        let datas = [];
        let geoMap = {}, geodeList = pagelodNode.geodes;
        for(let i = 0,j = geodeList.length;i < j;i++){
            let geodeNode = geodeList[i];

            let center = new hmap.util.Vector3(),radius;
            if(this.defined(pagelodNode.boundingSphere)) {
                let centerObj = pagelodNode.boundingSphere.center;
                center.set(centerObj.x, centerObj.y, centerObj.z);
                radius = pagelodNode.boundingSphere.radius;
            }
            let centerArray = modelMatrix.multiplyVector3(center).getElements();

            let skeletonNames = geodeNode.skeletonNames;
            for(let m = 0,n = skeletonNames.length;m < n; m++){
                let geoName = skeletonNames[m];
                let geoPackage = content.geoPackage[geoName];
                let vertexPackage = geoPackage.vertexPackage;

                let arrIndexPackage = geoPackage.arrIndexPackage;
                let pickInfo = geoPackage.pickInfo;
                let material;
                if(arrIndexPackage.length > 0) {
                    material = materialTable[arrIndexPackage[0].materialCode];
                }

                let minVerticesValue = vertexPackage.minVerticesValue;
                let vertCompressConstant = vertexPackage.vertCompressConstant;
                let geoMatrix = new hmap.util.Matrix4(new Float32Array(geodeNode.matrix));

                if(minVerticesValue){
                    geoMatrix.translate(minVerticesValue.x, minVerticesValue.y, minVerticesValue.z);         //父节点
                }
                if(vertCompressConstant){
                    geoMatrix.scale(vertCompressConstant,vertCompressConstant,vertCompressConstant);
                }

                let data = {
                    vertexPackage : vertexPackage,
                    arrIndexPackage : arrIndexPackage,
                    tileMatrix:geoMatrix.getElements(),
                    material : material,
                    boundingSphere : {
                        center: centerArray,
                        radius: radius
                    }
                };
                datas.push(data);
            }
        }
        pagelod.datas = datas;
    }

    parsePagelods(modelMatrix, content, materialTable) {
        let groupNode = content.groupNode;
        let pagelods = [];
        for(let i = 0, j = groupNode.pageLods.length;i < j; i++){
            let pagelod = {};
            let pagelodNode = groupNode.pageLods[i];
            pagelod.rangeMode = pagelodNode.rangeMode;
            pagelod.rangeDataList = pagelodNode.childTile;
            pagelod.rangeList = pagelodNode.rangeList;
            let center = pagelodNode.boundingSphere.center;
            let radius = pagelodNode.boundingSphere.radius;
            if(pagelod.rangeDataList !== ''){
                pagelod.boundingVolume = {
                    sphere : {
                        center : [center.x, center.y, center.z],
                        radius : radius
                    }
                };
            }
            else{
                pagelod.isLeafTile = true;      //最底下的节点
            }
            this.parseGeodes(modelMatrix, content, materialTable, pagelodNode, pagelod);
            pagelods.push(pagelod);
        }
        return pagelods;
    }

    parse(modelMatrix, content) {
        if(!content) {
            return ;
        }
        let materialTable = this.parseMaterial(content);
        let pagelods = this.parsePagelods(modelMatrix, content, materialTable);
        return pagelods;
    };

    static getDefaultMaterial(){
        return{
            ambientColor:[1,1,1,1],
            diffuseColor:[1,1,1,1],
            specularColor:[0,0,0,0],
            bTransparentSorting:false,
            textures:[]
        }
    }
};;hmap.format = hmap.format || {};
hmap.format.s3m = hmap.format.s3m || {};
/**
 * s3m解析器
 * @type {hmap.format.s3m.S3ModelParser}
 * @private
 */
hmap.format.s3m.S3ModelParser = class {
    /**
     *  构造函数
     */
    constructor(){
        this.initConsant();
    }

    /**
     * 初始化一些常量
     */
    initConsant(){
        //像素格式
        let S3MPixelFormat = {
            LUMINANCE_8 : 1,
            LUMINANCE_16 : 2,
            ALPHA : 3,
            ALPHA_4_LUMINANCE_4 : 4,
            LUMINANCE_ALPHA : 5,
            RGB_565 : 6,
            BGR565 : 7,
            RGB : 10,
            BGR : 11,
            ARGB : 12,
            ABGR : 13,
            BGRA : 14,
            WEBP : 25,
            RGBA : 28,
            DXT1 : 17,
            DXT2 : 18,
            DXT3 : 19,
            DXT4 : 20,
            DXT5 : 21
        };

        //解压格式
        let S3MCompressType = {
            encNONE : 0,
            enrS3TCDXTN : 14,
            enrPVRTPF_PVRTC2 : 19,
            enrPVRTPF_PVRTC : 20,
            enrPVRTPF_PVRTC_4bpp : 21,
            enrPVRTPF_ETC1 : 22
        };

        //组件数据类型
        this.ComponentDatatype = {
            BYTE : 5120,
            UNSIGNED_BYTE : 5121,
            SHORT : 5122,
            UNSIGNED_SHORT : 5123,
            INT : 5124,
            UNSIGNED_INT : 5125,
            FLOAT : 5126,
            DOUBLE : 5130
        };

        //顶点解压选项
        this.VertexCompressOptions = {
            SVC_Vertex : 1,
            SVC_Normal : 2,
            SVC_VertexColor : 4,
            SVC_SecondColor	: 8,
            SVC_TexutreCoord : 16,
            SVC_TexutreCoordIsW	: 32
        };

        //顶点数据格式
        this.S3MBVertexTag = {
            SV_Unkown : 0,
            SV_Standard : 1,        //标准格式
            SV_Compressed : 2       //压缩格式
        };
    }

    /**
     * 获取解压后的buffer
     * @param buffer
     * @param bytesOffset
     */
    unZip(buffer, bytesOffset) {
        let dataZip = new Uint8Array(buffer, bytesOffset);
        return new hmap.util.Inflate(dataZip).decompress().buffer;
    }

    defined(value){
        return (value != null && value != undefined);
    }

    /**
     * 解析文本
     * @param buffer
     * @param view
     * @param bytesOffset
     * @returns {{string: *|String, bytesOffset: number | *}}
     */
    parseString(buffer, view, bytesOffset) {
        let length = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let stringBufferView = new Uint8Array(buffer, bytesOffset, length);
        let string = this.getStringFromTypedArray(stringBufferView);
        bytesOffset += length;

        return {
            string : string,
            bytesOffset : bytesOffset
        }
    }

    /**
     * 解析LOD中的geodes
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param geodes
     * @returns {number | *}
     */
    parseGeode(buffer, view, bytesOffset, geodes) {
        let geode = {};
        let skeletonNames = [];
        let geoMatrix = new Array(16);
        for(let i = 0; i < 16; i++){
            geoMatrix[i] = view.getFloat64(bytesOffset, true);
            bytesOffset += Float64Array.BYTES_PER_ELEMENT;
        }

        geode.matrix = geoMatrix;
        geode.skeletonNames = skeletonNames;
        let skeletonCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < skeletonCount; i++){
            let res = this.parseString(buffer, view, bytesOffset);
            skeletonNames.push(res.string);
            bytesOffset = res.bytesOffset;
        }

        geodes.push(geode);

        return bytesOffset;
    }

    /**
     * 解析LOD
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param pageLods
     * @returns {number | *}
     */
    parsePageLOD(buffer, view, bytesOffset, pageLods) {
        let pageLOD = {};
        pageLOD.rangeList = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        pageLOD.rangeMode = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let center = {};
        center.x = view.getFloat64(bytesOffset, true);
        bytesOffset += Float64Array.BYTES_PER_ELEMENT;
        center.y = view.getFloat64(bytesOffset, true);
        bytesOffset += Float64Array.BYTES_PER_ELEMENT;
        center.z = view.getFloat64(bytesOffset, true);
        bytesOffset += Float64Array.BYTES_PER_ELEMENT;
        let radius = view.getFloat64(bytesOffset, true);
        bytesOffset += Float64Array.BYTES_PER_ELEMENT;
        pageLOD.boundingSphere = {
            center : center,
            radius : radius
        };

        let res = this.parseString(buffer, view, bytesOffset);
        let strChildTile = res.string;
        bytesOffset = res.bytesOffset;
        let index = strChildTile.indexOf('Geometry');
        if(index !== -1){
            let ignoreString = strChildTile.substring(index);
            strChildTile = strChildTile.replace(ignoreString, '');
        }

        pageLOD.childTile = strChildTile;
        pageLOD.geodes = [];
        let geodeCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < geodeCount; i++){
            bytesOffset = this.parseGeode(buffer, view, bytesOffset, pageLOD.geodes);
        }

        pageLods.push(pageLOD);

        return bytesOffset;
    }

    /**
     * 解析groupNode数据
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param result
     * @returns {number | *}
     */
    parseGroupNode(buffer, view, bytesOffset, result) {
        let groupNode = {};
        let geodes = [];
        let pageLods = [];
        let size = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let count = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < count; i++){
            bytesOffset = this.parsePageLOD(buffer, view, bytesOffset, pageLods);
        }
        groupNode.pageLods = pageLods;
        let align = bytesOffset % 4;
        if(align !== 0){
            bytesOffset += (4 - align);
        }

        result.groupNode = groupNode;

        return bytesOffset;
    }

    /**
     * 解析顶点数据
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseVertex(buffer, view, bytesOffset, vertexPackage) {
        let verticesCount = view.getUint32(bytesOffset, true);
        vertexPackage.verticesCount = verticesCount;
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if(bytesOffset <= 0){
            return bytesOffset;
        }

        let vertexDimension = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let vertexStride = view.getUint16(bytesOffset, true);
        vertexStride = vertexDimension * Float32Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let byteLength = verticesCount * vertexDimension * Float32Array.BYTES_PER_ELEMENT;
        let vertexBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        bytesOffset += byteLength;
        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aPosition'] = attributes.length;
        attributes.push({
            index: attrLocation['aPosition'],
            typedArray: vertexBuffer,
            componentsPerAttribute: vertexDimension,
            componentDatatype: this.ComponentDatatype.FLOAT,
            offsetInBytes: 0,
            strideInBytes: vertexStride,
            normalize: false
        });

        return bytesOffset;
    }

    /**
     * 解析法线数据
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseNormal(buffer, view, bytesOffset, vertexPackage) {
        let normalCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if(normalCount <= 0){
            return bytesOffset;
        }

        let normalDimension = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let normalStride = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let byteLength = normalCount * normalDimension * Float32Array.BYTES_PER_ELEMENT;
        let normalBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        bytesOffset += byteLength;
        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aNormal'] = attributes.length;
        attributes.push({
            index: attrLocation['aNormal'],
            typedArray: normalBuffer,
            componentsPerAttribute : normalDimension,
            componentDatatype : this.ComponentDatatype.FLOAT,
            offsetInBytes: 0,
            strideInBytes: normalStride,
            normalize: false
        });

        return bytesOffset;
    }

    /**
     * 解析顶点颜色
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseVertexColor(buffer, view, bytesOffset, vertexPackage) {
        let colorCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let verticesCount = vertexPackage.verticesCount;
        let vertexColor;
        if (colorCount > 0){
            let colorStride = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT * 2;
            let byteLength = colorCount * Uint8Array.BYTES_PER_ELEMENT * 4;
            let typedArray = new Uint8Array(buffer, bytesOffset, byteLength);
            vertexColor = typedArray.slice(0, byteLength);
            bytesOffset += byteLength;
        }
        else{
            vertexColor = new Uint8Array(4 * verticesCount);
            for (let m = 0; m < verticesCount; m++) {
                vertexColor[m * 4] = 255;
                vertexColor[m * 4 + 1] = 255;
                vertexColor[m * 4 + 2] = 255;
                vertexColor[m * 4 + 3] = 255;
            }
        }

        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aColor'] = attributes.length;
        attributes.push({
            index: attrLocation['aColor'],
            typedArray: vertexColor,
            componentsPerAttribute: 4,
            componentDatatype: this.ComponentDatatype.UNSIGNED_BYTE,
            offsetInBytes: 0,
            strideInBytes: 4,
            normalize: true
        });

        vertexPackage.vertexColor = vertexColor;

        return bytesOffset;
    }

    /**
     * 解析第二颜色
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseSecondColor(buffer, view, bytesOffset, vertexPackage) {
        let secondColorCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if (secondColorCount <= 0){
            return bytesOffset;
        }

        let secondColorStride = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint8Array.BYTES_PER_ELEMENT * 2;
        let byteLength = secondColorCount * Uint8Array.BYTES_PER_ELEMENT * 4;
        let secColorBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        bytesOffset += byteLength;

        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aSecondColor'] = attributes.length;
        attributes.push({
            index: attrLocation['aSecondColor'],
            typedArray: secColorBuffer,
            componentsPerAttribute: 4,
            componentDatatype: this.ComponentDatatype.UNSIGNED_BYTE,
            offsetInBytes: 0,
            strideInBytes: 4,
            normalize: true
        });

        return bytesOffset;
    }

    /**
     * 解析纹理坐标
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseTexCoord(buffer, view, bytesOffset, vertexPackage) {
        let count = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;

        for(let i = 0; i < count; i++) {
            let texCoordCount = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let dimension = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            let texCoordStride = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            let byteLength = texCoordCount * dimension * Float32Array.BYTES_PER_ELEMENT;
            let texCoordBuffer = new Uint8Array(buffer, bytesOffset, byteLength)
            bytesOffset += byteLength;
            let str = 'aTexCoord' + i;
            let attributes = vertexPackage.vertexAttributes;
            let attrLocation = vertexPackage.attrLocation;
            attrLocation[str] = attributes.length;
            attributes.push({
                index: attrLocation[str],
                typedArray: texCoordBuffer,
                componentsPerAttribute: dimension,
                componentDatatype: this.ComponentDatatype.FLOAT,
                offsetInBytes: 0,
                strideInBytes: dimension * Float32Array.BYTES_PER_ELEMENT,
                normalize: false
            });
        }

        return bytesOffset;
    }

    parseInstanceInfo(buffer, view, bytesOffset, vertexPackage) {
        let count = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;

        for (let i=0; i < count; i++){
            let texCoordCount = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let texDimensions = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            let texCoordStride = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            let byteLength = texCoordCount * texDimensions * Float32Array.BYTES_PER_ELEMENT;
            if(texDimensions === 17 || texDimensions === 29){
                let instanceBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
                vertexPackage.instanceCount = texCoordCount;
                vertexPackage.instanceMode = texDimensions;
                vertexPackage.instanceBuffer = instanceBuffer;
                vertexPackage.instanceIndex = 1;
                let len = texDimensions * texCoordCount * 4;
                let vertexColorInstance = instanceBuffer.slice(0, len);
                vertexPackage.vertexColorInstance = vertexColorInstance;
                let byteStride;
                if(texDimensions === 17){
                    byteStride = Float32Array.BYTES_PER_ELEMENT * 17;
                    attrLocation['uv2'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv2'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 0,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv3'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv3'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 4 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv4'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv4'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 8 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv5'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv5'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 12 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv6'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv6'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.UNSIGNED_BYTE,
                        normalize: true,
                        offsetInBytes: 16 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });
                }
                else if (texDimensions === 29) {
                    byteStride = Float32Array.BYTES_PER_ELEMENT * 29;
                    attrLocation['uv1'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv1'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 0,
                        strideInBytes: byteStride,
                        instanceDivisor: 1,
                        byteLength: byteLength
                    });

                    attrLocation['uv2'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv2'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 4 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv3'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv3'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 8 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv4'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv4'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 12 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv5'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv5'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 16 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv6'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv6'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 20 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });

                    attrLocation['uv7'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv7'],
                        componentsPerAttribute: 3,
                        componentDatatype: this.ComponentDatatype.FLOAT,
                        normalize: false,
                        offsetInBytes: 24 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });
                    attrLocation['uv8'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv8'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.UNSIGNED_BYTE,
                        normalize: true,
                        offsetInBytes: 27 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });
                    attrLocation['uv9'] = attributes.length;
                    attributes.push({
                        index: attrLocation['uv9'],
                        componentsPerAttribute: 4,
                        componentDatatype: this.ComponentDatatype.UNSIGNED_BYTE,
                        normalize: true,
                        offsetInBytes: 28 * Float32Array.BYTES_PER_ELEMENT,
                        strideInBytes: byteStride,
                        instanceDivisor: 1
                    });
                }
            }
            else{
                let len = texCoordCount * texDimensions;
                vertexPackage.instanceBounds = new Float32Array(len);
                for(let k = 0; k < len; k++){
                    vertexPackage.instanceBounds[k] = view.getFloat32(bytesOffset, true);
                }
            }

            bytesOffset += byteLength;
        }

        return bytesOffset;
    }

    /**
     * 解析压缩的顶点数据
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseCompressVertex(buffer, view, bytesOffset, vertexPackage) {
        let verticesCount = view.getUint32(bytesOffset, true);
        vertexPackage.verticesCount = verticesCount;
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if(bytesOffset <= 0){
            return bytesOffset;
        }

        let vertexDimension = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let vertexStride = view.getUint16(bytesOffset, true);
        vertexStride = vertexDimension * Int16Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;

        let vertCompressConstant = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        let minVerticesValue = {};
        minVerticesValue.x = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        minVerticesValue.y = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        minVerticesValue.z = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        minVerticesValue.w = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;

        vertexPackage.vertCompressConstant = vertCompressConstant;
        vertexPackage.minVerticesValue = minVerticesValue;

        let byteLength = verticesCount * vertexDimension * Int16Array.BYTES_PER_ELEMENT;
        let vertexBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        bytesOffset += byteLength;

        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aPosition'] = attributes.length;
        attributes.push({
            index: attrLocation['aPosition'],
            typedArray: vertexBuffer,
            componentsPerAttribute: vertexDimension,
            componentDatatype: this.ComponentDatatype.SHORT,
            offsetInBytes: 0,
            strideInBytes: vertexStride,
            normalize: false
        });

        return bytesOffset;
    }

    /**
     * 解析压缩的法线数据
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseCompressNormal(buffer, view, bytesOffset, vertexPackage) {
        let normalCount = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if(normalCount <= 0){
            return bytesOffset;
        }

        let normalDimension = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let normalStride = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        let byteLength = normalCount * 2 * Int16Array.BYTES_PER_ELEMENT;
        let normalBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        bytesOffset += byteLength;
        let attributes = vertexPackage.vertexAttributes;
        let attrLocation = vertexPackage.attrLocation;
        attrLocation['aNormal'] = attributes.length;
        attributes.push({
            index: attrLocation['aNormal'],
            typedArray: normalBuffer,
            componentsPerAttribute : 2,
            componentDatatype : this.ComponentDatatype.SHORT,
            offsetInBytes: 0,
            strideInBytes: normalStride,
            normalize: false
        });

        return bytesOffset;
    }

    /**
     * 解析压缩的纹理坐标
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param vertexPackage
     * @returns {number | *}
     */
    parseCompressTexCoord(buffer, view, bytesOffset, vertexPackage) {
        vertexPackage.texCoordCompressConstant = [];
        vertexPackage.minTexCoordValue = [];
        let count = view.getUint16(bytesOffset, true);
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < count; i++){
            let bNeedTexCoordZ = view.getUint8(bytesOffset, true);
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT;
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT * 3;
            let texCoordCount = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let dimension = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;
            let texCoordStride = view.getUint16(bytesOffset, true);
            bytesOffset += Uint16Array.BYTES_PER_ELEMENT;

            let texCoordCompressConstant = view.getFloat32(bytesOffset, true);
            bytesOffset += Float32Array.BYTES_PER_ELEMENT;
            vertexPackage.texCoordCompressConstant.push(texCoordCompressConstant);

            let minTexCoordValue = {};
            minTexCoordValue.x = view.getFloat32(bytesOffset, true);
            bytesOffset += Float32Array.BYTES_PER_ELEMENT;
            minTexCoordValue.y = view.getFloat32(bytesOffset, true);
            bytesOffset += Float32Array.BYTES_PER_ELEMENT;
            minTexCoordValue.z = view.getFloat32(bytesOffset, true);
            bytesOffset += Float32Array.BYTES_PER_ELEMENT;
            minTexCoordValue.w = view.getFloat32(bytesOffset, true);
            bytesOffset += Float32Array.BYTES_PER_ELEMENT;
            vertexPackage.minTexCoordValue.push(minTexCoordValue);

            let byteLength = texCoordCount * dimension * Int16Array.BYTES_PER_ELEMENT;
            let texCoordBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
            bytesOffset += byteLength;
            let align = bytesOffset % 4;
            if(align !== 0){
                bytesOffset += (4 - align);
            }

            let str = 'aTexCoord' + i;
            let attributes = vertexPackage.vertexAttributes;
            let attrLocation = vertexPackage.attrLocation;
            attrLocation[str] = attributes.length;
            attributes.push({
                index: attrLocation[str],
                typedArray: texCoordBuffer,
                componentsPerAttribute: dimension,
                componentDatatype: this.ComponentDatatype.SHORT,
                offsetInBytes: 0,
                strideInBytes: dimension * Int16Array.BYTES_PER_ELEMENT,
                normalize: false
            });

            if(bNeedTexCoordZ){
                byteLength = texCoordCount * Float32Array.BYTES_PER_ELEMENT;
                let texCoordZBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
                bytesOffset += byteLength;
                vertexPackage.texCoordZMatrix = true;
                str = 'aTexCoordZ' + i;
                attrLocation[str] = attributes.length;
                attributes.push({
                    index: attrLocation[str],
                    typedArray: texCoordZBuffer,
                    componentsPerAttribute: 1,
                    componentDatatype: this.ComponentDatatype.FLOAT,         //组件数据类型
                    offsetInBytes: 0,
                    strideInBytes: Float32Array.BYTES_PER_ELEMENT,
                    normalize: false
                });
            }
        }
        return bytesOffset;
    }

    parseStandardSkeleton(buffer, view, bytesOffset, vertexPackage) {
        bytesOffset = this.parseVertex(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseNormal(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseVertexColor(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseSecondColor(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseTexCoord(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseInstanceInfo(buffer, view, bytesOffset, vertexPackage);

        return bytesOffset;
    }

    parseCompressSkeleton(buffer, view, bytesOffset, vertexPackage) {
        let compressOptions = view.getUint32(bytesOffset, true);
        vertexPackage.compressOptions = compressOptions;
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        if((compressOptions & this.VertexCompressOptions.SVC_Vertex) === this.VertexCompressOptions.SVC_Vertex){
            bytesOffset = this.parseCompressVertex(buffer, view, bytesOffset, vertexPackage);
        }
        else{
            bytesOffset = this.parseVertex(buffer, view, bytesOffset, vertexPackage);
        }

        if((compressOptions & this.VertexCompressOptions.SVC_Normal) === this.VertexCompressOptions.SVC_Normal){
            bytesOffset = this.parseCompressNormal(buffer, view, bytesOffset, vertexPackage);
        }
        else{
            bytesOffset = this.parseNormal(buffer, view, bytesOffset, vertexPackage);
        }

        bytesOffset = this.parseVertexColor(buffer, view, bytesOffset, vertexPackage);

        bytesOffset = this.parseSecondColor(buffer, view, bytesOffset, vertexPackage);

        if((compressOptions & this.VertexCompressOptions.SVC_TexutreCoord) === this.VertexCompressOptions.SVC_TexutreCoord){
            bytesOffset = this.parseCompressTexCoord(buffer, view, bytesOffset, vertexPackage);
        }
        else{
            bytesOffset = this.parseTexCoord(buffer, view, bytesOffset, vertexPackage);
        }

        if((compressOptions & this.VertexCompressOptions.SVC_TexutreCoordIsW) === this.VertexCompressOptions.SVC_TexutreCoordIsW){
            vertexPackage.textureCoordIsW = true;
        }

        bytesOffset = this.parseInstanceInfo(buffer, view, bytesOffset, vertexPackage);

        return bytesOffset;
    }

    parseIndexPackage(buffer, view, bytesOffset, arrIndexPackage) {
        let count = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for (let i = 0; i < count; i++){
            let indexPackage = {};
            let indexCount = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let indexType = view.getUint8(bytesOffset, true);
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT;
            let bUseIndex = view.getUint8(bytesOffset, true);
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT;
            let primitiveType = view.getUint8(bytesOffset, true);
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT;
            bytesOffset += Uint8Array.BYTES_PER_ELEMENT;

            if(indexCount > 0){
                let indexBuffer = null;
                let byteLength;
                if(indexType === 1 || indexType === 3){
                    byteLength = indexCount * Uint32Array.BYTES_PER_ELEMENT;
                    indexBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
                }
                else{
                    byteLength = indexCount * Uint16Array.BYTES_PER_ELEMENT;
                    indexBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
                    if(indexCount % 2 !== 0) {
                        byteLength += 2;
                    }
                }

                indexPackage.indicesTypedArray = indexBuffer;
                bytesOffset += byteLength;
            }

            indexPackage.indicesCount = indexCount;
            indexPackage.indexType = indexType;
            indexPackage.primitiveType = primitiveType;

            let arrPassName = [];
            let passNameCount = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            for(let j = 0; j < passNameCount; j++) {
                let res = this.parseString(buffer, view, bytesOffset);
                let passName = res.string;
                bytesOffset = res.bytesOffset;
                arrPassName.push(passName);
                indexPackage.materialCode = passName;
            }

            let align = bytesOffset % 4;
            if(align !== 0){
                let nReserved = 4 - bytesOffset % 4;
                bytesOffset += nReserved;
            }

            arrIndexPackage.push(indexPackage);
        }

        return bytesOffset;
    }

    /**
     * 解析骨骼
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param geoPackage
     * @returns {number | *}
     */
    parseSkeleton(buffer, view, bytesOffset, geoPackage) {
        let size = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let count = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < count; i++){
            let res = this.parseString(buffer, view, bytesOffset);
            let geometryName = res.string;
            bytesOffset = res.bytesOffset;
            let align = bytesOffset % 4;
            if(align !== 0){
                bytesOffset += (4 - align);
            }

            let tag = view.getUint32(bytesOffset, true);
            bytesOffset += Int32Array.BYTES_PER_ELEMENT;

            let vertexPackage = {
                vertexAttributes : [],
                attrLocation : {},
                instanceCount : 0,
                instanceMode : 0,
                instanceIndex : -1
            };

            if(tag === this.S3MBVertexTag.SV_Standard){
                bytesOffset = this.parseStandardSkeleton(buffer, view, bytesOffset, vertexPackage);
            }
            else if(tag === this.S3MBVertexTag.SV_Compressed){
                bytesOffset = this.parseCompressSkeleton(buffer, view, bytesOffset, vertexPackage);
            }

            let arrIndexPackage = [];
            bytesOffset = this.parseIndexPackage(buffer, view, bytesOffset, arrIndexPackage);

            geoPackage[geometryName] = {
                vertexPackage: vertexPackage,
                arrIndexPackage: arrIndexPackage
            };
        }

        let secColorSize =  view.getUint32(bytesOffset, true);
        bytesOffset += secColorSize;
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;

        return bytesOffset;
    }

    /**
     * 解析纹理包
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param texturePackage
     * @returns {number | *}
     */
    parseTexturePackage(buffer, view, bytesOffset, texturePackage) {
        let size = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let count = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        for(let i = 0; i < count; i++){
            let res = this.parseString(buffer, view, bytesOffset);
            let textureCode = res.string;
            bytesOffset = res.bytesOffset;
            let align = bytesOffset % 4;
            if(align !== 0){
                bytesOffset += (4 - align);
            }

            let level = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let width = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let height = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let compressType = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let size = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let pixelFormat = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let textureData = new Uint8Array(buffer, bytesOffset, size);
            bytesOffset += size;

            texturePackage[textureCode] = {
                id: textureCode,
                width: width,
                height: height,
                compressType: compressType,
                nFormat: pixelFormat,
                internalFormat : 0x83F3,
                imageBuffer: textureData
            };
        }

        return bytesOffset;
    }

    /**
     * 解析材质
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param result
     * @returns {number | *}
     */
    parseMaterial(buffer, view, bytesOffset, result) {
        let byteLength = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let materialBuffer = new Uint8Array(buffer, bytesOffset, byteLength);
        let strMaterials = this.getStringFromTypedArray(materialBuffer);
        bytesOffset += byteLength;
        result.materials = JSON.parse(strMaterials);

        return bytesOffset;
    }

    /**
     * 解析拾取信息
     * @param buffer
     * @param view
     * @param bytesOffset
     * @param nOptions
     * @param geoPackage
     * @returns {*}
     */
    parsePickInfo(buffer, view, bytesOffset, nOptions, geoPackage) {
        if((nOptions & 1) === 1){
            let size = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            let count = view.getUint32(bytesOffset, true);
            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
            for(let i = 0; i < count; i++){
                let res = this.parseString(buffer, view, bytesOffset);
                let geometryName = res.string;
                bytesOffset = res.bytesOffset;
                let selectInfoCount = view.getUint32(bytesOffset, true);
                bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
                let pickInfo = {};
                geoPackage[geometryName].pickInfo = pickInfo;
                let bInstanced = geoPackage[geometryName].vertexPackage.instanceIndex;
                for(let j = 0; j < selectInfoCount; j++){
                    let nDictID = view.getUint32(bytesOffset, true);
                    bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
                    let nSize = view.getUint32(bytesOffset, true);
                    bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
                    let infos = [];
                    for(let k = 0; k < nSize; k++){
                        let vertexColorOffset = view.getUint32(bytesOffset, true);
                        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
                        let vertexCount = 1;
                        if(bInstanced === -1){
                            vertexCount = view.getUint32(bytesOffset, true);
                            bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
                        }

                        infos.push({
                            vertexColorOffset: vertexColorOffset,
                            vertexColorCount: vertexCount
                        });
                    }

                    pickInfo[nDictID] = infos;
                }
            }
        }

        return bytesOffset;
    }

    /**
     * 解析buffer
     * @param buffer
     * @returns {{version: undefined, groupNode: undefined, geoPackage: {}, matrials: undefined, texturePackage: {}}}
     */
    parseBuffer(buffer) {
        let bytesOffset = 0;
        let result = {
            version : undefined,
            groupNode : undefined,
            geoPackage : {},
            matrials : undefined,
            texturePackage : {}
        };

        let view = new DataView(buffer);
        result.version = view.getFloat32(bytesOffset, true);
        bytesOffset += Float32Array.BYTES_PER_ELEMENT;
        let byteSize = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;
        let unzipBuffer = this.unZip(buffer, bytesOffset);
        view = new DataView(unzipBuffer);
        bytesOffset = 0;
        let nOptions = view.getUint32(bytesOffset, true);
        bytesOffset += Uint32Array.BYTES_PER_ELEMENT;

        bytesOffset = this.parseGroupNode(unzipBuffer, view, bytesOffset, result);

        bytesOffset = this.parseSkeleton(unzipBuffer, view, bytesOffset, result.geoPackage);

        bytesOffset = this.parseTexturePackage(unzipBuffer, view, bytesOffset, result.texturePackage);

        bytesOffset = this.parseMaterial(unzipBuffer, view, bytesOffset, result);

        this.parsePickInfo(unzipBuffer, view, bytesOffset, nOptions, result.geoPackage);

        return result;
    };

    /**
     * 将类型化数组转为字符串，后面会提取出公共方法
     * @returns {String}
     * @private
     * */
    getStringFromTypedArray(uint8Array, byteOffset, byteLength) {
        if (!this.defined(uint8Array)) {
            throw 'Batched3DModel3DTileContent: uint8Array is required.';
        }
        if (byteOffset < 0) {
            throw 'byteOffset cannot be negative.';
        }
        if (byteLength < 0) {
            throw 'byteLength cannot be negative.';
        }
        if ((byteOffset + byteLength) > uint8Array.byteLength) {
            throw 'sub-region exceeds array bounds.';
        }
        byteOffset = this.defined(byteOffset) ? byteOffset : 0;
        byteLength = this.defined(byteLength) ? byteLength : (uint8Array.byteLength - byteOffset);
        uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);

        if ( typeof TextDecoder !== 'undefined' ) {                 //es5自带的文本解码
            return new TextDecoder().decode( uint8Array );
        }
        var s = '';
        for ( var i = 0, il = uint8Array.length; i < il; i ++ ) {
            s += String.fromCharCode( uint8Array[ i ] );
        }
        return decodeURIComponent( escape( s ) );
    }
}
;hmap.format = hmap.format || {};
hmap.format.s3m = hmap.format.s3m || {};
/**
 * s3m压缩纹理
 * @type {hmap.format.s3m.DDSTexture}
 * @private
 */
hmap.format.s3m.DDSTexture = class {
    constructor(id,info){
        this._id=id;//纹理对象的唯一标识
        this._info=info;
        this._texture=null;
    }

    createCompressTexture(gl){
        gl.getExtension("WEBGL_compressed_texture_s3tc");
        this._texture=gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D,this._texture);
        let offset=0,i=0,texWidth=this._info.width,texHeight=this._info.height;
        let bMinMap=this.validateMinmap(this._info.imageBuffer,this._info.internalFormat,this._info.width,this._info.height);
        //生成压缩纹理
        do{
            let levelSize=hmap.format.s3m.PixelFormat.compressedTextureSizeInBytes(this._info.internalFormat,texWidth,texHeight);
            let subArrayBuffer=new Uint8Array(this._info.imageBuffer.buffer,this._info.imageBuffer.byteOffset+offset,levelSize);
            gl.compressedTexImage2D(gl.TEXTURE_2D,i++,this._info.internalFormat,texWidth,texHeight,0,subArrayBuffer);
            texWidth=Math.max(texWidth>>1,1);
            texHeight=Math.max(texHeight>>1,1);
            offset+=levelSize;
        }while (offset<this._size&&bMinMap);
        if(i>1){
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
        }else{
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
        }

        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl[this._info.wrapS]);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl[this._info.wrapT]);
        gl.bindTexture(gl.TEXTURE_2D,null);
    }

    validateMinmap(buffer,pixelFormat,width,height){
        const len=buffer.length;
        let totalBytes=0,w=width,h=height;
        while(1){
            totalBytes+=hmap.format.s3m.PixelFormat.compressedTextureSizeInBytes(pixelFormat,w,h);
            w=w>>1;//二进制有符号向右移位1
            h=h>>1;//二进制有符号向右移位1
            if(w===0&&h===0){
                break;
            }

            w=Math.max(w,1);
            h=Math.max(h,1);
        }
        return totalBytes===len;
    }
    enable(gl,unit=0){
        gl.activeTexture(gl.TEXTURE0+unit);
        gl.bindTexture(gl.TEXTURE_2D,this._texture);
    }

    disable(gl){
        gl.bindTexture(gl.TEXTURE_2D,null);
    }

    destroy(gl){
        gl.delete(this._texture);
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;hmap.format = hmap.format || {};
hmap.format.s3m = hmap.format.s3m || {};
/**
 * 像素格式
 * @type {hmap.format.s3m.PixelFormat}
 * @private
 */
hmap.format.s3m.PixelFormat=class{
    static formatTable(type){
        let table={
            RGB_DXT1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGB_S3TC_DXT1_EXT'),
            RGBA_DXT1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGBA_S3TC_DXT1_EXT'),
            RGB_ETC1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGB_ETC1_WEBGL'),
            RGBA_DXT3:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGBA_S3TC_DXT3_EXT'),
            RGBA_DXT5:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGBA_S3TC_DXT5_EXT'),
            RBG_PVRTC_4BPPV1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGB_PVRTC_4BPPV1_IMG'),
            RGBA_PVRTC_4BPPV1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGBA_PVRTC_4BPPV1_IMG'),
            RGB_PVRTC_2BPPV1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGB_PVRTC_2BPPV1_IMG'),
            RGBA_PVRTC_2BPPV1:hmap.util.GLConstantTable.getConstant('COMPRESSED_RGBA_PVRTC_2BPPV1_IMG'),
        };
        return table[type];
    }

    static compressedTextureSizeInBytes(pixelFormat,width,height){
        switch (pixelFormat){
            case hmap.format.s3m.PixelFormat.formatTable('RGB_DXT1'):
            case hmap.format.s3m.PixelFormat.formatTable('RGBA_DXT1'):
            case hmap.format.s3m.PixelFormat.formatTable('RGB_ETC1'):
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;

            case hmap.format.s3m.PixelFormat.formatTable('RGBA_DXT3'):
            case hmap.format.s3m.PixelFormat.formatTable('RGBA_DXT5'):
                return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

            case hmap.format.s3m.PixelFormat.formatTable('RGB_PVRTC_4BPPV1'):
            case hmap.format.s3m.PixelFormat.formatTable('RGBA_PVRTC_4BPPV1'):
                return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);

            case hmap.format.s3m.PixelFormat.formatTable('RGB_PVRTC_2BPPV1'):
            case hmap.format.s3m.PixelFormat.formatTable('RGBA_PVRTC_2BPPV1'):
                return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);

            default:
                return 0;
        }
    }
};;hmap.util = hmap.util || {};
/**
 * @private
 */
hmap.util.AF = class {
    constructor(scope,delay=10){
        this.delay=delay;
        this.timer=null;
        this.previous=0;
        this.now=0;
        this.scope=scope;
    }
    run(func,param){
        const me=this.scope;
        this.now = new Date().getTime();
        if (this.now - this.previous < this.delay) {
            clearTimeout(this.timer);
        }
        this.timer = setTimeout(function () {
            func.call(me,param);
            this.timer=null;
        }.bind(this), this.delay);
        this.previous=this.now;
    }
};"use strict";
hmap.util = hmap.util || {};
/**
 * 欧拉角，旋转变换时用到
 * @type {hmap.util.Euler}
 * @private
 */
hmap.util.Euler = class {
    /**
     * 构造欧拉角
     * @param x X坐标值
     * @param y Y坐标值
     * @param z Z坐标值
     */
    constructor(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || 'XYZ';
        this.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
        this.CLASS_NAME = "hmap.util.Euler";
    }

    getX(){
        return this._x
    }

    setX(value){
        this._x = value;
    }

    getY(){
        return this._y
    }

    setY(value){
        this._y = value;
    }

    getZ(){
        return this._z
    }

    setZ(value){
        this._z = value;
    }

    /**
     * 获取欧拉角顺序
     * */
    getOrder(){
        return this._order
    }

    /**
     * 设置欧拉角顺序
     * */
    setOrder(value){
        this._order = value;
    }

    /**
    *  设置欧拉角参数
    */
    set( x, y, z, order ) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
    }

    /**
     *  复制自身
     * */
    clone() {
        return new hmap.util.Euler( this._x, this._y, this._z, this._order);
    }


    /**
     *  把另一个欧拉角对象的参数复制给自身
     */
    copy( euler ) {
        this._x = euler.getX();
        this._y = euler.getY();
        this._z = euler.getZ();
        this._order = euler.getOrder();
    }

    /**
     *  根据旋转矩阵设置欧拉角
     */
    setFromRotationMatrix(matrix4,order) {
        var clamp =  function ( value, min, max ) {
            return Math.max( min, Math.min( max, value ));
        };

        var te = matrix4.elements;
        var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
        var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        order = order || this._order;
        if ( order === 'XYZ' ) {
            this._y = Math.asin( clamp( m13, - 1, 1 ) );
            if ( Math.abs( m13 ) < 0.99999 ) {
                this._x = Math.atan2( - m23, m33 );
                this._z = Math.atan2( - m12, m11 );
            } else {
                this._x = Math.atan2( m32, m22 );
                this._z = 0;
            }
        } else if ( order === 'YXZ' ) {
            this._x = Math.asin( - clamp( m23, - 1, 1 ) );
            if ( Math.abs( m23 ) < 0.99999 ) {
                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );
            } else {
                this._y = Math.atan2( - m31, m11 );
                this._z = 0;
            }
        } else if ( order === 'ZXY' ) {
            this._x = Math.asin( clamp( m32, - 1, 1 ) );
            if ( Math.abs( m32 ) < 0.99999 ) {
                this._y = Math.atan2( - m31, m33 );
                this._z = Math.atan2( - m12, m22 );
            } else {
                this._y = 0;
                this._z = Math.atan2( m21, m11 );
            }
        } else if ( order === 'ZYX' ) {
            this._y = Math.asin( - clamp( m31, - 1, 1 ) );
            if ( Math.abs( m31 ) < 0.99999 ) {
                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );
            } else {
                this._x = 0;
                this._z = Math.atan2( - m12, m22 );
            }
        } else if ( order === 'YZX' ) {
            this._z = Math.asin( clamp( m21, - 1, 1 ) );
            if ( Math.abs( m21 ) < 0.99999 ) {
                this._x = Math.atan2( - m23, m22 );
                this._y = Math.atan2( - m31, m11 );
            } else {
                this._x = 0;
                this._y = Math.atan2( m13, m33 );
            }
        } else if ( order === 'XZY' ) {
            this._z = Math.asin( - clamp( m12, - 1, 1 ) );
            if ( Math.abs( m12 ) < 0.99999 ) {
                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );
            } else {
                this._x = Math.atan2( - m23, m33 );
                this._y = 0;
            }
        } else {
            console.warn( 'hmap.util.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
        }
        this._order = order;
    }

    /**
     *  根据三维向量，创建欧拉角
     *  @param {hmap.util.Vector3} 三维向量
     */
    setFromVector3(vector3, order ) {
        return this.set( vector3.x, vector3.y, vector3.z, order || this._order );
    }

    /**
     * 检查当前欧拉角对象与另外一个欧拉角对象的值是否相等
     * @returns {Boolean}
     * */
    equals(euler) {
        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
    }

    /**
     * 根据数组内容创建欧拉角
     * @returns {hmap.util.Vector3}
     * */
    fromArray(array) {
        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
        return this;
    }

    /**
     * 将欧拉角对象内容转成数组
     * @returns {hmap.util.Vector3}
     * */
    toArray() {
        const array = [];
        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;
        return array;
    }

    /**
     * 将欧拉角象转换成三维向量
     * @returns {hmap.util.Vector3}
     * */
    toVector3() {
        return new hmap.util.Vector3( this._x, this._y, this._z );
    }
};

/**
 * Quaternion四元数
 * @type {hmap.util.Quaternion}
 * @private
 */
hmap.util.Quaternion = class {
    /**
     * 构造Quaternion
     * @param x X坐标值
     * @param y Y坐标值
     * @param z Z坐标值
     */
    constructor(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = ( w !== undefined ) ? w : 1;
    }

    getX(){
        return this._x
    }

    setX(value){
        this._x = value;
    }

    getY(){
        return this._y
    }

    setY(value){
        this._y = value;
    }

    getZ(){
        return this._z
    }

    setZ(value){
        this._z = value;
    }

    getW(){
        return this._w
    }

    setW(value){
        this._w = value;
    }

    /**
     * 从旋转矩阵中设置旋转四元数
     * */
    setFromRotationMatrix( matrix4 ) {

        var te = matrix4.getElements(),

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

            trace = m11 + m22 + m33, s;
        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        } else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        } else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        } else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }
        return this;
    }
};
;"use strict";
hmap.util=hmap.util || {};
/**
 * 3阶矩阵，列主序。
 * @type {hmap.util.Matrix3}
 */
hmap.util.Matrix3 = class {
    /**
     * 使用Float32Array类型、长度为16的数组构造四维矩阵，如果不传入数组，则构造单位矩阵
     * @param {Float32Array} elements 一个Float32Array类型、长度为9的数组
     */
    constructor(elements){
        this.ARRAY_TYPE = Float32Array;
        this._elements = new this.ARRAY_TYPE(9);
        if(elements){
            this.setElements(elements);
        }else{
            this.setIdentity();
        }
        this.CLASS_NAME = "hmap.util.Matrix3";
    }

    /**
     *  设置矩阵的值
     *  @returns {hmap.util.Matrix3}
     * */
    set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
        var te = this._elements;
        te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
        te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
        te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
        return this;
    }

    /**
     * 使用长度为9的列主序数组设置矩阵元素的值。如果数组长度小于9，则抛出异常；如果数组长度大于9，则使用前9个元素。
     * @param {TypedArray} elements 被复制的矩阵包含的元素
     */
    setElements(elements){
        if(!elements || !(elements instanceof this.ARRAY_TYPE)){
            throw `Matrix3 elements must be ${this.ARRAY_TYPE} type!`;
        }
        if(elements.length<9){
            throw 'length of the argument "elements" must not less than 9';
        }
        let i, s, d;

        s = elements;
        d = this._elements;

        if (s === d) {
            return;
        }

        for (i = 0; i < 9; ++i) {
            d[i] = s[i];
        }
    }

    /**
     * 获取矩阵所有元素，返回以列主序存储的类型化数组。
     * @returns {ARRAY_TYPE}
     */
    getElements(){
        return this._elements;
    }

    /**
     * 将当前矩阵设置为单位矩阵
     */
    setIdentity() {
        this.set(
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        );
        return this;
    }

    /**
     *  拷贝当前矩阵的元素，得到新的三维矩阵
     *  @returns {hmap.util.Matrix3} 三维矩阵
     * */
    clone() {
        return new this.constructor().fromArray(this._elements);
    }

    /**
     *  将目标矩阵的元素拷贝到当前矩阵中
     *  @param {hmap.util.Matrix3} matrix3 目标矩阵
     * */
    copy(matrix3) {
        var te = this._elements,me = matrix3.getElements();
        te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
        te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
        te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
        return this;
    }

    /**
     *  从4阶矩阵中获取元素，作为当前矩阵的元素
     *  @param {hmap.util.Matrix4} matrix4 4阶矩阵
     *  @returns {hmap.util.Matrix3}
     * */
    setFromMatrix4(matrix4) {
        var me = matrix4.getElements();
        this.set(
            me[ 0 ], me[ 4 ], me[ 8 ],
            me[ 1 ], me[ 5 ], me[ 9 ],
            me[ 2 ], me[ 6 ], me[ 10 ]
        );
        return this;
    }

    /**
     *  当前矩阵与目标矩阵相乘
     *  @param {hmap.util.Matrix3} 3阶矩阵
     *  @returns {hmap.util.Matrix3} 当前矩阵与一个3阶矩阵相乘之后的结果
     * */
    multiply( matrix3 ) {
        return this.multiplyMatrices( this, matrix3 );
    }

    /**
     *  目标矩阵与当前矩阵相乘
     *  @param {hmap.util.Matrix3} 3阶矩阵
     *
     * */
    premultiply( matrix3 ) {
        return this.multiplyMatrices( matrix3, this );
    }

    /**
     *  源矩阵和目标矩阵相乘，结果作为当前矩阵
     *  @param {hmap.util.Matrix3} a
     *  @param {hmap.util.Matrix3} b
     *  @returns {hmap.util.Matrix3}
     * */
    multiplyMatrices( srcMatrix, desMatrix ) {
        let ae = srcMatrix.getElements(),be = desMatrix.getElements(),te = this._elements;

        let a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
        let a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
        let a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

        let b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
        let b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
        let b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
        te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
        te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
        te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
        te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
        te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
        te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }

    /**
     *  将当前3维矩阵与一个变量相乘
     *  @param {Number} s
     */
    multiplyScalar( s ) {
        var te = this._elements;
        te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
        te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
        te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
        return this;
    }

    /**
     *  获取3维矩阵中行列式的值
     * */
    determinant() {
        var te = this._elements;
        var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
            d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
            g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }

    /**
     *  矩阵反转
     * */
    getInverse( matrix3, throwOnDegenerate ) {
        if ( matrix3 && matrix3 instanceof hmap.util.Matrix4 ) {
            console.error( "hmap.util.Matrix3: .getInverse() no longer takes a Matrix4 argument." );
        }
        var me = matrix3.getElements(),te = this._elements,
            n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
            n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
            n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
            t11 = n33 * n22 - n32 * n23,
            t12 = n32 * n13 - n33 * n12,
            t13 = n23 * n12 - n22 * n13,
            det = n11 * t11 + n21 * t12 + n31 * t13;
        if ( det === 0 ) {
            var msg = "hmap.util.Matrix3: .getInverse() can't invert matrix, determinant is 0";
            if ( throwOnDegenerate === true ) {
                throw new Error( msg );
            } else {
                console.warn( msg );
            }
            return this.setIdentity();
        }
        var detInv = 1 / det;

        te[ 0 ] = t11 * detInv;
        te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
        te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

        te[ 3 ] = t12 * detInv;
        te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
        te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

        te[ 6 ] = t13 * detInv;
        te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
        te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
        return this;
    }

    /**
     *  矩阵转置
     * */
    transpose() {
        var tmp, m = this._elements;
        tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
        tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
        tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
        return this;
    }

    /**
     *  获取标准矩阵
     *  @param {hmap.util.Matrix4} matrix4 4阶矩阵
     *  @returns {hmap.util.Matrix4} matrix4 标准4阶矩阵
     * */
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
    }

    /**
     *  移入一个数组参数
     *  @param {Array} r 数组参数
     */
    transposeIntoArray(r) {
        var m = this._elements;
        r[ 0 ] = m[ 0 ];
        r[ 1 ] = m[ 3 ];
        r[ 2 ] = m[ 6 ];
        r[ 3 ] = m[ 1 ];
        r[ 4 ] = m[ 4 ];
        r[ 5 ] = m[ 7 ];
        r[ 6 ] = m[ 2 ];
        r[ 7 ] = m[ 5 ];
        r[ 8 ] = m[ 8 ];
        return this;
    }

    /**
     *  设置UV变换
     */
    setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {
        var c = Math.cos( rotation ),s = Math.sin( rotation );
        this.set(
            sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
            - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
            0, 0, 1
        );
    }

    /**
     *  矩阵放缩
     * */
    scale(sx, sy) {
        var te = this._elements;
        te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
        te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;
        return this;
    }

    /**
     *  矩阵旋转
     *  @param {Number} theta 角度弧度
     * */
    rotate( theta ) {
        var c = Math.cos( theta ),s = Math.sin( theta );

        var te = this._elements;
        var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
        var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

        te[ 0 ] = c * a11 + s * a21;
        te[ 3 ] = c * a12 + s * a22;
        te[ 6 ] = c * a13 + s * a23;

        te[ 1 ] = - s * a11 + c * a21;
        te[ 4 ] = - s * a12 + c * a22;
        te[ 7 ] = - s * a13 + c * a23;
        return this;
    }

    /**
     *  矩阵x方向和y方向转换
     *  @param {Number} tx x方向变换
     *  @param {Number} ty y方向变换
     * */
    translate( tx, ty ) {
        var te = this._elements;
        te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
        te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];
        return this;
    }

    /**
     *  检查两个三维矩阵是否相等
     *  @param {hmap.util.Matrix3} matrix3
     *  @param {Boolean}
     * */
    equals( matrix3 ) {
        var te = this._elements;
        var me = matrix3.getElements();
        for ( var i = 0; i < 9; i ++ ) {
            if ( te[ i ] !== me[ i ] ) return false;
        }
        return true;
    }

    /**
     *  从数组中获取内容作为矩阵
     *  @param {Array}  array
     *  @param {Number} offset
     *  @returns {hmap.util.Matrix3}
     * */
    fromArray( array, offset ) {
        if ( offset === undefined ) offset = 0;
        for ( var i = 0; i < 9; i ++ ) {
            this._elements[ i ] = array[ i + offset ];
        }
        return this;
    }

    /**
     * 将三阶矩阵转成数组
     * */
    toArray( array, offset ) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;
        var te = this._elements;
        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];
        return array;
    }

    /**
     * 根据旋转角X创建旋转矩阵
     * @param {Number} 旋转的角度，以弧度为单位。正角为逆时针方向
     * @param {hmap.util.Matrix3} 返回值保存到的对象，如果参数为空则自动创建
     * @returns {hmap.util.Matrix3} 参数值对象或者新创建的对象，根据旋转角X创建的旋转矩阵
     */
    static fromRotationX(angle, result) {
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);

        if (!result) {
            return new hmap.util.Matrix3(new Float32Array([1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle]));
        }

        var re = result.getElements();
        re[0] = 1.0;
        re[1] = 0.0;
        re[2] = 0.0;
        re[3] = 0.0;
        re[4] = cosAngle;
        re[5] = sinAngle;
        re[6] = 0.0;
        re[7] = -sinAngle;
        re[8] = cosAngle;
        return result;
    };

    /**
     * 根据旋转角Y创建旋转矩阵
     * @param {Number} 旋转的角度，以弧度为单位。正角为逆时针方向
     * @param {hmap.util.Matrix3} 返回值保存到的对象，如果参数为空则自动创建
     * @returns {hmap.util.Matrix3} 参数值对象或者新创建的对象，根据旋转角Y创建的旋转矩阵
     */
    static fromRotationY(angle, result) {
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);

        if (!result) {
            return new hmap.util.Matrix3(new Float32Array([cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0,-sinAngle, 0.0, cosAngle]));
        }

        let re = result.getElements();
        re[0] = cosAngle;
        re[1] = 0.0;
        re[2] = -sinAngle;
        re[3] = 0.0;
        re[4] = 1.0;
        re[5] = 0.0;
        re[6] = sinAngle;
        re[7] = 0.0;
        re[8] = cosAngle;
        return result;
    };

    /**
     * 根据旋转角Z创建旋转矩阵
     * @param {Number} 旋转的角度，以弧度为单位。正角为逆时针方向
     * @param {hmap.util.Matrix3} 返回值保存到的对象，如果参数为空则自动创建
     * @returns {hmap.util.Matrix3} 参数值对象或者新创建的对象，根据旋转角Z创建的旋转矩阵
     */
    static fromRotationZ(angle, result) {
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);

        if (!result) {
            return new hmap.util.Matrix3(new Float32Array([cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0]))
        }

        let re = result.getElements();
        re[0] = cosAngle;
        re[1] = sinAngle;
        re[2] = 0.0;
        re[3] = -sinAngle;
        re[4] = cosAngle;
        re[5] = 0.0;
        re[6] = 0.0;
        re[7] = 0.0;
        re[8] = 1.0;
        return result;
    }
};
;"use strict";
hmap.util=hmap.util || {};
/**
 * 4阶矩阵，列主序。
 * @type {hmap.util.Matrix4}
 */
hmap.util.Matrix4 = class {
    /**
     * 使用Float32Array类型、长度为16的数组构造四维矩阵，如果不传入数组，则构造单位矩阵
     * @param {Float32Array} elements 一个Float32Array类型、长度为16的数组
     */
    constructor(elements){
        this.ARRAY_TYPE = Float32Array;
        this._elements = new this.ARRAY_TYPE(16);
        if(elements){
            this.setElements(elements);
        }else{
            this.setIdentity();
        }
        this.CLASS_NAME = "hmap.util.Matrix4";
    }

    /**
     * 将当前矩阵设置为单位矩阵
     */
    setIdentity(){
        let e = this._elements;
        e[0] = 1;   e[4] = 0;   e[8]  = 0;   e[12] = 0;
        e[1] = 0;   e[5] = 1;   e[9]  = 0;   e[13] = 0;
        e[2] = 0;   e[6] = 0;   e[10] = 1;   e[14] = 0;
        e[3] = 0;   e[7] = 0;   e[11] = 0;   e[15] = 1;
        return this;
    }

    /**
     * 使用长度为16的列主序数组设置矩阵元素的值。如果数组长度小于16，则抛出异常；如果数组长度大于16，则使用前16个元素。
     * @param {TypedArray} elements 被复制的矩阵包含的元素
     */
    setElements(elements){
        if(!elements || !(elements instanceof this.ARRAY_TYPE)){
            throw `Matrix4 elements must be ${this.ARRAY_TYPE} type!`;
        }
        if(elements.length<16){
            throw 'length of the argument "elements" must not less than 16';
        }
        let i, s, d;

        s = elements;
        d = this._elements;

        if (s === d) {
            return;
        }

        for (i = 0; i < 16; ++i) {
            d[i] = s[i];
        }
    }

    /**
     * 获取矩阵所有元素，返回以列主序存储的类型化数组。
     * @returns {ARRAY_TYPE}
     */
    getElements(){
        return this._elements;
    }

    /**
     * 右乘矩阵，结果存储在当前矩阵中。
     * @param {hmap.util.Matrix4} mat 被乘的矩阵
     * @return this
     */
    multiply(mat) {
        if(!(mat instanceof hmap.util.Matrix4)){
            throw "matrix must be instance of Matrix4!";
        }
        let i, e, a, b, ai0, ai1, ai2, ai3;

        // 计算e = a * b
        e = this._elements;
        a = this._elements;
        b = mat._elements;

        // 如果e等于b, 将b复制到临时矩阵中
        if (e === b) {
            b = new this.ARRAY_TYPE(16);
            for (i = 0; i < 16; ++i) {
                b[i] = e[i];
            }
        }

        for (i = 0; i < 4; i++) {
            ai0=a[i];  ai1=a[i+4];  ai2=a[i+8];  ai3=a[i+12];
            e[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
            e[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
            e[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
            e[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }

        return this;
    }

    /**
     *  左乘矩阵
     * */
    premultiply( m ) {
        return this.multiplyMatrices( m, this );
    }

    /**
     * 矩阵相乘
     * */
    multiplyMatrices( a, b ) {
        var ae = a.getElements();
        var be = b.getElements();
        var te = this._elements;

        var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
        var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
        var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
        var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

        var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
        var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
        var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
        var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

        te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

        return this;
    }

    /**
     * 对点坐标进行变换，即用矩阵右乘点坐标向量。该方法将传入3维向量转化为带有齐次坐标的4维向量，并矩阵前3行的12个元素组成的矩阵右乘该4维向量。
     * @param {hmap.util.Vector3} vec 被乘向量
     * @return 结果向量
     */
    multiplyVector3(vec) {
        if(!(vec instanceof hmap.util.Vector3)){
            throw "vec must be instance of Vector3!";
        }
        let e = this._elements;
        let p = vec._elements;
        let v = new hmap.util.Vector3();
        let resultElements = v.getElements();

        resultElements[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + e[12];
        resultElements[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + e[13];
        resultElements[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14];

        return v;
    }

    /**
     * 右乘4维向量，返回得到的向量。
     * @param {hmap.util.Vector4} vec 被乘向量
     * @return 结果向量
     */
    multiplyVector4(vec) {
        if(!(vec instanceof hmap.util.Vector4)){
            throw "vec must be instance of Vector4!";
        }
        let e = this._elements;
        let p = vec._elements;
        let v = new hmap.util.Vector4();
        let result = v.getElements();

        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[ 8] + p[3] * e[12];
        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[ 9] + p[3] * e[13];
        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];
        result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];

        return v;
    }

    /**
     * 计算矩阵的转置，结果存入当前矩阵。
     * @return this
     */
    transpose() {
        let e, t;

        e = this._elements;

        t = e[ 1];  e[ 1] = e[ 4];  e[ 4] = t;
        t = e[ 2];  e[ 2] = e[ 8];  e[ 8] = t;
        t = e[ 3];  e[ 3] = e[12];  e[12] = t;
        t = e[ 6];  e[ 6] = e[ 9];  e[ 9] = t;
        t = e[ 7];  e[ 7] = e[13];  e[13] = t;
        t = e[11];  e[11] = e[14];  e[14] = t;

        return this;
    }

    /**
     * 计算传入矩阵的逆矩阵，并将结果矩阵的元素复制到本矩阵的元素中
     * @param {hmap.util.Matrix4} mat 传入的矩阵
     * @return this
     */
    setInverseOf(mat) {
        if(!(mat instanceof hmap.util.Matrix4)){
            throw "matrix must be instance of Matrix4!";
        }
        let i, s, d, inv, det;

        s = mat._elements;
        d = this._elements;
        inv = new this.ARRAY_TYPE(16);

        inv[0]  =   s[5]*s[10]*s[15] - s[5] *s[11]*s[14] - s[9] *s[6]*s[15]
            + s[9]*s[7] *s[14] + s[13]*s[6] *s[11] - s[13]*s[7]*s[10];
        inv[4]  = - s[4]*s[10]*s[15] + s[4] *s[11]*s[14] + s[8] *s[6]*s[15]
            - s[8]*s[7] *s[14] - s[12]*s[6] *s[11] + s[12]*s[7]*s[10];
        inv[8]  =   s[4]*s[9] *s[15] - s[4] *s[11]*s[13] - s[8] *s[5]*s[15]
            + s[8]*s[7] *s[13] + s[12]*s[5] *s[11] - s[12]*s[7]*s[9];
        inv[12] = - s[4]*s[9] *s[14] + s[4] *s[10]*s[13] + s[8] *s[5]*s[14]
            - s[8]*s[6] *s[13] - s[12]*s[5] *s[10] + s[12]*s[6]*s[9];

        inv[1]  = - s[1]*s[10]*s[15] + s[1] *s[11]*s[14] + s[9] *s[2]*s[15]
            - s[9]*s[3] *s[14] - s[13]*s[2] *s[11] + s[13]*s[3]*s[10];
        inv[5]  =   s[0]*s[10]*s[15] - s[0] *s[11]*s[14] - s[8] *s[2]*s[15]
            + s[8]*s[3] *s[14] + s[12]*s[2] *s[11] - s[12]*s[3]*s[10];
        inv[9]  = - s[0]*s[9] *s[15] + s[0] *s[11]*s[13] + s[8] *s[1]*s[15]
            - s[8]*s[3] *s[13] - s[12]*s[1] *s[11] + s[12]*s[3]*s[9];
        inv[13] =   s[0]*s[9] *s[14] - s[0] *s[10]*s[13] - s[8] *s[1]*s[14]
            + s[8]*s[2] *s[13] + s[12]*s[1] *s[10] - s[12]*s[2]*s[9];

        inv[2]  =   s[1]*s[6]*s[15] - s[1] *s[7]*s[14] - s[5] *s[2]*s[15]
            + s[5]*s[3]*s[14] + s[13]*s[2]*s[7]  - s[13]*s[3]*s[6];
        inv[6]  = - s[0]*s[6]*s[15] + s[0] *s[7]*s[14] + s[4] *s[2]*s[15]
            - s[4]*s[3]*s[14] - s[12]*s[2]*s[7]  + s[12]*s[3]*s[6];
        inv[10] =   s[0]*s[5]*s[15] - s[0] *s[7]*s[13] - s[4] *s[1]*s[15]
            + s[4]*s[3]*s[13] + s[12]*s[1]*s[7]  - s[12]*s[3]*s[5];
        inv[14] = - s[0]*s[5]*s[14] + s[0] *s[6]*s[13] + s[4] *s[1]*s[14]
            - s[4]*s[2]*s[13] - s[12]*s[1]*s[6]  + s[12]*s[2]*s[5];

        inv[3]  = - s[1]*s[6]*s[11] + s[1]*s[7]*s[10] + s[5]*s[2]*s[11]
            - s[5]*s[3]*s[10] - s[9]*s[2]*s[7]  + s[9]*s[3]*s[6];
        inv[7]  =   s[0]*s[6]*s[11] - s[0]*s[7]*s[10] - s[4]*s[2]*s[11]
            + s[4]*s[3]*s[10] + s[8]*s[2]*s[7]  - s[8]*s[3]*s[6];
        inv[11] = - s[0]*s[5]*s[11] + s[0]*s[7]*s[9]  + s[4]*s[1]*s[11]
            - s[4]*s[3]*s[9]  - s[8]*s[1]*s[7]  + s[8]*s[3]*s[5];
        inv[15] =   s[0]*s[5]*s[10] - s[0]*s[6]*s[9]  - s[4]*s[1]*s[10]
            + s[4]*s[2]*s[9]  + s[8]*s[1]*s[6]  - s[8]*s[2]*s[5];

        det = s[0]*inv[0] + s[1]*inv[4] + s[2]*inv[8] + s[3]*inv[12];
        if (det === 0) {
            return this;
        }

        det = 1 / det;
        for (i = 0; i < 16; i++) {
            d[i] = inv[i] * det;
        }

        return this;
    }

    /**
     * 计算当前矩阵的逆矩阵，结果存入当前矩阵。
     * @return this
     */
    invert() {
        return this.setInverseOf(this);
    }

    /**
     * 将当前矩阵设置为正射投影矩阵
     * @param {Number} left 近裁剪面（也是可视空间）的左边界。
     * @param {Number} right 近裁剪面（也是可视空间）的右边界。
     * @param {Number} bottom 近裁剪面（也是可视空间）的下边界。
     * @param {Number} top 近裁剪面（也是可视空间）的上边界。
     * @param {Number} near 近裁剪面的位置，如果该平面在视点后方，则必须为负值。
     * @param {Number} far 远裁剪面的位置，如果该平面在视点后方，则必须为负值。
     * @return this
     */
    setOrtho(left, right, bottom, top, near, far) {
        const errMsg = "all arguments of setOrtho method must be Number!";
        if(arguments.length!==6){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e, rw, rh, rd;

        if (left === right || bottom === top || near === far) {
            throw 'null frustum';
        }

        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);

        e = this._elements;

        e[0]  = 2 * rw;
        e[1]  = 0;
        e[2]  = 0;
        e[3]  = 0;

        e[4]  = 0;
        e[5]  = 2 * rh;
        e[6]  = 0;
        e[7]  = 0;

        e[8]  = 0;
        e[9]  = 0;
        e[10] = -2 * rd;
        e[11] = 0;

        e[12] = -(right + left) * rw;
        e[13] = -(top + bottom) * rh;
        e[14] = -(far + near) * rd;
        e[15] = 1;

        return this;
    }

    /**
     * 构造一个正射投影矩阵，并用当前矩阵右乘该正射投影矩阵
     * @param {Number} left 近裁剪面（也是可视空间）的左边界
     * @param {Number} right 近裁剪面（也是可视空间）的右边界
     * @param {Number} bottom 近裁剪面（也是可视空间）的下边界
     * @param {Number} top 近裁剪面（也是可视空间）的上边界
     * @param {Number} near 近裁剪面的位置，如果该平面在视点后方，则必须为负值
     * @param {Number} far 远裁剪面的位置，如果该平面在视点后方，则必须为负值
     * @return this
     */
    ortho(left, right, bottom, top, near, far) {
        const errMsg = "all arguments of ortho method must be Number!";
        if(arguments.length!==6){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        return this.multiply(new hmap.util.Matrix4().setOrtho(left, right, bottom, top, near, far));
    }

    /**
     * 将当前矩阵设置为透视投影矩阵
     * @param {Number} left 近裁剪面的左边界
     * @param {Number} right 近裁剪面的右边界
     * @param {Number} bottom 近裁剪面的下边界
     * @param {Number} top 近裁剪面的上边界
     * @param {Number} near 近裁剪面的位置，必须为正值
     * @param {Number} far 远裁剪面的位置，必须为正值
     * @return this
     */
    setFrustum(left, right, bottom, top, near, far) {
        const errMsg = "all arguments of setFrustum method must be Number!";
        if(arguments.length!==6){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e, rw, rh, rd;

        if (left === right || top === bottom || near === far) {
            throw 'null frustum';
        }
        if (near <= 0) {
            throw 'near <= 0';
        }
        if (far <= 0) {
            throw 'far <= 0';
        }

        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);

        e = this._elements;

        e[ 0] = 2 * near * rw;
        e[ 1] = 0;
        e[ 2] = 0;
        e[ 3] = 0;

        e[ 4] = 0;
        e[ 5] = 2 * near * rh;
        e[ 6] = 0;
        e[ 7] = 0;

        e[ 8] = (right + left) * rw;
        e[ 9] = (top + bottom) * rh;
        e[10] = -(far + near) * rd;
        e[11] = -1;

        e[12] = 0;
        e[13] = 0;
        e[14] = -2 * near * far * rd;
        e[15] = 0;

        return this;
    }

    /**
     * 构造一个透视投影矩阵，并用当前矩阵右乘该透视投影矩阵
     * @param {Number} left 近裁剪面的左边界
     * @param {Number} right 近裁剪面的右边界
     * @param {Number} bottom 近裁剪面的下边界
     * @param {Number} top 近裁剪面的上边界
     * @param {Number} near 近裁剪面的位置，必须为正值
     * @param {Number} far 远裁剪面的位置，必须为正值
     * @return this
     */
    frustum(left, right, bottom, top, near, far) {
        const errMsg = "all arguments of frustum method must be Number!";
        if(arguments.length!==6){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        return this.multiply(new hmap.util.Matrix4().setFrustum(left, right, bottom, top, near, far));
    }

    /**
     * 将本矩阵设置为透视投影矩阵
     * @param {Number} fovy 垂直视角，即可视空间顶面和底面的夹角，必须大于0
     * @param {Number} aspect 近裁剪面的宽高比(width/height)
     * @param {Number} near 近裁剪面的位置，必须大于0
     * @param {Number} far 远裁剪面的位置，必须大于0
     * @return this
     */
    setPerspective(fovy, aspect, near, far) {
        const errMsg = "all arguments of setPerspective method must be Number!";
        if(arguments.length!==4){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e, rd, s, ct;

        if (near === far || aspect === 0) {
            throw 'null frustum';
        }
        if (near <= 0) {
            throw 'near <= 0';
        }
        if (far <= 0) {
            throw 'far <= 0';
        }

        fovy = Math.PI * fovy / 180 / 2;
        s = Math.sin(fovy);
        if (s === 0) {
            throw 'null frustum';
        }

        rd = 1 / (far - near);
        ct = Math.cos(fovy) / s;

        e = this._elements;

        e[0]  = ct / aspect;
        e[1]  = 0;
        e[2]  = 0;
        e[3]  = 0;

        e[4]  = 0;
        e[5]  = ct;
        e[6]  = 0;
        e[7]  = 0;

        e[8]  = 0;
        e[9]  = 0;
        e[10] = -(far + near) * rd;
        e[11] = -1;

        e[12] = 0;
        e[13] = 0;
        e[14] = -2 * near * far * rd;
        e[15] = 0;

        return this;
    }

    /**
     * 构造一个透视投影矩阵，并用当前矩阵右乘该视图投影矩阵
     * @param {Number} fovy 垂直视角，即可视空间顶面和底面的夹角，必须大于0
     * @param {Number} aspect 近裁剪面的宽高比(width/height)
     * @param {Number} near 近裁剪面的位置，必须大于0
     * @param {Number} far 远裁剪面的位置，必须大于0
     * @return this
     */
    perspective(fovy, aspect, near, far) {
        const errMsg = "all arguments of perspective method must be Number!";
        if(arguments.length!==4){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        return this.multiply(new hmap.util.Matrix4().setPerspective(fovy, aspect, near, far));
    }

    /**
     * 将矩阵设置为缩放矩阵
     * @param {Number} x X轴缩放因子
     * @param {Number} y Y轴缩放因子
     * @param {Number} z Z轴缩放因子
     * @return this
     */
    setScale(x, y, z) {
        const errMsg = "all arguments of setScale method must be Number!";
        if(arguments.length!==3){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e = this._elements;
        e[0] = x;  e[4] = 0;  e[8]  = 0;  e[12] = 0;
        e[1] = 0;  e[5] = y;  e[9]  = 0;  e[13] = 0;
        e[2] = 0;  e[6] = 0;  e[10] = z;  e[14] = 0;
        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;
        return this;
    }

    /**
     * 右乘缩放矩阵
     * @param {Number} x X轴缩放因子
     * @param {Number} y Y轴缩放因子
     * @param {Number} z Z轴缩放因子
     * @return this
     */
    scale(x, y, z) {
        const errMsg = "all arguments of scale method must be Number!";
        if(arguments.length!==3){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e = this._elements;
        e[0] *= x;  e[4] *= y;  e[8]  *= z;
        e[1] *= x;  e[5] *= y;  e[9]  *= z;
        e[2] *= x;  e[6] *= y;  e[10] *= z;
        e[3] *= x;  e[7] *= y;  e[11] *= z;
        return this;
    }

    /**
     * 将矩阵设置为平移矩阵
     * @param {Number} x X轴平移量
     * @param {Number} y Y轴平移量
     * @param {Number} z Z轴平移量
     * @return this
     */
    setTranslate(x, y, z) {
        const errMsg = "all arguments of setTranslate method must be Number!";
        if(arguments.length!==3){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e = this._elements;
        e[0] = 1;  e[4] = 0;  e[8]  = 0;  e[12] = x;
        e[1] = 0;  e[5] = 1;  e[9]  = 0;  e[13] = y;
        e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = z;
        e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;
        return this;
    }

    /**
     * 右乘平移矩阵
     * @param {Number} x X轴平移量
     * @param {Number} y Y轴平移量
     * @param {Number} z Z轴平移量
     * @return this
     */
    translate(x, y, z) {
        const errMsg = "all arguments of translate method must be Number!";
        if(arguments.length!==3){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e = this._elements;
        e[12] += e[0] * x + e[4] * y + e[8]  * z;
        e[13] += e[1] * x + e[5] * y + e[9]  * z;
        e[14] += e[2] * x + e[6] * y + e[10] * z;
        e[15] += e[3] * x + e[7] * y + e[11] * z;
        return this;
    }

    /**
     * 将矩阵设置为旋转矩阵，旋转轴向量可不归一化
     * @param {Number} angle 旋转角度
     * @param {Number} x 旋转轴向量的X轴坐标
     * @param {Number} y 旋转轴向量的Y轴坐标
     * @param {Number} z 旋转轴向量的Z轴坐标
     * @return this
     */
    setRotate(angle, x, y, z) {
        const errMsg = "all arguments of setRotate method must be Number!";
        if(arguments.length!==4){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;

        angle = Math.PI * angle / 180;
        e = this._elements;

        s = Math.sin(angle);
        c = Math.cos(angle);

        if (0 !== x && 0 === y && 0 === z) {
            // 绕X轴旋转
            if (x < 0) {
                s = -s;
            }
            e[0] = 1;  e[4] = 0;  e[ 8] = 0;  e[12] = 0;
            e[1] = 0;  e[5] = c;  e[ 9] =-s;  e[13] = 0;
            e[2] = 0;  e[6] = s;  e[10] = c;  e[14] = 0;
            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;
        } else if (0 === x && 0 !== y && 0 === z) {
            // 绕Y轴旋转
            if (y < 0) {
                s = -s;
            }
            e[0] = c;  e[4] = 0;  e[ 8] = s;  e[12] = 0;
            e[1] = 0;  e[5] = 1;  e[ 9] = 0;  e[13] = 0;
            e[2] =-s;  e[6] = 0;  e[10] = c;  e[14] = 0;
            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;
        } else if (0 === x && 0 === y && 0 !== z) {
            // 绕Z轴旋转
            if (z < 0) {
                s = -s;
            }
            e[0] = c;  e[4] =-s;  e[ 8] = 0;  e[12] = 0;
            e[1] = s;  e[5] = c;  e[ 9] = 0;  e[13] = 0;
            e[2] = 0;  e[6] = 0;  e[10] = 1;  e[14] = 0;
            e[3] = 0;  e[7] = 0;  e[11] = 0;  e[15] = 1;
        } else {
            // 绕其他轴旋转
            len = Math.sqrt(x*x + y*y + z*z);
            if (len !== 1) {
                rlen = 1 / len;
                x *= rlen;
                y *= rlen;
                z *= rlen;
            }
            nc = 1 - c;
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;

            e[ 0] = x*x*nc +  c;
            e[ 1] = xy *nc + zs;
            e[ 2] = zx *nc - ys;
            e[ 3] = 0;

            e[ 4] = xy *nc - zs;
            e[ 5] = y*y*nc +  c;
            e[ 6] = yz *nc + xs;
            e[ 7] = 0;

            e[ 8] = zx *nc + ys;
            e[ 9] = yz *nc - xs;
            e[10] = z*z*nc +  c;
            e[11] = 0;

            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }

        return this;
    }

    /**
     * 右乘旋转矩阵，旋转轴向量可不归一化
     * @param {Number} angle 旋转角度
     * @param {Number} x 旋转轴向量的X轴坐标
     * @param {Number} y 旋转轴向量的Y轴坐标
     * @param {Number} z 旋转轴向量的Z轴坐标
     * @return this
     */
    rotate(angle, x, y, z) {
        const errMsg = "all arguments of rotate method must be Number!";
        if(arguments.length!==4){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        return this.multiply(new hmap.util.Matrix4().setRotate(angle, x, y, z));
    }

    /**
     *  方法用来提取参数matrix4(4x4矩阵)的旋转分量.并返回当前的Matrix4(4x4矩阵).
     * */
    extractRotation(matrix4) {
        var v1 = new hmap.util.Vector3();
        var te = this._elements,me = matrix4.getElements();

        var scaleX = 1 / v1.fromArray( me, 0 ).length();        //第一行
        var scaleY = 1 / v1.fromArray( me, 4 ).length();        //第二行
        var scaleZ = 1 / v1.fromArray( me, 8 ).length();        //第三行

        te[ 0 ] = me[ 0 ] * scaleX;
        te[ 1 ] = me[ 1 ] * scaleX;
        te[ 2 ] = me[ 2 ] * scaleX;

        te[ 4 ] = me[ 4 ] * scaleY;
        te[ 5 ] = me[ 5 ] * scaleY;
        te[ 6 ] = me[ 6 ] * scaleY;

        te[ 8 ] = me[ 8 ] * scaleZ;
        te[ 9 ] = me[ 9 ] * scaleZ;
        te[ 10 ] = me[ 10 ] * scaleZ;

        return this;
    }

    /**
     *  矩阵增加一个欧拉角
     *  @param {hmap.util.Euler} euler 欧拉角对象
     * */
    makeRotationFromEuler( euler ) {
        if (!(euler && euler instanceof hmap.util.Euler)) {
            console.error( 'hmap.util.Matrix4: .makeRotationFromEuler() expects a Euler rotation' );
        }
        var te = this._elements;
        var x = euler.getX(), y = euler.getY(), z = euler.getZ();
        var a = Math.cos( x ), b = Math.sin( x );
        var c = Math.cos( y ), d = Math.sin( y );
        var e = Math.cos( z ), f = Math.sin( z );

        const order = euler.getOrder();
        if ( order === 'XYZ' ) {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[ 0 ] = c * e;
            te[ 4 ] = - c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = - b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;
        } else if ( order === 'YXZ' ) {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;
        } else if ( order === 'ZXY' ) {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[ 0 ] = ce - df * b;
            te[ 4 ] = - a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = - a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;
        } else if ( order === 'ZYX' ) {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = - d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;
        } else if ( order === 'YZX' ) {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b * e;

            te[ 2 ] = - d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;
        } else if ( order === 'XZY' ) {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[ 0 ] = c * e;
            te[ 4 ] = - f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;
        }
        // bottom row
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;
        // last column
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;
        return this;
    }

    /**
     *  将目标矩阵拷贝到当前矩阵中
     *  @param {hmap.util.Matrix} 目标矩阵
     * */
    copy( matrix ) {
        var te = this._elements,me = matrix.getElements();
        te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
        te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
        te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
        te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
        return this;
    }

    /**
     *  将目标矩阵中的位置信息拷贝到当前矩阵中(4*4矩阵中的第12、13、14个元素)
     *  @param {hmap.util.Matrix} 目标矩阵
     * */
    copyPosition(matrix) {
        let te = this._elements, me = matrix.getElements();
        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];
        return this;
    }

    /**
     *  将目标向量的位置信息设置到当前矩阵中
     *  @param {hmap.util.Vector3} 目标矩阵
     * */
    setPosition( vector3 ){
        let te = this._elements;
        const xyz = vector3.getElements();
        te[ 12 ] = xyz[ 0 ];
        te[ 13 ] = xyz[ 1 ];
        te[ 14 ] = xyz[ 2 ];
        return this;
    }

    /**
     * 将矩阵设为视图矩阵
     * @param {Number} eyeX 视点X坐标
     * @param {Number} eyeY 视点Y坐标
     * @param {Number} eyeZ 视点Z坐标
     * @param {Number} centerX 观察目标点X坐标
     * @param {Number} centerY 观察目标点Y坐标
     * @param {Number} centerZ 观察目标点Z坐标
     * @param {Number} upX 上方向X分量
     * @param {Number} upY 上方向Y分量
     * @param {Number} upZ 上方向Z分量
     * @return this
     */
    setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
        const errMsg = "all arguments of setLookAt method must be Number!";
        if(arguments.length!==9){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        let e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;

        fx = centerX - eyeX;
        fy = centerY - eyeY;
        fz = centerZ - eyeZ;

        // 归一化f
        rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
        fx *= rlf;
        fy *= rlf;
        fz *= rlf;

        // 计算f和up的外积
        sx = fy * upZ - fz * upY;
        sy = fz * upX - fx * upZ;
        sz = fx * upY - fy * upX;

        // 归一化s
        rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
        sx *= rls;
        sy *= rls;
        sz *= rls;

        // 计算s和f的外积
        ux = sy * fz - sz * fy;
        uy = sz * fx - sx * fz;
        uz = sx * fy - sy * fx;

        // 将各元素设置到this矩阵中
        e = this._elements;
        e[0] = sx;
        e[1] = ux;
        e[2] = -fx;
        e[3] = 0;

        e[4] = sy;
        e[5] = uy;
        e[6] = -fy;
        e[7] = 0;

        e[8] = sz;
        e[9] = uz;
        e[10] = -fz;
        e[11] = 0;

        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        // 平移
        return this.translate(-eyeX, -eyeY, -eyeZ);
    }

    /**
     * 右乘视图矩阵
     * @param {Number} eyeX 视点X坐标
     * @param {Number} eyeY 视点Y坐标
     * @param {Number} eyeZ 视点Z坐标
     * @param {Number} centerX 观察目标点X坐标
     * @param {Number} centerY 观察目标点Y坐标
     * @param {Number} centerZ 观察目标点Z坐标
     * @param {Number} upX 上方向X分量
     * @param {Number} upY 上方向Y分量
     * @param {Number} upZ 上方向Z分量
     * @return this
     */
    lookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
        const errMsg = "all arguments of lookAt method must be Number!";
        if(arguments.length!==9){
            throw errMsg;
        }
        for(let i in arguments){
            if(!Number.isFinite(arguments[i])){
                throw errMsg;
            }
        }
        return this.multiply(new hmap.util.Matrix4()
                    .setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));
    }

    /**
     * 判断两个矩阵是否相等
     * @param {hmap.util.Matrix4} mat 传入矩阵
     * @returns {Boolean}
     */
    equals(mat){
        let e = this.getElements();
        let otherElements = mat.getElements();
        let result = true;
        for(let i in e){
            if(e[i]!==otherElements[i]){
                result = false;
            }
        }
        return result;
    }

    clone(){
        return new hmap.util.Matrix4(this._elements);
    }

    /**
     *  根据position、quaternion以及scale组装matrix
     * */
    compose(position, quaternion, scale) {
        this.makeRotationFromQuaternion( quaternion );
        let scaleArray = scale.getElements();
        this.scale(scaleArray[0],scaleArray[1],scaleArray[2]);
        this.setPosition( position );
        return this;
    }

    /**
     * 根据数组形式的position,quaternion,scale组装matrix
     * @param translation [x,y,z]
     * @param quaternion [x,y,z,w]
     * @param scale [x,y,z]
     * returns this
     */
    composeFromArray(translation,quaternion,scale){
        let dst=this._elements;

        const x = quaternion[0];
        const y = quaternion[1];
        const z = quaternion[2];
        const w = quaternion[3];

        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;

        const xx = x * x2;
        const xy = x * y2;
        const xz = x * z2;

        const yy = y * y2;
        const yz = y * z2;
        const zz = z * z2;

        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;

        const sx = scale[0];
        const sy = scale[1];
        const sz = scale[2];

        dst[0] = (1 - (yy + zz)) * sx;
        dst[1] = (xy + wz) * sx;
        dst[2] = (xz - wy) * sx;
        dst[3] = 0;

        dst[4] = (xy - wz) * sy;
        dst[5] = (1 - (xx + zz)) * sy;
        dst[6] = (yz + wx) * sy;
        dst[7] = 0;

        dst[ 8] = (xz + wy) * sz;
        dst[ 9] = (yz - wx) * sz;
        dst[10] = (1 - (xx + yy)) * sz;
        dst[11] = 0;

        dst[12] = translation[0];
        dst[13] = translation[1];
        dst[14] = translation[2];
        dst[15] = 1;

        return this;
    }

    /**
     *  从Quaternion四元数中获取旋转角
     *  @param {hmap.util.Quaternion} q 旋转角四元数
     * */
    makeRotationFromQuaternion( q ) {
        var te = this._elements;
        var x = q.getX(), y = q.getY(), z = q.getZ(), w = q.getW();
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[ 0 ] = 1 - ( yy + zz );
        te[ 4 ] = xy - wz;
        te[ 8 ] = xz + wy;

        te[ 1 ] = xy + wz;
        te[ 5 ] = 1 - ( xx + zz );
        te[ 9 ] = yz - wx;

        te[ 2 ] = xz - wy;
        te[ 6 ] = yz + wx;
        te[ 10 ] = 1 - ( xx + yy );

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;
    }

    /**
     *  根据position、quaternion以及scale组装matrix
     * */
    decompose( position, quaternion, scale ) {
        var vector = new hmap.util.Vector3();
        var matrix = new hmap.util.Matrix4();

        var te = this._elements;

        var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
        var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
        var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if ( det < 0 ) sx = - sx;

        position.getElements()[0] = te[ 12 ];
        position.getElements()[1] = te[ 13 ];
        position.getElements()[2] = te[ 14 ];

        // scale the rotation part
        matrix.copy( this );

        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;

        matrix.getElements()[ 0 ] *= invSX;
        matrix.getElements()[ 1 ] *= invSX;
        matrix.getElements()[ 2 ] *= invSX;

        matrix.getElements()[ 4 ] *= invSY;
        matrix.getElements()[ 5 ] *= invSY;
        matrix.getElements()[ 6 ] *= invSY;

        matrix.getElements()[ 8 ] *= invSZ;
        matrix.getElements()[ 9 ] *= invSZ;
        matrix.getElements()[ 10 ] *= invSZ;

        quaternion.setFromRotationMatrix( matrix );

        scale.getElements()[0] = sx;
        scale.getElements()[1] = sy;
        scale.getElements()[2] = sz;

        return this;
    }

    /**
     *  行列式
     * */
    determinant() {
        var te = this._elements;
        var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
        var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
        var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
        var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return (
            n41 * (
                + n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34
            ) +
            n42 * (
                + n11 * n23 * n34
                - n11 * n24 * n33
                + n14 * n21 * n33
                - n13 * n21 * n34
                + n13 * n24 * n31
                - n14 * n23 * n31
            ) +
            n43 * (
                + n11 * n24 * n32
                - n11 * n22 * n34
                - n14 * n21 * n32
                + n12 * n21 * n34
                + n14 * n22 * n31
                - n12 * n24 * n31
            ) +
            n44 * (
                - n13 * n22 * n31
                - n11 * n23 * n32
                + n11 * n22 * n33
                + n13 * n21 * n32
                - n12 * n21 * n33
                + n12 * n23 * n31
            )
        );
    }

    /**
     *  将旋转和平移转追加到指定的4阶矩阵上
     * */
    static fromRotationTranslation(rotation, translation, result) {
        if(!(rotation instanceof hmap.util.Matrix3)){
            rotation = new hmap.util.Matrix3();
        }
        if(!translation || !(translation instanceof hmap.util.Vector3)){
            translation = new hmap.util.Vector3();
        }

        if (!(result instanceof hmap.util.Matrix4)) {
            let rotationToArray = rotation.getElements();
            return new hmap.util.Matrix4(new Float32Array([rotationToArray[0], rotationToArray[3], rotationToArray[6], translation.getElements()[0],
                rotationToArray[1], rotationToArray[4], rotationToArray[7], translation.getElements()[1],
                rotationToArray[2], rotationToArray[5], rotationToArray[8], translation.getElements()[2],
                0.0,         0.0,         0.0,           1.0]));
        }

        let re = result.getElements();
        re[0] = rotation[0];
        re[1] = rotation[1];
        re[2] = rotation[2];
        re[3] = 0.0;
        re[4] = rotation[3];
        re[5] = rotation[4];
        re[6] = rotation[5];
        re[7] = 0.0;
        re[8] = rotation[6];
        re[9] = rotation[7];
        re[10] = rotation[8];
        re[11] = 0.0;
        re[12] = translation.getElements()[0];
        re[13] = translation.getElements()[1];
        re[14] = translation.getElements()[2];
        re[15] = 1.0;
        return result;
    }
};
;"use strict";
hmap.util = hmap.util || {};
/**
 * 3维向量
 * @type {hmap.util.Vector3}
 */
hmap.util.Vector3 = class {
    /**
     * 使用3个坐标值构造3维向量
     * @param x X坐标值
     * @param y Y坐标值
     * @param z Z坐标值
     */
    constructor(x = 0, y = 0, z = 0) {
        this.ARRAY_TYPE = Float32Array;
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
            throw "every component of vector must be a number!";
        }
        this._elements = new this.ARRAY_TYPE(3);
        this._elements[0] = x;
        this._elements[1] = y;
        this._elements[2] = z;
        this.CLASS_NAME = "hmap.util.Vector3";
    }

    /**
     * 设置向量坐标值
     * @param x
     * @param y
     * @param z
     */
    set(x, y, z) {
        if (Number.isNaN(x) || Number.isNaN(y) || Number.isNaN(z)) {
            throw "every component of vector must be a number!";
        }
        this._elements[0] = x;
        this._elements[1] = y;
        this._elements[2] = z;

        return this;
    }

    /**
     * 根据坐标值数组，设置当前三维向量
     * @param {Array} array 坐标值数组
     * @param {Number} offset 偏移值
     */
    fromArray(array,offset) {
        if ( offset === undefined ) offset = 0;
        this._elements[0] = array[offset];
        this._elements[1] = array[offset + 1];
        this._elements[2] = array[offset + 2];
        return this;
    }

    /**
     * 获取向量所有元素，返回包含三个元素的数组
     * @returns {ARRAY_TYPE}
     */
    getElements() {
        return this._elements;
    }

    /**
     * 获取向量指定维的坐标
     * @param {Number} index
     * @returns {Number}
     */
    getElement(index) {
        if (index < 0 || index > 2 || !Number.isInteger(index)) {
            throw "index must be man integer ore than 0 and less than 3!";
        }
        return this._elements[index];
    }

    /**
     * 加上一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector3} vec 被加向量
     * @returns this
     */
    add(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }

        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] + e[0];
        resultElements[1] = this._elements[1] + e[1];
        resultElements[2] = this._elements[2] + e[2];

        return this;
    }

    /**
     * 减去一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector3} vec 被减向量
     * @returns this
     */
    substract(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }
        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] - e[0];
        resultElements[1] = this._elements[1] - e[1];
        resultElements[2] = this._elements[2] - e[2];
        return this;
    }

    /**
     * 乘以一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector3} vec 被乘向量
     * @returns this 结果向量，每个分量的值为原向量各分量相乘的结果
     */
    multiply(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }

        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] * e[0];
        resultElements[1] = this._elements[1] * e[1];
        resultElements[2] = this._elements[2] * e[2];

        return this;
    }

    /**
     * 除以一个向量，结果存储在当前向量中，每个分量的值为原向量各分量相除的结果。
     * @param {hmap.util.Vector3} vec 被除向量
     * @returns this 结果向量，每个分量的值为原向量各分量相除的结果
     */
    divide(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }

        let elements = vec.getElements();
        for (let e in elements) {
            if (e === 0) {
                throw "all elements in dividend must be lager than 0!";
            }
        }
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] / elements[0];
        resultElements[1] = this._elements[1] / elements[1];
        resultElements[2] = this._elements[2] / elements[2];

        return this;
    }

    /**
     * 向量内积
     * @param {hmap.util.Vector3} vec 传入向量
     * @returns {Number}
     */
    dot(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }
        const e = vec.getElements();
        const result = this._elements[0] * e[0] + this._elements[1] * e[1] + this._elements[2] * e[2];
        return result;
    }

    /**
     * 向量外积，结果存储在当前向量中
     * @param {hmap.util.Vector3} vec 传入向量
     * @returns this
     */
    cross(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }
        let e = vec.getElements();

        let ax = this._elements[0], ay = this._elements[1], az = this._elements[2];
        let bx = e[0], by = e[1], bz = e[2];

        this._elements[0] = ay * bz - az * by;
        this._elements[1] = az * bx - ax * bz;
        this._elements[2] = ax * by - ay * bx;

        return this;
    }

    /**
     * 乘以标量，结果存储在当前向量中
     * @param {Number} s 标量
     * @returns this
     */
    multiplyScalar(s) {
        if (Number.isNaN(s)) {
            throw "s must be a Number!";
        }
        let e = this.getElements();
        e[0] *= s;
        e[1] *= s;
        e[2] *= s;

        return this;
    }

    /**
     * 除以标量，结果存储在当前向量中
     * @param {Number} s 标量
     * @returns this
     */
    divideScalar(s) {
        if (Number.isNaN(s) || s === 0) {
            throw "s must be a non-zero Number!";
        }
        let e = this._elements;
        e[0] /= s;
        e[1] /= s;
        e[2] /= s;

        return this;
    }

    /**
     * 向量长度
     * @returns {hmap.util.Number} 长度
     */
    length() {
        const e = this._elements;
        const result = Math.sqrt(e[0] * e[0] + e[1] * e[1]
            + e[2] * e[2]);
        return result;
    }

    /**
     * 向量距离
     * @param {hmap.util.Vector3} vec 另一个向量
     * @returns {Number} 距离
     */
    distanceTo(vec) {
        if (!(vec instanceof hmap.util.Vector3)) {
            throw "vec must be instance of Vector3!";
        }
        let fromElement = this.getElements();
        let toElement = vec.getElements();
        let x = toElement[0] - fromElement[0];
        let y = toElement[1] - fromElement[1];
        let z = toElement[2] - fromElement[2];

        const result = Math.sqrt(x * x + y * y + z * z + w * w);
        return result;
    }

    /**
     * 对向量所有分量取负值，结果存储在当前向量中
     * @returns this
     */
    negate() {
        let e = this._elements;
        e[0] = -e[0];
        e[1] = -e[1];
        e[2] = -e[2];

        return this;
    }

    /**
     * 归一化向量，结果存储在当前向量中
     * @returns this
     */
    normalize() {
        let e = this._elements;
        let x = e[0];
        let y = e[1];
        let z = e[2];

        let len = Math.sqrt(x * x + y * y + z * z);
        if (len > 0) {
            e[0] = x / len;
            e[1] = y / len;
            e[2] = z / len;
        } else {
            e[0] = 0;
            e[1] = 0;
            e[2] = 0;
        }
        return this;
    }

    /**
     * 计算与另一向量的夹角
     * @param {hmap.util.Vector3} vec 传入向量
     * @returns {Number} 两向量夹角的弧度值
     */
    angle(vec) {
        const result = Math.acos(this.dot(vec) / (this.length() * vec.length()));
        return result;
    }

    /**
     *  将三维向量通过3阶矩阵进行转换
     *  @param {hmap.util.Matrix3} matrix3 3阶矩阵
     *  @returns {hmap.util.Vector3}  经转换后的三维向量
     */
    applyMatrix3( matrix3 ) {
        let x = this._elements[0], y = this._elements[1], z = this._elements[2],
            element = matrix3.getElements();
        this._elements[0] = element[ 0 ] * x + element[ 3 ] * y + element[ 6 ] * z;
        this._elements[1] = element[ 1 ] * x + element[ 4 ] * y + element[ 7 ] * z;
        this._elements[2] = element[ 2 ] * x + element[ 5 ] * y + element[ 8 ] * z;
        return this;
    }

    /**
     *  将三维向量通过4阶矩阵进行转换
     *  @param {hmap.util.Matrix4} matrix4 4阶矩阵
     *  @returns {hmap.util.Vector3} 经转换后的三维向量
     */
    applyMatrix4( matrix4 ) {
        let x = this._elements[0], y = this._elements[1], z = this._elements[2],
            element = matrix4.getElements();
        let w = 1 / ( element[ 3 ] * x + element[ 7 ] * y + element[ 11 ] * z + element[ 15 ] );
        this._elements[0] = ( element[ 0 ] * x + element[ 4 ] * y + element[ 8 ] * z + element[ 12 ] ) * w;
        this._elements[1] = ( element[ 1 ] * x + element[ 5 ] * y + element[ 9 ] * z + element[ 13 ] ) * w;
        this._elements[2] = ( element[ 2 ] * x + element[ 6 ] * y + element[ 10 ] * z + element[ 14 ] ) * w;
        return this;
    }

    /**
     * 计算与另一向量的绕法向量n的旋转角，默认计算在x-y坐标平面的旋转角。
	 * 当前向量与另一向量的旋转角的定义：从当前向量开始，逆时针旋转，转到另一向量时所转过的角度，取值范围是0~360度。
     * @param {hmap.util.Vector3} vec 另一向量
     * @param {hmap.util.Vector3} n 法向量，默认与Z轴平行
     * @returns {Number} 旋转角的弧度值
     */
    rotateAngle(vec, n = new hmap.util.Vector3(0, 0, 1)) {
        let angle = this.angle(vec);
        const signNum = n.dot(this.clone().cross(vec));
        if (signNum < 0) {
            angle = 2 * Math.PI - angle;
        }
        return angle;
    }

    /********
     * 判断两个向量是否相等
     * @param {hmap.util.Vector3} vec 传入向量
     * @returns {Boolean}
     */
    equals(vec) {
        let e = this.getElements();
        let otherElements = vec.getElements();
        let result = true;
        for (let i in e) {
            if (e[i] !== otherElements[i]) {
                result = false;
                break;
            }
        }
        return result;
    }

    /**
     * 克隆向量对象
     * @returns {hmap.util.Vector3}
     */
    clone() {
        let oldElements = this._elements;
        return new hmap.util.Vector3(oldElements[0], oldElements[1], oldElements[2]);
    }

    /**
     * 设置特定维度的值
     * @param {Number} index 向量索引
     * @param {Number} value 值
     * @returns this
     */
    setElement(index, value) {
        if (index < 0 || index > 2 || !Number.isInteger(index)) {
            throw "index must be an integer number more than 0 and less than 3!";
        }
        this._elements[index] = value;
        return this;
    }

};
;"use strict";
hmap.util = hmap.util || {};
/**
 * 4维向量
 * @type {hmap.util.Vector4}
 */
hmap.util.Vector4 = class {
    /**
     * 使用4个坐标值构造4维向量
     * @param x X坐标值
     * @param y Y坐标值
     * @param z Z坐标值
     * @param w W坐标值
     */
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.ARRAY_TYPE = Float32Array;
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z) || !Number.isFinite(w)) {
            throw "every component of vector must be a number!";
        }
        this._elements = new this.ARRAY_TYPE(4);
        this._elements[0] = x;
        this._elements[1] = y;
        this._elements[2] = z;
        this._elements[3] = w;
        this.CLASS_NAME = "hmap.util.Vector4";
    }

    /**
     * 设置向量坐标值
     * @param x
     * @param y
     * @param z
     * @param w
     */
    set(x, y, z, w) {
        this._elements[0] = x;
        this._elements[1] = y;
        this._elements[2] = z;
        this._elements[3] = w;
    }

    /**
     * 获取向量所有元素，返回包含三个元素的数组
     * @returns {ARRAY_TYPE}
     */
    getElements() {
        return this._elements;
    }

    /**
     * 获取向量指定维的坐标
     * @param {Number} index
     * @returns {Number}
     */
    getElement(index) {
        if (index < 0 || index > 3 || !Number.isInteger(index)) {
            throw "index must be an integer more than 0 and less than 4!";
        }
        return this._elements[index];
    }

    /**
     * 加上一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector4} vec 被加向量
     * @returns this
     */
    add(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }

        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] + e[0];
        resultElements[1] = this._elements[1] + e[1];
        resultElements[2] = this._elements[2] + e[2];
        resultElements[3] = this._elements[3] + e[3];

        return this;
    }

    /**
     * 减去一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector4} vec 被减向量
     * @returns this
     */
    substract(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }

        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] - e[0];
        resultElements[1] = this._elements[1] - e[1];
        resultElements[2] = this._elements[2] - e[2];
        resultElements[3] = this._elements[3] - e[3];

        return this;
    }

    /**
     * 乘以一个向量，结果存储在当前向量中
     * @param {hmap.util.Vector4} vec 被乘向量
     * @returns this 结果向量，每个分量的值为原向量各分量相乘的结果
     */
    multiply(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }

        let e = vec.getElements();
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] * e[0];
        resultElements[1] = this._elements[1] * e[1];
        resultElements[2] = this._elements[2] * e[2];
        resultElements[3] = this._elements[3] * e[3];

        return this;
    }

    /**
     * 除以一个向量，结果存储在当前向量中，每个分量的值为原向量各分量相除的结果。
     * @param {hmap.util.Vector4} vec 被除向量
     * @returns this 结果向量，每个分量的值为原向量各分量相除的结果
     */
    divide(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }

        let elements = vec.getElements();
        for (let e in elements) {
            if (e === 0) {
                throw "all elements in dividend must be lager than 0!";
            }
        }
        let resultElements = this.getElements();

        resultElements[0] = this._elements[0] / elements[0];
        resultElements[1] = this._elements[1] / elements[1];
        resultElements[2] = this._elements[2] / elements[2];
        resultElements[3] = this._elements[3] / elements[3];

        return this;
    }

    /**
     * 向量内积
     * @param {hmap.util.Vector4} vec 传入向量
     * @returns {Number}
     */
    dot(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }
        let e = vec.getElements();
        const result = this._elements[0] * e[0] + this._elements[1] * e[1]
            + this._elements[2] * e[2] + this._elements[3] * e[3];
        return result;
    }

    /**
     * 计算两个向量前三个元素构成的三维向量外积，结果存储在当前向量中，当前向量的第四个元素不变。
     * @param {hmap.util.Vector4} vec 传入向量
     * @returns this
     */
    cross(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }
        let e = vec.getElements();

        let ax = this._elements[0], ay = this._elements[1], az = this._elements[2];
        let bx = e[0], by = e[1], bz = e[2];

        this._elements[0] = ay * bz - az * by;
        this._elements[1] = az * bx - ax * bz;
        this._elements[2] = ax * by - ay * bx;

        return this;
    }

    /**
     * 乘以标量，结果存储在当前向量中
     * @param {Number} s 标量
     * @returns this
     */
    multiplyScalar(s) {
        if (Number.isNaN(s)) {
            throw "s must be a Number!";
        }
        let e = this.getElements();
        e[0] *= s;
        e[1] *= s;
        e[2] *= s;
        e[3] *= s;

        return this;
    }

    /**
     * 除以标量，结果存储在当前向量中
     * @param {Number} s 标量
     * @returns this
     */
    divideScalar(s) {
        if (Number.isNaN(s) || s === 0) {
            throw "s must be a Number!";
        }
        let e = this.getElements();
        e[0] /= s;
        e[1] /= s;
        e[2] /= s;
        e[3] /= s;

        return this;
    }

    /**
     * 向量长度
     * @returns {hmap.util.Number} 长度
     */
    length() {
        let e = this.getElements();
        const result = Math.sqrt(e[0] * e[0] + e[1] * e[1]
            + e[2] * e[2] + e[3] * e[3]);
        return result;
    }

    /**
     * 向量距离
     * @param {hmap.util.Vector4} vec 另一个向量
     * @returns {Number} 距离
     */
    distance(vec) {
        if (!(vec instanceof hmap.util.Vector4)) {
            throw "vec must be instance of Vector4!";
        }
        let fromElement = this.getElements();
        let toElement = vec.getElements();
        let x = toElement[0] - fromElement[0];
        let y = toElement[1] - fromElement[1];
        let z = toElement[2] - fromElement[2];
        let w = toElement[3] - fromElement[3];

        const result =  Math.sqrt(x * x + y * y + z * z + w * w);
        return result;
    }

    /**
     * 对向量所有分量取负值，结果存储在当前向量中
     * @returns this
     */
    negate() {
        let e = this.getElements();
        e[0] = -e[0];
        e[1] = -e[1];
        e[2] = -e[2];
        e[3] = -e[3];

        return this;
    }

    /**
     * 归一化向量，结果存储在当前向量中
     * @returns this
     */
    normalize() {
        let e = this.getElements();
        let x = e[0];
        let y = e[1];
        let z = e[2];
        let w = e[3];

        let len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len > 0) {
            e[0] = x / len;
            e[1] = y / len;
            e[2] = z / len;
            e[3] = w / len;

            return this;
        } else {
            throw "the length of vector must be lager than 0!";
        }
    }

    /********
     * 判断两个向量是否相等
     * @param {hmap.util.Vector4} vec 传入向量
     * @returns {Boolean}
     */
    equals(vec) {
        let e = this.getElements();
        let otherElements = vec.getElements();
        let result = true;
        for (let i in e) {
            if (e[i] !== otherElements[i]) {
                result = false;
            }
        }
        return result;
    }

    /**
     * 克隆向量对象
     * @returns {hmap.util.Vector4}
     */
    clone() {
        let oldElements = this.getElements();
        return new hmap.util.Vector4(oldElements[0], oldElements[1], oldElements[2], oldElements[3]);
    }
};
;"use strict";
hmap.util=hmap.util||{};
hmap.util.Ajax=class{
    static get(url,format,success,fault,signal=null){
        /**
         * options 包括：
         * method：请求方法，常用的有get和post；
         * headers：请求头信息，最常用的就是表单格式的数据：”Content-type”:”application/x-www-form-urlencoded”；
         * mode：控制是否允许跨域。same-origin（同源请求）、no-cors（默认）和cros（允许跨域请求）；
         * cache：关于缓存的一些设置；
         * body：要发送到后台的参数，可以为ArrayBuffer，String，FormData等类型；
         * @private
         */
        let options={signal,method:"GET",mode:'cors'};
        // if(signal){
        //     options={signal,method:"GET",mode:'cors'};
        // }else {
        //     options={method:"GET",mode:'cors'};
        // }
        return fetch(url,options).then(response=>{
            if(response.status===200){
                switch(format){
                    case "blob":
                        return response.blob();
                    case "text":
                        return response.text();
                    case "json":
                        return response.json();
                    case "arrayBuffer":
                        return response.arrayBuffer();
                    case "formData":
                        return response.formData();
                    default:
                        throw new Error("unsupport format");
                }
           }
        }).then(result=>{
            if(success){
                return success(result);
            }
        }).catch(err=>{
                if (err.name === 'AbortError') {
                    //console.log('Fetch aborted');
                } else {
                    //console.log('Another error');
                }
        });
    }
    // static async asyncGet(url,format){
    //     let options={method:"GET"};
    //     let response=await fetch(url,options);
    //     return response;
    // }


    /**
     * 发送post请求
     * @private
     */
    static post(url,params,responseFormat,success,error){
        //组装参数
        let body="";
        for(let key in params){
            body+=key+"="+params[key]+"&";
        }
        body.substring(0, body.length - 1);
        
        return fetch(url, {
                method: "POST",
                mode: "cors",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                body:body
        }).then(
            function(response) {
                switch(responseFormat){
                    case "blob":
                        return response.blob();
                    case "text":
                        return response.text();
                    case "json":
                        return response.json();
                    case "arrayBuffer":
                        return response.arrayBuffer();
                    case "formData":
                        return response.formData();
                    default:
                        throw new Error("unsupport format");
                }
            }
        ).then(
            function(result){
                return success(result);
            },
            function(err) {
                return error(err);
            }
        ).catch(err=>{
        });



        // .catch(
        //     function(e){
        //         error(e);
        //     }
        // );





    }
};;"use strict";
hmap.Camera = class {
    constructor(eyeX, eyeY, resolution, containerWidth, containerHeight, crs) {
        if (!Number.isFinite(eyeX) || !Number.isFinite(eyeY) || !Number.isFinite(resolution) ||
            !Number.isFinite(containerWidth) || !Number.isFinite(containerHeight)) {
            throw "eyeX, eyeY, resolution, containerWidth, containerHeight must be type of Number";
        }
        this._eyeX = eyeX;
        this._eyeY = eyeY;
        this._fovy = 60;
        this._halfFovy = this._fovy / 2;
        this._containerWidth = containerWidth;
        this._containerHeight = containerHeight;
        this._aspect = containerWidth / containerHeight;
        this._resolution = resolution;
        this._rotateX = 0;
        this._rotateZ = 0;
        // 雾化变量
        this._fogStartFactor = 1.5; // 雾化开始时屏幕上可见的地理范围占未旋转时地理范围的倍数
        this._fogEndFactor = 2; // 雾化结束时屏幕上可见的地理范围占未旋转时地理范围的倍数
        this._fogExtentTopRatio = 1.1; // 地理范围扩展比例

        this._rotateXMatrix = new hmap.util.Matrix4();
        this._crs = crs;
        this.setResolution(resolution);
        this._rotateZMatrix = new hmap.util.Matrix4().setRotate(this._rotateZ, 0, 0, 1);
        this._viewMatrix=new hmap.util.Matrix4();
        this._vMatrix=new hmap.util.Matrix4();
        this._vpMatrix=new hmap.util.Matrix4();
    }

    //获取远平面距离
    getFPlaneDistance() {
        return this._far;
    }

    // 重新设置地图视图的宽度和高度
    updateContainerSize(width, height) {
        this._containerWidth = width;
        this._containerHeight = height;
        this._aspect = width / height;
        this._projMatrix =this._projMatrix.setIdentity().setPerspective(this._fovy, this._aspect, this._near, this._far);
    }

    // 获得眼睛在没有旋转时相对地面的高度
    getEyeZ() {
        return this._eyeZ;
    }

    getRotateX() {
        return this._rotateX;
    }

    getRotateZ() {
        return this._rotateZ;
    }

    getResolution() {
        return this._resolution;
    }

    setCrs(crs) {
        this._crs = crs;
    }

    // 获得眼睛距离地面的高度
    _getEyeH(eyeZ, rotateX) {
        return eyeZ * Math.cos((rotateX) * Math.PI / 180);
    }

    // 对世界坐标系中的对象绕X轴旋转angle角
    rotateX(angle) {
        this._rotateX += angle;
        this._updateRotateXMatrix(this._rotateX, this._eyeZ);
    }

    _updateRotateXMatrix(rotateX, eyeZ) {
        this._rotateXMatrix = this._rotateXMatrix.setTranslate(0, 0, -eyeZ).rotate(rotateX, 1, 0, 0).translate(0, 0, eyeZ);
    }

    // 对世界坐标系中的对象绕Z轴旋转angle角
    rotateZ(angle) {
        this._rotateZ += angle;
        this._rotateZMatrix = this._rotateZMatrix.setRotate(this._rotateZ, 0, 0, 1);
    }

    // 旋转矩阵恢复默认值
    resetRotate() {
        this._rotateXMatrix.setIdentity();
        this._rotateZMatrix.setIdentity();
        this._rotateX = 0;
        this._rotateZ = 0;
    }

    // 视图正矩阵
    getVMatrix() {
        return this._vMatrix.setIdentity().setTranslate(-this._eyeX, -this._eyeY, -this._eyeZ);
    }

    // 视图矩阵
    getViewMatrix() {
        return this._viewMatrix.setIdentity().multiply(this._rotateXMatrix).multiply(this._rotateZMatrix).multiply(this.getVMatrix());
    }

    // 投影矩阵
    getPMatrix() {
        return this._projMatrix;
    }

    // vp矩阵
    getVPMatrix() {
        return this._vpMatrix.setIdentity().multiply(this.getPMatrix()).multiply(this.getViewMatrix());
    }

    // 平移和缩放时设置地图中心和级别，由于都不影响视图矩阵的旋转分量，将视图矩阵向Eye的负方向平移就可以
    setCenter(center, resolution) {
        this._eyeX = center.getOrdinate("X");
        this._eyeY = center.getOrdinate("Y");
        this.setResolution(resolution);
    }

    _recalculateYRanges() {
        // 计算雾化参数
        this._halfYRange = this._eyeZ * Math.tan(this._fovy / 2 * Math.PI / 180); // 在正射视角时，顶边到中心的距离
        this._maxYRange = this._halfYRange * this._fogStartFactor; // 顶边到中心的最大距离，超过时开始雾化
    }

    //设置地图分辨率
    setResolution(resolution) {
        this._resolution = resolution;
        this._eyeZ = this._getEyeZByResolution(resolution);
        this._updateRotateXMatrix(this._rotateX, this._eyeZ);

        this._recalculateYRanges();

        // 更新近裁面和原裁面
        this._far = this._getFarthestEyeZ();
        //this._near=this._far / 50;
        this._near =Math.max(this._far / 50,this._eyeZ/3);
        this._projMatrix = new hmap.util.Matrix4().setPerspective(this._fovy, this._aspect, this._near, this._far);
    }

    _getEyeZByResolution(resolution) {
        const halfFovy = this._fovy / 2;
        const halfYSpan = this._containerHeight / 2 * resolution;
        const h = halfYSpan / Math.tan(halfFovy * Math.PI / 180);
        return h;
    }

    _getExtentTopToCenterAngle(fogExtentTopRatio = this._fogExtentTopRatio) {
        const maxTopToCenterY = this._maxYRange * fogExtentTopRatio;
        const maxTopToCenterAngleY = this._getAngleYByTargetToCenter(maxTopToCenterY);
        if (maxTopToCenterAngleY < this._halfFovy) {
            return maxTopToCenterAngleY;
        } else {
            return this._halfFovy;
        }
    }

    _getExtentTopToCenterY(fogExtentTopRatio = this._fogExtentTopRatio, isFogShown) {
        if (isFogShown) {
            return this._maxYRange * fogExtentTopRatio;
        } else {
            return this._getTargetToCenterYSpan(-this._rotateX, this._halfFovy); // 顶边到中心的距离
        }
    }

    // 获取可视地图范围
    getExtent() {
        const halfFovy = this._fovy / 2;

        // 计算旋转X轴时可见的梯形范围
        const bottomToCenterY = this._getTargetToCenterYSpan(-this._rotateX, -halfFovy); // 底边到中心的距离
        const bottomHalfXSpan = this._getTargetToCenterXSpanByAspect(-this._rotateX, -halfFovy); // 底边宽度的一半
        const topAngleY = this._getExtentTopToCenterAngle(this._fogExtentTopRatio);
        const topToCenterY = this._getExtentTopToCenterY(this._fogExtentTopRatio, topAngleY !== this._halfFovy);
        const topHalfXSpan = this._getTargetToCenterXSpanByAspect(-this._rotateX, topAngleY); // 顶边宽度的一半

        // 绕地图中心旋转可见梯形范围，旋转方向与地图旋转方向相反
        const cornerPoints = new hmap.geom.MultiPoint([
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + bottomHalfXSpan, this._eyeY + bottomToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - bottomHalfXSpan, this._eyeY + bottomToCenterY))]);
        cornerPoints.rotate("Z", -this._rotateZ, new hmap.basetype.Coordinate(this._eyeX, this._eyeY));

        // 与最大经纬度范围求交集
        const cornerExtent = cornerPoints.getExtent();
        const crsExtent = this._crs.getExtent();
        return cornerExtent.getIntersection(crsExtent);
    }

    //TODO:该方法从getExtent拷贝过来，注记显示问题将在注记方案中得到全面解决
    getRotatedLabelExtent() {
        const halfFovy = this._fovy / 2;

        // 计算旋转X轴时可见的梯形范围
        const bottomToCenterY = this._getTargetToCenterYSpan(-this._rotateX, -halfFovy); // 底边到中心的距离
        const bottomHalfXSpan = this._getTargetToCenterXSpanByAspect(-this._rotateX, -halfFovy); // 底边宽度的一半
        const topAngleY = halfFovy * Math.cos(this._rotateX * Math.PI / 180);
        const topToCenterY = this._getTargetToCenterYSpan(-this._rotateX, topAngleY); // 顶边到中心的距离
        const topHalfXSpan = this._getTargetToCenterXSpanByAspect(-this._rotateX, topAngleY); // 顶边宽度的一半

        // 绕地图中心旋转可见梯形范围，旋转方向与地图旋转方向相反
        const cornerPoints = new hmap.geom.MultiPoint([
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + bottomHalfXSpan, this._eyeY + bottomToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - bottomHalfXSpan, this._eyeY + bottomToCenterY))]);
        cornerPoints.rotate("Z", -this._rotateZ, new hmap.basetype.Coordinate(this._eyeX, this._eyeY));

        // 与最大经纬度范围求交集
        const cornerExtent = cornerPoints.getExtent();
        const crsExtent = this._crs.getExtent();
        const intersectionExtent = cornerExtent.getIntersection(crsExtent);
        if (intersectionExtent) {
            return intersectionExtent.getTop();
        } else {
            return Number.NaN;
        }
    }

    _getXyzArrayFromCoords(coords) {
        const xyzs = [];
        let coord;
        for (let i = 0; i < coords.length; i++) {
            coord = coords[i];
            xyzs.push(coord.getOrdinate("X"), coord.getOrdinate("Y"), coord.getOrdinate("Z"));
        }
        return xyzs;
    }

    //获取雾化范围
    getFogBackgroundCoords() {
        const farthestZ = this._getFarthestEyeZ();
        const fogZ = -this._maxYRange * 0.90;
        const halfYRange = Math.tan(this._halfFovy * Math.PI / 180) * farthestZ*5;
        const halfXRange = this._aspect * halfYRange;

        // 绕地图中心旋转雾化梯形范围，旋转方向与地图旋转方向相同
        const cornerLine = new hmap.geom.LinearRing([
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - halfXRange, this._eyeY + halfYRange, fogZ)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - halfXRange, this._eyeY - halfYRange, fogZ)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + halfXRange, this._eyeY - halfYRange, fogZ)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + halfXRange, this._eyeY + halfYRange, fogZ)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - halfXRange, this._eyeY + halfYRange, fogZ))]);
        // const center = new hmap.basetype.Coordinate(this._eyeX, this._eyeY, this._eyeZ);
        const center = new hmap.basetype.Coordinate(this._eyeX, this._eyeY);
        cornerLine.rotate("X", -this._rotateX, center);
        cornerLine.rotate("Z", -this._rotateZ, center);
        const cornerCoordSeq = cornerLine.getCoordSeq();
        return this._getXyzArrayFromCoords(cornerCoordSeq.extractCoords(0, cornerCoordSeq.getCoordCount() - 1));
    }

    // 获取地图可视背景范围
    getMapBackgroundCoords() {
        const halfFovy = this._fovy / 2;

        const topAngleY = this._getExtentTopToCenterAngle(1.1);
        // 计算旋转X轴时可见的梯形范围
        const topToCenterY = 2 * this._getTargetToCenterYSpan(-this._rotateX, topAngleY); // 顶边到中心的距离
        const topHalfXSpan = 2 * this._getTargetToCenterXSpanByAspect(-this._rotateX, topAngleY); // 顶边宽度的一半
        const bottomToCenterY = 2 * this._getTargetToCenterYSpan(-this._rotateX, -halfFovy); // 底边到中心的距离
        const bottomHalfXSpan = 2 * this._getTargetToCenterXSpanByAspect(-this._rotateX, -halfFovy); // 底边宽度的一半

        // 绕地图中心旋转地图可视梯形范围，旋转方向与地图旋转方向相同
        const cornerLine = new hmap.geom.LinearRing([
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - bottomHalfXSpan, this._eyeY + bottomToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + bottomHalfXSpan, this._eyeY + bottomToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX + topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - topHalfXSpan, this._eyeY + topToCenterY)),
            new hmap.geom.Point(new hmap.basetype.Coordinate(this._eyeX - bottomHalfXSpan, this._eyeY + bottomToCenterY))]);
        cornerLine.rotate("Z", -this._rotateZ, new hmap.basetype.Coordinate(this._eyeX, this._eyeY));
        const cornerCoordSeq = cornerLine.getCoordSeq();
        return this._getXyzArrayFromCoords(cornerCoordSeq.extractCoords(0, cornerCoordSeq.getCoordCount() - 1));
    }

    // 根据比例获取指定高度的center
    _getCenterByZ(zRatio, rotateZRadian) {
        const offsetZRatio = 1 - zRatio;
        // 绕X轴旋转后，在指定高度平面上center所在位置偏离原center的量，该偏移量在Y轴发生作用
        const yRotateOffset = Math.sin(this._rotateX * Math.PI / 180) * this._eyeZ * offsetZRatio;
        const xOffset = yRotateOffset * Math.sin(rotateZRadian);
        const yOffset = yRotateOffset * Math.cos(rotateZRadian);
        return [this._eyeX + xOffset, this._eyeY + yOffset];
    }

    // 计算相机到给定坐标的深度与到地图中心点的深度的比值
    // 这个比值用于计算相机处于该高度时给定地理坐标的分辨率与地面分辨率的比值
    _getResolutionRatio(coord) {
        // 计算相机处到地面的高度与坐标高度之差，得到相机到指定坐标的高度
        const eyeH = this._getEyeH(this._eyeZ, this._rotateX) - coord.getOrdinate("Z");
        const eyeZ = eyeH / Math.cos(this._rotateX * Math.PI / 180);
        const zRatio = eyeZ / this._eyeZ;
        return zRatio;
    }

    //根据屏幕坐标获得地理坐标
    getPixelFromCoordinate(coord) {
        const [pixelX, pixelY]=this._getPixelFromXYZ(coord.getOrdinate("X"),coord.getOrdinate("Y"),coord.getOrdinate("Z"),)
        return new hmap.basetype.Pixel(pixelX, pixelY); // 像素值为整数
    }

    //根据屏幕坐标获得地理坐标
    _getPixelFromXYZ(x,y,z=0) {
        const eyeH = this._getEyeH(this._eyeZ, this._rotateX) - z;
        const eyeZ = eyeH / Math.cos(this._rotateX * Math.PI / 180);
        const zRatio = eyeZ / this._eyeZ;

        // 将Z轴的旋转角度转为弧度
        const rotateZRadian = this._rotateZ * Math.PI / 180;
        // 根据坐标高度计算指定高程平面上的中心点
        const [eyeX, eyeY] = this._getCenterByZ(zRatio, rotateZRadian);

        // 目标点到地图中心的距离在地理坐标X方向的分量
        const rotatedXSpan = x - eyeX;
        // 目标点到地图中心的距离在地理坐标Y方向的分量
        const rotatedYSpan = y - eyeY;

        // 目标点到地图中心地理距离在屏幕X轴方向的分量
        const xSpan = rotatedXSpan * Math.cos(rotateZRadian) - rotatedYSpan * Math.sin(rotateZRadian);
        // 目标点到地图中心地理距离在屏幕Y轴方向的分量
        const ySpan = rotatedXSpan * Math.sin(rotateZRadian) + rotatedYSpan * Math.cos(rotateZRadian);

        const angleY = this._getAngleYByTargetToCenter(ySpan, eyeZ);
        const angleX = this._getAngleXByTargetToCenter(xSpan, angleY, this._resolution * zRatio);
        const pixelX = this._getPixelXByAngle(angleX, this._containerWidth);
        const pixelY = this._getPixelYByAngle(angleY, this._containerHeight);
        return [pixelX, pixelY]; // 像素值为整数
    }

    //根据地理坐标获得屏幕坐标
    getCoordinateFromPixel(pixel, resolution) {
        const angleY = this._getAngleYByPixel(pixel.getY(), this._containerHeight);
        const angleX = this._getAngleXByPixel(pixel.getX(), this._containerWidth);
        const ySpan = this._getTargetToCenterYSpan(-this._rotateX, angleY, resolution);
        const xSpan = this._getTargetToCenterXSpan(-this._rotateX, angleX, angleY, resolution);
        const rotateZRadian = -this._rotateZ * Math.PI / 180;
        const rotatedXSpan = xSpan * Math.cos(rotateZRadian) - ySpan * Math.sin(rotateZRadian);
        const rotatedYSpan = xSpan * Math.sin(rotateZRadian) + ySpan * Math.cos(rotateZRadian);
        return new hmap.basetype.Coordinate(this._eyeX + rotatedXSpan, this._eyeY + rotatedYSpan);
    }

    // 根据Y轴方向角度得到对应像素坐标Y值
    _getPixelYByAngle(angleY, containerHeight) {
        const halfFovy = this._fovy / 2;
        const ratioH = Math.tan(angleY * Math.PI / 180) / Math.tan(halfFovy * Math.PI / 180);
        return containerHeight / 2 - ratioH * (containerHeight / 2);
    }

    // 根据X轴方向视角得到对应像素坐标X值
    _getPixelXByAngle(angleX, containerWidth) {
        const halfFovy = this._fovy / 2;
        const ratioW = Math.tan(angleX * Math.PI / 180) / Math.tan(halfFovy * Math.PI / 180) / this._aspect;
        return ratioW * (containerWidth / 2) + containerWidth / 2;
    }

    // 根据像素坐标Y值得到对应Y轴方向视角
    _getAngleYByPixel(pixelY, containerHeight) {
        const halfFovy = this._fovy / 2;
        const ratioH = (containerHeight / 2 - pixelY) / (containerHeight / 2);
        return Math.atan(ratioH * Math.tan(halfFovy * Math.PI / 180)) * 180 / Math.PI;
    }

    // 根据像素坐标X值得到对应X轴方向视角
    _getAngleXByPixel(pixelX, containerWidth) {
        const halfFovy = this._fovy / 2;
        const ratioW = (pixelX - containerWidth / 2) / (containerWidth / 2);
        return Math.atan(ratioW * Math.tan(halfFovy * Math.PI / 180) * this._aspect) * 180 / Math.PI;
    }

    // 根据目标到中心点的Y方向距离得到Y方向角度
    _getAngleYByTargetToCenter(targetToCenterY, eyeZ = this._eyeZ) {
        const eyeToCenterY = eyeZ * Math.sin(-this._rotateX * Math.PI / 180); //相机到地图中心Y轴方向的距离
        const eyeToTargetY = eyeToCenterY + targetToCenterY;
        const eyeH = this._getEyeH(eyeZ, this._rotateX);
        return Math.atan(eyeToTargetY / eyeH) * 180 / Math.PI + this._rotateX;
    }

    // 根据目标到中心点的X方向距离得到X方向角度
    _getAngleXByTargetToCenter(targetToCenterX, angleY, resolution) {
        return Math.atan(targetToCenterX / this._getTargetZ(-this._rotateX, angleY, resolution)) * 180 / Math.PI;
    }

    // 参数为眼睛到目标与眼睛到中心的夹角的X方向分量
    _getTargetToCenterXSpan(rotateX, angleX, angleY, resolution) {
        return this._getTargetZ(rotateX, angleY, resolution) * Math.tan(angleX * Math.PI / 180);
    }

    // 参数为眼睛到目标与眼睛到中心的夹角的Y方向分量
    _getTargetToCenterYSpan(rotateX, angleY, resolution) {
        let eyeZ;
        if (resolution) {
            eyeZ = this._getEyeZByResolution(resolution);
        } else {
            eyeZ = this._eyeZ;
        }
        const eyeH = this._getEyeH(eyeZ, rotateX);
        const eyeToCenterY = eyeZ * Math.sin((rotateX) * Math.PI / 180); //相机到地图中心Y轴方向的距离
        const eyeToTargetY = eyeH * Math.tan((rotateX + angleY) * Math.PI / 180); //相机到顶边Y轴方向的距离
        return eyeToTargetY - eyeToCenterY;
    }

    // 参数为眼睛到目标与眼睛到中心的夹角的Y方向分量
    _getTargetToCenterXSpanByAspect(rotateX, angleY) {
        const halfFovy = this._fovy / 2;
        const eyeH = this._getEyeH(this._eyeZ, rotateX);
        return this._getEyeToTargetYozDist(eyeH, rotateX, angleY) * Math.sin(halfFovy * Math.PI / 180) * this._aspect;
    }

    // 相机到目标在YoZ平面上的距离
    _getEyeToTargetYozDist(eyeH, rotateX, angleY) {
        return eyeH / Math.cos((rotateX + angleY) * Math.PI / 180);
    }

    // 获取指定Y轴方向角度对应的相机深度
    _getTargetZ(rotateX, angleY, resolution) {
        let eyeZ;
        if (resolution) {
            eyeZ = this._getEyeZByResolution(resolution);
        } else {
            eyeZ = this._eyeZ;
        }
        const eyeH = this._getEyeH(eyeZ, this._rotateX);
        const eyeToTargetYozDist = this._getEyeToTargetYozDist(eyeH, rotateX, angleY);
        return eyeToTargetYozDist * Math.cos(angleY * Math.PI / 180); //相机到目标视线方向的深度
    }

    // 获取远裁面深度
    _getFarthestEyeZ() {
        return this._eyeZ + this._maxYRange;
    }

    // 获取开始雾化的深度
    getFogStartDepth(rotateX = -this._rotateX) {
        if (this._getExtentTopToCenterAngle(1) === this._halfFovy) {
            return this._eyeZ + this._halfYRange;
        }
        const angleY = this._getAngleYByTargetToCenter(this._halfYRange * this._fogStartFactor);
        return this._getTargetZ(rotateX, angleY);
    }

    //获取结束雾化的深度
    getFogEndDepth(rotateX = -this._rotateX) {
        if (this._getExtentTopToCenterAngle(1) === this._halfFovy) {
            return this._eyeZ + this._halfYRange;
        }
        const angleY = this._getAngleYByTargetToCenter(this._halfYRange * this._fogEndFactor);
        return this._getTargetZ(rotateX, angleY);
    }

    /**
     * 获取相机的坐标，包括旋转后
     * @returns {hmap.basetype.Coordinate}
     */
    getCoordinate() {
        const originCoord = new hmap.basetype.Coordinate(this._eyeX, this._eyeY, this._eyeZ);
        const center = new hmap.basetype.Coordinate(this._eyeX, this._eyeY, 0);
        originCoord.rotate("X", -this._rotateX, center);
        originCoord.rotate("Z", -this._rotateZ, center);
        return originCoord;
    }

    /**
     * 获取视图矩阵中的平移矩阵
     * @returns {hmap.util.Matrix4}
     */
    getViewTranslation(){
        return  new hmap.util.Matrix4().translate(
            -this._eyeX,
            -this._eyeY,
            -this._eyeZ
        );
    }

    /**
     * 获取视图矩阵中的旋转矩阵
     * @returns {hmap.util.Matrix4}
     */
    getViewRotate(){
        return this._rotateXMatrix.clone().multiply(this._rotateZMatrix);
    }
};
;hmap.util = hmap.util || {};
/**
 * @private
 */
hmap.util.Aid = class {
  /**
   * 创建类唯一标记，运行时生成
   * @param {String} className1
   */
  static createUnique(className1) {
    return (
      className1 +
      "-" +
      "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        const r = (Math.random() * 16) | 0,
          v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      })
    );
  }
};;"use strict";
hmap.util = hmap.util || {};
/**
 * @license zlib.js中的解压部分，为自由软件授权
 * js二进制解压缩工具类，使用了zlib.Inflate函数
 * @private
 */
hmap.util.Inflate = class {
    /**
     * 构造函数
     * */
    constructor(input, opt_params){
        let cmf,flg;
        this.input = input;
        this.ip = 0;
        //this.BufferType = {BLOCK:0, ADAPTIVE:1};
        this.rawinflate;
        this.verify;
        if(opt_params || !(opt_params = {})) {
            if(opt_params["index"]) {
                this.ip = opt_params["index"]
            }
            if(opt_params["verify"]) {
                this.verify = opt_params["verify"]
            }
        }
        cmf = input[this.ip++];
        flg = input[this.ip++];
        switch(cmf & 15) {
            case 8:
                this.method = 8;
                break;
            default:
                throw new Error("unsupported compression method");
        }
        if(((cmf << 8) + flg) % 31 !== 0) {
            throw new Error("invalid fcheck flag:" + ((cmf << 8) + flg) % 31);
        }
        if(flg & 32) {
            throw new Error("fdict flag is not supported");
        }
        this.rawinflate = new hmap.util.RawInflate(input, {"index":this.ip, "bufferSize":opt_params["bufferSize"], "bufferType":opt_params["bufferType"], "resize":opt_params["resize"]})
    }

    /**
     * 解压缩
     * @private
     * */
    decompress() {
        let input = this.input,buffer,adler32;
        buffer = this.rawinflate.decompress();
        this.ip = this.rawinflate.ip;
        if(this.verify) {
            adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;
            if(adler32 !== this.checkAdler32(buffer)) {
                throw new Error("invalid adler-32 checksum");
            }
        }
        return buffer
    }

    checkAdler32(array) {
        if(typeof array === "string") {
            let result = array.split(""),i,il;
            for(i = 0, il = result.length;i < il;i++) {
                result[i] = (result[i].charCodeAt(0) & 255) >>> 0
            }
            return result
        }else{
            let s1 = 1 & 65535;
            let s2 = 1 >>> 16 & 65535;
            let len = array.length, tlen, i = 0;
            while(len > 0) {
                tlen = len > 1024 ? 1024 : len;
                len -= tlen;
                do {
                    s1 += array[i++];
                    s2 += s1
                }while(--tlen);
                s1 %= 65521;
                s2 %= 65521
            }
            return(s2 << 16 | s1) >>> 0
        }
    }
}


/**
 * 原始解压
 * @private
 * */
hmap.util.RawInflate = class {
    /**
     * 原始解压
     * */
    constructor(input, opt_params){
        this.buffer = undefined;
        this.BufferTypeConst = {BLOCK:0, ADAPTIVE:1};
        this.MaxBackwardLength = 32768;
        this.MaxCopyLength = 258;
        this.blocks = [];
        this.bufferSize = 32768;
        this.totalpos = 0;
        this.ip = 0;
        this.bitsbuf = 0;
        this.bitsbuflen = 0;
        this.USE_TYPEDARRAY = this.checkTypArray();
        this.input = this.USE_TYPEDARRAY ? new Uint8Array(input) : input;
        this.output;
        this.op;
        this.bfinal = false;
        this.bufferType = this.BufferTypeConst.ADAPTIVE;
        this.resize = false;
        if(opt_params || !(opt_params = {})) {
            if(opt_params["index"]) {
                this.ip = opt_params["index"]
            }
            if(opt_params["bufferSize"]) {
                this.bufferSize = opt_params["bufferSize"]
            }
            if(opt_params["bufferType"]) {
                this.bufferType = opt_params["bufferType"]
            }
            if(opt_params["resize"]) {
                this.resize = opt_params["resize"]
            }
        }
        switch(this.bufferType) {
            case this.BufferTypeConst.BLOCK:
                this.op = this.MaxBackwardLength;
                this.output = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(this.MaxBackwardLength + this.bufferSize + this.MaxCopyLength);
                break;
            case this.BufferTypeConst.ADAPTIVE:
                this.op = 0;
                this.output = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
                this.expandBuffer = this.expandBufferAdaptive;
                this.concatBuffer = this.concatBufferDynamic;
                this.decodeHuffman = this.decodeHuffmanAdaptive;
                break;
            default:
                throw new Error("invalid inflate mode");
        }
    }

    decompress() {
        while(!this.bfinal) {
            this.parseBlock()
        }
        return this.concatBuffer()
    }

    Order() {
        let data = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        return this.USE_TYPEDARRAY ? new Uint16Array(data) : data
    };

    LengthCodeTable() {
        let data = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
        return this.USE_TYPEDARRAY ? new Uint16Array(data) : data
    }

    LengthExtraTable() {
        let data = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
        return this.USE_TYPEDARRAY ? new Uint8Array(data) : data
    }

    DistCodeTable() {
        let data = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
        return this.USE_TYPEDARRAY ? new Uint16Array(data) : data
    }

    DistExtraTable() {
        let data = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        return this.USE_TYPEDARRAY ? new Uint8Array(data) : data
    }

    FixedLiteralLengthTable() {
        let lengths = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(288);
        let i, il;
        for(i = 0, il = lengths.length;i < il;++i) {
            lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8
        }
        return this.buildHuffmanTable(lengths)
    }

    FixedDistanceTable() {
        let lengths = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(30);
        let i, il;
        for(i = 0, il = lengths.length;i < il;++i) {
            lengths[i] = 5
        }
        return this.buildHuffmanTable(lengths)
    }

    parseBlock() {
        let hdr = this.readBits(3);
        if(hdr & 1) {
            this.bfinal = true
        }
        hdr >>>= 1;
        switch(hdr) {
            case 0:
                this.parseUncompressedBlock();
                break;
            case 1:
                this.parseFixedHuffmanBlock();
                break;
            case 2:
                this.parseDynamicHuffmanBlock();
                break;
            default:
                throw new Error("unknown BTYPE: " + hdr);
        }
    }

    readBits(length) {
        let bitsbuf = this.bitsbuf, bitsbuflen = this.bitsbuflen, input = this.input, ip = this.ip,
            inputLength = input.length, octet;
        while(bitsbuflen < length) {
            if(ip >= inputLength) {
                throw new Error("input buffer is broken");
            }
            bitsbuf |= input[ip++] << bitsbuflen;
            bitsbuflen += 8
        }
        octet = bitsbuf & (1 << length) - 1;
        bitsbuf >>>= length;
        bitsbuflen -= length;
        this.bitsbuf = bitsbuf;
        this.bitsbuflen = bitsbuflen;
        this.ip = ip;
        return octet
    }

    readCodeByTable(table) {
        let bitsbuf = this.bitsbuf, bitsbuflen = this.bitsbuflen, input = this.input, ip = this.ip,
            inputLength = input.length, codeTable = table[0], maxCodeLength = table[1], codeWithLength, codeLength;
        while(bitsbuflen < maxCodeLength) {
            if(ip >= inputLength) {
                break
            }
            bitsbuf |= input[ip++] << bitsbuflen;
            bitsbuflen += 8
        }
        codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
        codeLength = codeWithLength >>> 16;
        if(codeLength > bitsbuflen) {
            throw new Error("invalid code length: " + codeLength);
        }
        this.bitsbuf = bitsbuf >> codeLength;
        this.bitsbuflen = bitsbuflen - codeLength;
        this.ip = ip;
        return codeWithLength & 65535
    }

    parseUncompressedBlock() {
        let input = this.input, ip = this.ip, output = this.output, op = this.op, inputLength = input.length,
            len, nlen, olength = output.length, preCopy;
        this.bitsbuf = 0;
        this.bitsbuflen = 0;
        if(ip + 1 >= inputLength) {
            throw new Error("invalid uncompressed block header: LEN");
        }
        len = input[ip++] | input[ip++] << 8;
        if(ip + 1 >= inputLength) {
            throw new Error("invalid uncompressed block header: NLEN");
        }
        nlen = input[ip++] | input[ip++] << 8;
        if(len === ~nlen) {
            throw new Error("invalid uncompressed block header: length verify");
        }
        if(ip + len > input.length) {
            throw new Error("input buffer is broken");
        }
        switch(this.bufferType) {
            case RawInflate.BufferType.BLOCK:
                while(op + len > output.length) {
                    preCopy = olength - op;
                    len -= preCopy;
                    if(this.USE_TYPEDARRAY) {
                        output.set(input.subarray(ip, ip + preCopy), op);
                        op += preCopy;
                        ip += preCopy
                    }else {
                        while(preCopy--) {
                            output[op++] = input[ip++]
                        }
                    }
                    this.op = op;
                    output = this.expandBuffer();
                    op = this.op
                }
                break;
            case RawInflate.BufferType.ADAPTIVE:
                while(op + len > output.length) {
                    output = this.expandBuffer({fixRatio:2})
                }
                break;
            default:
                throw new Error("invalid inflate mode");
        }
        if(this.USE_TYPEDARRAY) {
            output.set(input.subarray(ip, ip + len), op);
            op += len;
            ip += len
        }else {
            while(len--) {
                output[op++] = input[ip++]
            }
        }
        this.ip = ip;
        this.op = op;
        this.output = output
    }

    parseFixedHuffmanBlock() {
        this.decodeHuffman(this.FixedLiteralLengthTable(), this.FixedDistanceTable())
    }

    parseDynamicHuffmanBlock() {
        let hlit = this.readBits(5) + 257, hdist = this.readBits(5) + 1, hclen = this.readBits(4) + 4, order  = this.Order();
        let codeLengths = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(order.length);
        let codeLengthsTable, litlenTable, distTable, lengthTable, code, prev, repeat, i, il;
        for(i = 0;i < hclen;++i) {
            codeLengths[order[i]] = this.readBits(3)
        }
        if(!this.USE_TYPEDARRAY) {
            for(i = hclen, hclen = codeLengths.length;i < hclen;++i) {
                codeLengths[order[i]] = 0
            }
        }
        codeLengthsTable = this.buildHuffmanTable(codeLengths);
        lengthTable = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);
        for(let i = 0, il = hlit + hdist;i < il;) {
            code = this.readCodeByTable(codeLengthsTable);
            switch(code) {
                case 16:
                    repeat = 3 + this.readBits(2);
                    while(repeat--) {
                        lengthTable[i++] = prev
                    }
                    break;
                case 17:
                    repeat = 3 + this.readBits(3);
                    while(repeat--) {
                        lengthTable[i++] = 0
                    }
                    prev = 0;
                    break;
                case 18:
                    repeat = 11 + this.readBits(7);
                    while(repeat--) {
                        lengthTable[i++] = 0
                    }
                    prev = 0;
                    break;
                default:
                    lengthTable[i++] = code;
                    prev = code;
                    break
            }
        }
        litlenTable = this.USE_TYPEDARRAY ? this.buildHuffmanTable(lengthTable.subarray(0, hlit)) : this.buildHuffmanTable(lengthTable.slice(0, hlit));
        distTable = this.USE_TYPEDARRAY ? this.buildHuffmanTable(lengthTable.subarray(hlit)) : this.buildHuffmanTable(lengthTable.slice(hlit));
        this.decodeHuffman(litlenTable, distTable)
    }

    decodeHuffman(litlen, dist) {
        let output = this.output, op = this.op;
        this.currentLitlenTable = litlen;
        let olength = output.length - this.MaxCopyLength;
        let code, ti, codeDist, codeLength;
        while((code = this.readCodeByTable(litlen)) !== 256) {
            if(code < 256) {
                if(op >= olength) {
                    this.op = op;
                    output = this.expandBuffer();
                    op = this.op
                }
                output[op++] = code;
                continue
            }
            ti = code - 257;
            codeLength = this.LengthCodeTable()[ti];
            if(this.LengthExtraTable()[ti] > 0) {
                codeLength += this.readBits(this.LengthExtraTable()[ti])
            }
            code = this.readCodeByTable(dist);
            codeDist = this.DistCodeTable()[code];
            if(this.DistExtraTable()[code] > 0) {
                codeDist += this.readBits(this.DistExtraTable()[code])
            }
            if(op >= olength) {
                this.op = op;
                output = this.expandBuffer();
                op = this.op
            }
            while(codeLength--) {
                output[op] = output[op++ - codeDist]
            }
        }
        while(this.bitsbuflen >= 8) {
            this.bitsbuflen -= 8;
            this.ip--
        }
        this.op = op
    }

    decodeHuffmanAdaptive(litlen, dist) {
        let output = this.output, op = this.op;
        this.currentLitlenTable = litlen;
        let olength = output.length, code, ti, codeDist, codeLength;
        while((code = this.readCodeByTable(litlen)) !== 256) {
            if(code < 256) {
                if(op >= olength) {
                    output = this.expandBuffer();
                    olength = output.length
                }
                output[op++] = code;
                continue
            }
            ti = code - 257;
            codeLength = this.LengthCodeTable()[ti];
            if(this.LengthExtraTable()[ti] > 0) {
                codeLength += this.readBits(this.LengthExtraTable()[ti])
            }
            code = this.readCodeByTable(dist);
            codeDist = this.DistCodeTable()[code];
            if(this.DistExtraTable()[code] > 0) {
                codeDist += this.readBits(this.DistExtraTable()[code])
            }
            if(op + codeLength > olength) {
                output = this.expandBuffer();
                olength = output.length
            }
            while(codeLength--) {
                output[op] = output[op++ - codeDist]
            }
        }
        while(this.bitsbuflen >= 8) {
            this.bitsbuflen -= 8;
            this.ip--
        }
        this.op = op
    }

    expandBuffer(opt_param) {
        let maxBackwardLength = this.MaxBackwardLength
        let buffer = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(this.op - maxBackwardLength);
        let backward = this.op - this.MaxBackwardLength;
        let i, il, output = this.output;
        if(this.USE_TYPEDARRAY) {
            buffer.set(output.subarray(maxBackwardLength, buffer.length))
        }else {
            for(i = 0, il = buffer.length;i < il;++i) {
                buffer[i] = output[i + maxBackwardLength]
            }
        }
        this.blocks.push(buffer);
        this.totalpos += buffer.length;
        if(this.USE_TYPEDARRAY) {
            output.set(output.subarray(backward, backward + maxBackwardLength))
        }else {
            for(i = 0;i < maxBackwardLength;++i) {
                output[i] = output[backward + i]
            }
        }
        this.op = maxBackwardLength;
        return output
    }

    expandBufferAdaptive(opt_param) {
        let ratio = this.input.length / this.ip + 1 | 0;
        let buffer, maxHuffCode, newSize, maxInflateSize;
        let input = this.input, output = this.output;
        if(opt_param) {
            if(typeof opt_param.fixRatio === "number") {
                ratio = opt_param.fixRatio
            }
            if(typeof opt_param.addRatio === "number") {
                ratio += opt_param.addRatio
            }
        }
        if(ratio < 2) {
            maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
            maxInflateSize = maxHuffCode / 2 * 258 | 0;
            newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1
        }else {
            newSize = output.length * ratio
        }
        if(this.USE_TYPEDARRAY) {
            buffer = new Uint8Array(newSize);
            buffer.set(output)
        }else {
            buffer = output
        }
        this.output = buffer;
        return this.output
    }

    concatBuffer() {
        let maxBackwardLength = this.MaxBackwardLength;
        let limit = this.totalpos + (this.op - maxBackwardLength);
        let output = this.output, blocks = this.blocks;
        let buffer = new (this.USE_TYPEDARRAY ? Uint8Array : Array)(limit);
        let pos = 0, block, i, il, j, jl;
        if(blocks.length === 0) {
            return this.USE_TYPEDARRAY ? this.output.subarray(maxBackwardLength, this.op) : this.output.slice(maxBackwardLength, this.op)
        }
        for(let i = 0, il = blocks.length;i < il;++i) {
            block = blocks[i];
            for(let j = 0, jl = block.length;j < jl;++j) {
                buffer[pos++] = block[j]
            }
        }
        for(let i = maxBackwardLength, il = this.op;i < il;++i) {
            buffer[pos++] = output[i]
        }
        this.blocks = [];
        this.buffer = buffer;
        return this.buffer
    }

    concatBufferDynamic() {
        let buffer, op = this.op;
        if(this.USE_TYPEDARRAY) {
            if(this.resize) {
                buffer = new Uint8Array(op);
                buffer.set(this.output.subarray(0, op))
            }else {
                buffer = this.output.subarray(0, op)
            }
        }else {
            if(this.output.length > op) {
                this.output.length = op
            }
            buffer = this.output
        }
        this.buffer = buffer;
        return this.buffer
    }

    buildHuffmanTable(lengths) {
        let listSize = lengths.length;
        let maxCodeLength = 0, minCodeLength = Number.POSITIVE_INFINITY;
        let size, table, bitLength, code, skip, reversed, rtemp, i, il, j, value;
        for(i = 0, il = listSize;i < il;++i) {
            if(lengths[i] > maxCodeLength) {
                maxCodeLength = lengths[i]
            }
            if(lengths[i] < minCodeLength) {
                minCodeLength = lengths[i]
            }
        }
        size = 1 << maxCodeLength;
        table = new (this.USE_TYPEDARRAY ? Uint32Array : Array)(size);
        for(bitLength = 1, code = 0, skip = 2;bitLength <= maxCodeLength;) {
            for(i = 0;i < listSize;++i) {
                if(lengths[i] === bitLength) {
                    for(reversed = 0, rtemp = code, j = 0;j < bitLength;++j) {
                        reversed = reversed << 1 | rtemp & 1;
                        rtemp >>= 1
                    }
                    value = bitLength << 16 | i;
                    for(j = reversed;j < size;j += skip) {
                        table[j] = value
                    }
                    ++code
                }
            }
            ++bitLength;
            code <<= 1;
            skip <<= 1
        }
        return[table, maxCodeLength, minCodeLength]
    }

    checkTypArray(){
        return typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined" && typeof DataView !== "undefined";
    }
};"use strict";
Array.prototype.flat=function () {
    let arr = [];
    this.forEach(item => {
        if (Array.isArray((item))) {
            arr = arr.concat(item.flat())
        } else {
            arr.push(item)
        }
    })
    return arr;
};hmap.util = hmap.util || {};
/**
 * @private
 */
hmap.util.Correction = class {

    static float32FromDouble64(num,unit="degrees") {
        let high = 0, low = 0, tempHigh = 0;
        if (unit === "degrees") {
            high = Math.floor(num);
            low = (num - high) * Math.pow(10, 7);
            low = Math.floor(low);
        } else {
            if (num > 0) {
                tempHigh = Math.floor(num / 65536) * 65536;
                high = tempHigh;
                low = num - tempHigh;
            } else {
                tempHigh = Math.floor(-num / 65536) * 65536;
                high = -tempHigh;
                low = num + tempHigh;
            }
        }
        return [high, low];
    }

    /**
     * 矩阵的精度修正，将64为浮点数修正为高位和低位两个矩阵
     * @param matrixEle 需修正的矩阵元素
     * @param indexArray 需修正的矩阵元素索引
     * @param unit  修正单位
     * @returns {{highMatrix: *, lowMatrix: any[]}}
     */
    static matrix32FromDouble64(matrixEle,indexArray,unit){
        let elementsL=new Array(16).fill(0);
        let elementsH=[...matrixEle];
        for(let i=0,len=indexArray.length;i<len;i++){
            const index=indexArray[i];
            const e=matrixEle[index];
            const hl=hmap.util.Correction.float32FromDouble64(e,unit);
            elementsH[index]=hl[0],elementsL[index]=hl[1];
        }
        return{
            matrixH:elementsH,
            matrixL:elementsL
        }
    }
};;'use strict'
hmap.util = hmap.util || {};

/**
 * 计算颜色插值
 * @type {hmap.util.InterpolateColor}
 * @private
 */
hmap.util.InterpolateColor = class {
    /**
     * 计算线性插值颜色
     * @param fromColor {hmap.style.Color} 插值计算起始颜色
     * @param toColor {hmap.style.Color} 插值计算终止颜色
     * @param ratio {Number} 处于起始颜色和终止颜色之间的比例，在0到1之间
     * @returns {hmap.style.Color|*} 插值后的颜色
     */
    static interpolateColorByLine(fromColor, toColor, ratio) {
        let [r0, g0, b0, a0] = fromColor.toArray(),
            [r1, g1, b1, a1] = toColor.toArray();
        let r = Math.floor(this._interpolate(r0, r1, ratio)),
            g = Math.floor(this._interpolate(g0, g1, ratio)),
            b = Math.floor(this._interpolate(b0, b1, ratio)),
            a = this._interpolate(a0, a1, ratio);
        return new hmap.style.Color(r, g, b, a);
    }

    /**
     * 计算某个分量线性插值
     * @param from
     * @param to
     * @param ratio
     * @returns {number}
     * @private
     */
    static _interpolate(from, to, ratio) {
        return Math.min(Math.max(from + (to - from) * ratio, 0), 255);
    }

    /**
     * 辗转相除法求一个正整数数组内各个元素的最大公约数
     * @param intArr {Array<Number>} 元素为正整数的数组
     * @returns {*}
     */
    static getArrGreatestDivisor(intArr) {
        let temp = this.getGreatestDivisor(intArr[0], intArr[1]);
        for (let i = 2, l =intArr.length; i < l; i++) {
            temp = this.getGreatestDivisor(temp, intArr[i]);
        }
        return temp;
    }

    /**
     * 辗转相除法求两个正整数的最大公约数
     * @param n1 {Number}
     * @param n2 {Number}
     * @returns {Number}
     */
    static getGreatestDivisor(n1, n2) {
        let temp;
        if (n1 < n2) {
            temp = n1;
            n1 = n2;
            n2 = temp;
        }
        while (n2 != 0) {
            temp = n1 % n2;
            n1 = n2;
            n2 = temp;
        }
        return n1;
    }
}
;hmap.util = hmap.util || {};
/**
 * @private
 */
hmap.util.GLConstantTable = class {
    static getConstant(key) {
        let table = {
            DEPTH_BUFFER_BIT: 0x00000100,
            STENCIL_BUFFER_BIT: 0x00000400,
            COLOR_BUFFER_BIT: 0x00004000,
            POINTS: 0x0000,
            LINES: 0x0001,
            LINE_LOOP: 0x0002,
            LINE_STRIP: 0x0003,
            TRIANGLES: 0x0004,
            TRIANGLE_STRIP: 0x0005,
            TRIANGLE_FAN: 0x0006,
            ZERO: 0,
            ONE: 1,
            SRC_COLOR: 0x0300,
            ONE_MINUS_SRC_COLOR: 0x0301,
            SRC_ALPHA: 0x0302,
            ONE_MINUS_SRC_ALPHA: 0x0303,
            DST_ALPHA: 0x0304,
            ONE_MINUS_DST_ALPHA: 0x0305,
            DST_COLOR: 0x0306,
            ONE_MINUS_DST_COLOR: 0x0307,
            SRC_ALPHA_SATURATE: 0x0308,
            FUNC_ADD: 0x8006,
            BLEND_EQUATION: 0x8009,
            BLEND_EQUATION_RGB: 0x8009, // same as BLEND_EQUATION
            BLEND_EQUATION_ALPHA: 0x883D,
            FUNC_SUBTRACT: 0x800A,
            FUNC_REVERSE_SUBTRACT: 0x800B,
            BLEND_DST_RGB: 0x80C8,
            BLEND_SRC_RGB: 0x80C9,
            BLEND_DST_ALPHA: 0x80CA,
            BLEND_SRC_ALPHA: 0x80CB,
            CONSTANT_COLOR: 0x8001,
            ONE_MINUS_CONSTANT_COLOR: 0x8002,
            CONSTANT_ALPHA: 0x8003,
            ONE_MINUS_CONSTANT_ALPHA: 0x8004,
            BLEND_COLOR: 0x8005,
            ARRAY_BUFFER: 0x8892,
            ELEMENT_ARRAY_BUFFER: 0x8893,
            ARRAY_BUFFER_BINDING: 0x8894,
            ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
            STREAM_DRAW: 0x88E0,
            STATIC_DRAW: 0x88E4,
            DYNAMIC_DRAW: 0x88E8,
            BUFFER_SIZE: 0x8764,
            BUFFER_USAGE: 0x8765,
            CURRENT_VERTEX_ATTRIB: 0x8626,
            FRONT: 0x0404,
            BACK: 0x0405,
            FRONT_AND_BACK: 0x0408,
            CULL_FACE: 0x0B44,
            BLEND: 0x0BE2,
            DITHER: 0x0BD0,
            STENCIL_TEST: 0x0B90,
            DEPTH_TEST: 0x0B71,
            SCISSOR_TEST: 0x0C11,
            POLYGON_OFFSET_FILL: 0x8037,
            SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
            SAMPLE_COVERAGE: 0x80A0,
            NO_ERROR: 0,
            INVALID_ENUM: 0x0500,
            INVALID_VALUE: 0x0501,
            INVALID_OPERATION: 0x0502,
            OUT_OF_MEMORY: 0x0505,
            CW: 0x0900,
            CCW: 0x0901,
            LINE_WIDTH: 0x0B21,
            ALIASED_POINT_SIZE_RANGE: 0x846D,
            ALIASED_LINE_WIDTH_RANGE: 0x846E,
            CULL_FACE_MODE: 0x0B45,
            FRONT_FACE: 0x0B46,
            DEPTH_RANGE: 0x0B70,
            DEPTH_WRITEMASK: 0x0B72,
            DEPTH_CLEAR_VALUE: 0x0B73,
            DEPTH_FUNC: 0x0B74,
            STENCIL_CLEAR_VALUE: 0x0B91,
            STENCIL_FUNC: 0x0B92,
            STENCIL_FAIL: 0x0B94,
            STENCIL_PASS_DEPTH_FAIL: 0x0B95,
            STENCIL_PASS_DEPTH_PASS: 0x0B96,
            STENCIL_REF: 0x0B97,
            STENCIL_VALUE_MASK: 0x0B93,
            STENCIL_WRITEMASK: 0x0B98,
            STENCIL_BACK_FUNC: 0x8800,
            STENCIL_BACK_FAIL: 0x8801,
            STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
            STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
            STENCIL_BACK_REF: 0x8CA3,
            STENCIL_BACK_VALUE_MASK: 0x8CA4,
            STENCIL_BACK_WRITEMASK: 0x8CA5,
            VIEWPORT: 0x0BA2,
            SCISSOR_BOX: 0x0C10,
            COLOR_CLEAR_VALUE: 0x0C22,
            COLOR_WRITEMASK: 0x0C23,
            UNPACK_ALIGNMENT: 0x0CF5,
            PACK_ALIGNMENT: 0x0D05,
            MAX_TEXTURE_SIZE: 0x0D33,
            MAX_VIEWPORT_DIMS: 0x0D3A,
            SUBPIXEL_BITS: 0x0D50,
            RED_BITS: 0x0D52,
            GREEN_BITS: 0x0D53,
            BLUE_BITS: 0x0D54,
            ALPHA_BITS: 0x0D55,
            DEPTH_BITS: 0x0D56,
            STENCIL_BITS: 0x0D57,
            POLYGON_OFFSET_UNITS: 0x2A00,
            POLYGON_OFFSET_FACTOR: 0x8038,
            TEXTURE_BINDING_2D: 0x8069,
            SAMPLE_BUFFERS: 0x80A8,
            SAMPLES: 0x80A9,
            SAMPLE_COVERAGE_VALUE: 0x80AA,
            SAMPLE_COVERAGE_INVERT: 0x80AB,
            COMPRESSED_TEXTURE_FORMATS: 0x86A3,
            DONT_CARE: 0x1100,
            FASTEST: 0x1101,
            NICEST: 0x1102,
            GENERATE_MIPMAP_HINT: 0x8192,
            BYTE: 0x1400,
            UNSIGNED_BYTE: 0x1401,
            SHORT: 0x1402,
            UNSIGNED_SHORT: 0x1403,
            INT: 0x1404,
            UNSIGNED_INT: 0x1405,
            FLOAT: 0x1406,
            DEPTH_COMPONENT: 0x1902,
            ALPHA: 0x1906,
            RGB: 0x1907,
            RGBA: 0x1908,
            LUMINANCE: 0x1909,
            LUMINANCE_ALPHA: 0x190A,
            UNSIGNED_SHORT_4_4_4_4: 0x8033,
            UNSIGNED_SHORT_5_5_5_1: 0x8034,
            UNSIGNED_SHORT_5_6_5: 0x8363,
            FRAGMENT_SHADER: 0x8B30,
            VERTEX_SHADER: 0x8B31,
            MAX_VERTEX_ATTRIBS: 0x8869,
            MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
            MAX_VARYING_VECTORS: 0x8DFC,
            MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
            MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
            MAX_TEXTURE_IMAGE_UNITS: 0x8872,
            MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
            SHADER_TYPE: 0x8B4F,
            DELETE_STATUS: 0x8B80,
            LINK_STATUS: 0x8B82,
            VALIDATE_STATUS: 0x8B83,
            ATTACHED_SHADERS: 0x8B85,
            ACTIVE_UNIFORMS: 0x8B86,
            ACTIVE_ATTRIBUTES: 0x8B89,
            SHADING_LANGUAGE_VERSION: 0x8B8C,
            CURRENT_PROGRAM: 0x8B8D,
            NEVER: 0x0200,
            LESS: 0x0201,
            EQUAL: 0x0202,
            LEQUAL: 0x0203,
            GREATER: 0x0204,
            NOTEQUAL: 0x0205,
            GEQUAL: 0x0206,
            ALWAYS: 0x0207,
            KEEP: 0x1E00,
            REPLACE: 0x1E01,
            INCR: 0x1E02,
            DECR: 0x1E03,
            INVERT: 0x150A,
            INCR_WRAP: 0x8507,
            DECR_WRAP: 0x8508,
            VENDOR: 0x1F00,
            RENDERER: 0x1F01,
            VERSION: 0x1F02,
            NEAREST: 0x2600,
            LINEAR: 0x2601,
            NEAREST_MIPMAP_NEAREST: 0x2700,
            LINEAR_MIPMAP_NEAREST: 0x2701,
            NEAREST_MIPMAP_LINEAR: 0x2702,
            LINEAR_MIPMAP_LINEAR: 0x2703,
            TEXTURE_MAG_FILTER: 0x2800,
            TEXTURE_MIN_FILTER: 0x2801,
            TEXTURE_WRAP_S: 0x2802,
            TEXTURE_WRAP_T: 0x2803,
            TEXTURE_2D: 0x0DE1,
            TEXTURE: 0x1702,
            TEXTURE_CUBE_MAP: 0x8513,
            TEXTURE_BINDING_CUBE_MAP: 0x8514,
            TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
            TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
            TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
            TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
            TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
            TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
            MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
            TEXTURE0: 0x84C0,
            TEXTURE1: 0x84C1,
            TEXTURE2: 0x84C2,
            TEXTURE3: 0x84C3,
            TEXTURE4: 0x84C4,
            TEXTURE5: 0x84C5,
            TEXTURE6: 0x84C6,
            TEXTURE7: 0x84C7,
            TEXTURE8: 0x84C8,
            TEXTURE9: 0x84C9,
            TEXTURE10: 0x84CA,
            TEXTURE11: 0x84CB,
            TEXTURE12: 0x84CC,
            TEXTURE13: 0x84CD,
            TEXTURE14: 0x84CE,
            TEXTURE15: 0x84CF,
            TEXTURE16: 0x84D0,
            TEXTURE17: 0x84D1,
            TEXTURE18: 0x84D2,
            TEXTURE19: 0x84D3,
            TEXTURE20: 0x84D4,
            TEXTURE21: 0x84D5,
            TEXTURE22: 0x84D6,
            TEXTURE23: 0x84D7,
            TEXTURE24: 0x84D8,
            TEXTURE25: 0x84D9,
            TEXTURE26: 0x84DA,
            TEXTURE27: 0x84DB,
            TEXTURE28: 0x84DC,
            TEXTURE29: 0x84DD,
            TEXTURE30: 0x84DE,
            TEXTURE31: 0x84DF,
            ACTIVE_TEXTURE: 0x84E0,
            REPEAT: 0x2901,
            CLAMP_TO_EDGE: 0x812F,
            MIRRORED_REPEAT: 0x8370,
            FLOAT_VEC2: 0x8B50,
            FLOAT_VEC3: 0x8B51,
            FLOAT_VEC4: 0x8B52,
            INT_VEC2: 0x8B53,
            INT_VEC3: 0x8B54,
            INT_VEC4: 0x8B55,
            BOOL: 0x8B56,
            BOOL_VEC2: 0x8B57,
            BOOL_VEC3: 0x8B58,
            BOOL_VEC4: 0x8B59,
            FLOAT_MAT2: 0x8B5A,
            FLOAT_MAT3: 0x8B5B,
            FLOAT_MAT4: 0x8B5C,
            SAMPLER_2D: 0x8B5E,
            SAMPLER_CUBE: 0x8B60,
            VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
            VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
            VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
            VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
            VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
            VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
            VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,
            IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
            IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,
            COMPILE_STATUS: 0x8B81,
            LOW_FLOAT: 0x8DF0,
            MEDIUM_FLOAT: 0x8DF1,
            HIGH_FLOAT: 0x8DF2,
            LOW_INT: 0x8DF3,
            MEDIUM_INT: 0x8DF4,
            HIGH_INT: 0x8DF5,
            FRAMEBUFFER: 0x8D40,
            RENDERBUFFER: 0x8D41,
            RGBA4: 0x8056,
            RGB5_A1: 0x8057,
            RGB565: 0x8D62,
            DEPTH_COMPONENT16: 0x81A5,
            STENCIL_INDEX: 0x1901,
            STENCIL_INDEX8: 0x8D48,
            DEPTH_STENCIL: 0x84F9,
            RENDERBUFFER_WIDTH: 0x8D42,
            RENDERBUFFER_HEIGHT: 0x8D43,
            RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
            RENDERBUFFER_RED_SIZE: 0x8D50,
            RENDERBUFFER_GREEN_SIZE: 0x8D51,
            RENDERBUFFER_BLUE_SIZE: 0x8D52,
            RENDERBUFFER_ALPHA_SIZE: 0x8D53,
            RENDERBUFFER_DEPTH_SIZE: 0x8D54,
            RENDERBUFFER_STENCIL_SIZE: 0x8D55,
            FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
            FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
            FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
            FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
            COLOR_ATTACHMENT0: 0x8CE0,
            DEPTH_ATTACHMENT: 0x8D00,
            STENCIL_ATTACHMENT: 0x8D20,
            DEPTH_STENCIL_ATTACHMENT: 0x821A,
            NONE: 0,
            FRAMEBUFFER_COMPLETE: 0x8CD5,
            FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
            FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
            FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
            FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
            FRAMEBUFFER_BINDING: 0x8CA6,
            RENDERBUFFER_BINDING: 0x8CA7,
            MAX_RENDERBUFFER_SIZE: 0x84E8,
            INVALID_FRAMEBUFFER_OPERATION: 0x0506,
            UNPACK_FLIP_Y_WEBGL: 0x9240,
            UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
            CONTEXT_LOST_WEBGL: 0x9242,
            UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
            BROWSER_DEFAULT_WEBGL: 0x9244,

            // WEBGL_compressed_texture_s3tc
            COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
            COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
            COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
            COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,

            // WEBGL_compressed_texture_pvrtc
            COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
            COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
            COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
            COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,

            // WEBGL_compressed_texture_etc1
            COMPRESSED_RGB_ETC1_WEBGL: 0x8D64,

            // EXT_color_buffer_half_float
            HALF_FLOAT_OES: 0x8D61,

            // Desktop OpenGL
            DOUBLE: 0x140A,

            // WebGL 2
            READ_BUFFER: 0x0C02,
            UNPACK_ROW_LENGTH: 0x0CF2,
            UNPACK_SKIP_ROWS: 0x0CF3,
            UNPACK_SKIP_PIXELS: 0x0CF4,
            PACK_ROW_LENGTH: 0x0D02,
            PACK_SKIP_ROWS: 0x0D03,
            PACK_SKIP_PIXELS: 0x0D04,
            COLOR: 0x1800,
            DEPTH: 0x1801,
            STENCIL: 0x1802,
            RED: 0x1903,
            RGB8: 0x8051,
            RGBA8: 0x8058,
            RGB10_A2: 0x8059,
            TEXTURE_BINDING_3D: 0x806A,
            UNPACK_SKIP_IMAGES: 0x806D,
            UNPACK_IMAGE_HEIGHT: 0x806E,
            TEXTURE_3D: 0x806F,
            TEXTURE_WRAP_R: 0x8072,
            MAX_3D_TEXTURE_SIZE: 0x8073,
            UNSIGNED_INT_2_10_10_10_REV: 0x8368,
            MAX_ELEMENTS_VERTICES: 0x80E8,
            MAX_ELEMENTS_INDICES: 0x80E9,
            TEXTURE_MIN_LOD: 0x813A,
            TEXTURE_MAX_LOD: 0x813B,
            TEXTURE_BASE_LEVEL: 0x813C,
            TEXTURE_MAX_LEVEL: 0x813D,
            MIN: 0x8007,
            MAX: 0x8008,
            DEPTH_COMPONENT24: 0x81A6,
            MAX_TEXTURE_LOD_BIAS: 0x84FD,
            TEXTURE_COMPARE_MODE: 0x884C,
            TEXTURE_COMPARE_FUNC: 0x884D,
            CURRENT_QUERY: 0x8865,
            QUERY_RESULT: 0x8866,
            QUERY_RESULT_AVAILABLE: 0x8867,
            STREAM_READ: 0x88E1,
            STREAM_COPY: 0x88E2,
            STATIC_READ: 0x88E5,
            STATIC_COPY: 0x88E6,
            DYNAMIC_READ: 0x88E9,
            DYNAMIC_COPY: 0x88EA,
            MAX_DRAW_BUFFERS: 0x8824,
            DRAW_BUFFER0: 0x8825,
            DRAW_BUFFER1: 0x8826,
            DRAW_BUFFER2: 0x8827,
            DRAW_BUFFER3: 0x8828,
            DRAW_BUFFER4: 0x8829,
            DRAW_BUFFER5: 0x882A,
            DRAW_BUFFER6: 0x882B,
            DRAW_BUFFER7: 0x882C,
            DRAW_BUFFER8: 0x882D,
            DRAW_BUFFER9: 0x882E,
            DRAW_BUFFER10: 0x882F,
            DRAW_BUFFER11: 0x8830,
            DRAW_BUFFER12: 0x8831,
            DRAW_BUFFER13: 0x8832,
            DRAW_BUFFER14: 0x8833,
            DRAW_BUFFER15: 0x8834,
            MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49,
            MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A,
            SAMPLER_3D: 0x8B5F,
            SAMPLER_2D_SHADOW: 0x8B62,
            FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
            PIXEL_PACK_BUFFER: 0x88EB,
            PIXEL_UNPACK_BUFFER: 0x88EC,
            PIXEL_PACK_BUFFER_BINDING: 0x88ED,
            PIXEL_UNPACK_BUFFER_BINDING: 0x88EF,
            FLOAT_MAT2x3: 0x8B65,
            FLOAT_MAT2x4: 0x8B66,
            FLOAT_MAT3x2: 0x8B67,
            FLOAT_MAT3x4: 0x8B68,
            FLOAT_MAT4x2: 0x8B69,
            FLOAT_MAT4x3: 0x8B6A,
            SRGB: 0x8C40,
            SRGB8: 0x8C41,
            SRGB8_ALPHA8: 0x8C43,
            COMPARE_REF_TO_TEXTURE: 0x884E,
            RGBA32F: 0x8814,
            RGB32F: 0x8815,
            RGBA16F: 0x881A,
            RGB16F: 0x881B,
            VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD,
            MAX_ARRAY_TEXTURE_LAYERS: 0x88FF,
            MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
            MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
            MAX_VARYING_COMPONENTS: 0x8B4B,
            TEXTURE_2D_ARRAY: 0x8C1A,
            TEXTURE_BINDING_2D_ARRAY: 0x8C1D,
            R11F_G11F_B10F: 0x8C3A,
            UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B,
            RGB9_E5: 0x8C3D,
            UNSIGNED_INT_5_9_9_9_REV: 0x8C3E,
            TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F,
            MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80,
            TRANSFORM_FEEDBACK_VARYINGS: 0x8C83,
            TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
            TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,
            TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
            RASTERIZER_DISCARD: 0x8C89,
            MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
            MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,
            INTERLEAVED_ATTRIBS: 0x8C8C,
            SEPARATE_ATTRIBS: 0x8C8D,
            TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,
            TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,
            RGBA32UI: 0x8D70,
            RGB32UI: 0x8D71,
            RGBA16UI: 0x8D76,
            RGB16UI: 0x8D77,
            RGBA8UI: 0x8D7C,
            RGB8UI: 0x8D7D,
            RGBA32I: 0x8D82,
            RGB32I: 0x8D83,
            RGBA16I: 0x8D88,
            RGB16I: 0x8D89,
            RGBA8I: 0x8D8E,
            RGB8I: 0x8D8F,
            RED_INTEGER: 0x8D94,
            RGB_INTEGER: 0x8D98,
            RGBA_INTEGER: 0x8D99,
            SAMPLER_2D_ARRAY: 0x8DC1,
            SAMPLER_2D_ARRAY_SHADOW: 0x8DC4,
            SAMPLER_CUBE_SHADOW: 0x8DC5,
            UNSIGNED_INT_VEC2: 0x8DC6,
            UNSIGNED_INT_VEC3: 0x8DC7,
            UNSIGNED_INT_VEC4: 0x8DC8,
            INT_SAMPLER_2D: 0x8DCA,
            INT_SAMPLER_3D: 0x8DCB,
            INT_SAMPLER_CUBE: 0x8DCC,
            INT_SAMPLER_2D_ARRAY: 0x8DCF,
            UNSIGNED_INT_SAMPLER_2D: 0x8DD2,
            UNSIGNED_INT_SAMPLER_3D: 0x8DD3,
            UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4,
            UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,
            DEPTH_COMPONENT32F: 0x8CAC,
            DEPTH32F_STENCIL8: 0x8CAD,
            FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD,
            FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
            FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
            FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
            FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
            FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
            FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
            FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
            FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
            FRAMEBUFFER_DEFAULT: 0x8218,
            UNSIGNED_INT_24_8: 0x84FA,
            DEPTH24_STENCIL8: 0x88F0,
            UNSIGNED_NORMALIZED: 0x8C17,
            DRAW_FRAMEBUFFER_BINDING: 0x8CA6, // Same as FRAMEBUFFER_BINDING
            READ_FRAMEBUFFER: 0x8CA8,
            DRAW_FRAMEBUFFER: 0x8CA9,
            READ_FRAMEBUFFER_BINDING: 0x8CAA,
            RENDERBUFFER_SAMPLES: 0x8CAB,
            FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4,
            MAX_COLOR_ATTACHMENTS: 0x8CDF,
            COLOR_ATTACHMENT1: 0x8CE1,
            COLOR_ATTACHMENT2: 0x8CE2,
            COLOR_ATTACHMENT3: 0x8CE3,
            COLOR_ATTACHMENT4: 0x8CE4,
            COLOR_ATTACHMENT5: 0x8CE5,
            COLOR_ATTACHMENT6: 0x8CE6,
            COLOR_ATTACHMENT7: 0x8CE7,
            COLOR_ATTACHMENT8: 0x8CE8,
            COLOR_ATTACHMENT9: 0x8CE9,
            COLOR_ATTACHMENT10: 0x8CEA,
            COLOR_ATTACHMENT11: 0x8CEB,
            COLOR_ATTACHMENT12: 0x8CEC,
            COLOR_ATTACHMENT13: 0x8CED,
            COLOR_ATTACHMENT14: 0x8CEE,
            COLOR_ATTACHMENT15: 0x8CEF,
            FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56,
            MAX_SAMPLES: 0x8D57,
            HALF_FLOAT: 0x140B,
            RG: 0x8227,
            RG_INTEGER: 0x8228,
            R8: 0x8229,
            RG8: 0x822B,
            R16F: 0x822D,
            R32F: 0x822E,
            RG16F: 0x822F,
            RG32F: 0x8230,
            R8I: 0x8231,
            R8UI: 0x8232,
            R16I: 0x8233,
            R16UI: 0x8234,
            R32I: 0x8235,
            R32UI: 0x8236,
            RG8I: 0x8237,
            RG8UI: 0x8238,
            RG16I: 0x8239,
            RG16UI: 0x823A,
            RG32I: 0x823B,
            RG32UI: 0x823C,
            VERTEX_ARRAY_BINDING: 0x85B5,
            R8_SNORM: 0x8F94,
            RG8_SNORM: 0x8F95,
            RGB8_SNORM: 0x8F96,
            RGBA8_SNORM: 0x8F97,
            SIGNED_NORMALIZED: 0x8F9C,
            COPY_READ_BUFFER: 0x8F36,
            COPY_WRITE_BUFFER: 0x8F37,
            COPY_READ_BUFFER_BINDING: 0x8F36, // Same as COPY_READ_BUFFER
            COPY_WRITE_BUFFER_BINDING: 0x8F37, // Same as COPY_WRITE_BUFFER
            UNIFORM_BUFFER: 0x8A11,
            UNIFORM_BUFFER_BINDING: 0x8A28,
            UNIFORM_BUFFER_START: 0x8A29,
            UNIFORM_BUFFER_SIZE: 0x8A2A,
            MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B,
            MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D,
            MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E,
            MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F,
            MAX_UNIFORM_BLOCK_SIZE: 0x8A30,
            MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31,
            MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33,
            UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34,
            ACTIVE_UNIFORM_BLOCKS: 0x8A36,
            UNIFORM_TYPE: 0x8A37,
            UNIFORM_SIZE: 0x8A38,
            UNIFORM_BLOCK_INDEX: 0x8A3A,
            UNIFORM_OFFSET: 0x8A3B,
            UNIFORM_ARRAY_STRIDE: 0x8A3C,
            UNIFORM_MATRIX_STRIDE: 0x8A3D,
            UNIFORM_IS_ROW_MAJOR: 0x8A3E,
            UNIFORM_BLOCK_BINDING: 0x8A3F,
            UNIFORM_BLOCK_DATA_SIZE: 0x8A40,
            UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,
            UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,
            UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,
            UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,
            INVALID_INDEX: 0xFFFFFFFF,
            MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
            MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
            MAX_SERVER_WAIT_TIMEOUT: 0x9111,
            OBJECT_TYPE: 0x9112,
            SYNC_CONDITION: 0x9113,
            SYNC_STATUS: 0x9114,
            SYNC_FLAGS: 0x9115,
            SYNC_FENCE: 0x9116,
            SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
            UNSIGNALED: 0x9118,
            SIGNALED: 0x9119,
            ALREADY_SIGNALED: 0x911A,
            TIMEOUT_EXPIRED: 0x911B,
            CONDITION_SATISFIED: 0x911C,
            WAIT_FAILED: 0x911D,
            SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
            VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE,
            ANY_SAMPLES_PASSED: 0x8C2F,
            ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A,
            SAMPLER_BINDING: 0x8919,
            RGB10_A2UI: 0x906F,
            INT_2_10_10_10_REV: 0x8D9F,
            TRANSFORM_FEEDBACK: 0x8E22,
            TRANSFORM_FEEDBACK_PAUSED: 0x8E23,
            TRANSFORM_FEEDBACK_ACTIVE: 0x8E24,
            TRANSFORM_FEEDBACK_BINDING: 0x8E25,
            COMPRESSED_R11_EAC: 0x9270,
            COMPRESSED_SIGNED_R11_EAC: 0x9271,
            COMPRESSED_RG11_EAC: 0x9272,
            COMPRESSED_SIGNED_RG11_EAC: 0x9273,
            COMPRESSED_RGB8_ETC2: 0x9274,
            COMPRESSED_SRGB8_ETC2: 0x9275,
            COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,
            COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,
            COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
            COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,
            TEXTURE_IMMUTABLE_FORMAT: 0x912F,
            MAX_ELEMENT_INDEX: 0x8D6B,
            TEXTURE_IMMUTABLE_LEVELS: 0x82DF,

            // Extensions
            MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF
        };
        Object.freeze(table);
        return table[key];
    }
};;hmap.util = hmap.util || {};
/**
 * indexedDB,适合数据量比较大的本地缓存
 * @private
 */
hmap.util.IndexedDB = class {
    /**
     * 构造一个indexedDB对象
     * @param {String} dbName 数据库名
     * @param {Number} version 版本号，正整数
     * @param options
     * @param {Array<hmap.util.DataStore>} options.storeList 数据库初始化新建的存储空间
     */
    constructor(dbName, version, options = {}) {
        this._indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        this._dbName = dbName;
        if(!/^\d+$/.test(version)){
            throw new Error('version must be a integer greater than 0！');
        }
        this._version = version;
        if(options.storeList&&!options.storeList instanceof Array){
            throw new Error('options.storeList must be an array of hmap.util.DataStore！');
        }
        this._storeList = options.storeList||[]; //记录所有表结构，包括表名，主键，索引
        this._taskManager = hmap.core.TaskManager.instance();
        this.CLASS_NAME = "hmap.util.IndexedDB";
        this.id = "hmap.util.IndexedDB";
    }

    /**
     * 初始化数据库和存储空间
     */
    init() {
        this._request = this._indexedDB.open(this._dbName, this._version);
        const _this = this;
        this._request.onupgradeneeded = function (event) {
            const db = event.target.result;
            _this._storeList.forEach(item => {
                if (!db.objectStoreNames.contains(item.getStoreName())) {
                    const store = db.createObjectStore(item.getStoreName(), item.getStoreParam());
                    const indexList = item.getIndexList();
                    indexList.forEach(index => {
                        store.createIndex(index.indexName, index.keyPath, index.indexParam);
                    });
                }
            })
        };
        return new Promise((resolve, reject) => {
            const _this = this;
            this._request.onsuccess = function (event) {
                _this._dataBase = event.target.result;
                resolve({
                    code: 1,
                    msg: 'Database link opened successfully！',
                    res: event.target.result
                });
            };
            this._request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'Database link opened fail！',
                    res: event
                });
            };
        })
    }

    /**
     * 关闭数据库
     */
    closeDB() {
        this._dataBase.close();
    }

    /**
     * 添加存储空间
     * @param {hmap.util.DataStore} store 存储空间名称
     */
    addObjectStore(store) {
        this._storeList.push(store);
        //手动触发upgradeneeded，添加store
        this._version++;
        this.closeDB();
        this.init();
    }

    /**
     * 给指定名称的存储空间添加数据
     * @param {String} storeName 存储空间名称
     * @param {Object} data 行数据
     * @param {IDBValidKey | IDBKeyRange} key 主键,如果在store中已经有定义过，这里就可以省略，所以建议在初始化store的时候就把keyPath确定
     * @returns {Promise<any>} 返回Promise实例，成功返回{code:'ok'},失败返回event
     */
    addData(storeName, data = {}, key) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        const _this = this;
        return new Promise((resolve, reject) => {
            const db = _this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            let request;
            if (key) {
                request = objectStore.add(data, key);
            } else {
                request = objectStore.add(data);
            }
            request.onsuccess = function (event) {
                data = null;
                //这里直接返回是否添加成功的标识
                resolve({
                    code: 1,
                    msg: 'Added successfully！'
                });
            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'Add failed',
                    error: {
                        event,
                        data
                    }
                });
            }
        }).catch(e => {
            throw e;
        })
    }
    /**
     * rail模型给指定名称的存储空间添加数据,为s3m定制的，不具有通用性
     * @param {String} storeName 存储空间名称
     * @param {Object} data 行数据
     * @param {IDBValidKey | IDBKeyRange} key 主键,如果在store中已经有定义过，这里就可以省略，所以建议在初始化store的时候就把keyPath确定
     * @returns {Promise<any>} 返回Promise实例，成功返回{code:'ok'},失败返回event
     */
    addDataByTask(storeName, data = {}, key) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        const _this = this;
        return new Promise((resolve, reject) => {
            _this._taskManager.addHeavy(_this, function (param) {
                const {
                    storeName,
                    data,
                    key
                } = param;
                const db = _this._dataBase;
                const transaction = db.transaction([storeName], 'readwrite');
                const objectStore = transaction.objectStore(storeName);
                let request;
                if (key) {
                    request = objectStore.add(data, key);
                } else {
                    request = objectStore.add(data);
                }
                request.onsuccess = function (event) {
                    //这里直接返回是否添加成功的标识
                    resolve({
                        code: 1,
                        msg: 'Added successfully！'
                    });
                };
                request.onerror = function (event) {
                    reject({
                        code: 0,
                        msg: 'Add failed！',
                        error: {
                            event,
                            data
                        }
                    });
                }
            }, {
                storeName,
                data,
                key,
                id: data.tileName
            })
        }).catch(e => {
            throw e;
        })
    }

    /**
     * 从指定的存储空间获取指定key的数据
     * @param {String} storeName 存储空间名称
     * @param {*} keyValue key值
     */
    getData(storeName, keyValue) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.get(keyValue);
            request.onsuccess = function (event) {
                if (event.target.result) {
                    resolve({
                        code: 1,
                        msg: 'ok！',
                        result: event.target.result
                    });
                } else {
                    resolve({
                        code: 2,
                        result: event.target.result,
                        msg: 'No corresponding data found！'
                    });
                }
            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'fail！',
                    error: event
                });
            }
        })
    }

    /**
     * 在指定的存储空间，通过索引查询，如果不传索引，默认就是主键对应的索引
     * @param {String} indexName 索引名称，dataStore中indexList的indexName
     * @param {String} storeName 存储空间名称
     * @param keyValue 主键的值
     * @returns {Promise<any>}
     */
    findData(storeName, indexName,keyValue) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const index = objectStore.index(indexName);
            const request = index.get(keyValue);
            request.onsuccess = function (event) {
                resolve(event.target.result);

            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'query failed！',
                    error: event
                });
            }
        })
    }

    /**
     * 从指定的存储空间删除指定key的数据
     * @param {String} storeName 存储空间名称
     * @param {*} keyValue key值
     */
    delData(storeName, keyValue) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.delete(keyValue);
            request.onsuccess = function (event) {
                if (event.target.result) {
                    resolve({
                        code: 1,
                        result: event.target.result,
                        msg: 'deleted successfully！'
                    });
                } else {
                    resolve({
                        code: 2,
                        result: event.target.result,
                        msg: 'No corresponding data found！'
                    });
                }
            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'delete failed！',
                    error: event
                });
            }
        })
    }

    /**
     * 清空指定名称的存储空间的所有数据
     * @param storeName
     */
    clearData(storeName) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.clear();
            request.onsuccess = function (event) {
                resolve({
                    code: 1,
                    result: event.target.result,
                    msg: 'cleared successfully！'
                });
            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'clear failed！',
                    error: event
                });
            }
        })
    }

    /**
     * 从指定的存储空间更新某条数据
     * @param {String} storeName 存储空间名称
     * @param {*} data 要更新的数据
     */
    updateData(storeName, data) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.put(data);
            request.onsuccess = function (event) {
                //这里应该有一个判断是新增还是更新
                resolve({
                    code: 1,
                    result: event.target.result,
                    msg: 'updated successfully！'
                });
            };
            request.onerror = function (event) {
                reject({
                    code: 0,
                    msg: 'update failed！',
                    error: event
                });
            }
        })
    }

    /**
     * 从指定的存储空间获取所有数据
     * @param {String} storeName 存储空间名称
     * @returns {Promise}
     */
    getAllData(storeName) {
        //首先判断是否存在指定的存储空间
        if (!this._dataBase.objectStoreNames.contains(storeName)) {
            throw new Error('No objectStore was found for the specified name！');
        }
        const res = [];
        return new Promise((resolve, reject) => {
            const db = this._dataBase;
            const transaction = db.transaction([storeName], 'readwrite');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.openCursor();
            request.onsuccess = function (event) {
                const cursor = event.target.result;
                if (cursor) {
                    res.push(cursor.value);
                    cursor.continue();
                } else {
                    resolve(res);
                }
            };
            request.onerror = function (event) {
                reject(event);
            }
        })
    }
};

/**
 * indexedDb的数据存储空间，相当于sql的table
 * @type {hmap.util.DataStore}
 * @private
 */
hmap.util.DataStore = class {
    /**
     * @param {String} storeName 存储空间名称
     * @param {IDBObjectStoreParameters} options
     * @param {String|Array<String>|null} options.keyPath 主键,选填项，但是建议在初始化存储空间的时候就定下来，如果这里没有keyPath，addData的时候也不指定keyPath就会报错
     * @param {Boolean} options.autoIncrement 主键自增
     */
    constructor(storeName, options = {
        keyPath: 'id',
        autoIncrement: true
    }) {
        this._storeName = storeName;
        this._storeParam = options;
        this._indexList = [];
    }

    getStoreName() {
        return this._storeName;
    }

    getStoreParam() {
        return this._storeParam;
    }

    getIndexList() {
        return this._indexList;
    }

    /**
     * 设置索引
     * @param {String} indexName 索引名称，通过索引查询的时候用到
     * @param {String|Array<String>} keyPath 创建索引的属性名
     * @param {IDBIndexParameters} indexParam 索引可选参数
     * @param {Boolean} indexParam.unique 用来指定索引值是否可以重复，为true代表不能相同，为false时代表可以相同
     * @param {Boolean} indexParam.multiEntry 如果设为true，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。
     */
    setIndex(indexName, keyPath, indexParam) {
        this._indexList.push({
            indexName,
            keyPath,
            indexParam
        });
    }
};;"use strict";
/**
 * 图层容器类
 * @type {hmap.LayerContainer}
 * @private
 */
hmap.LayerContainer = class {
    /**
     * @param containerId {String} 容器的id，用来唯一标识一个容器
     */
    constructor(containerId='hmapCanvas') {
        this._container = null;
        this._containerZIndex = 0;
        this._context = null;
        this._layers = [];//保存该container中所有的图层
        this._map = null;
        this._initContainer(containerId);
        this.CLASS_NAME = "hmap.LayerContainer";
        if(containerId==='hmapCanvas'){
            this.program=new hmap.program.PolyColorProgram(this._context);
            this.drawBackground=this._drawBackground;
            //this.drawBackground=this._clearScreen;
        }else{
            this.drawBackground=this._clearScreen;
        }
    }
    _initContainer(id){
        const canvas = document.createElement('canvas');
        canvas.id = id;
        canvas.style.position = "absolute";
        canvas.style.width = "100%";
        canvas.style.height = "100%";
        canvas.style.overflow = "hidden";
        canvas.style.zIndex = this._containerZIndex;
        this._container = canvas;
        //TODO 考虑第二个参数是否能删除，目前配置界面的保存图片功能需要此项。
        this._context =canvas.getContext("webgl2",{preserveDrawingBuffer: true, antialias:true});
    }

    destroy(){
        //移除dom
        this._map.container.removeChild(this._container);
        const help=hmap.help.glHelper.get(this._context);
        if(help)
            help.destroy();
        const layers = this.getLayers();
        const len = layers.length;
        for(let i=len-1;i>-1;i--){
            layers[i]._map = null;
            layers[i].setLayerContainer(null);
            layers[i]=null;
            layers.splice(i,1);
        }
        this._container=null;
        this._context=null;
    }

    /**
     * 返回容器
     * @returns {null|*}
     */
    getContainer(){
        return this._container;
    }

    /**
     * 返回容器的id
     */
    getContainerId(){
        return this._container.id;
    }

    /**
     * 返回容器的ZIndex
     * @returns {number|*}
     */
    getContainerZIndex(){
        return parseFloat(this._container.style.zIndex);
    }

    /**
     * 返回图层容器的上下文
     * @returns {null|*}
     */
    getContext(){
        return this._context;
    }

    /**
     * 返回该图层容器内所有的图层
     * @returns {Array}
     */
    getLayers(){
        return this._layers;
    }

    /**
     * 设置图层容器的id
     * @param id {String}
     */
    setContainerId(id){
        this._container.id = id;
    }

    /**
     * 设置容器的ZIndex
     * @param zindex {Number} 容器的ZIndex
     */
    setContainerZIndex(zindex){
        this._containerZIndex = zindex;
        this._container.style.zIndex = zindex;
    }

    /**
     *
     * @param map
*/
    setMap(map){
        this._map = map;
    }
    /**
     * 根据图层的id返回对应的图层
     * @param layerId
     * @returns {*}
     */
    getLayerById(layerId){
        for(let i=0;i<this._layers.length;i++){
            if(layerId===this._layers[i].getId()) {
                return this._layers[i];
            }
        }
        return null;
    }

    /**
     * 添加一个图层到图层容器中
     * @param layer {hmap.layer.Layer} 要添加的图层
     * @param zIndex {Number} 控制上下顺序的索引值
     */
    addLayer(layer,zIndex){
        const map = this.getMap();
        if(layer.isBaseLayer()&& (layer.CLASS_NAME === "hmap.layer.TMSLayer" || layer.CLASS_NAME === "hmap.layer.VectorTileLayer")){//如果图层是基础图层
            if(layer.getCrs()) {
                map.setCrs(layer.getCrs());
                map._resolutions = layer.getResolutions();
            }
            map._camera.setCrs(map._crs);
        }

        const layers = this._layers;
        if(zIndex!==undefined&&zIndex!==null){
            layer.setZIndex(zIndex);
        }else{
            //求出当前最大的ZIndex
            let maxZIndex = -1;
            for(let i=0;i<layers.length;i++){
                if(layers[i].getZIndex() > maxZIndex){
                    maxZIndex = layers[i].getZIndex();
                }
            }
            layer.setZIndex(maxZIndex + 1);
        }
        layer.setLayerContainer(this);
        layer.setMap(map);
        layers.push(layer);
        this.orderLayerByIndex();
    }

    /**
     * 从图层容器中移除一个指定的图层，同时将该图层从地图上移除
     * @param layer
     */
    removeLayer(layer){
        const layers = this.getLayers();
        for(let i = 0;i<layers.length;i++){
            if(layer ===layers[i]){
                layer._map=null;
                layers.splice(i,1);
            }
        }
    }

    /**
     * 移除图层容器中所有的图层，同时将所有图层从地图上移除
     */
    removeAllLayers(){
        const layers = this.getLayers();
        const len = layers.length;
        for(let i=len-1;i>-1;i--){
            layers[i]._map = null;
            layers.splice(i,1);
        }
    }

    /**
     * 按照索引值大小升序排序
     * @private
     */
    orderLayerByIndex() {
        const layers = this._layers;
        const orderByZIndex = function (layerA,layerB) {
            return layerA.getZIndex() - layerB.getZIndex();
        };
        layers.sort(orderByZIndex);
    }

    /**
     * 返回最大的ZIndex
     */
    getLayerMaxZIndex(){
        let maxZIndex=0;
        const layers = this._layers;
        for(let i=0;i<layers.length;i++){
            if(layers[i].getZIndex()>maxZIndex){
                maxZIndex = layers[i].getZIndex();
            }
        }
        return maxZIndex;
    }
    /**
     *  返回最小的ZIndex
     */
    getLayerMinZIndex(){
        const layers = this._layers;
        let minZIndex= -1;
        if(layers.length>0){
            minZIndex = layers[0].getZIndex();
        }
        for(let i=0;i<layers.length;i++){
            if(layers[i].getZIndex()<minZIndex){
                minZIndex = layers[i].getZIndex();
            }
        }
        return minZIndex;
    }

    /**
     * 返回图层容器关联的地图对象
     * @returns {null|*}
     */
    getMap(){
        return this._map;
    }


    /**
     * 重新绘制,包括绘制背景和绘制所有可见的图层
     * @param type {Number} 0或1. 0 表示map调用redraw，1表示layer调用redraw。
     * @param force {Boolean} 是否强制重绘，默认值为false，即不强制重绘。
     */
    redraw(type){
        if(this._layers.length<=0){
            return;
        }
        this.drawBackground();
        const len = this._layers.length;
        for(let i=0;i<len;i++){
            const layer = this._layers[i];

            if(type===0) layer.prepareData();

            if(layer.getVisibility()) layer.draw();
        }
    }

    /**
     * 绘制图层容器的背景色
     * @private
     */
    _drawBackground(){
        //TODO  修改背景色和雾色的绘制，不能依赖图层
        const map = this.getMap();
        const context = this.getContext();
        const program=this.program;
        const fogColor=map.getFogColor();
        this.getContainer().style.backgroundColor='rgba(' + fogColor[0] + ',' + fogColor[1] + ',' +fogColor[2] + ',' + fogColor[3] + ')';
        //context.enable(context.DEPTH_TEST);
        // context.disable(context.CULL_FACE);
        // context.disable(context.BLEND)
        context.clearColor(fogColor[0],fogColor[1],fogColor[2],fogColor[3]);
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
        const isViewChange = map._resizeCanvasToDisplaySize(this.getContainer());
        if (isViewChange) {
            map._setViewPort(context);
        }
        //创建vao
        if(!this._bkVao){
            const vao=context.createVertexArray();
            context.bindVertexArray(vao);
            const vbos=program.createVBOs(context);
            context.bindVertexArray(null);
            this._bkVao= {'vao':vao,'vbos':vbos};
        }
        //组织数据
        //const xyzs=[...map._camera.getFogBackgroundCoords(),...map._camera.getMapBackgroundCoords()];
        const xyzs=map._camera.getMapBackgroundCoords();
        let arrays= {posH:xyzs,posL:new Array(12).fill(0)};
        const data= {
            a_position:arrays.posH,
            a_positionL:arrays.posL,
            a_color:[].concat.apply([],new Array(4).fill(map.getLandColor())),
            a_checked:[0,0,0,0,0,0],
            // index:[8,5,6,6,7,8]
            index:[3,0,1,1,2,3]
        };
        program.setGL(context);
        program.setVBOs(this._bkVao.vbos,data);
        const res=map.getResolution();
        const numDash1px=(1/res)/20;//约1px需要的纹理个数,注意宽线纹理
        program.useProgram();
        program.setPublicUniforms(map.getVPMatrix(),map.getFogColor(),map.getFogDist());
        const coord=map.getCamera().getCoordinate();
        const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
        const xx=this._float32FromDouble64(x),yy=this._float32FromDouble64(y),zz=this._float32FromDouble64(z);
        const splitPrecision={
            chx:xx[0],
            clx:xx[1],
            chy:yy[0],
            cly:yy[1],
            chz:zz[0],
            clz:zz[1]
        };
        program.setPrivateUniforms({
            u_viewport: [0, 0, context.canvas.clientWidth, context.canvas.clientHeight],
            u_color: [0.0, 1.0, 0.0, 1],
            NumDash: numDash1px,
            u_mvMatrix: map.getViewMatrix(),
            u_ifRTE: false,
            u_camera: splitPrecision,
            u_projMatrix: map.getProjMatrix(),
            u_resolution: res,
            u_farPlaneD: false,
            u_logConstant:0.00000001,
            u_ifLGD: false,
            u_opacity: 1.0,
        });
        context.bindVertexArray(this._bkVao.vao);
        program.draw(6);
        context.bindVertexArray(null);
    }

    /**
     * 用透明色清除画布
     * @private
     */
    _clearScreen(){
        const map = this.getMap();
        const context = this.getContext();
        const isViewChange = map._resizeCanvasToDisplaySize(this.getContainer());
        if (isViewChange) {
            map._setViewPort(context);
        }
        context.clearColor(0.0,0.0,0.0,0.0);
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
    }
    _float32FromDouble64(num){

        let high=0,low=0,tempHigh=0;
        if(this.mapUnit=="degrees"){
            high=Math.floor(num);
            low=(num-high)*Math.pow(10,7);
            low=Math.floor(low);
        }else{
            if(num>0){
                tempHigh = Math.floor(num / 65536) * 65536;
                high = tempHigh;
                low = num - tempHigh;
            }else{
                tempHigh = Math.floor(-num / 65536) * 65536;
                high = -tempHigh;
                low = num + tempHigh
            }
        }
        return [high,low];
    }

    // redrawCountIncrease() {
    //     this._redrawCount++;
    // }
    //
    // redrawCountDecrease() {
    //     this._redrawCount--;
    //     if (this._redrawCount < 0) {
    //         this._redrawCount = 0;
    //     }
    // }
};
;"use strict";
/**
 * 地图对象。
 * 1、一个地图对象只能有一个容器和一个坐标系。
 * 2、地图视窗指地图的可视屏幕范围，即地图的容器范围。
 * 3、地图分辨率由底图决定。
 * 4、每个地图对象包含一个event属性，用于实现事件的注册和注销，参见{@link hmap.event.EventManager}。
 * @type {hmap.Map}
 * @example
 * //要在body元素中添加<div id="hmap"></div>
 * let res=[
 1.40625,//全球 360/256
 0.703125,
 0.3515625,
 0.17578125,
 0.087890625,
 0.0439453125,
 0.02197265625,
 0.010986328125,
 0.0054931640625,
 0.00274658203125,
 0.001373291015625,
 0.0006866455078125,
 0.00034332275390625,
 0.000171661376953125,
 0.0000858306884765629,
 0.0000429153442382814,
 0.000021457672119140625,
 0.000010728836059570312,
 0.000005364418029785156,//街道
 0.000002682209014892578,
 0.000001341104507446289];//地图分辨率
 * let coord = new hmap.basetype.Coordinate(120.435078, 30.19345, 0);
 * let mapOptions = {
            zoom: 12,//地图初始化时的级别
            center: coord,//地图初始化时的中心点
            resolutions: res,//地图的分辨率数组
            crs:new hmap.proj.Crs('4326') //地图采用的坐标系
       };
 * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id
 */

hmap.Map = class {
    /**
     * 构造一个地图实例。
     * @param {String} divid 一个div元素id的属性值，该div元素将作为地图容器。同时构造Map对象时，会自动创建一个id为’hmap‘的canvas作为底图的图层容器（画板）。
     * @param {Object} options 地图选项，其中坐标系选项是必须要指明的。
     * @param {hmap.basetype.Coordinate} options.center 地图中心的地理坐标。
     * @param {hmap.proj.Crs} options.crs 地图的坐标系,如果不指定则默认WGS-84。
     * @param {Number} options.maxPitch 地图的最大俯仰角角度，建议取值范围0 ~ 85，默认值为65，如果取值不在建议范围内，可能会出现地图显示异常的情况。
     * @param {Array<Number>} options.resolutions 分辨率数组，分辨率数组中每个元素对应地图每个缩放级别的分辨率。
     * @param {Number} options.zoom 地图默认缩放级别。
     * @param {Number} options.minLevel 地图可以缩小到的最小级别，默认为0
     * @param {Number} options.maxLevel 地图可以放大到的最大级别，默认为最小分辨率对应的级别。
     * @param {hmap.basetype.Extent} options.restrictedExtent 允许访问的地图的最大范围，超过该范围时不允许拖动地图。
     * @param {Boolean} options.enableRotate 地图默认是否可以旋转，默认为true,如果为false，map初始化之后还可以通过addControl添加旋转控件。
     * @param {Boolean} options.enablePan 地图默认是否可以平移，默认为true,如果为false，map初始化之后还可以通过addControl添加平移控件。
     * @param {Boolean} options.enableZoom 地图默认是否可以缩放，默认为true,如果为false，map初始化之后还可以通过addControl添加缩放控件。
     * @param {Number} options.zoomInterval 滚轮滚动zoomInterval次，地图级别改变一级，默认为1。如，当前地图为15级，将在滚轮滚动zoomInterval次后，
     * 会再次向服务器请求数据并渲染。当图层是栅格图层如TMS、WMS时，在放大或者缩小时，会出现图片模糊的情况，建议该参数设置为1，消除图片模糊的情况。
     *
     */
    constructor(divid, options = {}) {

        //地图容器,首先要判断是否为一个div元素

        this._onMap = true;
        this._hasMove = false;//用来区分 click mousedown mouseup事件的共享冲突  当为true时不会触发click事件 反之触发
        //如果坐标系未指定,默认采用CGCS2000
        this._crs = (options.crs && (options.crs instanceof hmap.proj.Crs)) ? options.crs : new hmap.proj.Crs('4326');
        //根据地图坐标初始化精度纠正函数
        hmap.core.precision=new hmap.core.Precision(this._crs.getUnit());
        hmap._srid = this._crs.getSrid();
        this._maxPitch = options.maxPitch ? options.maxPitch : 65;
        // 地图事件池，一个hashMap对象。一个键值对集合，键表示事件名称；值为对应的执行函数。
        this.event = new hmap.event.EventManager();

        //地图的分辨率数组
        if (options.resolutions) {
            this._resolutions = options.resolutions;
        } else {
            this._resolutions = this._createRessByCrs(this._crs);
        }
        //比例级别范围
        let reslen = this._resolutions.length;
        if (reslen <= 0) {
            throw new TypeError("resolutions is illegal");
        } else {
            this._minLevel = options.minLevel ? options.minLevel : 0;
            this._maxLevel = options.maxLevel ? options.maxLevel : reslen - 1;
            if (!(this._minLevel >= 0 && this._minLevel <= this._maxLevel && this._maxLevel <= reslen - 1)) {
                throw "The parameters minLevel and maxLevel are not valid";
            }
        }
        //当前地图的比例级别
        this._zoom = options.zoom ? options.zoom : 11;
        this._zoomWithInterval = this._zoom;
        this._zoomInterval = options.zoomInterval || 1;
        //地图中心点
        this._center = options.center ? options.center : new hmap.basetype.Coordinate(0, 0, 0);
        //地图最大的显示范围，超过该范围不允许缩小或拖动
        this._restrictedExtent = options.restrictedExtent ? options.restrictedExtent : null;
        //存放所有的图层容器
        this._layerContainers = [];
        this._overlayLayers = [];
        this.container = this._createDomOptions(divid);
        this._addLayerContainer('hmapCanvas');//添加一个默认的layerContainer
        //=======================相机设置==================
        const centerX = this.getCenter().getOrdinate("X"), centerY = this.getCenter().getOrdinate("Y");
        const currentResolution = this.getResolution(this._zoom);
        this.mapdiv = (typeof divid === 'string') ? document.getElementById(divid) : divid;
        const size = this._getElementSize(this.mapdiv);
        const w = size[0], h = size[1];
        this._camera = new hmap.Camera(centerX, centerY, currentResolution, w, h, this.getCrs());
        //地图控件
        this._controls = [];
        //设置雾化
        this._fogColor = [0.75, 0.75, 0.75, 1.0];
        this._landColor = [0.75, 0.75, 0.75, 1.0];

        this._wheelEnable = false;
        this._dragEnable = false;
        this._dragging = false;

        this.animate = null;
        this.startTime = Date.now();
        this._hasBaseLayer = false;
        this._enablePan = options.hasOwnProperty("enablePan") ? options.enablePan : true;
        this._enableZoom = options.hasOwnProperty("enableZoom") ? options.enableZoom : true;
        this._enableRotate = options.hasOwnProperty("enableRotate") ? options.enableRotate : true;
        this._initControl();
        this.CLASS_NAME = "hmap.Map";
        //hmap默认创建的唯一标识
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //注册地图的默认事件
        this.af=new hmap.core.AF(this);
        this._register();
    }

    /**
     * 初始化平移旋转缩放控件
     * @private
     */
    _initControl() {
        if (this.getPanEnable()) {
            this._panCtr = new hmap.control.Pan();
            this.addControl(this._panCtr);
        }
        if (this.getZoomEnable()) {
            this._zoomCtr = new hmap.control.Zoom();
            this.addControl(this._zoomCtr);
        }
        if (this.getRotateEnable()) {
            this._rotateCtr = new hmap.control.Rotate();
            this.addControl(this._rotateCtr);
        }
    }

    _createRessByCrs(crs) {
        let resArr = [];
        let extWidth = crs.getExtent().getWidth();
        const firstRes = extWidth / 256;
        for (let i = 0; i < 21; i++) {
            resArr.push(firstRes * Math.pow(0.5, i));
        }
        return resArr;
    }

    /**
     * 创建地图容器，本质上是一个dom元素。为了更好的扩展：默认创建一个div元素作为地图的顶级元素，再创建一个canvas用来存放所有的图层内容。
     * @private
     */
    _createDomOptions(divid) {
        let element = (typeof divid === 'string') ? document.getElementById(divid) : divid;
        if (element !== null && element.tagName === "DIV") {
            element.style.position = "relative";
            element.style.overflow = 'hidden';
            const size = this._getElementSize(element);
            const w = size[0], h = size[1];
            if (h === 0) {
                throw "The height of map div cannot be 0";
            }

            let container = document.createElement("DIV");
            container.style.position = "relative";
            container.style.width = "100%";
            container.style.height = "100%";
            container.style.overflow = "hidden";
            container.oncontextmenu = function () {
                return false;
            };
            element.appendChild(container);
            return container;

        } else {
            throw new Error("map container is not a 'div' dom-element!");
        }
    }

    _addLayerContainer(containerId = 'hmapCanvas') {
        const lyContainer = new hmap.LayerContainer(containerId);
        lyContainer.setMap(this);
        this.container.appendChild(lyContainer.getContainer());
        this._layerContainers.push(lyContainer);
        return lyContainer;
    }

    getMapContainer() {
        return this.container;
    }

    _getElementSize(element) {
        // let w = element.clientWidth, h = element.clientHeight;
        // if (w === 0 && h === 0 || isNaN(w) && isNaN(h)) {
        //     w = element.offsetWidth;
        //     h = element.offsetHeight;
        // }
        // if (w === 0 && h === 0 || isNaN(w) && isNaN(h)) {
        //     w = parseInt(element.style.width);
        //     h = parseInt(element.style.height);
        // }
        let w = element.clientWidth || element.offsetWidth || parseInt(element.style.width);
        let h = element.clientHeight || element.offsetHeight || parseInt(element.style.height);
        return [w, h];
    }

    //当窗口改变时,更改相机参数
    _resize() {
        const [w, h] = this._getElementSize(this.container);
        this._camera.updateContainerSize(w, h);
        const pixel = new hmap.basetype.Pixel(w / 2, h / 2);
        this._center = this.getCoordinateFromPixel(pixel);
        this.setCenter(this._center, this._zoom);
    }

    getControls() {
        return this._controls;
    }

    /**
     * 获取相机对象。
     * @returns {hmap.Camera} 相机对象。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);
     * map.getCamera();
     */
    getCamera() {
        return this._camera;
    }

    //event.button
    //0 left button
    //1 middle button
    //2 right button
    //event.buttons
    // 0  : No button or un-initialized
    // 1  : Primary button (usually left)
    // 2  : Secondary button (usually right)
    // 4  : Auxilary button (usually middle or mouse wheel button)
    // 8  : 4th button (typically the "Browser Back" button)
    // 16 : 5th button (typically the "Browser Forward" button)
    _register() {
        this.clickTimer = null;
        //当用户点击某个对象时调用的事件句柄。
        this.container.addEventListener("click", function (event) {
            if (!this._hasMove) {
                if (this.clickTimer) clearTimeout(this.clickTimer);
                const targetBounding = this.container.getBoundingClientRect();
                event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
                event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
                let _eventManager = this.event, _event = event;
                this.clickTimer = setTimeout(function () {
                    _eventManager.fire(_event);
                }, 300);
            }
        }.bind(this));
        //当用户双击某个对象时调用的事件句柄。
        this.container.addEventListener("dblclick", function (event) {
            if (this.clickTimer) clearTimeout(this.clickTimer);
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
        }.bind(this));
        //鼠标按钮被按下
        this.container.addEventListener("mousedown", function (event) {
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
            // hmap.style.Cursor.set(this.container, "HAND_DRAG");
        }.bind(this));
        //鼠标被移动。
        this.container.addEventListener("mousemove", function (event) {
            if (!this._onMap) {
                return;
            }
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
        }.bind(this));
        //鼠标从某元素移出。
        this.container.addEventListener("mouseout", function (event) {
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
        }.bind(this));
        //鼠标移到某元素之上
        this.container.addEventListener("mouseover", function (event) {
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
            // hmap.style.Cursor.set(this.container, "HAND_RELEASE");
        }.bind(this));
        //鼠标按键被松开
        this.container.addEventListener("mouseup", function (event) {
            if (!this._onMap) {
                return;
            }
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
            // hmap.style.Cursor.set(this.container, "HAND_RELEASE");
        }.bind(this));
        this.container.addEventListener("mousewheel", function (event) {
            if (!this._onMap) {
                return;
            }
            const targetBounding = this.container.getBoundingClientRect();
            event.mapPixel = new hmap.basetype.Pixel(event.clientX - targetBounding.left - this.container.clientLeft, event.clientY - targetBounding.top - this.container.clientTop);
            event.lonlat = this.getCoordinateFromPixel(new hmap.basetype.Pixel(event.mapPixel.getX(), event.mapPixel.getY()));
            this.event.fire(event);
        }.bind(this));

        // 监听窗口大小改变
        window.addEventListener("resize", function (e) {
            this._resize();
        }.bind(this), true);
    }

    /**
     * 添加一组图层。该方法根据图层在数组中的先后顺序，依次将图层添加到地图上。
     * @param {Array<hmap.layer.Layer>} layers 图层数组。
     * @param containerId {String} 图层容器的名称标识,该名称标识可以自己命名，默认值为‘hmapCanvas’。当传入名称标识时，layers的图层会共用该名称标识对应的图层容器。如果Map中不包含该标识的图层容器时，会自动创建一个新的图层容器（比如canvas）。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let tileOrigin = new hmap.basetype.Coordinate(-180, 90);
     * let tmsOptions = {
            matrixOrigin: tileOrigin,//切片原点
            dataFormat: "png"//切片文件的格式
       };
     * let tmsLayer = new hmap.layer.TMSLayer("杭州地图", "http://ip:port/GeoData/map/SpiritMap/vec/", tmsOptions);//url地址为：地图切片的地址
     * map.addLayer(tmsLayer);
     * let vecLayer1 = new hmap.layer.VectorLayer("矢量图层1");
     * let vecLayer2 = new hmap.layer.VectorLayer('矢量图层2');
     * map.addLayers([vecLayer1,vecLayer2],'vectorLayerContainer');
     */
    addLayers(layers, containerId = 'hmapCanvas') {
        const layerContainer = this._getLayerContainerById(containerId);
        for (let i = 0; i < layers.length; i++) {
            const layer = layers[i];
            //非图层实例不能添加
            if (!(layer instanceof hmap.layer.Layer)) {
                continue;
            }
            //layer已经添加到地图上
            if (layer.getLayerContainer()) {
                continue;
            }
            layerContainer.addLayer(layer);
        }
        this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_REDRAW));
        //this.redraw();
    }

    /**
     *
     * @private
     */
    _getLayerContainerById(containerId) {
        const layerContainers = this._layerContainers;
        let layerContainer = null;
        //判断layerContainers中是否包含id为containerId的容器
        for (let i = 0; i < layerContainers.length; i++) {
            if (containerId === layerContainers[i].getContainerId()) {
                layerContainer = layerContainers[i];
                break;
            }
        }
        if (!layerContainer) {
            layerContainer = this._addLayerContainer(containerId);
        }
        return layerContainer;
    }

    /**
     * 添加一个地图控件。
     * @param {hmap.control.Control} control 地图控件。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let matrixOrigin = new hmap.basetype.Coordinate(-180, 90);
     * let tmsOptions = {
            matrixOrigin: matrixOrigin,//切片原点
            dataFormat: "png"//切片类型
       };
     * let tmsLayer = new hmap.layer.TMSLayer("杭州地图", "http://ip:port/GeoData/map/SpiritMap/vec/", tmsOptions);//url地址为：地图切片的地址
     * map.addLayer(tmsLayer);
     * let panControl = new hmap.control.Pan();
     * map.addControl(panControl);
     */
    addControl(control) {
        let has = false;
        const len = this._controls.length;
        for (let i = 0; i < len; i++) {
            if (this._controls[i].CLASS_NAME === control.CLASS_NAME) {
                has = true;
                return;//如果已经存在相同控件直接跳出。
            }
        }
        if (!has) {
            this._controls.push(control);
            control.setMap(this);
        }

    }

    /**
     * 移除地图控件。
     * @param {hmap.control.Control} control 地图控件
     */
    removeControl(control) {
        for (let i = 0; i < this._controls.length; i++) {
            if (this._controls[i].CLASS_NAME === control.CLASS_NAME) {
                //如果存在，则删除，且删除map中的数组的引用
                control.destroy();
                this._controls.splice(i,1);
            }
        }
    }

    /**
     * 添加图层。图层的zIndex决定了该图层在图层容器中的顺序，值越大，顺序越靠上。
     * @param {hmap.layer.Layer} layer 图层对象。
     * @param {Number} zIndex 图层的zIndex，其值为大于0的整数。用来控制在同一个图层容器（画板）中图层显示的上下顺序。zIndex越大显示越靠上，当不传或传null时，会生成一个比图层画板中图层zIndex的最大值大1的值。
     * @param {String} containerId 图层容器的名称标识,该名称标识可以自己命名，默认值为‘hmap’。当传入名称标识时，
     *                 layer图层会使用该名称标识对应的图层容器。如果Map中不包含该名称标识对应的图层容器时，会自动创建一个新的图层容器（比如canvas）。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);
     * const vecLayer1 = new hmap.layer.VectorLayer();
     * map.addLayer(vecLayer1,3,'veclayerContainer');
     * const vecLayer2 = new hmap.layer.VectorLayer();
     * map.addLayer(vecLayer2,null,'veclayerContainer');
     */
    addLayer(layer, zIndex, containerId = 'hmapCanvas') {//
        //WebGL 图层
        if (layer instanceof hmap.layer.Layer) {
            //layer已经添加到地图上
            if (layer.getLayerContainer()) {
                return;
            }
            const layerContainer = this._getLayerContainerById(containerId);
            layerContainer.addLayer(layer, zIndex);
        } else if (layer instanceof hmap.layer.OverlayLayer) {//OverlayLayer
            layer.setMap(this);
            this._overlayLayers.push(layer);
        }
        //this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_REDRAW));
         this.redraw();
    }

    /**
     *
     * @returns {Array}
     */
    getLayerContainers() {
        return this._layerContainers;
    }

    /**
     * 根据图层容器的id找到对应的图层容器对象。
     * @param id {String}
     * @returns {hmap.layer.LayerContainer}
     * @private
     */
    getLayerContainerById(id) {
        const layerContainers = this._layerContainers;
        let container = null;
        for (let i = 0; i < layerContainers.length; i++) {
            if (id === layerContainers[i].getContainerId()) {
                container = layerContainers[i];
            }
        }
        return container;
    }

    //==========视图矩阵与投影矩阵设置==================
    /**
     * 获取视图矩阵。
     * @returns {hmap.util.Matrix4} 视图矩阵。
     */
    getViewMatrix() {
        return this._camera.getViewMatrix();
    }

    /**
     * 获取投影矩阵。
     * @returns {hmap.util.Matrix4} 投影矩阵。
     */
    getProjMatrix() {
        return this._camera.getPMatrix();
    }

    /**
     * 获取视图投影矩阵。
     * @returns {hmap.util.Matrix4} 视图投影矩阵。该矩阵为投影矩阵右乘视图矩阵得到的结果。
     */
    getVPMatrix() {
        return this._camera.getVPMatrix();
    }

    /**
     * 获取雾化距离参数。
     * @returns {Array<Number>} 雾化参数数组。包含两个元素，第一个元素为开始雾化的距离，第二个元素为雾化程度最大的距离。
     * @private
     */
    getFogDist() {
        return [this._camera.getFogStartDepth(), this._camera.getFogEndDepth()];
    }

    /**
     * 获取雾的颜色值。
     * @returns {Array<Number>} 雾的颜色值。
     * @private
     */
    getFogColor() {
        return this._fogColor;
    }

    /**
     * 获取陆地颜色，返回格式为归一化后的rgba数组
     * @returns {Array<Number>} 归一化后的rgba组成的数组
     */
    getLandColor() {
        return this._landColor;
    }

    /**
     * 设置雾的颜色
     * @param color {hmap.style.Color}
     */
    setFogColor(color) {
        this._fogColor = color.toNormalizeArray();
    }

    /**
     * 设置地图的陆地背景色
     * @param color {hmap.style.Color} 背景颜色
     * @private
     */
    setLandColor(color) {
        this._landColor = color.toNormalizeArray();
    }

    /**
     * 获取雾和陆地的信息
     * @returns {{fog: {a_position: *, a_color: Array<Number>, a_checked: number[], index: number[], pointCount: number}, land: {a_position: *, a_color: number[]|*, a_checked: number[], index: number[], pointCount: number}}}
     */
    getFogAndLand() {
        return {
            fog: {
                a_position: this._camera.getFogBackgroundCoords(),
                a_color: this.getFogColor(),
                a_checked: [0],
                index: [3, 0, 1, 1, 2, 3],
                pointCount: 5,
            },
            land: {
                a_position: this._camera.getMapBackgroundCoords(),
                a_color: this.getLandColor(),
                a_checked: [0],
                index: [3, 0, 1, 1, 2, 3],
                pointCount: 5,
            }
        };
    }

    /**
     * 重新设置视口大小
     * @private
     */
    _setViewPort(gl) {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    /**
     * 根据canvas调整宽和高
     * @private
     */
    _resizeCanvasToDisplaySize(canvas, multiplier) {
        multiplier = multiplier || 1;
        const width = canvas.clientWidth * multiplier | 0;
        const height = canvas.clientHeight * multiplier | 0;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            return true;
        }
        return false;
    }

    /**
     * 重绘地图
     * @param {Boolean} force 是否强制重绘，默认值为false，即不强制重绘。
     */
    redraw(type=0) {
        const layerContainers = this.getLayerContainers();
        //绘制背景
        for (let i = 0; i < layerContainers.length; i++) {
            const layerContainer = layerContainers[i];
            layerContainer.redraw(type);
        }
        const ovLayers = this._overlayLayers;
        for (let j = 0; j < ovLayers.length; j++) {
            ovLayers[j].redraw(type);
        }
    }

    /**
     * 计算当前地图视窗的像素高度。
     * @returns {Number} 地图视窗的像素高度。
     * @private
     */
    getContainerVSpan() {
        return this.container.clientHeight;
    }

    /**
     * 计算当前地图视窗的像素宽度。
     * @returns {Number} 地图视窗的像素宽度。
     * @private
     */
    getContainerHSpan() {
        return this.container.clientWidth;
    }

    /**
     * 获取坐标系的信息。
     * @returns {hmap.proj.Crs} 坐标系信息。
     */
    getCrs() {
        return this._crs;
    }

    /**
     * 设置地图所在的坐标系。
     * @param {hmap.proj.Crs} crs 坐标系。
     * @private
     */
    setCrs(crs) {
        if (crs && crs instanceof hmap.proj.Crs) {
            this._crs = crs;
            hmap._srid = this._crs.getSrid();
        }
    }

    /**
     * 计算地图视窗像素尺寸。
     * @returns {hmap.basetype.Size} 地图视窗像素尺寸。
     * @private
     */
    getSize() {
        const width = this.getContainerHSpan();
        const height = this.getContainerVSpan();
        return new hmap.basetype.Size(width, height);
    }

    /**
     * 获取当前地图视窗的左上角地理坐标。
     * @returns {hmap.basetype.Extent} 地理坐标。
     * @private
     */
    getGeoTL() {
        return this.getExtent().getTopLeft();
    }

    /**
     * 计算地图视窗中心的地理坐标。
     * @returns {hmap.basetype.Coordinate} 地理坐标。
     * @private
     */
    getCenter() {
        return this._center.clone();
    }

    /**
     * 获取当前地图视窗的地理范围。
     * @returns {hmap.basetype.Extent} 地理范围。如果当前可视范围超出了最大地理范围，则返回null。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let result = map.getExtent();
     * //result=new hmap.basetype.Extent(120.108235,30.176284,120.761921,30.210616)
     */
    getExtent() {
        return this._camera.getExtent();
    }

    /**
     * 计算当前地图视口的像素范围。
     * @returns {Array<Number>} 像素范围。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let result = map.getViewport();//result=[0, 0, 1904, 100]
     */
    getViewport() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        return [0, 0, width, height];
    }

    /**
     * 从地图对象的图层数组中移除指定图层。注：图层对象脱离地图对象后依然存在，直到该图层被彻底销毁。
     * @param {hmap.layer.Layer} layer 要删除的图层。
     */
    removeLayer(layer) {
        if (layer instanceof hmap.layer.Layer) {
            //地图的图层列表中删除图层信息
            const layerContainer = layer.getLayerContainer();
            if (layerContainer === null) {
                return;
            }

            layerContainer.removeLayer(layer);

            const layers = layerContainer.getLayers();
            if (layers.length === 0) {
                this._removeLayerContainer(layerContainer);
            }
            //layer.getLayerContainer().redraw();
            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_REDRAW));
        } else if (layer instanceof hmap.layer.OverlayLayer) {
            const ovLayers = this._overlayLayers;
            for (let j = 0; j < ovLayers.length; j++) {
                if (layer === ovLayers[j]) {
                    ovLayers.splice(j, 1);
                    layer._map = null;
                    this.container.removeChild(layer.container);
                }
            }
        }

    }

    /**
     * 获取允许访问的最大显示范围
     * @returns {null|*}
     */
    getRestrictedExtent() {
        return this._restrictedExtent;
    }

    /**
     * 设置最大地理范围。该方法在地图缩放时
     * @param extent {hmap.basetype.Extent} 最大显示范围
     */
    setRestrictedExtent(extent) {
        this._restrictedExtent = extent;
    }

    /**
     * 获取合法的中心点
     * @param center 地图中心点的地理坐标
     * @param zoom 地图缩放级别
     * @returns {*}
     * @private
     */
    _getValidateCenter(center, zoom) {
        let toZoom = zoom ? zoom : this.getZoom();
        const maxExtent = this.getRestrictedExtent();
        if (maxExtent) {
            const xMin = maxExtent.getLeft();
            const xMax = maxExtent.getRight();
            const yMin = maxExtent.getBottom();
            const yMax = maxExtent.getTop();

            const deltX = this.container.clientWidth * this.getResolution(toZoom) / 2.0;
            const deltY = this.container.clientHeight * this.getResolution(toZoom) / 2.0;

            const centerMinX = xMin + deltX;
            const centerMaxX = xMax - deltX;
            const centerMinY = yMin + deltY;
            const centerMaxY = yMax - deltY;
            if (center.getOrdinate("X") < centerMinX) {
                center.setOrdinate("X", centerMinX);
            } else if (center.getOrdinate("X") > centerMaxX) {
                center.setOrdinate("X", centerMaxX);
            }

            if (center.getOrdinate("Y") < centerMinY) {
                center.setOrdinate("Y", centerMinY);
            } else if (center.getOrdinate("Y") > centerMaxY) {
                center.setOrdinate("Y", centerMaxY);
            }
        }
        return center;
    }

    /**
     * 设置地图的中心点和缩放级别。
     * @param {hmap.basetype.Coordinate} center 地图中心点的地理坐标。设置中心点时候的Z值坐标无效
     * @param {Number} zoom 地图缩放级别。
     * @param {Boolean} force 是否强制重绘。默认为false。
     */
    setCenter(center, zoom, force) {
        if (!(center instanceof hmap.basetype.Coordinate)) {
            throw new TypeError("the parameter center is not an invalidate Coordinate");
        }
        let toZoom = zoom!==undefined ? zoom : this.getZoom();
        //当指定的级别小于最小级别时，设置为最小级别
        if (toZoom < this._minLevel) {
            toZoom = this._minLevel;
        }
        else if (toZoom > this._maxLevel) {
            toZoom = this._maxLevel;
        }

        //如果zoom存在，且toZoom和this._zoom不相等
        if (zoom!==undefined && toZoom !== this._zoom) {
            // this._zoom = toZoom;
            const i = parseInt(toZoom.toString());
            this._zoom = Math.abs(toZoom - i) < 0.000001 ? i : (Math.abs(toZoom - i - 1) < 0.000001 ? i + 1: this._zoom);

            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMCHANGED));
            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMCHANGE));
        }
        this._zoomWithInterval = toZoom;
        const beforeExtent = this.getExtent();
        this._center = this._getValidateCenter(center.clone(), toZoom);//得到一个在最大显示范围内的中心点
        this._camera.setCenter(this._center, this.getResolution(toZoom));
        const afterExtent = this.getExtent();
        //如果相机setCenter前后，范围不相等，则派发EXTENTCHANGED事件
        if (!beforeExtent.equals(afterExtent)) {
            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_EXTENTCHANGED));
        }
        //this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMCHANGE));
        this.redraw();
    }

    /**
     * @brief panTo 将地图移动到指定坐标
     * @param coordinate Coordinate
     * @param smoothly Boolean （当前版本中，该参数无效）
     * @private
     */
    panTo(coordinate, smoothly) {
        if (coordinate instanceof hmap.basetype.Coordinate) {
            //坐标转换为二维
            coordinate.clone().setOrdinate("Z", 0);
            if (!this._center.equals(coordinate)) {
                this.setCenter(coordinate, this._zoomWithInterval);
            }
        }
    }
    /**
     * 将地图缩放到指定级别，如果zoom小于minLevel，则缩小到minLevel，如果大于maxLevel，则放大到maxLevel。
     * @param  {Number} zoom 地图的缩放级别，类型为正整数。
     */
    zoomTo(zoom){
        this.setCenter(this.getCenter(), zoom);
    }

    /**
     * 在地图上搜索给定像素附近的地理要素。
     * @param {hmap.basetype.Pixel} pixel 屏幕上一个像素。
     * @param {Array<String>} layerNames 图层名称组成的数组。返回的地理要素仅限于指定的图层之内，如果不指定，则查询范围为所有图层。注意：无法搜索图片式图层中的地理要素。
     * @param {Number} tolerance 容差值，单位为像素。在容差范围内搜索到的地理要素都会作为结果返回，对于面要素无效。
     * @returns {Array<Object>} 地理要素的数组。如果没有检测到任何地理要素则返回空数组。
     * @example
     * let pixel = new hmap.basetype.Pixel(200,100);
     * let layerName="测试";
     * let features = map.detectFeaturesAtPixel(pixel, [layerName], 3);
     * //console.log(features);
     */
    detectFeaturesAtPixel(pixel, layerNames = null, tolerance = 5) {
        let layers = [];
        if (layerNames) {
            for (let i = 0; i < layerNames.length; i++) {
                layers = layers.concat(this.getLayersByName(layerNames[i]));
            }
        } else {
            layers = this.getAllLayers(0);
        }
        if (layers.length <= 0) {
            return null;
        }
        if (!this.ray) {
            this.ray = new hmap.strategy.Raycaster({
                map: this,
                tolerance: tolerance
            })
        }
        this.ray.setFromCoordinate(this.getCoordinateFromPixel(pixel));
        return this.ray.intersect(layers, true);
    }

    /**
     * 调整图层在图层容器中的顺序（未完全实现）。
     * delta为0时，不调整图层顺序；
     * delta为负时，将图层向前调整，如果调整后的位置小于索引值0，则将图层位置移动到所有图层之前；
     * delta为正时，将图层向后调整，如果调整后的位置大于最大索引值，则将图层位置移动到所有图层之后。
     * @param {hmap.layer.Layer} layer 要调整的图层，类型不为{@link hmap.layer.Layer}时不调整图层顺序。
     * @param {Number} delta 相对于原来位置，在图层数组中移动的步数。不为整数时不调整图层顺序。
     * @private
     */
    shiftLayerZIndex(layer, delta) {
        if (!(layer instanceof hmap.layer.Layer) || !Number.isInteger(delta) || delta == 0) {
            return false;//参数异常或者delta为0
        }
        layer.setZIndex(layer.getZIndex() + delta);
        layer.getLayerContainer().orderLayerByIndex();
    }

    /**
     * 设置图层顺序，图层顺序按现有索引重新排序。
     * @param {hmap.layer.Layer} layer 调整的图层。
     * @param {Number} zindex 新的索引值。
     */
    setLayerZIndex(layer, zindex) {
        if (!Number.isInteger(zindex)) {
            return false;//参数异常
        }
        if (layer instanceof hmap.layer.Layer) {
            layer.setZIndex(zindex);
            layer.getLayerContainer().orderLayerByIndex();
        } else if (layer instanceof hmap.layer.OverlayLayer) {
            layer.setLayerZIndex(zindex);
        }
        //layer.redraw();
        this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMCHANGE));
    }

    /**
     * 地图销毁
     * 销毁和Map相关的事件、控件、DOM元素。
     */
    destroy(){
        //销毁控件
        for(let i=this._controls.length-1;i>=0;i--){
            this._controls[i].destroy();
            this._controls[i]=null;
        }
        this._controls=[];
        //销毁事件
        this.event.destroy();
        //销毁容器
        const layerContainers = this.getLayerContainers();
        //绘制背景
        for (let i =layerContainers.length-1; i >=0 ; i--) {
            layerContainers[i].destroy();
            layerContainers[i]=null;
            layerContainers.splice(i, 1);
        }
        const ovLayers = this._overlayLayers;
        for (let j = ovLayers.length - 1; j >-0; j--) {
            const layer = ovLayers[j];
            ovLayers.splice(j, 1);
            this.container.removeChild(layer.container);
            layer._map = null;
        }
        this.mapdiv.innerHTML = "";
    }


    /**
     * 设置图层容器的zIndex
     * @param containerId {String} 图层容器的id
     * @param containerZIndex {Number} 图层容器的zIndex
     */
    setLayerContainerZIndex(containerId, containerZIndex) {
        const layerContainers = this.getLayerContainers();
        for (let i = 0; i < layerContainers.length; i++) {
            if (containerId === layerContainers[i].getContainerId()) {
                const container = layerContainers[i];
                container.setContainerZIndex(containerZIndex);
            }
        }
    }

    /**
     * 计算地理坐标对应的屏幕像素位置。起算点是当前屏幕坐标系原点。
     * 该方法在三种情况下计算的准确度低：
     * 1.坐标超出地图视窗的地理范围时；
     * 2.地图旋转的俯仰角较大时，偏离地图中心越远准确度越低；
     * 3.地理坐标的Z分量接近甚至超出相机高度时。
     * @param {hmap.basetype.Coordinate} coord 地理坐标。转换过程考虑地理坐标的高程分量。
     * @returns {hmap.basetype.Pixel} 屏幕像素。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * const coord1 = new hmap.basetype.Coordinate(120.13982, 30.34331, 0);
     * let result = map.getPixelFromCoordinate(coord1);//result=new hmap.basetype.Pixel(100,50)在地图未旋转的情况下可以得到该测试结果
     */
    getPixelFromCoordinate(coord) {
        if (!(coord instanceof hmap.basetype.Coordinate)) {
            throw "coord must be instance of hmap.basetype.Coordinate!";
        }
        return this._camera.getPixelFromCoordinate(coord, this.container.clientWidth, this.container.clientHeight);
    }

    /**
     * 计算屏幕像素位置所对应的地理坐标。
     * 该方法在两种情况下计算的准确度低：
     * 1.坐标超出地图视窗的地理范围时；
     * 2.地图旋转的俯仰角较大时，偏离地图中心越远准确度越低。
     * @param {hmap.basetype.Pixel} pixel 屏幕像素。
     * @returns {hmap.basetype.Coordinate} 地理坐标。转换过程忽略地理坐标的高程分量。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let pixel = new hmap.basetype.Pixel(100,50);
     * let result = map.getCoordinateFromPixel(pixel);//result=new hmap.basetype.Coordinate(120.13982,30.34331,0)在地图未旋转的情况下可以得到该测试结果
     */
    getCoordinateFromPixel(pixel) {
        if (!(pixel instanceof hmap.basetype.Pixel)) {
            throw "pixel must be instance of hmap.basetype.Pixel!";
        }
        return this._camera.getCoordinateFromPixel(pixel, this.getResolution(this._zoomWithInterval));
    }

    /**
     * 获取最大分辨率。
     * @returns {Number} 最大分辨率。
     */
    getMaxResolution() {
        if (this._resolutions === null || this._resolutions.length === 0) {
            throw "the resolutions array is empty!";
        }
        return this._resolutions[this._resolutions.length - 1];
    }

    /**
     * 获取最小分辨率。
     * @return {Number} 最小分辨率。
     */
    getMinResolution() {
        if (this._resolutions === null || this._resolutions.length === 0)
            throw "the resolutions array is empty!";
        return this._resolutions[0];
    }

    /**
     * 获取地图分辨率数组。
     * @return {Array<Number>} 分辨率数组。
     */
    getResolutions() {
        return this._resolutions;
    }

    /**
     * 获取地图分辨率。如果传入zoom参数，则返回对应缩放级别的分辨率，否则返回当前缩放级别的分辨率。
     * @param {Number} zoom 缩放级别。
     * @returns {Number} 地图分辨率。
     */
    getResolution(zoom) {
        if (!this._resolutions || this._resolutions.length === 0) {
            throw "the resolutions array is empty!";
        }
        let _zoom = zoom != undefined ? zoom : this._zoomWithInterval;
        // if (!Number.isInteger(_zoom)) {
        //     throw "zoom parameter must be an integer!";
        // }
        if (_zoom < 0 || _zoom >= this._resolutions.length) {
            throw "zoom parameter out of range!";
        }
        if (Number.isInteger(_zoom)) {
            return this._resolutions[_zoom];
        }
        else {
            const lowZoom = Math.floor(_zoom),
                upZoom = lowZoom + 1,
                lowRes = this._resolutions[lowZoom],
                upRes = this._resolutions[upZoom],
                f = _zoom - lowZoom;
            return lowRes - (lowRes - upRes) * f;
        }
    }

    /**
     * 获取当前地图比例尺分母，根据地图的分辨率、坐标系和当前级别计算得出。
     * @returns {Number} 当前地图比例尺分母。
     * @example
     * let map = new hmap.Map("hmap", mapOptions);//"hmap"为地图容器div元素的id名
     * let result = map.getScale();//result=54070.29327392578
     */
    getScale() {
        let units = this.getCrs().getUnit();
        if (!units) {
            units = "degrees";
        }
        return this._resolutions[this._zoom] * hmap.initState.inchesPerUnit[units] * hmap.initState.dotsPerInch;
    }

    /**
     * 获取地图的当前缩放级别。如果res参数不为空，则在分辨率数组中寻找最接近res且不小于res的级别。(向下取)
     * @param {Number} res 分辨率。
     * @returns {Number} 缩放级别。
     */
    getZoom(res) {
        if (res) {
            let nearestIndex = 0;
            const resArr = this._resolutions;
            const maxLevel = resArr.length;
            for (let i = 0; i <maxLevel-1; i++) {
                if(resArr[i] >= res&&res>resArr[i+1]){
                    return i;
                }
            }
            if(res<resArr[maxLevel]){
                return maxLevel;
            }
            return nearestIndex;
        }
        //如果没有传入参数
        return this._zoom;
    }

    /**
     * 获取地图最大缩放级别。
     * @returns {Number} 最大缩放级别。
     */
    getMaxZoom() {
        return this._maxLevel;
    }

    /**
     * 获取地图最小缩放级别。
     * @returns {Number} 最小缩放级别。
     */
    getMinZoom() {
        return this._minLevel;
    }

    /**
     * 设置地图最大缩放级别。
     * @param {Number} zoom 地图最大缩放级别
     */
    setMaxZoom(zoom) {
        if (!Number.isInteger(zoom)) {
            throw "zoom parameter must be an integer!";
        }
        if (zoom < 0 || zoom >= this._resolutions.length) {
            throw "zoom parameter out of range!";
        }
        if (zoom < this._minLevel) {
            throw "maxZoom must be not less than minZoom!";
        }
        this._maxLevel = zoom;
    }

    /**
     * 设置地图最小缩放级别。
     * @param {Number} zoom 最小缩放级别。
     */
    setMinZoom(zoom) {
        if (!Number.isInteger(zoom)) {
            throw "zoom parameter must be an integer!";
        }
        if (zoom < 0 || zoom >= this._resolutions.length) {
            throw "zoom parameter out of range!";
        }
        if (zoom > this._maxLevel) {
            throw "minZoom must be not more than maxZoom!";
        }
        this._minLevel = zoom;
    }

    /**
     * 旋转地图。
     * @param {String} type 旋转类型，可选类型为“bearing”和“pitch”。“bearing”为方位角，表示指北针绕垂直地表方向逆时针旋转过的角度；“pitch”为俯仰角，表示视线方向和垂直地表方向形成夹角，如果在设置俯仰角时angle参数的值大于构造Map对象时设置的maxPitch属性，则angle的值设置为maxPitch的值。
     * @param {Number} angle 旋转的角度。
     * @param {Boolean} force 是否强制重绘地图，true时强制重绘，false时不强制重绘。
     * @returns {Number} 旋转的总角度。假如当前地图已经旋转的角度为N，那么返回值所表示的角度为N+angle。
     */
    rotate(type, angle,force=false) {
        if (type === "bearing") {
            this._camera.rotateZ(angle);
            this.redraw();
            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATING));
            return this._camera.getRotateZ();
        } else if (type === "pitch") {
            const cur = -this._camera.getRotateX();
            angle = angle + cur >= this._maxPitch ? this._maxPitch - cur : angle;
            this._camera.rotateX(-angle);
            this.redraw();
            this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATING));
            return -this._camera.getRotateX();
        }
    }

    /**
     * 获取地图当前的方位角或俯仰角
     * @param {String} type 旋转类型，可选类型为“bearing”和“pitch”。“bearing”为方位角，"pitch"为俯仰角。
     * @returns {Number} 方位角或俯仰角
     */
    getRotateAngle(type){
        if (type === "bearing") {
            return this._camera.getRotateZ();
        } else if (type === "pitch") {
            return -this._camera.getRotateX();
        }
    }

    /**
     * 将地图设置为未旋转状态
     * @private
     */
    setUnRotated() {
        this._camera.resetRotate();
        this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_TILTCHANGE));
        //this.redraw();
    }

    /**
     * 增加一个缩放级别
     */
    zoomIn() {
        this._zoom += 1;

        this.setCenter(this.getCenter(), this._zoom);
    }

    /**
     * 减小一个缩放级别
     */
    zoomOut() {
        this._zoom -= 1;
        this.setCenter(this.getCenter(), this._zoom);
    }

    /**
     * 缩放到指定的地理范围。
     * @param {hmap.basetype.Extent} ext 地理范围。
     * @param {Boolean} force 是否强制重绘，默认值为false。
     */
    zoomToExt(ext,force=false) {
        //将传入的ext调整宽高比跟地图容器宽高比统一之后再去定位
        let extNew = {};
        const mapWidth = this.container.clientWidth;
        const mapHeight = this.container.clientHeight;
        //计算map的宽高比
        const proportion_view = mapWidth / mapHeight;
        const ySpan = ext.getTop() - ext.getBottom();
        const xSpan = ext.getRight() - ext.getLeft();
        //计算ext的宽高比
        const proportion_ext = xSpan / ySpan;
        if (proportion_view > proportion_ext) {
            //说明要扩展ext的宽度
            extNew.height = ySpan;
            extNew.width = ySpan * proportion_view
        } else if (proportion_view < proportion_ext) {
            //说明要扩展ext的宽度
            extNew.width = xSpan;
            extNew.height = xSpan / proportion_view
        } else {
            extNew.width = xSpan;
            extNew.height = ySpan;
        }

        let res = extNew.width / this.getContainerHSpan();
        const toCenter=ext.getCenter();
        const toZoom=this.getZoom(res)
        this.setCenter(toCenter,toZoom,force);
    }

    /**
     * 获取图层的ZIndex值。
     * @param {hmap.layer.Layer} layer 图层对象
     * @returns {Number} 图层的zIndex值
     */
    getLayerZIndex(layer) {
        return layer.getZIndex();
    }

    /**
     * 获取图层的容器在图层容器数组中的索引
     * @param layer {hmap.layer.Layer}
     * @returns {Number} 图层容器的索引
     */
    getLayerContainerIndexByLayer(layer){
        const layerContainer = layer.getLayerContainer();
        for (let i = 0; i < this.getLayerContainers().length; i++) {
            if (layerContainer === this.getLayerContainers()[i]) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 获取图层所在容器的ZIndex
     * @param containerId {String} 图层容器的ID
     * @returns {Number|null} zIndex值或null，当containerId不存在时返回null。
     */
    getLayerContainerZIndex(containerId) {
        let zindex = null;
        const lyContainers = this.getLayerContainers();
        for (let i = 0,len=lyContainers.length; i < len; i++) {
            if (containerId === lyContainers[i].getContainerId()) {
                zindex = lyContainers[i].getContainerZIndex();
            }
        }
        return zindex;
    }

    /**
     * 获取图层数量。
     * @param containsBaseLayer true表示结果返回包含基础地图的图层数量，false表示结果返回不包含基础底图的图层数量。
     * @returns {Number} 图层数量。
     */
    getLayerCount(containsBaseLayer = true) {
        let count = 0;
        const layerContainers = this.getLayerContainers();
        for (let i = 0; i < layerContainers.length; i++) {
            const layers = layerContainers[i].getLayers();
            count += layers.length;
        }
        count = count + this._overlayLayers.length;
        return containsBaseLayer ? count : count - 1;
    }

    /**
     * 获取图层名称为给定值的图层对象。
     * @param {String} name 图层名称。
     * @returns {Array<hmap.layer.Layer>} 名称为给定值的图层数组。
     */
    getLayersByName(name) {
        const layers = this.getAllLayers();
        const resultLayers = [];
        for (let i = 0, len = layers.length; i < len; i++) {
            if (name === layers[i].getName()) {
                resultLayers.push(layers[i]);
            }
        }
        return resultLayers;
    }

    /**
     * 获取包含给定pixel及其周边tolerance圈pixel。tolerance为0时，得到一个pixel；tolerance为3时，得到9个pixel。
     * @param {hmap.basetype.Pixel} pixel 像素。
     * @param {Number} tolerance 容差值，单位为像素。
     * @private
     */
    _getPixelsArround(pixel, tolerance) {
        const arr = [];

        const x = pixel.getX();
        const y = pixel.getY();

        //i表示行 j表示列
        for (let i = tolerance; i >= -tolerance; i--) {
            for (let j = tolerance; j >= -tolerance; j--) {
                arr.push(new hmap.basetype.Pixel(x + i, y + j));
            }
        }
        return arr;
    }

    /**
     * 获取control的类型
     * @param {String} controlType 控件类型
     * controlType 参数有以下几种：
     * hmap.control.controlType.DrawFeature
     * hmap.control.controlType.Graticule
     * hmap.control.controlType.Handler
     * hmap.control.controlType.HighLightPoint
     * hmap.control.controlType.Magnifier
     * hmap.control.controlType.Measure
     * hmap.control.controlType.MiniMap
     * hmap.control.controlType.MousePosition
     * hmap.control.controlType.MouseTipControl
     * hmap.control.controlType.Pan
     * hmap.control.controlType.Plot
     * hmap.control.controlType.Rotate
     * hmap.control.controlType.ScaleBar
     * hmap.control.controlType.Zoom
     *@example
     * map.getControlByType(hmap.control.controlType.Zoom);
     * //result:  hmap.control.Zoom?{_status: true, CLASS_NAME: "hmap.control.Zoom", _exclusive: false……
     */
    getControlByType(controlType) {
        const controls = this._controls;
        const len = controls.length;
        for (let i = 0; i < len; i++) {
            if (controlType === controls[i].getControlType()) {
                return controls[i];
            }
        }
        return null;
    }


    /**
     * 获取加载到地图上的所有图层
     * @param  {Number} type 缺省值为1
     * 1 返回所有图层，包括canvas图层和叠加层overlayLayer
     * 0 只返回canvas图层
     * @returns {Array} 图层组成的数组
     */
    getAllLayers(type = 1) {
        const layers = [];
        const lyContainers = this.getLayerContainers();
        for (let i = 0; i < lyContainers.length; i++) {
            const lys = lyContainers[i].getLayers();
            for (let j = 0; j < lys.length; j++) {
                layers.push(lys[j]);
            }
        }
        if (type === 1) {
            const ovLys = this._overlayLayers;
            for (let k = 0; k < ovLys.length; k++) {
                layers.push(ovLys[k]);
            }
        }
        return layers;
    }


    /**
     * 去除与地图对象挂接的所有图层。图层对象脱离地图对象后依然存在，直到彻底销毁这些图层。
     */
    removeAllLayers() {
        const lyContainers = this._layerContainers;
        const count = lyContainers.length;
        for (let i = count - 1; i > 0; i--) {
            const layerContainer = lyContainers[i];
            lyContainers.splice(i, 1);
            this.container.removeChild(layerContainer.getContainer());
            layerContainer.setMap(null);
            layerContainer.removeAllLayers();
        }
        //保留id为‘hmap’的layerContainer，但是移除里面的图层
        lyContainers[0].removeAllLayers();
        //lyContainers[0].redraw();
        this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_REDRAW));
        // 删除所有的叠加图层
        const ovLayers = this._overlayLayers;
        for (let j = ovLayers.length - 1; j > -1; j--) {
            const layer = ovLayers[j];
            ovLayers.splice(j, 1);
            this.container.removeChild(layer.container);
            layer._map = null;
        }
    }

    /**
     * 从地图中移除指定的图层容器，同时会将该图层容器中的图层从地图中移除。
     * @param layerContainer
     * @private
     */
    _removeLayerContainer(layerContainer) {
        const lyContainers = this._layerContainers;
        for (let i = 0; i < lyContainers.length; i++) {
            if (layerContainer === lyContainers[i]) {
                lyContainers.splice(i, 1);
                this.container.removeChild(layerContainer.getContainer());
                layerContainer.setMap(null);
                layerContainer.removeAllLayers();
            }
        }
    }

    /**
     * 设置地图的背景色，在没有地图的地方显示指定的颜色。(备用)
     * @param {hmap.style.Color} color 背景颜色对象
     * @private
     */
    setBackgroundColor(color) {
        const colorNormal = color.toNormalizeArray();
        this.gl.clearColor(colorNormal[0], colorNormal[1], colorNormal[2], colorNormal[3]);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT, this.gl.DEPTH_BUFFER_BIT);
        this.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_REDRAW));
        //this.redraw();
    }

    /**
     * 返回地图是否可以缩放
     * @returns {Boolean} 是否启用缩放。
     */
    getZoomEnable() {
        return this._enableZoom;
    }

    /**
     * 返回地图是否可以旋转
     * @returns {Boolean} 是否启用旋转。
     */
    getRotateEnable() {
        return this._enableRotate;
    }

    /**
     * 返回地图是否可以平移
     * @returns {Boolean} 是否启用平移地图。
     */
    getPanEnable() {
        return this._enablePan;
    }

    /**
     * 激活或者取消激活缩放控件
     * @param {Boolean} enableZoom 是否激活缩放控件
     */
    setZoomEnable(enableZoom) {
        if (!this._enableZoom == enableZoom) {
            if (this._zoomCtr) {
                if (enableZoom) {
                    this._zoomCtr.activate();
                } else {
                    this._zoomCtr.deactivate();
                }
                this._enableZoom = enableZoom;
            }
        }
    }

    /**
     * 激活或者取消激活旋转控件
     * @param {Boolean} enableRotate 是否激活旋转控件
     */
    setRotateEnable(enableRotate) {
        if (!this._enableRotate == enableRotate) {
            if (this._rotateCtr) {
                if (enableRotate) {
                    this._rotateCtr.activate();
                } else {
                    this._rotateCtr.deactivate();
                }
                this._enableRotate = enableRotate;
            }
        }
    }

    /**
     * 激活或者取消激活平移控件
     * @param {Boolean} enablePan 是否激活平移控件
     */
    setPanEnable(enablePan) {
        if (!this._enablePan == enablePan) {
            if (this._panCtr) {
                if (enablePan) {
                    this._panCtr.activate();
                } else {
                    this._panCtr.deactivate();
                }
                this._enablePan = enablePan;
            }
        }
    }

    /**
     * 在当前地图范围，top到bottom的一半处，经度跨度，单位为米
     * @private
     */
    getExtentHSpan() {
        const ext = this.getExtent(),
            left = ext.getLeft(),
            right = ext.getRight(),
            top = ext.getTop(),
            bottom = ext.getBottom(),
            yMidlle = (top + bottom) / 2,
            coord1 = new hmap.basetype.Coordinate(left, yMidlle),
            coord2 = new hmap.basetype.Coordinate(right, yMidlle);

        return coord1.get2Dist(coord2);
    }

    getZoomWithInterval() {
        return this._zoomWithInterval;
    }
};
;"use strict";
/**
 *  鼠标键盘类事件：
 *  EventType.MAPMOUSEEVENT_CLICK: 鼠标在地图上单击触发
 *  EventType.MAPMOUSEEVENT_DOUBLECLICK: 鼠标在地图上双击时触发
 *  EventType.MAPMOUSEEVENT_MOUSEDOWN: 鼠标在地图上摁下时触发
 *  EventType.MAPMOUSEEVENT_MOUSEMOVE: 鼠标在地图上移动时触发
 *  EventType.MAPMOUSEEVENT_MOUSEOUT: 鼠标移出地图时触发
 *  EventType.MAPMOUSEEVENT_MOUSEOVER: 鼠标移入地图上时触发
 *  EventType.MAPMOUSEEVENT_MOUSEUP: 鼠标地图上释放时触发
 *  EventType.MAPMOUSEEVENT_MOUSEWHEEL: 在地图上滚动鼠标滚轮时触发
 *  非鼠标键盘事件：
 *  EventType.MAPEVENT_MOVESTART: 注册后，开始拖动地图触发
 *  EventType.MAPEVENT_MOVING: 注册后，拖动地图过程中触发
 *  EventType.MAPEVENT_MOVEEND: 注册后，拖动地图结束触发
 *  EventType.MAPEVENT_ZOOMSTART: 地图开始缩放触发
 *  EventType.MAPEVENT_ZOOMING: 地图缩放过程中触发
 *  EventType.MAPEVENT_ZOOMEND: 地图缩放结束触发
 *  EventType.MAPEVENT_ROTATESTART: 地图旋转开始触发
 *  EventType.MAPEVENT_ROTATING: 地图旋转过程中触发
 *  EventType.MAPEVENT_ROTATEEND: 地图旋转结束触发
 *  EventType.LAYEREVENT_LOADEND: 图层加载完成触发
 *  EventType.MAPEVENT_EXTENTCHANGED: 地图范围变化时触发
 * @type {{MAPEVENT_MOVESTART: string, MAPEVENT_MOVING: string, MAPEVENT_MOVEEND: string, MAPEVENT_ZOOMSTART: string, MAPEVENT_ZOOMING: string, MAPEVENT_ZOOMEND: string, MAPEVENT_ROTATESTART: string, MAPEVENT_ROTATING: string, MAPEVENT_ROTATEEND: string, MAPEVENT_EXTENTCHANGED: string, MAPMOUSEEVENT_CLICK: string, MAPMOUSEEVENT_DOUBLECLICK: string, MAPMOUSEEVENT_MOUSEDOWN: string, MAPMOUSEEVENT_MOUSEMOVE: string, MAPMOUSEEVENT_MOUSEOUT: string, MAPMOUSEEVENT_MOUSEOVER: string, MAPMOUSEEVENT_MOUSEUP: string, MAPMOUSEEVENT_MOUSEWHEEL: string, LAYEREVENT_LOADEND: string, LAYEREVENT_POINTFEATURE_READY: string, VECTORTILE_STYLELOADED: string, VECTOR_MODELDRAWEND: string}}
 */
const EventType={
    "MAPEVENT_CENTERCHANGE":"centerChange",  //中心点改变
    "MAPEVENT_ZOOMCHANGE":"zoomChange",      //级别发生改变
    "MAPEVENT_HEADINGCHANGE":"headingChange",  //正北方向发生改变
    "MAPEVENT_TILTCHANGE":"tiltChange",      //倾斜角发生改变
    "MAPEVENT_REDRAW":"MAPEVENT_REDRAW",      //倾斜角发生改变
    "MAPEVENT_MOVESTART":"moveStart",
    "MAPEVENT_MOVING":"moving",
    "MAPEVENT_MOVEEND":"moveEnd",
    "MAPEVENT_ZOOMCHANGED":"zoomChanged",
    "MAPEVENT_ZOOMSTART":"zoomStart",
    "MAPEVENT_ZOOMING":"zooming",
    "MAPEVENT_ZOOMEND":"zoomend",
    "MAPEVENT_ROTATESTART":"rotateStart",
    "MAPEVENT_ROTATING":"rotating",
    "MAPEVENT_ROTATEEND":"rotateEnd",
    "MAPEVENT_ROTATERESET":"ratateReset",
    'MAPEVENT_EXTENTCHANGED':'extentChanged',
    "MAPMOUSEEVENT_CLICK":"click",
    "MAPMOUSEEVENT_DOUBLECLICK":"dblclick",
    "MAPMOUSEEVENT_MOUSEDOWN":"mousedown",
    "MAPMOUSEEVENT_MOUSEMOVE":"mousemove",
    "MAPMOUSEEVENT_MOUSEOUT":"mouseout",
    "MAPMOUSEEVENT_MOUSEOVER":"mouseover",
    "MAPMOUSEEVENT_MOUSEUP":"mouseup",
    "MAPMOUSEEVENT_MOUSEWHEEL":"mousewheel",
    "LAYEREVENT_LOADEND":"loadEnd",
    "LAYEREVENT_DATACHANGE":"dataChange",
    "LAYEREVENT_POINTFEATURE_READY":"pointfeature_ready",
    "VECTORTILE_STYLELOADED":"styleLoaded",
    "VECTOR_MODELDRAWEND":"modeldrawend",
};;"use strict";
hmap.event=hmap.event||{};
/**
 * 事件类，事件的生命周期包含事件的产生、传递和销毁。事件对象在hmap中流转的过程称之为事件流。
 * @type {hmap.event.Event}
 */
hmap.event.Event=class {
    /**
     * 事件类构造函数
     * @param {String} type 事件类型，用来区别不同事件。
     * @param {Map} data  事件携带的信息，在事件的流转过程中可以修改。
     * @param {DOM} target 事件源位置。
     */
    constructor(type,data,target){
        this.setType(type);
        this.setData(data);
        this.setTarget(target);
        this.setCurTarget(target);
        this.setFireTimes(0);
        this.setEventFlowStatus(2);
        this.CLASS_NAME="hmap.event.Event";
    }

    /**
     * 返回事件流的目标对象。
     * @returns {DOM} 事件流的目标对象。
     * @private
     */
    getTarget(){
        return this._target;
    }

    /**
     * 设置事件流的目标对象
     * @param {DOM} target 事件流的目标对象
     * @private
     */
    setTarget(target){
        this._target=target;
    }

    /**
     * 返回事件流的当前对象
     * @returns {DOM} 事件流的当前对象。
     */
    getCurTarget(){
        return this._curTarget;
    }

    /**
     * @param {Object} target 要设置为当前事件流目标的对象
     * @private
     */
    setCurTarget(target){
        this._curTarget=target;
    }

    /**
     * 返回事件类型的名称。
     * @returns {String} 事件类型的名称。
     */
    getType(){
        return this._type;
    }
    get type(){
        return this._type;
    }

    /**
     * 设置事件类型
     * @param {String} type 事件类型的名称
     */
    setType(type){
        this._type=type;
    }

    /**
     * 获取事件是否可取消
     * @return {Boolean}
     * @private
     */
    getCancelable(){
        return this._cancelable;
    }

    /**
     * 设置事件是否可取消
     * @param {Boolean} cancelable
     * @private
     */
    setCancelable(cancelable){
        this._cancelable=cancelable;
    }

    /**
     * 返回事件流携带的数据。
     * @returns {Map} 返回事件流携带的数据。
     */
    getData(){
        return this._data;
    }

    /**
     * 设置事件流传递的数据信息。
     * @param {Map} data 事件流要携带的信息。
     */
    setData(data){
        this._data=data;
    }

    /**
     * 返回事件最近一次触发的时间。
     * @returns {Date} 事件最近一次触发的时间。
     */
    getTime(){
        return this._time;
    }

    /**
     * 设置时间
     * @param {Date} time 时间值
     * @private
     */
    setTime(time){
        this._time=time;
    }

    /**
     * 获取是冒泡还是捕捉
     * @return {*} 1表示是冒泡，0表示是捕捉。
     * @private
     */
    getBubbles(){
        return this._bubbles;
    }

    /**
     * 设置是冒泡还是捕捉。
     * @param bubbles 是冒泡还是捕捉，1表示是冒泡，0表示是捕捉。
     * @private
     */
    setBubbles(bubbles){
        this._bubbles=bubbles;
    }

    /**
     *
     * @return {Number|*}
     * @private
     */
    getEventFlowStatus(){
        return this._eventFlowStatus;
    }

    /**
     * @param eventFlowStatus {Number} 事件流状态,可选 0，1，2,事件创建时，默认值为2
     * 0 表示只能触发一次，一旦触发就失效
     * 1 表示只能在同一个地方触发，在同一个目标上可以多吃触发
     * 2 表示无限广播，不做限制
     * @private
     */
    setEventFlowStatus(eventFlowStatus){
        this._eventFlowStatus=eventFlowStatus;
    }

    /**
     * 返回事件被触发的次数
     * @returns {int} 事件被触发的次数。
     */
    getFireTimes(){
        return this._fireTimes;
    }

    /**
     * 设置被触发的次数，事件每被触发一次，次数加1.
     * @param {int} fireTimes
     * @private
     */
    setFireTimes(fireTimes){
        this._fireTimes=fireTimes;
    }
};;"use strict";
hmap.event=hmap.event||{};
/**
 * 地图事件类。
 * @private
 * @type {hmap.event.MapEvent}
 * @extends hmap.event.Event
 * @example
 * let event = new hmap.event.MapEvent();
 */
hmap.event.MapEvent=class extends hmap.event.Event{
    /**
     *
     * @param {String} type 事件类型，用来区别不同事件。
     * @param {Map} data  事件携带的信息，在事件的流转过程中可以修改。
     * @param {DOM} target 事件源位置。
     */
    constructor(type,data,target){
        super(type,data,target);
        this.CLASS_NAME="hmap.event.MapEvent";
    }

    /**
     * 获得坐标对象
     * @returns {hmap.basetype.Coordinate} 坐标对象
     */
    getCoordinate(){
        return this._coordinate;
    }

    /**
     * 设置坐标对象
     * @param {hmap.basetype.Coordinate} coordinate 坐标对象
     */
    setCoordinate(coordinate){
        this._coordinate=coordinate;
    }
};;"use strict";
hmap.event = hmap.event || {};
/**
 * 事件管理类，提供注册事件、取消注册事件、派发事件的功能。hmap全局维护一个事件管理类实例。
 * 使用register addListener接口 注册相对应的事件,注册的事件会缓存到事件观察器中。
 * 使用unRegister removeListener接口 移除事件观察器中对应的事件。
 * 使用 dispatch  fire接口 派发事件，HMap2.1 包含以下事件：
 * 鼠标键盘事件，通过register方法注册， unRegister方法取消注册， fire方法触发。
 * 其它事件，通过addLisenter方法注册， removeLisenter方法取消注冊， dispatch方法触发。
 *
 * 需要通过register方法注册（鼠标键盘事件）的有以下8种类型：
 *  1."MAPMOUSEEVENT_CLICK": 鼠标在地图上单击触发
 *  2."MAPMOUSEEVENT_DOUBLECLICK": 鼠标在地图上双击时触发
 *  3."MAPMOUSEEVENT_MOUSEDOWN": 鼠标在地图上摁下时触发
 *  4."MAPMOUSEEVENT_MOUSEMOVE": 鼠标在地图上移动时触发
 *  5."MAPMOUSEEVENT_MOUSEOUT": 鼠标移出地图时触发
 *  6."MAPMOUSEEVENT_MOUSEOVER": 鼠标移入地图上时触发
 *  7."MAPMOUSEEVENT_MOUSEUP": 鼠标地图上释放时触发
 *  8."MAPMOUSEEVENT_MOUSEWHEEL": 在地图上滚动鼠标滚轮时触发
 * 需要通过addListener方法添加监听（非鼠标键盘事件）的有以下11种类型：
 *  1."MAPEVENT_MOVESTART": 注册后，开始拖动地图触发
 *  2."MAPEVENT_MOVING":" 注册后，拖动地图过程中触发
 *  3."MAPEVENT_MOVEEND": 注册后，拖动地图结束触发
 *  4."MAPEVENT_ZOOMSTART": 地图开始缩放触发
 *  5."MAPEVENT_ZOOMING": 地图缩放过程中触发
 *  6."MAPEVENT_ZOOMEND": 地图缩放结束触发
 *  7."MAPEVENT_ROTATESTART": 地图旋转开始触发
 *  8."MAPEVENT_ROTATING": 地图旋转过程中触发
 *  9."MAPEVENT_ROTATEEND": 地图旋转结束触发
 *  10."LAYEREVENT_LOADEND": 图层加载完成触发
 *  11."MAPEVENT_EXTENTCHANGED": 地图范围变化时触发

 *
 * @type {hmap.event.EventManager}
 * @example
 * let evtMgr = new hmap.event.EventManager();
 * //注：在Map对象中有一个全局的event(通过map.event可获得)可供使用， 即{hmap.event.EventManager}对象，在地图应用产品中不用再创建EventManager对象。
 */
hmap.event.EventManager = class {
    constructor() {
        this._events = new Map();
        this._domEvents = new Map();
        this.CLASS_NAME = "hmap.event.EventManager";
    }

    destroy(){
        this._events.clear();
        this._domEvents.clear();
    }
    /**
     * 返回所有在监听的事件
     * @returns {Map|*}
     * @private
     */
    get events() {
        return this._events;
    }

    /**
     *
     * @param events
     * @private
     */
    set events(events) {
        this._events = events;
    }

    /**
     * 添加事件监听，用来注册非鼠标键盘类事件.
     * 支持的事件类型：
     *  1."MAPEVENT_MOVESTART": 注册后 开始拖动地图触发
     *  2."MAPEVENT_MOVING":" 注册后 拖动地图过程中触发
     *  3."MAPEVENT_MOVEEND": 注册后 拖动地图结束触发
     *  4."MAPEVENT_ZOOMSTART": 地图开始缩放触发
     *  5."MAPEVENT_ZOOMING": 地图缩放过程中触发
     *  6."MAPEVENT_ZOOMEND": 地图缩放结束触发
     *  7."MAPEVENT_ROTATESTART": 地图旋转开始触发
     *  8."MAPEVENT_ROTATING": 地图旋转过程中触发
     *  9."MAPEVENT_ROTATEEND": 地图旋转结束触发
     *  10."LAYEREVENT_LOADEND": 图层加载完成触发
     *  11."MAPEVENT_EXTENTCHANGED": 地图范围变化事件
     * @param {String} eventType 事件类型,参看EventType下定义的以上事件类型。
     * @param {Function} callback 事件监听后的回调函数
     * @param {Boolean} cancelBefore 表示注册时是否删除已经注册的同类型事件的监听。默认false：不删除之前注册的监听事件，true：删除之前注册的同类型监听事件。
     * @param {Boolean} once 是否只触发一次. false，可以触发多次.true，事件只触发一次，表示只要同类型事件触发过一次就会销毁该事件对象的传播
     * @param {Object} target 事件监听并响应后，事件流的当前对象(event._curTarget)会设置为target。如果不指定，则target默认为监听对象的上下文。
     * @example
     * function mapMoveHandler(evt){
     *      console.log(evt.getCoordinate());
     * }
     * let eventMgr=new hmap.event.EventManager();
     * eventMgr.addListener(EventType.MAPEVENT_MOUSEMOVE,mapMoveHandler);
     * //也可以像下面这样调用
     * map.event.addListener(EventType.MAPEVENT_MOUSEMOVE,mapMoveHandler);
     */
    addListener(eventType, callback, cancelBefore = false, once = false, target = null) {
        if (target === null) {
            target = this;
        }
        if(this._events.has(eventType)){
            if(cancelBefore) {
                this._events.get(eventType).length=0;
            }
        } else {
            this._events.set(eventType, []);
        }
        this._events.get(eventType).push({"handler": callback, "once": once, "target": target});
    }

    /**
     * 移除事件监听,用来移除通过addListener添加的事件监听
     * @param {String} eventType 事件类型
     * @param {Function} callback 注册事件监听的回调函数
     * @example
     * let callback = function(evt){
     *   console.log(evt);
     * };
     * evtMgr.removeListener(EVENTTYPE.MAPEVENT_ZOOMEND,callback);
     */
    removeListener(eventType, callback) {
        let funs = this._events.get(eventType);
        if (!funs)
            return;
        const funLen = funs.length;
        for (let i = funLen-1; i >=0; i--) {
            if(callback==undefined){
                funs.splice(i, 1);
                continue;
            }else if(funs[i].handler.name === callback.name) {
                funs.splice(i, 1);
            }
        }
        if (funs.length <= 0) {
            this._events.delete(eventType);
        }
    }

    /**
     * 派发事件 派发的事件通过addListener来监听。
     * @param {hmap.event.Event} event 要派发的事件 可查看eventType接口支持的event类型
     * @example
     * eventMgr.addListener(EventType.LAYEREVENT_LOADEND,this.redraw.bind(this));
     * //以上注册了“LAYEREVENT_LOADEND”的监听，dispatch派发后，既可以监听到并响应回调函数。
     * eventMgr.dispatch(new hmap.event.Event(EventType.LAYEREVENT_LOADEND));
     */
    dispatch(event) {
        if (this._events.has(event.getType())) {
            this._events.get(event.getType()).forEach(lisener => {
                if (lisener.once) {
                    this.removeListener(event.getType())
                }
                let flag = true;
                if (event._eventFlowStatus === 0) {
                    if (event.fireTimes > 0) {
                        flag = false;
                    }
                }
                if (event._eventFlowStatus === 1) {
                    if (event._fireTimes > 0 && lisener.target === event._curTarget) {
                        flag = false;
                    }
                }
                if (flag) {
                    event._fireTimes++;
                    event.setTime(new Date());
                    lisener.handler(event);
                    event._curTarget = lisener.target;
                }
            });
            event = null;
        }
    }

    //==============================dom事件注册机制===============================

    /**
     * 派发事件 派发的事件通过register 来监听
     * @param {DomEvent} event dom事件类型
     */
    fire(event) {
        if (this._domEvents.has(event.type)) {
            this._domEvents.get(event.type).forEach(callback => {
                event._fireTimes++;
                callback(event);
            });
        }
    }

    /**
     * 添加事件监听，用来注册鼠标键盘类事件监听。
     * 支持的事件类型：
     *  1."MAPMOUSEEVENT_CLICK": 地图上鼠标单击触发
     *  2."MAPMOUSEEVENT_DOUBLECLICK": 地图上鼠标双击触发
     *  3."MAPMOUSEEVENT_MOUSEDOWN": 地图上鼠标按下触发
     *  4."MAPMOUSEEVENT_MOUSEMOVE":" 地图上鼠标移动触发
     *  5."MAPMOUSEEVENT_MOUSEOUT": 鼠标移出地图触发
     *  6."MAPMOUSEEVENT_MOUSEOVER": 鼠标在地图上滑动触发
     *  7."MAPMOUSEEVENT_MOUSEUP": 地图上鼠标抬起触发
     *  8."MAPMOUSEEVENT_MOUSEWHEEL": 地图上鼠标滚轮滚动触发
     * @param {String} eventType 鼠标事件类型，参照EventType下的定义。
     * @param {Function} callback 事件回调函数
     * @example
     * const mapDbClickHandler = function(event){
     *      //todo Something
     * }
     * map.event.register(EventType.MAPMOUSEEVENT_DOUBLECLICK,mapDbClickHandler);
     */
    register(eventType, callback) {
        if (!this._domEvents.has(eventType)) {
            this._domEvents.set(eventType, []);
        }
        this._domEvents.get(eventType).push(callback);
    }

    /**
     * 移除事件监听 用来移除通过register添加的事件监听
     * @param {String} eventType  事件类型，具体类型参照EventType中的枚举事件类型.
     * @param {Function} callback  监听到事件后做的后续动作
     * @example
     * const mapDbClickHandler = function(event){
     *      //todo Something
     * }
     * eventMgr.unRegister(EventType.MAPMOUSEEVENT_DOUBLECLICK,mapDbClickHandler);
     */
    unRegister(eventType, callback) {
        let funs = this._domEvents.get(eventType);
        if(!funs)
            return;
        const funLen = funs.length;
        if (funLen <= 0) {
            this._events.delete(eventType);
        } else {
            for (let i = 0; i < funLen; i++) {
                if (funs[i].name === callback.name) {
                    funs.splice(i, 1);
                    return;
                }
            }
        }
    }
};
;"use strict";
hmap.language = hmap.language || {};
/**
 * 中文内容
 * @type {{m: string, km: string, m2: string, km2: string, clear: string, close: string, totalLength: string, area: string, unknownArea: string, start: string, measureTip: string}}
 */
hmap.language.zh_CN={
    "m":"米",
    "km":"千米",
    "m2":"平方米",
    "km2":"平方千米",
    "clear":"清除",
    "close":"关闭",
    "totalLength":"总长",
    "area":"面积",
    "unknownArea":"自相交多边形面积未知",
    "start":"起点",
    //测量提示
    "measureTip":"单击确定位置,双击结束绘制."
}
;"use strict";
hmap.language = hmap.language || {};
/**
 * 英文内容
 * @type {{m: string, km: string, m2: string, km2: string, clear: string, close: string, totalLength: string, area: string, unknownArea: string, start: string, measureTip: string}}
 */
hmap.language.en_US={
    "m":"m",
    "km":"km",
    "m2":"m²",
    "km2":"km²",
    "clear":"clear",
    "close":"close",
    "totalLength":"length",
    "area":"area",
    "unknownArea":"Area of intersecting polygon is unknown",
    "start":"start",
    //测量提示
    "measureTip":"Single click to determine position,double click to end drawing."
};;"use strict";
hmap.control=hmap.control||{};
/**
 * 控件类的基类:控件是hmap中用来控制地图或图层行为的接口。控件分为地图非排它控件和排它控件，通过setExclusive 接口来改变控件排他性。
 * 非排他控件不具有排它性，可以多个控件并存，同时影响或改变地图和图层行为。排他控件激活时，其它排他控件会处于禁用状态。
 * @type {hmap.control.Control}
 */
hmap.control.Control=class{
    constructor(){
        //this.controls=[];
        //this.defaultControls=[];
        this._status=false;
        this.CLASS_NAME = "hmap.control.Control";
        this._exclusive=false;
    }
    /**
     * 获取控件唯一标识
     * @return {String} 控件标识。
     */
    getId(){
        return this._id;
    }
    /**
     * 设置控件唯一标识。如果唯一标识已经存在，则会返回添加失败异常。
     * @param {String} id 控件唯一标识。
     */
    setId(id){
        this._id=id;
    }
    /**
     * 返回控件当前状态.
     * @return {Boolean}  true:表示激活  false:表示禁用。
     */
    getStatus(){
        return this._status;
    }

    setMap(map){
        this._map=map;
    }

    /**
     * 克隆控件
     * @return {hmap.control.Control} 控件对象
     */
    clone(){

    }
    /**
     * 销毁控件
     */
    destroy(){
        if(this._listenKeys){
            this._listenKeys.clear();
        }
        this._status=false;
        delete this;
    }
    /**
     * 获取控件绑定的地图对象。
     * @returns {hmap.Map} 地图对象。
     */
    getMap(){
        return this._map;
    }

    /**
     * 激活控件
     */
    activate(){
        const len=this._map._controls.length;
        for(let i=0;i<len;i++){
            if(this._map._controls[i]._exclusive===true && this._map._controls[i].CLASS_NAME===this.CLASS_NAME){
                this._map._controls[i].deactivate();
            }
        }
    }

    /**
     * 设置当前控件是否为地图排他控件
     * @param {Boolean} flag
     * false 表示当前控件为地图非排他控件，当激活一个非默认控件的时候会禁用其他控件 ，一旦结束当前非默认控件行为的话，会自动激活地图的所有非排他控件
     * true 表示当前控件为地图排他控件，不会自动激活
     */
    setExclusive(flag){
        this._exclusive=flag;
    }

    /**
     * 获取当前控件是否为地图排他控件
     * @returns {boolean|*}
     */
    getExclusive(){
        return this._exclusive;
    }
};
/**
 * 控件类型
 * @type {{Graticule: string, HighLightPoint: string, Magnifier: string, Measure: string, MiniMap: string, MousePosition: string, MouseTipControl: string, Pan: string, Plot: string, Rotate: string, ScaleBar: string, Zoom: string, Compass: string}}
 */
hmap.control.controlType = {
    Graticule:"hmap.control.Graticule",
    HighLightPoint:"hmap.control.HighLightPoint",
    Magnifier:"hmap.control.Magnifier",
    Measure:"hmap.control.Measure",
    MiniMap:"hmap.control.MiniMap",
    MousePosition:"hmap.control.MousePosition",
    MouseTipControl:"hmap.control.MouseTipControl",
    Pan:"hmap.control.Pan",
    Plot:"hmap.control.Plot",
    Rotate:"hmap.control.Rotate",
    ScaleBar:"hmap.control.ScaleBar",
    Zoom:"hmap.control.Zoom",
    Compass:"hmap.control.Compass"
};;"use strict";
hmap.control = hmap.control || {};

/**
 * 地图平移控件，通过平移控件实现在地图上按住鼠标左键来拖动地图。
 * @type {hmap.control.Pan}
 * @extends hmap.control.Control
 * @example
 * let map = new hmap.Map("hmap", {
        zoom: 12,
        center: new hmap.basetype.Coordinate(120.435078, 30.19345, 0),
        crs:new hmap.proj.Crs('4326'),//坐标系是地理可视化计算的基础,在地图对象初始化前务必指定
        minLevel:1,
        maxLevel:16
 * });
 * let pan = new hmap.control.Pan({"map": map});
 */
hmap.control.Pan = class extends hmap.control.Control {

    /**
     * 构造函数
     * @param {Object} options 可选参数
     * @param {hmap.Map} options.map 地图对象
     * @param {Number} options.disTolerance 距离容差，单位px， 默认8px。
     * @param {Number} options.timeTolerance 时间容差，单位是毫秒，默认值1000.
     * @param {} options.status
     *
     */
    constructor(options = {}) {
        super();
        this._map = null;
        this._status = false;
        this._disTolerance = options.disTolerance ? options.disTolerance : 8;
        this._animate = options.animate ? options.animate : false;

        this._hasMove = false;
        //拖动的速率
        this._speed = 1.0;
        this._isPlaying = false;
        this._exclusive = false;
    }

    /**
     * (暂未启用)
     * @returns {*}
     * @private
     */
    getAniminate() {
        return this._animate;
    }

    /**
     * (暂未启用)
     * @param animate
     * @private
     *
     */
    setAniminate(animate) {
        this._animate = animate;
    }

    /**
     * 移动地图
     * @param {hmap.basetype.Coordinate} coord 地图坐标
     * @private
     */
    mapPan(coord) {
        this._map.panTo(coord, true);
    }

    /**
     * 设置当前控件的地图对象
     * @param {hmap.Map}  map 控件的地图对象
     */
    setMap(map) {
        super.setMap(map);
        // this._map.event.addListener(EventType.MAPEVENT_ROTATING,this._updateSpped.bind(this));
        this.activate();
    }

    /**
     * 激活控件，map 添加控件会自动调用该方法，激活控件，只有控件添加到地图上时才起作用。
     * @example
     * pan.activate();
     */
    activate() {
        super.activate();
        //map存在，且状态为未激活时才添加坚挺
        if (this._map && !this._status) {
            this._status = true;
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEDOWN, this.panStart.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE, this.panning.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEUP, this.panend.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEOUT, this.panend.bind(this));
        }
    }

    /**
     * 开始移动
     * @param event
     * @private
     */
    panStart(event) {
        //不是左键按下这返回
        if (event.button !== 0) {
            return;
        }
        this.lPixel = event.mapPixel;
        this.isPlaying = true;
        let ev = new hmap.event.Event(EventType.MAPEVENT_MOVESTART);
        this._map.event.dispatch(ev);
        //抛出Darg结束事件
        this._map._hasMove = false;
    }

    /**
     * 正在移动
     * @param event
     * @private
     */
    panning(event) {
        if (event.button !== 0 || event.buttons !== 1) {
            return;
        }
        this._moving(event);
    }

    _moving(event) {
        const cPixel = event.mapPixel;
        if ((Math.abs(cPixel._x - this.lPixel._x) + Math.abs(cPixel._y - this.lPixel._y)) < this._disTolerance) {
            //一次移动小于5px视为点击 而非拖动
            return;
        }
        const ev = new hmap.event.Event(EventType.MAPEVENT_MOVING);
        this._map.event.dispatch(ev);
        const lP = this._map.getCoordinateFromPixel(this.lPixel);
        const cP = this._map.getCoordinateFromPixel(cPixel);
        const xOffset = -(cP.getOrdinate("X") - lP.getOrdinate("X"));
        const yOffset = -(cP.getOrdinate("Y") - lP.getOrdinate("Y"));
        //let center = this.getCenterAfterPan(xOffset,yOffset);
        let oldcenter = this._map.getCenter();
        let center = new hmap.basetype.Coordinate(oldcenter.getOrdinate("X") + xOffset, oldcenter.getOrdinate("Y") + yOffset);
        this._map.panTo(center);
        this.lPixel = cPixel;
        this._map._hasMove = true;
    }

    /**
     * 平移结束
     * @param event
     * @private
     */
    panend(event) {
        this._map._hasMove = false;
        if (this._isPlaying) {
            this._isPlaying = false;
        } else {
            return;
        }
        if (event.button === 0 && this._map._hasMove) {
            this._moveEnd(event);
        }
    }

    _moveEnd(event) {
        const cPixel = event.mapPixel;
        const lP = this._map.getCoordinateFromPixel(this.lPixel);
        const cP = this._map.getCoordinateFromPixel(cPixel);
        const xOffset = -(cP.getOrdinate("X") - lP.getOrdinate("X"));
        const yOffset = -(cP.getOrdinate("Y") - lP.getOrdinate("Y"));
        let oldcenter = this._map.getCenter();
        let center = new hmap.basetype.Coordinate(oldcenter.getOrdinate("X") + xOffset, oldcenter.getOrdinate("Y") + yOffset);
        this._map.panTo(center);
        this.lPixel = cPixel;

        let ev = new hmap.event.Event(EventType.MAPEVENT_MOVEEND);
        this._map.event.dispatch(ev);
    }

    /**
     * 禁用控件  禁用地图的拖动操作。
     * @example
     * pan.deactivate();
     */
    deactivate() {
        //只有状态为激活状态时，才执行取消激活
        if (this._status) {
            this._status = false;
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEDOWN, this.panStart.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE, this.panning.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEUP, this.panend.bind(this));
        }
    }

    /**
     * 克隆一个拖动地图的控件。
     * @example
     * pan.clone();
     */
    clone() {
        return new hmap.control.Pan({
            map: this._map,
            animate: this._animate,
            status: this._status
        });
    }

    /**
     * 销毁接口：销毁控件，释放占用的内存
     * @example
     * pan.destroy();
     */
    destroy() {
        this.deactivate();
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
        this.__proto__ = null;
    }

    /**
     * 返回控件的类型
     * @returns {String} 控件类型的名称。
     */
    getControlType() {
        return hmap.control.controlType.Pan;
    }
};;"use strict";
hmap.control = hmap.control || {};
/**
 * 地图缩放控件。向前滚动鼠标滚轮增加地图的缩放级别，向后滚动鼠标滚轮减小地图的缩放级别。
 * @type {hmap.control.Zoom}
 * @extends hmap.control.Control
 * @example
 * let res = [5.36441802978515E-06,
                1.07288360595703E-05,
                2.1457672119140625E-05,
                4.29153442382814E-05,
                8.58306884765629E-05,
                0.000171661376953125,
                0.00034332275390625,
                0.0006866455078125,
                0.001373291015625,
                0.00274658203125,
                0.0054931640625,
                0.010986328125,
                0.02197265625,
                0.0439453125,
                0.087890625,
                0.17578125,
                0.3515625,
                0.703125].reverse();
 * let map = new hmap.Map("hmap", {
        zoom: 12,
        center: new hmap.basetype.Coordinate(120.435078, 30.19345, 0),
        resolutions: res,
        crs:new hmap.proj.Crs('4326'),//坐标系是地理可视化计算的基础,在地图对象初始化前务必指定
        minLevel:1,
        maxLevel:16
 * });
 * let zoom = new hmap.control.Zoom({"map": map});
 */
hmap.control.Zoom = class extends hmap.control.Control {
    /**
     * 构造一个地图缩放控件。
     * @param {Object} options 可选项。
     * @param {hmap.Map} options.map 地图对象。
     */
    constructor(options) {
        super();
        options = Object.assign({
            animate: 250
        }, options);

        //父类成员
        this._target = options.target;

        //子类成员
        this._animate = options.animate;
        //this._level = options.level ? options.level : 1;
        //this._center = options.center;
        if (options.map) {
            this.setMap(options.map);
        }
        this.CLASS_NAME = "hmap.control.Zoom";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._exclusive=false;
        this._stopTime=800;
    }

    getAnimate() {
        return this._animate;
    }

    setAnimate(animate) {
        this._animate = animate;
    }

    /**
     * 按照中心点坐标和级别缩放地图
     * @param {hmap.basetype.Coordinate} center 要缩放到的中心点
     * @param {int} zoom 要缩放到的级别
     * @private
     */
    _mapZoom(center, zoom) {
        this._map.setCenter(center, zoom);
    }


    /**
     * 将当前控件与地图对象绑定。绑定后，缩放控件直接激活，能够对地图进行缩放操作。
     * @param {hmap.Map} map 地图对象。
     */
    setMap(map) {
        super.setMap(map);
        this._zoomInterval = this._map._zoomInterval;
        this.activate();
    }

    /**
     * 激活控件,监听鼠标滚轮事件。
     * @example
     * zoom.activate();
     */
    activate() {
        super.activate();
        if (this._map && !this._status) {
            this._status = true;
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEWHEEL,this._zoom.bind(this));
        }
    }

    /**
     * 执行缩放
     * @param {Object} event 事件对象
     * @private
     */
    _zoom(event){
        this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMSTART));
        this._trigerTime=(new Date()).valueOf();
        let delta = 0;
        if (event.wheelDelta) {
            delta = event.wheelDelta;
            if (delta % 160 === 0) {
                // 早期Opera坂本为160
                delta = delta * 0.75;
            }
            //其他浏览器为120
            delta = delta / 120;
        } else if (event.detail) { //Firefox
            // OS X中Firefox的detail值为Windows的1/3
            // 将delta限制为1/-1
            delta = -(event.detail / Math.abs(event.detail));
        }
        if (delta) {
            let zoom = this._map.getZoomWithInterval();
            const levelBeforeZoom = zoom;
            if (delta < 0) {
                const minZoom = this._map.getMinZoom();
                zoom = zoom - 1 / this._zoomInterval;
                if(zoom<minZoom){
                    return;
                }
            } else {
                const maxZoom = this._map.getMaxZoom();
                zoom = zoom + 1 / this._zoomInterval;
                if(zoom>maxZoom){
                    return;
                }
            }
            const levelAfterZoom = zoom;
            const anchorPixel = event.mapPixel;
            const centerOffset = this._getZoomTargetCenterDelta(anchorPixel, levelBeforeZoom, levelAfterZoom);
            const center = this._map.getCenter().clone().addOffset(centerOffset);
            this._map.setCenter(center, zoom);
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMING));
        }
        this._scollTimer=setTimeout(this._zoomEnd.bind(this), this._stopTime,this._trigerTime+this._stopTime);
    }

    /**
     *
     * @param ev
     * @private
     */
    _zoomEnd(ev){
        clearTimeout(this._scollTimer);
        if(ev-this._trigerTime===this._stopTime){
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ZOOMEND));
        }

    }

    /**
     *
     * @param anchorPixel
     * @param levelBeforeZoom
     * @param levelAfterZoom
     * @return {hmap.basetype.Offset|*}
     * @private
     */
    _getZoomTargetCenterDelta(anchorPixel, levelBeforeZoom, levelAfterZoom) {
        const coordBeforeZoom = this._map._camera.getCoordinateFromPixel(anchorPixel,
            this._map.getResolution(levelBeforeZoom));
        const coordAfterZoom = this._map._camera.getCoordinateFromPixel(anchorPixel,
            this._map.getResolution(levelAfterZoom));
        const offset = coordBeforeZoom.minus(coordAfterZoom);
        return offset;
    }

    /**
     * 禁用控件。
     * @example
     * zoom.deactivate();
     */
    deactivate() {
        if (this._map && this._status) {
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEWHEEL,this._zoom.bind(this));
            this._status = false;
        }
    }

    /**
     * 销毁控件，释放占用的内存。
     * @example
     * zoom.destroy();
     */
    destroy() {
        this.deactivate();
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }

    /**
     * 克隆一个缩放控件
     * @example
     * zoom.clone();
     */
    clone() {
        return new hmap.control.Zoom({
            animate: this._animate,
            target: this._target,
            map: this._map
        });
    }
    /**
     * 返回控件类型的名称。
     * @returns {string} 控件类型的名称。
     */
    getControlType(){
        return hmap.control.controlType.Zoom;
    }
};
;"use strict";
hmap.control = hmap.control || {};
/**
 * 地图旋转控件，通过改变地图的方位角和俯仰角控制地图旋转。
 * 方位角：在地图的俯仰角为0时，屏幕上方向到地图指北针的旋转角，可沿顺时针和逆时针方向改变；
 * 俯仰角：地图倾斜后所在平面与屏幕所在平面形成的夹角，角度范围限制在0度到所设置的最大俯仰角之间。
 * 改变方位角和俯仰角的操作方式如下：
 * 按下鼠标右键，在屏幕水平方向拖动时，可改变地图的方位角；
 * 按下鼠标右键，沿屏幕垂直方向上移动鼠标时，可改变地图的俯仰角；
 * 点击鼠标中键重置方位角和俯仰角，该操作将地图恢复到方位角和俯仰角都为0的状态。
 * @type {hmap.control.Rotate}
 * @extends hmap.control.Control
 * @example
 let tmslayer, vectorLayer,control;
 * map = new hmap.Map("hmap", {
        zoom: 12,
        center: new hmap.basetype.Coordinate(120.435078, 30.19345, 0),
        crs:new hmap.proj.Crs('4326'),//坐标系是地理可视化计算的基础,在地图对象初始化前务必指定
        minLevel:1,
        maxLevel:16
 * });
 * let rotate = new hmap.control.Rotate({
        "map": map,
 * });
 */
hmap.control.Rotate = class extends hmap.control.Control {
    /**
     * 构造一个地图旋转控件。
     * @param {Object} options 可选项。
     * @param {hmap.Map} options.map 地图对象。
     */
    constructor(options={}) {
        super();
        this._animate = (options && options.animate)?options.animate:null;
        if (options && options.map) {
            this.setMap(options.map);
        }
        this.CLASS_NAME = "hmap.control.Rotate";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._exclusive=false;
    }

    /**
     *
     * @returns {*}
     * @private
     */
    getAnimate() {
        return this._animate;
    }

    /**
     *
     * @param animate
     * @private
     */
    setAnimate(animate) {
        this._animate = animate;
    }

    /**
     * 获取允许的最大俯仰角。
     * @return {Number} 最大俯仰角,单位是角度。
     * @example
     * let maxPitch = rotate.getMaxPitch();
     */
    getMaxPitch() {
        return this._maxPitch;
    }

    /**
     * 将旋转控件与地图对象绑定。绑定后，旋转控件直接激活，能够对地图进行旋转操作。
     * @param {hmap.Map} map 地图对象。
     */
    setMap(map) {
        super.setMap(map);
        this._maxPitch=map._maxPitch;
        this.activate();
    }

    /**
     * 激活控件，只有控件添加到地图上时才起作用。
     * @example
     * rotate.activate();
     */
    activate() {
        super.activate();
        if (this._map && !this._status) {
            this._status = true;
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEDOWN, this._rotateStart.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE, this._rotating.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEUP, this._rotateEnd.bind(this));
        }
    }

    /**
     * 开始旋转
     * @param event
     * @private
     */
    _rotateStart(event) {
        if (event.button === 2) {
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATESTART));
            this._mousePixel = new hmap.basetype.Pixel(event.x, event.y);
        } else if (event.button === 1) {
            //恢复默认值
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATERESET));
            this._map._camera.resetRotate();
            this._map.redraw();
        }
    }

    /**
     * 执行旋转
     * @param event
     * @private
     */
    _rotating(event) {
        if (event.buttons === 2) {
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATING));
            let curMousePixel = new hmap.basetype.Pixel(event.x, event.y);
            const deltaX = event.x - this._mousePixel.getX();
            const deltaY = this._mousePixel.getY() - event.y;
            let rotateX = 0;
            let rotateZ = 0;
            //选择鼠标运动的主要方向进行旋转
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                rotateZ = this._getRotateZ(curMousePixel);
            } else {
                rotateX = this._getRotateX(curMousePixel);
            }
            const pitch = -this._map._camera.getRotateX();
            const newPitch = pitch + rotateX;
            rotateX = newPitch < this._maxPitch ? rotateX : this._maxPitch - pitch;
            rotateX = newPitch > 0 ? rotateX : -pitch;
            this._map._camera.rotateX(-rotateX);
            this._map._camera.rotateZ(rotateZ);
            this._mousePixel = curMousePixel.clone();
            this._map.redraw();
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_EXTENTCHANGED,"",this));
        }
    }

    /**
     * 旋转结束
     * @param event
     * @private
     */
    _rotateEnd(event) {
        if (event.button === 2) {
            let curMousePixel = new hmap.basetype.Pixel(event.x, event.y);
            const deltaX = event.x - this._mousePixel.getX();
            const deltaY = this._mousePixel.getY() - event.y;
            let rotateX = 0;
            let rotateZ = 0;
            //选择鼠标运动的主要方向进行旋转
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                rotateZ = this._getRotateZ(curMousePixel);
            } else {
                rotateX = this._getRotateX(curMousePixel);
            }
            const pitch = -this._map._camera.getRotateX();
            const newPitch = pitch + rotateX;
            rotateX = newPitch < this._maxPitch ? rotateX : this._maxPitch - pitch;
            rotateX = newPitch > 0 ? rotateX : -pitch;
            this._map._camera.rotateX(-rotateX, 1, 0, 0);
            this._map._camera.rotateZ(rotateZ, 0, 0, 1);
            this._mousePixel = curMousePixel.clone();
            //this._map.redraw();
            this._map.event.dispatch(new hmap.event.Event(EventType.MAPEVENT_ROTATEEND));
        }
    }

    /**
     * 获得绕Z轴旋转的角度
     * @param curMousePixel
     * @returns {number}
     * @private
     */
    _getRotateZ(curMousePixel) {
        const centerX = this._map.container.clientWidth / 2;
        const centerY = this._map.container.clientHeight / 2;
        const oldMousePixel = this._mousePixel.clone();
        const ab = new hmap.util.Vector3(oldMousePixel.getX() - centerX,
            centerY - oldMousePixel.getY());
        const ac = new hmap.util.Vector3(curMousePixel.getX() - centerX,
            ab.getElement(1));
        ab.normalize();
        ac.normalize();
        let dot = ac.dot(ab);
        dot = dot > 1 ? 1 : dot;
        dot = dot < -1 ? -1 : dot;
        let angle = Math.acos(dot) * 180 / Math.PI;
        const cross = ab.getElement(0) * ac.getElement(1) - ab.getElement(1) * ac.getElement(0);
        if (cross < 0) {
            angle = -angle;
        }
        return angle;
    }

    /**
     * 获得绕X轴旋转的角度
     * @param curMousePixel
     * @return {number}
     * @private
     */
    _getRotateX(curMousePixel) {
        const offy = (this._mousePixel.getY() - curMousePixel.getY()) * this._map.getResolution();
        const height = this._map._camera.getEyeZ();
        const tan = -offy / height * 4;
        return Math.atan(tan) * 180 / Math.PI;
    }


    /**
     * 禁用旋转控件，禁用对地图的旋转操作。
     * @example
     * rotate.deactivate();
     */
    deactivate() {
        if (this._map && this._status) {
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEDOWN, this._rotateStart.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE, this._rotating.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEUP, this._rotateEnd.bind(this));
            this._status = false;
        }
    }

    /**
     * 销毁接口：销毁控件，释放占用的内存
     * @example
     * rotate.destroy();
     */
    destroy() {
        this.deactivate();
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }

    /**
     * 克隆一个旋转控件。
     * @example
     * rotate.clone();
     */
    clone() {
        return new hmap.control.Rotate({
            maxPitch: this._maxPitch,
            animate: this._animate,
            map: this._map
        });
    }
    /**
     * 返回控件的类型
     * @returns {string} 控件类型的名称。
     */
    getControlType(){
        return hmap.control.controlType.Rotate;
    }
};
;"use strict";
hmap.control=hmap.control||{};
/**
 * 比例尺控件。用来表示图上距离与实地距离的关系。控件长度代表图上距离，文字描述实地距离。
 * @type {hmap.control.ScaleBar}
 * @extends {hmap.control.Control}
 * @example
 * let scaleBar = new hmap.control.ScaleBar({
                    "scaleTextStyle":'width: 100%;height: 20px;text-align: center;color:#ff0000',
                    "scaleBarStyle":'width: 100%; height: 3px; background-color: #cccccc'
 * });
 */
hmap.control.ScaleBar=class extends hmap.control.Control{
    /**
     * 创建比例尺控件
     * @param {Object} options  可选项
     * @param {String} options.scaleTextStyle  文字CSS样式
     * @param {String} options.scaleBarSTYLE 刻度条CSS样式
     */
    constructor(options={}){
        super();
        this._unit_m = hmap.language[hmap.initState.language].m;
        this._unit_km = hmap.language[hmap.initState.language].km;
        this._unit= this._unit_m;//默认单位为米
        this._scaleBarLength=150;
        this._scaleText=500;
        this._scaleTextStyle=options.scaleTextStyle?options.scaleTextStyle:"width: 100%;height: 20px;text-align: center";
        this._scaleBarStyle=options.scaleBarStyle?options.scaleBarStyle:"width: 100%; height: 3px; background-color: #cccccc";
        this.CLASS_NAME = "hmap.control.ScaleBar";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._exclusive=false;



    }
    /**
     * 激活比例尺控件。
     * @example
     * scaleBar.activate();
     */
    activate(){
        super.activate();
        this.updateScaleBar();
        this._map.event.addListener(EventType.MAPEVENT_ZOOMCHANGED,this.updateScaleBar.bind(this));
        //this._map.event.addListener(EventType.MAPEVENT_ZOOMING,this.updateScaleBar.bind(this));
    }

    /**
     * 禁用比例尺控件，禁用后 比例尺控件的文字描述及比例尺长度不随地图缩放发生改变
     * @example
     * scaleBar.deactivate();
     */
    deactivate(){
        this._map.event.removeListener(EventType.MAPEVENT_ZOOMCHANGED,this.updateScaleBar.bind(this));
        //this._map.event.removeListener(EventType.MAPEVENT_ZOOMING,this.updateScaleBar.bind(this));
    }

    /**
     * 更新比例尺样式
     */
    updateScaleBar(){
        this._scaleBarLength=150;
        //50个像素代表的地图距离地图单位
        let mapDis=150*this._map.getResolution();
        //地图单位转为米为单位,或许完成
        mapDis=mapDis*111000;
        if(mapDis>1000){
            this._unit=this._unit_km;//"公里";
            this._scale=1000;
        }else{
            this._unit=this._unit_m;//"米";
            this._scale=1;
        }
        //寻找最合适的比例尺长度
        let mapTrueDis=mapDis;
        mapTrueDis=mapTrueDis.toFixed(0);
        const b=mapTrueDis.toString().length;
        const start=Number.parseInt(mapDis.toString().substr(0,1));
        if(start<2){
            mapTrueDis=1*Math.pow(10,b-1);
        }else if(start<5){
            mapTrueDis=2*Math.pow(10,b-1);
        }else if(start<10){
            mapTrueDis=5*Math.pow(10,b-1);
        }
        this._scaleBarLength=Math.ceil(this._scaleBarLength*mapTrueDis/mapDis);
        this._scaleText=(mapTrueDis/this._scale).toFixed(0);
        //更新ui
        document.getElementById("scale").style.width=this._scaleBarLength+"px";
        document.getElementById("scaleText").innerHTML=this._scaleText+" "+this._unit;
    }

    /**
     * 和地图对象进行绑定，并自动激活控件。
     * addControl的时候调用setMap()
     * @param {hmap.Map} map
     */
    setMap(map){
        super.setMap(map);
        this.scale=document.createElement("div");
        const scale=this.scale;
        scale.id="scale";
        scale.style.position="absolute";
        scale.style.left="10px";
        scale.style.bottom="10px";
        scale.style.zIndex=999;
        this._map.container.parentElement.appendChild(scale);
        let scaleText=document.createElement("div");
        scaleText.id="scaleText";
        let scaleBar=document.createElement("div");
        scaleBar.id="scaleBar";
        scale.appendChild(scaleText);
        scale.appendChild(scaleBar);
        scaleText.style=this._scaleTextStyle;
        scaleBar.style=this._scaleBarStyle;
        this.activate();
    }

    setTarget(dom){
        this._dom=dom;
    }

    /**
     * 销毁控件，释放占用的内存。
     * @example
     * scaleBar.destroy();
     */
    destroy(){
        this.deactivate();
        if(this.scale){
            this._map.container.parentElement.removeChild(scale);
        }
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }
    /**
     * 返回控件的类型
     * @returns {String} 控件类型的名称
     */
    getControlType(){
        return hmap.control.controlType.ScaleBar;
    }
};
;"use strict";
hmap.control=hmap.control || {};

/**
 * 鼠标位置控件，鼠标在地图上移动时显示出鼠标位置对应的地图坐标。
 * @type {hmap.control.MousePosition}
 * @extends hmap.control.Control
 * @example
 * let mousePosition = new hmap.control.MousePosition({
        "textColor": "ff0000",
        "fontSize": "14"
 * });
 */
hmap.control.MousePosition=class extends hmap.control.Control {

    /**
     * 构造函数
     * @param {Object} options 可选项。
     * @param {String} options.style  鼠标位置控件的样式，例："color:#ff0000";
     * @param {String} options.status 状态
     * @param {hmap.Map} options.map 地图对象
     */
    constructor(options={}){
        super();
        this._map=null;
        this.options=options?options:{};
        if(this.options.hasOwnProperty("map")){
            this._map=this.options.map;
        }

        if(this.options.hasOwnProperty("animate")){
            this._animate=this.options.animate;
        }

        if(this.options.hasOwnProperty("status")){
            if(this._map){
                this._status=this.options.status;
            }
        }
        this._style=options.style?options.style:"position: absolute;right: 10px;bottom: 10px;color:#526542;font-size:13px;zIndex:999";
        this._listenKeys=[];
        this._status=false;
        this.CLASS_NAME = "hmap.control.MousePosition";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._exclusive=false;
    }

    /******
     * (暂未启用)
     */
    getAniminate(){
        return this._animate;
    }

    /******
     * (暂未启用)
     */
    setAniminate(animate){
        this._animate=animate;
    }

    /**
     * 地图平移。
     * @param {hmap.basetype.Coordinate} coord
     * @private
     */
    mapPan(coord){
        this._map.panTo(coord,true);
    }

    /**
     * 将鼠标位置控件和地图对象进行绑定，并自动激活。
     * @param {hmap.Map} map 地图对象
     */
    setMap(map){
        super.setMap(map);
        this.position=document.createElement("div");
        this.position.id="position";
        // position.style.position="absolute";
        // position.style.right="10px";
        // position.style.bottom="10px";
        // position.style.color=this.options.hasOwnProperty("textColor")?this.options.textColor:"#000000";
        // position.style.fontSize=this.options.hasOwnProperty("fontSize")?this.options.fontSize:13;
        // position.style.zIndex=999;
        this.position.style=this._style;
        this._map.container.parentElement.appendChild(this.position);
        this.activate();
    }


    /**
     * 激活该控件，只有将控件添加到地图上时才起作用。
     * @example
     * mousePosition.activate();
     */
    activate(){
        super.activate();
        //map存在，且状态为未激活时才添加坚挺
        if(this._map && !this._status){
            this._status=true;
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.updateMousePosition.bind(this));
        }
    }

    /**
     * 更新鼠标位置控件的显示内容
     * @param {Event} event
     * @private
     */
    updateMousePosition(event){
        let pixel=new hmap.basetype.Pixel(event.clientX,event.clientY);
        let coordinate=this._map.getCoordinateFromPixel(pixel);
        document.getElementById("position").innerHTML = coordinate.getOrdinate("X").toFixed(5)+","+coordinate.getOrdinate("Y").toFixed(5);
    }

    /**
     * 禁用鼠标位置控件。禁用后，控件显示的地图坐标不会随鼠标位置发生更新，需调用activate接口来激活。
     * @example
     * mousePosition.deactivate();
     */
    deactivate(){
        //只有状态为激活状态时，才执行取消激活
        if(this._status){
            this._status=false;
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.updateMousePosition.bind(this));
        }
    }


    /**
     * 克隆一个鼠标位置控件。
     * @returns {hmap.control.MousePosition} 鼠标位置控件对象。
     * @example
     * mousePosition.clone();
     */
    clone(){
        return new hmap.control.Pan({
            map:this._map,
            animate:this._animate,
            status:this._status
        });
    }

    /**
     * 销毁接口：销毁控件，释放占用的内存
     * @example
     * mousePosition.destroy();
     */
    destroy(){
        this.deactivate();
        if(this.position){
            this._map.container.parentElement.removeChild(this.position);
        }
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }
    /**
     * 返回控件的类型
     * @returns {string} 控件类型的名称。
     */
    getControlType(){
        return hmap.control.controlType.MousePosition;
    }
};
;"use strict";

hmap.control = hmap.control || {};
/**
 * 高亮要素的控件。
 * @type {hmap.control.HighLightPoint}
 * @private
 */
hmap.control.HighLightPoint = class extends hmap.control.Control {
    /**
     * 构造一个缩放控件。属性信息都可以在options中配置
     */
    constructor(options) {
        super();
        this.CLASS_NAME = "hmap.control.HighLightPoint";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._map=null;
        this._vtLayer=null;
        this._status=false;
        this._exclusive=false;
        this._preHighLightFid=[];
    }

    /**
     * 设置地图对象
     * @param map 地图对象
     */
    setMap(map) {
        super.setMap(map);
        this.activate();
    }

    /**
     * 激活控件
     */
    activate() {
        super.activate();
        if (this._map && !this._status) {
            this._status = true;
            //需要监听鼠标移动到要素事件
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEOVER,this.mouseOver.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEOUT,this.mouseOut.bind(this));
        }
    }
   
    /**
     * 禁用控件
     */
    deactivate() {
        if (this._map && this._status) {
            //需要注销鼠标滑动事件
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEOVER,this.mouseOver.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEOUT,this.mouseOut.bind(this));
            this._status = false;
        }
    }

    destroy() {
    }

    clone() {
    }

    /******
     * 鼠标移动到元素上时触发的事件
     */
    mouseOver(event) {
        //找出矢量切片图层---临时放这里
        const layers=this._map.layers;
        for(let i=0,len=layers.length;i<len;i++){
            if(layers[i].CLASS_NAME==="hmap.layer.VectorTile"){
                this._vtLayer=layers[i];
                break;
            }
        }
        if(!this._vtLayer){
            //只有矢量切片才能用点高亮控件
            throw new Error("there is no VectorTile layer in your map!");
        }
        //找出矢量切片图层---临时放这里

        //在这里注册鼠标mouseMove事件
        this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.mouseMove.bind(this));
    }

    /**
     * 鼠标从元素上移出时触发的事件
     */
    mouseOut(event) {
        //在这里取消鼠标mouseMove事件
        this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.mouseMove.bind(this));
    }

    /**
     * 鼠标在元素上移动时触发的事件
     */
    mouseMove(event) {
        //取消之前高亮要素
        if(this._preHighLightFid.length>0){
            this._vtLayer.updatePointStatusByFid(this._preHighLightFid.pop(),0);
        }
        hmap.style.Cursor.set(this._map.container,"Move");
        const pointFids=[];
        // 获取鼠标所在像素值
        const pixel=new hmap.basetype.Pixel(event.clientX,event.clientY);
        const coord = this._map.getCoordinateFromPixel(pixel);
        const features=this._vtLayer.getFeaturesByCoord(coord);
        //查找features(只取出点)
        for(let i=0,len=features.length;i<len;i++){
            if(features[i].superType==="POI"){
                pointFids.push(features[i].id);
            }
        }
        //只更新第一个要素
        if(pointFids.length>0){
            this._vtLayer.updatePointStatusByFid(pointFids[0],1);
            this._preHighLightFid.push(pointFids[0]);
            //改变游标
            hmap.style.Cursor.set(this._map.container, "HAND_OVER");
        }
       
    }
    /**
     * 返回控件的类型
     * @returns {string}
     */
    getControlType(){
        return hmap.control.controlType.HighLightPoint;
    }
};
;'use strict';
hmap.control=hmap.control || {};
/**
 * 鼠标提示控件，即跟随鼠标移动显示提示内容的控件。
 * @type {hmap.control.MouseTipControl}
 * @extends hmap.control.Control
 * @example
 * let mousePosition = new hmap.control.MouseTipControl({
            "tipContent": "测试"
 *  });
 */
hmap.control.MouseTipControl = class extends hmap.control.Control{
    /**
     * 构造函数,鼠标移动时，显示提示框的内容，风格可自定义。
     * @param {Object} options 可选参数
     * @param {hmap.Map} options.map 地图对象
     * @param {String} options.tipContent 要跟随鼠标提示的内容
     * @param {String} options.style 提示框的css样式,默认样式为： "position:absolute;color:black;font-size:13px;zIndex:999;width:fit-content;height:30px;line-height:30px;padding-left:8px;padding-right:8px;border:1px solid black;background:white;display:none;user-select:none;"。
     * @param {String} options.offsetX 提示框的在x轴方向上的偏移像素,不指定缺省值为5。x轴正方向为屏幕坐标系的x正方向，即向右为正。
     * @param {String} options.offsetY 提示框的在y轴方向上的偏移像素,不指定缺省值为5。y轴正方向为屏幕坐标系的y轴正方向，即向下为正。
     *
     */
    constructor(options = {}){
        super();
        this.CLASS_NAME = "hmap.control.MouseTipControl";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._map = null;
        this._status = false; //默认不激活
        if (options.map) {
            this.setMap(options.map);
        }
        this._offsetX=5;
        this._offsetY=5;
        if(options.offsetX){
            this._offsetX=options.offsetX;
        }
        if(options.offsetY){
            this._offsetY=options.offsetY;
        }
        this._tipContent = options.tipContent?options.tipContent:"";
        this._style = options.style?options.style:
        "position:absolute;color:black;font-size:13px;zIndex:999;width:fit-content;height:30px;line-height:30px;padding-left:8px;padding-right:8px;border:1px solid black;background:white;display:none;user-select:none;";
        this._animate= options.animate?options.animate:'';
        this._tipDomId = this._id + (new Date().getTime());
        this._tipDom = null;
        this._exclusive=false;
    }
     /******
     * (暂未启用)
     */
    getAniminate(){
        return this._animate;
    }
    /******
     * (暂未启用)
     */
    setAniminate(animate){
        this._animate=animate;
    }

    /**
     * 绑定地图对象
     * @param {hmap.Map} map 地图对象
     */
    setMap(map){
        super.setMap(map);
        this.createTipDom()
    }
    /**
     * 返回,提示框div的id方便自定义操作
     */
    getTipDomId(){
        return this._tipDomId;
    }

    /**
     * 创建提示框Dom对象
     * @private
     */
    createTipDom(){
        const tipDom = document.createElement("div");
        tipDom.id= this._tipDomId;
        tipDom.style = this._style;

        tipDom.style.position = "absolute";
        tipDom.style.display = 'none';
        tipDom.style.zIndex = 999;
        tipDom.innerHTML  = this._tipContent;
        this._map.container.parentElement.appendChild(tipDom);
        this._tipDom = tipDom;
        this.activate();
    }
    /**
     * 移动到指定位置
     * @private
     */
    mapPan(coord){
        this._map.panTo(coord,true);
    }
    /**
     * 激活该控件，只有将控件添加到地图上时才起作用。
     * @example
     * MouseTipControl.activate();
     */
    activate(){
        super.activate();
        //map存在，且状态为未激活时才添加监听
        if(this._map && !this._status){
            this._status=true;
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.updateMouseTip.bind(this));
        }
    }

    /**
     * 更新提示框
     * @param {Event} event
     * @private
     */
    updateMouseTip(event){
        let pixel=event.mapPixel;
        if(this._tipContent===""){
            this._tipDom.style.display = 'none';
        }else {
            this._tipDom.style.display = 'block';
            this._tipDom.style.left = pixel.getX()+this._offsetX + "px";
            this._tipDom.style.top = pixel.getY()+this._offsetY + "px";
        }
    }
    /**
	 * 重设提示框的内容。
	 */
    setTipContent( content){
        this._tipContent = content;
        const tipDom = document.getElementById(this._tipDomId);
        if(tipDom){//tipDom不为null
            tipDom.innerHTML = this._tipContent;
        }
    }
    /**
     * 禁用控件。禁用后提示框不显示,注册的鼠标移动事件监听函数被移除监听。
     * @example
     * mouseTipControl.deactivate();
     */
    deactivate(){
        //只有状态为激活状态时，才执行取消激活
        if(this._status){
            this._status=false;
            this._tipDom.style.display = 'none';
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE,this.updateMouseTip.bind(this));
        }
     }
    /**
     * 克隆一个鼠标提示控件。
     * @example
     * MouseTipControl.clone();
     */
    clone(){
        return new hmap.control.MouseTipControl({
            map:this._map,
            animate:this._animate,
            status:this._status
        });
    }
    /**
	 * 销毁MouseTipControl对象
	 */
    destroy(){
        this.deactivate();
        const tipDom = document.getElementById(this._tipDomId);
        if(tipDom){
            this._map.container.parentElement.removeChild(tipDom);
        }
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }
    /**
     * 获取控件的类型
     * @returns {String} 控件类型的名称。
     */
    getControlType(){
        return hmap.control.controlType.MouseTipControl;
    }
};
;hmap.control = hmap.control || {};
/**
 * 鹰眼控件。以上帝视角查看当前地图。
 * @type {hmap.control.MiniMap}
 * @extends hmap.control.Control
 * @example
 * const tmsLayer = new hmap.layer.TMS("TMS", tmsURL, tmsOptions);
 * const miniMap = new hmap.control.MiniMap(tmsLayer);
 * map.addControl(miniMap);
 */
hmap.control.MiniMap = class extends hmap.control.Control {
	/**
	 * 创建鹰眼控件
	 * @param {hmap.layer.Layer} layer  在鹰眼控件中展示的图层
	 * @param {Object} options  可选项
	 * @param {Number} options.miniMapMiniLevel  鹰眼地图的默认最小缩放级别，建议取一个合适的数值使miniMap的最小级别范围是你所感兴趣的范围，默认为0级
	 * @param {String} options.containerDomStyle 鹰眼控件CSS样式 默认320*180 2px红色实线矩形框，绝对定位右下角
	 * @param {hmap.style.Style} options.extentStyle 鹰眼控件内部extent矩形样式，默认紫色 1px实线框
	 * @param {String} options.showBtnStyle 展开鹰眼控件的按钮样式,默认 20*20绝对定位右下角
	 * @param {String} options.hideBtnStyle 隐藏鹰眼控件的按钮样式，默认 20*20绝对定位左上角
	 * @param {String} options.showBtnText 展开鹰眼控件的文字，默认为‘+’
	 * @param {String} options.hideBtnText 隐藏鹰眼控件的文字，默认为‘-’
	 * @param {Number} options.offsetZoom 主地图比鹰眼地图大的级别数，默认为4
	 */
	constructor(layer = null, options = {}) {
		super();
		this.layer = layer; //要展示的内容
		this.container = null; //鹰眼的父div
		this._mainMap = null; //鹰眼放在哪个地图上
		this.miniMap = null; //鹰眼中展示的地图
		this._operateBtn = null; //鹰眼中的最小化按钮
		this._showBtnStyle = options.showBtnStyle != undefined ? options.showBtnStyle : "width: 20px;height: 20px;position: absolute;top: -20px;left: -20px;background: white;text-align: center;line-height: 20px;cursor: pointer";
		this._hideBtnStyle = options.hideBtnStyle != undefined ? options.hideBtnStyle : "width: 20px;height: 20px;position: absolute;top: 0;left: 0;background: white;text-align: center;line-height: 20px;cursor: pointer";
		this._showBtnText = options.showBtnText != undefined ? options.showBtnText : "+";
		this._hideBtnText = options.hideBtnText != undefined ? options.hideBtnText : "-";
		this._miniMapZoom = options.miniMapMiniLevel != undefined ? options.miniMapMiniLevel : 0;
		this._containerDomStyle = options.containerDomStyle != undefined ? options.containerDomStyle : "position:absolute;width:320px;height:180px;right:5px;bottom:5px;border:2px solid red;zIndex:999;";
		this._offsetZoom = options.offsetZoom != undefined ? options.offsetZoom : 4;
		this.CLASS_NAME = "hmap.control.MiniMap";
		this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
		if (options['extentStyle']) {
			this._extentStyle = options['extentStyle']
		} else {
			const colorFill = new hmap.style.ColorFill(new hmap.style.Color(0, 255, 0, 0));
			const lineSymbol = new hmap.style.LineSymbol({
				color: new hmap.style.Color(255, 0, 255, 1), //线的颜色值
				width: 1 //线的像素宽度，默认为1个像素
			});
			this._extentStyle = new hmap.style.Style({
				fillSymbols: [colorFill],
				lineSymbols: [lineSymbol]
			});
		}
		this._miniMapMousedown = false; //miniMap鼠标是否处于按下的状态
		this._mouseInExent = false; //miniMap 鼠标移动到了extent内部
		this._miniMapClickCoord;
		this._currentZoom = 0;
		this._center = null;
	}

	/**
	 * 设置当前控件的地图对象，调用该方法会自动激活放大镜控件
	 * @param map {hmap.Map} 控件的地图对象
	 * @private
	 */
	setMap(map) {
		this._mainMap = map; //要绑定的map
		if (!this.container) {
			this.container = this._createPane("div", "hmap-control-minimap");
			this.setStyle(this._containerDomStyle);
		}
		this.miniMap = this._addMiniMap(this._mainMap);
		this._rectangleLayer = new hmap.layer.VectorLayer('extent', {
			enableHashCode: true
		});
		this.miniMap.addLayer(this._rectangleLayer);
		this.setStyle(this._containerDomStyle);
		const extent = this._mainMap.getExtent();
		const rectangle = this._getRectFromExtent(extent);
		this._rectangleFeature = new hmap.feature.Vector(rectangle, {}, this._extentStyle);
		this._rectangleLayer.addFeature(this._rectangleFeature);
		this._operateBtn = this._addButton();
		this.activate();
	}
	/**
	 * 根据边界盒构造rectangle实例
	 * @param {hmap.basetype.Extent} extent 边界盒
	 * @returns {hmap.geom.Rectangle} 矩形
	 * @private 
	 */
	_getRectFromExtent(extent) {
		const bl = extent.getBottomLeft();
		const tr = extent.getTopRight();
		const pointBL = new hmap.geom.Point(bl);
		const pointTR = new hmap.geom.Point(tr);
		const rectangle = new hmap.geom.Rectangle([pointBL, pointTR]);
		return rectangle;
	}

	/**
	 * 激活鹰眼控件
	 */
	activate() {
		let _this = this;
		//监听主mainMap的extentChange
		this._mainMap.event.addListener(EventType.MAPEVENT_EXTENTCHANGED, this._updataMiniMap.bind(this));
		this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE, function (event) {
			if (!_this._miniMapMousedown) {
				let mapPixel = event.mapPixel;
				let features = _this.miniMap.detectFeaturesAtPixel(mapPixel, ["extent"], 3)
				if (features.length > 0) {
					_this._mouseInExent = true;
					_this.miniMap.container.style.cursor = "pointer";
				} else {
					_this._mouseInExent = false;
					_this.miniMap.container.style.cursor = "context-menu";
				}
			}
		});
		this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEUP, this._updataMainMap.bind(this));

		//监听miniMap的mousedown事件，记录状态，注册mousemove
		this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEDOWN, function (e) {
			//记录点击时候的状态
			_this._miniMapMousedown = true;
			_this._miniMapClickCoord = e.lonlat;
			_this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE, _this._updataMainMap.bind(_this));
		});

		//鼠标弹起，注销mousemove事件
		this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEUP, function () {
			_this._miniMapMousedown = false;
			_this.miniMap.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE, _this._updataMainMap.bind(_this));
		});
	}

	/**
	 * 禁用鹰眼控件
	 */
	deactivate() {
		let _this = this;
		this._mainMap.event.removeListener(EventType.MAPEVENT_EXTENTCHANGED, _this._updataMiniMap.bind(this));
		this.miniMap.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE, this._updataMainMap.bind(this));
		this.miniMap.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEUP, this._updataMainMap.bind(this));
		this.miniMap.event.register(EventType.MAPMOUSEEVENT_MOUSEDOWN, function () {
			_this._miniMapMousedown = false;
		});
	}

	/**
	 * 设置控件面板样式
	 * @param style {String} 要设置的css样式字符串
	 */
	setStyle(style) {
		this.container.style.cssText = style;
	}

	/**
	 * 创建鹰眼面板
	 * @param tagName {String} dom元素的类型
	 * @param className {String} dom元素的元素名称
	 * @private
	 */
	_createPane(tagName, className) {
		const container = document.createElement(tagName);
		container.className = className;
		container.id = hmap.util.Aid.createUnique(container.className);
		return container;
	}

	/**
	 * 将控件添加到map上
	 * @param map {hmap.Map} dom元素的类型
	 * @private
	 */
	_addMiniMap(map) {
		const option = {
			zoom: (this._mainMap.getZoom() - this._offsetZoom) < this._miniMapZoom ? this._miniMapZoom : this._mainMap.getZoom() - this._offsetZoom,
			minLevel: this._miniMapZoom,
			resolutions: map.getResolutions(),
			center: map.getCenter(),
			crs: map.getCrs(),
			enableRotate: false,
			enableZoom: false,
			enablePan: false
		};
		//添加到主map中
		map.container.parentElement.appendChild(this.container);
		let miniMap = new hmap.Map(this.container.id, option);
		miniMap.addLayer(this.layer);
		return miniMap;
	}

	/**
	 * 更新控件显示范围
	 * @private
	 */
	_updataMiniMap() {
		//拖动小地图的时候就不再被动修改地图范围  或者光标不在范围框里面也直接返回
		if (this._miniMapMousedown) {
			return;
		}
		const extent = this._mainMap.getExtent();
		const bl = extent.getBottomLeft();
		const tr = extent.getTopRight();
		const pointBL = new hmap.geom.Point(bl);
		const pointTR = new hmap.geom.Point(tr);
		const miniZoom = (this._mainMap.getZoom() - this._offsetZoom) < this._miniMapZoom ? this._miniMapZoom : this._mainMap.getZoom() - this._offsetZoom;
		this._rectangle = new hmap.geom.Rectangle([pointBL, pointTR]);
		const rectangleFeature = new hmap.feature.Vector(this._rectangle, {}, this._extentStyle);
		const center = this._mainMap.getCenter();
		this.miniMap.setCenter(center, miniZoom);
		this._rectangleLayer.removeFeature(this._rectangleFeature);
		this._rectangleFeature = rectangleFeature;
		this._rectangleLayer.addFeature(this._rectangleFeature);
		this._currentZoom = miniZoom;
	}

	/**
	 * 重新指定MainMap的中心点
	 * @private
	 */
	_updataMainMap(e) {
		const coord = e.lonlat;
		const cursorX = coord.getOrdinate("X");
		const cursorY = coord.getOrdinate("Y");

		switch (e.type) {
			case "mousemove":
				if (!this._mouseInExent) {
					return;
				}
				const x = this._miniMapClickCoord.getOrdinate("X");
				const y = this._miniMapClickCoord.getOrdinate("Y");
				const offsetX = cursorX - x;
				const offsetY = cursorY - y;
				const centerBeforeMove = this._mainMap.getCenter();
				const centerafterMove = new hmap.basetype.Coordinate(centerBeforeMove.getOrdinate("X") + offsetX, centerBeforeMove.getOrdinate('Y') + offsetY);
				this._mainMap.setCenter(centerafterMove, this._mainMap.getZoom());
				this._rectangleLayer.removeFeature(this._rectangleFeature);
				const rectangleFeature = this._rectangleFeature.copyTo(centerafterMove);
				this._rectangleLayer.addFeature(rectangleFeature);
				this._rectangleFeature = rectangleFeature;
				//更新完地图状态之后，重新初始化_miniMapClickCoord
				this._miniMapClickCoord = coord;

				this.miniMap.container.style.cursor = "-webkit-grabbing";
				break;
			case "mouseup":
				//地图中心点移到红框中心点
				this.miniMap.setCenter(this._rectangleFeature.getExtent().getCenter(), this.miniMap.getZoom());
				break;
		}
	}

	/**
	 * 添加最小化(最大化)的按钮
	 * @private
	 */
	_addButton() {
		const btn = this._createPane("span", "minimapButton_hidden");
		btn.style.cssText = this._hideBtnStyle;
		btn.innerHTML = this._hideBtnText;
		this.container.appendChild(btn);
		btn.addEventListener("click", this._updateBtn.bind(this));
		return btn;
	}

	/**
	 * btn被点击时触发的回调函数
	 * @private
	 */
	_updateBtn() {
		if (this._operateBtn.className === "minimapButton_hidden") {
			this._hideMiniMap();
			this._operateBtn.innerHTML = this._showBtnText;
			this._operateBtn.style.cssText = this._showBtnStyle;
			this._operateBtn.className = "minimapButton_show";
		} else {
			this._showMiniMap();
			this._operateBtn.innerHTML = this._hideBtnText;
			this._operateBtn.style.cssText = this._hideBtnStyle;
			this._operateBtn.className = "minimapButton_hidden"
		}
	}

	/**
	 * 隐藏minimap
	 * @private
	 */
	_hideMiniMap() {
		this.container.style.height = "0";
		this.container.style.width = "0";
		this.container.style.border = "0";
	}
	/**
	 * @private
	 */
	_showMiniMap() {
		this.setStyle(this._containerDomStyle);
	}

	/**
	 * 获取mainMap的中心点
	 * @private
	 */
	_getMainMapCenter() {
		return this._mainMap.getCenter();
	}
	/**
	 * 获取mainMap的级别
	 * @private
	 */
	_getMainMapZoom() {
		return this._mainMap.getZoom();
	}
	/**
	 * 返回控件的类型
	 * @returns {string} 控件类型的名称。
	 */
	getControlType() {
		return hmap.control.controlType.MiniMap;
	}

	/**
	 * 销毁控件，释放占用的内存。
	 * @example
	 * miniMap.destroy();
	 */
	destroy() {
		this.deactivate();
		this.miniMap.destroy();
		this._mainMap.container.parentNode.removeChild(this.container);
		let entries = Object.entries(this);
		for (let i = 0; i < entries.length; i++) {
			if (entries[i][0] !== '_mainMap') {
				this[entries[i][0]] = null;
			}
		}
		delete this;
	}
};"use strict";
hmap.control = hmap.control || {};
/**
 * 放大镜控件。用来跨级别显示鼠标选取的位置。
 * @type {hmap.control.Magnifier}
 * @extends hmap.control.Control
 * @example
 * const tmsLayer = new hmap.layer.TMS("TMS", tmsURL, tmsOptions);
 * const magnifier = new hmap.control.Magnifier([tmsLayer]);
 * map.addControl(magnifier);
 */
hmap.control.Magnifier = class extends hmap.control.Control {
	/**
	 * 创建放大镜控件
	 * @param layer {Array<hmap.layer.Layer>} 在放大镜中展示的图层。
	 * @param options {Map} 可选项
	 * @param options.zoomOffset {Number} 放大镜放大的级别，即放大镜展示的级别与原地图显示级别的差值.默认值为2
	 * @param options.style {String} 放大镜CSS样式,默认半径100px，边框为2px的实心圆
	 */
	constructor(layer = [], options = {}) {
		super();
		this.layer = layer; //要展示的内容
		this.container = null; //放大镜的父div
		this._mainMap = null; //鹰眼放在哪个地图上
		this.magnifierMap = null; //鹰眼中展示的地图
		//默认options
		this.options = {
			//显示级别偏移量
			zoomOffset: 2,
			//放大镜的样式
			style: "position:relative;width:200px;height:200px;zIndex:999;overflow:hidden;border-radius:50%;border:2px solid red"
		};
		this._extendOptions(options);
		this.CLASS_NAME = "hmap.control.Magnifier";
		this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
	}

	/**
	 * 设置当前控件的地图对象，调用该方法会自动激活放大镜控件
	 * @param map {hmap.Map} 控件的地图对象
	 */
	setMap(map) {
		if (!(map instanceof hmap.Map)) {
			return;
		}
		this._mainMap = map; //要绑定的map
		if (!this.container) {
			this.container = this._createPane("DIV", "hmap-control-magnifier");
			this.setStyle(this.options.style);
		}
		this.activate();
	}

	/**
	 * 激活该控件，显示放大镜且注册放大镜的事件监听。
	 *
	 */
	activate() {
		this._mainMap.event.register(EventType.MAPMOUSEEVENT_MOUSEOVER, this._onMouseOverEvent.bind(this));
	}

	/**
	 * 禁用该控件，隐藏放大镜且注销放大镜所有的事件监听。
	 *
	 */
	deactivate() {
		const _this = this;
		//取消注册事件
		_this._mainMap.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEOVER, _this._onMouseOverEvent.bind(this));
		_this._mainMap.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE, _this._updataMagnifierMap.bind(this));
		//隐藏放大镜
		_this._hiddenMaginer();
	}

	/**
	 * @param {Object} options 扩展options，将用户传来的options替换控件默认的设置。
	 * @private
	 */
	_extendOptions(options) {
		for (let i in options) {
			if (this.options.hasOwnProperty(i)) {
				this.options[i] = options[i];
			}
		}
	}

	/**
	 * 鼠标经过时的回调函数
	 * @private
	 */
	_onMouseOverEvent() {
		const _this=this;
		if (!this.magnifierMap) {
			this.magnifierMap = this._addMagnifierMap(this._mainMap);
			this._showMaginer();
			this._mainMap.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE, _this._updataMagnifierMap.bind(this));
		}
		this._showMaginer();
	}

	/**
	 * 显示放大镜
	 * @private
	 */
	_showMaginer() {
		this.magnifierMap.container.style.display = "block";
		this.container.style.display = "block";
		//待删除
		//this.setStyle(this.options.style);
	}

	/**
	 * 隐藏放大镜
	 * @private
	 */
	_hiddenMaginer() {
		this.magnifierMap.container.style.display = "none";
		this.container.style.display = "none";
		//待删除
		//this.container.style.display="inline-block";
		//this.container.style.width = "0px";
		//this.container.style.height = "0px";
	}

	/**
	 * 设置放大镜面板样式
	 * @param style {String} 要设置的css样式字符串
	 */
	setStyle(style) {
		if (Object.prototype.toString.call(style) === "[object String]") {
			this.options.style = style;
			this.container.style.cssText = style;
		} else {
			//考虑是否兼容map对象形式的css
			/*
			this.container.style.position="relative";
			this.container.style.zIndex=999;
			this.container.style.width="200px";
			this.container.style.height="200px";
			this.container.style.backgroundColor="red";
			//this.container.style.border="2px solid #000";
			this.container.style.borderRadius="50%";
			*/
		}
	}

	/**
	 * 创建放大镜面板
	 * @param tagName {String} dom元素的类型
	 * @param className {String} dom元素的元素名称
	 * @private
	 */
	_createPane(tagName, className) {
		const container = document.createElement(tagName);
		container.className = className;
		container.id = hmap.util.Aid.createUnique(container.className);
		return container;
	}

	/**
	 * 将放大镜添加到map上
	 * @param map {hmap.Map} 地图对象
	 * @private
	 */
	_addMagnifierMap(map) {
		const option = {
			zoom: map.getZoom() + this.options.zoomOffset, //注意超过最小值的判断
			resolutions: map.getResolutions(),
			center: map.getCenter(),
			crs: map.getCrs(),
		};
		//添加到主map中
		map.container.appendChild(this.container);
		let magnifierMap = new hmap.Map(this.container.id, option);
		//magnifierMap.container.style.borderRadius="50%";
		//magnifierMap.container.style.overflow="hidden";
		//magnifierMap.container.style.border="2px solid red";
		magnifierMap.addLayers(this.layer);
		//magnifierMap.addControl(new hmap.control.Pan());
		//magnifierMap.addControl(new hmap.control.Zoom());
		return magnifierMap;
	}

	/**
	 * 放大镜的位置跟着鼠标移动
	 * @param event {Event} 监听的鼠标事件
	 * @private
	 */
	_updataMagnifierMap(event) {
		const x = event.clientX,
			y = event.clientY;
		const offsetX = parseInt(this.container.style.width) / 2;
		const offsetY = parseInt(this.container.style.height) / 2;
		const cursorX = x - offsetX;
		const cursorY = y - offsetY;
		const pixel = new hmap.basetype.Pixel(x, y);
		const coord = this._mainMap.getCoordinateFromPixel(pixel);
		this.magnifierMap.setCenter(coord, this._getMagnifierMapZoom());
		this.container.style.left = cursorX + "px";
		this.container.style.top = cursorY + "px";
	}

	/**
	 * 获取当前放大镜的级别
	 * @private
	 * @returns {Number}
	 */
	_getMagnifierMapZoom() {
		const maxZoom = this._mainMap.getMaxZoom();
		const curZoom = this._getMainMapZoom() + this.options.zoomOffset;
		return curZoom < maxZoom ? curZoom : maxZoom;
	}

	/**
	 * 获取mainMap的中心点
	 * @private
	 * @returns {hmap.basetype.Coordinate}
	 */
	_getMainMapCenter() {
		return this._mainMap.getCenter();
	}

	/**
	 * 获取mainMap的级别
	 * @private
	 * @returns {Number}
	 */
	_getMainMapZoom() {
		return this._mainMap.getZoom();
	}

	/**
	 * 返回控件的类型
	 * @returns {string} 控件类型的名称。
	 */
	getControlType() {
		return hmap.control.controlType.Magnifier;
	}

	/**
	 * 销毁控件，释放占用的内存。
	 * @example
	 * magnifier.destroy();
	 */
	destroy() {
		this.deactivate();
		this.magnifierMap.destroy();
		this._mainMap.container.removeChild(this.container);
		let entries = Object.entries(this);
		for (let i = 0; i < entries.length; i++) {
			if (entries[i][0] !== '_mainMap') {
				this[entries[i][0]] = null;
			}
		}
		delete this;
	}
};;"use strict";
hmap.control=hmap.control || {};

/**
 * 标绘控件。
 * @type {hmap.control.Plot}
 * @extends hmap.control.Control
 * @example
 * let plotControl = new hmap.control.Plot();
 * //事件回调枚举：
 * //plotEventType.NEWPOINT     绘制图形时，新增一个节点时触发
 * //plotEventType.CHANGEPOINT  绘制图形时，控制点随鼠标变化时触发
 * //plotEventType.PLOTFINISHED 单个图形绘制完成时触发
 * //plotEventType.EDITPOINT    编辑图形时，编辑单个节点时触发
 * //plotEventType.EDITMOVEEND  编辑图形时，移动一个要素或节点结束时触发
 * //plotEventType.EDITFINISHED 编辑图形时，完成单个编辑时触发
 * plotControl.on(plotControl.plotEventType.NEWPOINT,function(data){
 *      console.log(data);
 * })
 */
hmap.control.Plot=class extends hmap.control.Control {

    /**
     * 构造函数
     * @param {Object} options 必须项
     * @param {hmap.layer.VectorLayer} options.layer 保存标绘要素的图层，建议单独为标绘创建一个图层，该图层单独使用一个画板。
     * @param {hmap.style.Style} options.editPointStyle 标绘点以及标绘修改时的节点的样式，有默认样式
     * @param {hmap.style.Style} options.midPointStyle 标绘修改时节点间中间点的样式，有默认样式
     */
    constructor(options){
        super();
        this._map=null;
        //标绘相关
        this._isPlotting = false;                 //是否正在标绘，状态
        this._type = undefined;                   //标绘类型
        this._movingPoint = undefined;           //跟随鼠标移动的绘制辅助点要素
        this._plottingPoints = [];                //正在绘制的要素的坐标点
        this._plottingFeature = undefined;      //正在绘制的要素，坐标符合条件时创建，完成绘制时置undefined
        this._plotLayer = options.layer;          //保存绘制要素的图层
        //编辑相关
        this._isEditing = false;                  //是否正在编辑
        this._ctrlFeatures = [];                   //控制点的要素
        this._midPointFeatures = [];              //修改时，节点间的中间点要素
        this.selectedCtrlPoint = null;           //选中的控制点要素
        this.selectedMidPoint = null;            //选中的中间点
        this._mouseNotUp = false;                    //是否点击未抬起
        this._isClick = false;                       //是否为点击，鼠标点击未弹起或移动 为点击

        this._style = (this._plotLayer && this._plotLayer.getStyle()) ? this._plotLayer.getStyle():hmap.style.Style.getDefault();  //绘制的样式，区别于图层样式
        this._editPointStyle = options.editPointStyle ? options.editPointStyle : undefined;
        this._midPointStyle = options.midPointStyle ? options.midPointStyle : undefined;
        this._callbacks = {};       //回调函数object
        this._status=false;                        //激活状态，默认不激活
        this.CLASS_NAME = "hmap.control.Plot";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._exclusive=false;
        this._init();
    }

    /**
     *  初始化标绘图层和编辑的节点样式
     *  @private
     */
    _init(){
        if(!(this._plotLayer instanceof hmap.layer.VectorLayer)){
            throw TypeError("parameter layer must be instanceof hmap.layer.VectorLayer!")
        }
        if(!(this._editPointStyle instanceof hmap.style.Style)){    //编辑的节点样式
            this._editPointStyle = new hmap.style.Style({
                markerSymbols:[new hmap.style.Circle({
                    "radius":8,
                    "fillColor":new hmap.style.Color(200,100,100,0.1),
                    "outlineColor":new hmap.style.Color(100,200,100,0.5),
                    "outlineWidth":3
                })]
            })
        }
        if(!(this._midPointStyle instanceof hmap.style.Style)){     //中间点的样式
            this._midPointStyle = new hmap.style.Style({
                markerSymbols:[new hmap.style.Circle({
                    "radius":5,
                    "fillColor":new hmap.style.Color(200,100,100,0.1),
                    "outlineColor":new hmap.style.Color(100,200,100,0.3),
                    "outlineWidth":1
                })]
            })
        }
        this.plotEventType = {      //plot事件
            NEWPOINT:"newpoint",                    //绘制图形时，新增一个节点
            CHANGEPOINT:"changepoint",              //绘制图形时，控制点随鼠标变化
            PLOTFINISHED:"plotfinished",            //单个图形绘制完成
            EDITPOINT:"editpoint",                  //编辑图形时，编辑单个节点时触发
            EDITMOVEEND:"editmoveend",              //编辑图形时，移动一个要素或节点结束时触发
            EDITFINISHED:"editfinished"             //编辑图形时，完成单个编辑时触发
        };
        this.freehandType = {              //自由绘制的几何类型 直接用 freehandType[type] 判断
            "FreeLine":"FreeLine",
            "FreePolygon":"FreePolygon"
        };

        this.dbclickEndType = {            //双击结束的几何类型 直接用 dbclickEndType[type] 判断
            "Line":"Line",
            "Polygon":"Polygon",
            "FreeLine":"FreeLine",
            "FreePolygon":"FreePolygon",
            "MultiPoint":"MultiPoint",
            "BezierCurveN":"BezierCurveN",
            "CardinalCurve":"CardinalCurve",
            "CloseCurve":"CloseCurve",
            "StraightArrow":"StraightArrow",
            "DiagonalArrow":"DiagonalArrow",
            "DoveTailStraightArrow":"DoveTailStraightArrow",
            "DoveTailDiagonalArrow":"DoveTailDiagonalArrow",
            "PolylineArrow":"PolylineArrow",
            "ParallelSearch":"ParallelSearch",
            "BezierCurveArrow":"BezierCurveArrow",
            "CardinalCurveArrow":"CardinalCurveArrow"
        };
        //要素编辑类型。FEATURE：只编辑要素；POINT：只编辑节点；
        this.editType = {FEATURE:"featureOnly",POINT:"pointOnly"};
        //修改时，节点类型
        this.sketchPointType={
            CTRLPOINT:"ctrlPoint",      //控制点
            MIDPOINT:"midPoint"         //控制点的中间节点
        }
    }

    /**
     * 将控件与地图绑定，并自动激活控件。
     * @param {hmap.Map} map
     */
    setMap(map){
        super.setMap(map);
        this.activate();
    }

    /**
     * 激活标绘控件，只有将控件添加到地图上时才起作用。
     * @example
     * plotControl.activate();
     */
    activate(){
        super.activate();
        //map存在，且状态为未激活时才添加监听
        if(this._map && !this._status){
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEDOWN,this._mouseDownHandler.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEUP,this._mouseUpHandler.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_CLICK,this._mouseClickHandler.bind(this));
            this._map.event.register(EventType.MAPMOUSEEVENT_DOUBLECLICK,this._dbClickHandler.bind(this));        //MAPMOUSEEVENT_MOUSEUP
            this._map.event.register(EventType.MAPMOUSEEVENT_MOUSEMOVE,this._mouseMoveHandler.bind(this));
            this._status=true;
        }
    }

    /**
     * 禁用控件，取消标绘。
     * @example
     * plotControl.deactivate();
     */
    deactivate(){
        this.setPlotType(undefined);     //先停止
        //只有状态为激活状态时，才执行取消激活
        if(this._status){
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEDOWN,this._mouseDownHandler.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEUP,this._mouseUpHandler.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_CLICK,this._mouseClickHandler.bind(this));
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_DOUBLECLICK,this._dbClickHandler.bind(this));        //MAPMOUSEEVENT_MOUSEUP
            this._map.event.unRegister(EventType.MAPMOUSEEVENT_MOUSEMOVE,this._mouseMoveHandler.bind(this));
            this._status = false;
        }
    }

    /**
     *  绑定事件,同一个绘制对象的同种类型事件，多次绑定前面的将被覆盖。
     *  @param {String} type 触发类型 plotEventType的项
     *  @param {function} callback 回调函数
     */
    on(type,callback){
        this._callbacks[type] = callback;
    }

    /**
     *  取消事件绑定
     *  @param {String} type 触发类型 plotEventType的项
     */
    un(type){
        this._callbacks[type] = undefined;
    }

    /**
     *  流程触发事件
     *  @param {String} type 触发类型 plotEventType的项
     *  @param {Object} data 回调的数据
     *  @private
     */
    _fire(type,data){
        if(this._callbacks[type]){
            this._callbacks[type](data);
        }
    }

    /**
     *  启用标绘的编辑功能
     *  @param {String} editType 编辑类型，默认值为undefined，要素和节点都可以编辑
     *  @example
     * //事件回调枚举：
     * //editType.FEATURE   只编辑要素（只拖动要素）
     * //editType.POINT     只编辑节点（只拖动节点）
     * plotControl.enableEdit(plotControl.editType.FEATURE)
     */
    enableEdit(editType){
        if(this._isPlotting){       //正在绘制
            this._breakPlot();         //中断标绘
        }
        this._isEditing = true;
        this.plotEditType = editType;
    }

    /**
     *  禁用标绘的编辑功能
     */
    removeEdit(){
        if(this._isEditing){       //正在编辑
            this. _clearFeatureEdit();
            this._plotLayer.redraw();
            this._isEditing = false;
        }
        if(this._type){
            this._type = undefined;
        }
    }

    /**
     *  获取标绘控件的图层容器
     *  @returns {hmap.layer.VectorLayer} 矢量图层
     */
    getLayer(){
        return this._plotLayer;
    }

    /**
     *  设置绘制样式
     *  @param {hmap.style.Style} style 绘制样式
     */
    setNextFeatureStyle(style){
        if(!(style instanceof hmap.style.Style)){
            throw TypeError("param must be instanceof hmap.style.Style!");
        }
        this._style = style;
    }

    /**
     *  设置标绘类型，开始标绘
     *  @param {String} plotType 设置绘制类型，参见PlotTypes枚举，如果设置undefined则停止绘制
     */
    setPlotType(plotType){
        if(this._isPlotting || this._isEditing){       //正在绘制 或者编辑
            if(this._isPlotting){
                this._breakPlot();          //中断标绘
            }else{                              //编辑状态
                this. _clearFeatureEdit();
                this._isEditing = undefined;
            }
            this._plotLayer.redraw();
        }
        this._type = plotType;
        this._isPlotting = true;

        if(this._type && !this._status){              //如果未激活状态，重新激活
            this.activate();
        }
    }

    /**
     *  完成一次标绘
     *  @private
     */
    _finishPlot(){
        const data = {          //绘制完成，回调数据
            feature:this._plottingFeature,
            points:this._plottingPoints,
            type:this._type
        };
        if(this._plottingFeature){      //正在绘制未结束的图层要素
            this._plottingFeature.setStyle(this._style);
            this._plotLayer.updateFeatures([this._plottingFeature]);
            this._plottingFeature = undefined;
        }
        this._plottingPoints = [];      //清空正在绘制的坐标点集合
        this._fire(this.plotEventType.PLOTFINISHED,data);     //最后回调，防止回调中的更改被覆盖
    }

    /**
     *  中断标绘
     *  @private
     */
    _breakPlot(){
        if(this._plottingFeature){      //正在绘制未结束的图层要素
            this._plotLayer.removeFeatures([this._plottingFeature]);
            this._plottingFeature = undefined;
        }
        if(this._movingPoint){              //跟随鼠标移动
            this._plotLayer.removeFeatures([this._movingPoint]);
            this._movingPoint = undefined;
        }
        this._plottingPoints = [];      //清空正在绘制的坐标点集合
        this._type = undefined;
        this._isPlotting = false;
    }

    /**
     *  鼠标摁下事件触发的处理函数
     *  @private
     *  @param {hmap.event.Event} event 鼠标按下事件回调
     */
    _mouseDownHandler(event){
        if(!event.lonlat) return;
        this._mouseNotUp = true;
        const _x = event.lonlat.getOrdinate("X"), _y = event.lonlat.getOrdinate("Y"), _z = event.lonlat.getOrdinate("Z");
        if(this._isPlotting){           //标绘状态，在拖动的基础上新增一个节点
            if(!this._type) return;
            if(this._isClick){
                return;
            }else{
                this._plottingPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(_x,_y,_z)));
            }
            const data = {          //绘制完成，回调数据
                feature:this._plottingFeature,
                points:this._plottingPoints,
                type:this._type
            };
            this._fire(this.plotEventType.NEWPOINT,data);
            let finished = this._generateFeature([_x,_y,_z]);
            if(finished){
                this._finishPlot();
            }
            this._plotLayer.redraw();      //刷新
        }
        if(this._isEditing){            //编辑状态
            let features = this._map.detectFeaturesAtPixel(event.mapPixel,[this._plotLayer.name],3);
            if(features && features.length !== 0){
                let selectedFeature,selectedCtrlPoint,selectedMidPoint,selectedF;
                for(let i=0;i<features.length;i++){
                    if(features[i].getAttributes().type === this.sketchPointType.CTRLPOINT){
                        selectedCtrlPoint = features[i];
                        break;
                    }
                }
                if(!selectedCtrlPoint){
                    for(let i=0;i<features.length;i++){
                        if(features[i].getAttributes().type === this.sketchPointType.MIDPOINT){
                            selectedMidPoint = features[i];
                            break;
                        }
                    }
                }
                for(let i=0;i<features.length;i++){
                    let type = features[i].getAttributes().type;
                    if(type != this.sketchPointType.MIDPOINT && type != this.sketchPointType.CTRLPOINT){
                        selectedF = features[i];
                        break;
                    }
                }

                selectedFeature = selectedCtrlPoint ? selectedCtrlPoint:(selectedMidPoint?selectedMidPoint:selectedF);            //选中的要素
                let cPoints;
                if(this._isBuildByCtrlPoint(selectedFeature)){                  //是否由控制点生成的图形
                    cPoints = selectedFeature.getGeometry().getCtrlPoints();
                }
                if(cPoints){             //拓展的图形要素
                    this._addFeatureEdit(selectedFeature,cPoints);
                    this._map.container.style.cursor = "move";
                }else{
                    if(!selectedFeature.getAttributes().type){
                        let pointObj = this._getFeaturePoints(selectedFeature);
                        this._addFeatureEdit(selectedFeature,pointObj.points,pointObj.midPointsObj);           //添加要素为编辑状态
                    }else{
                        if(!this._plottingFeature){
                            let pointObj = this._getFeaturePoints(selectedF);
                            this._addFeatureEdit(selectedF,pointObj.points,pointObj.midPointsObj);           //添加要素为编辑状态
                        }
                        if(selectedFeature.getAttributes().type === this.sketchPointType.CTRLPOINT){            //选中了控制点
                            this._map.container.style.cursor = "pointer";
                            this.selectedCtrlPoint = selectedFeature;
                        }else if(selectedFeature.getAttributes().type === this.sketchPointType.MIDPOINT){       //选中了中间点
                            this.selectedMidPoint = selectedFeature;
                        }
                    }
                }
                this.pan = this._map.getControlByType(hmap.control.controlType.Pan);    //获取鼠标平移状态
                if(this.pan && this.pan.getStatus()){
                    this.pan.deactivate();
                }
            }else{      //没有选中要素
                this._clearFeatureEdit();
            }
            this._plotLayer.redraw();          //刷新
        }
        this._isClick = true;
    }

    /**
     *  获取要素的点几何数组
     *  @private
     *  @param {hmap.feature.Vector} feature 要素
     *  @returns {Object}
     */
    _getFeaturePoints(feature){
        let coordSeq;const points = [];const midPointsObj = [];

        if(typeof(feature.getGeometry().getCoordSeqs) === 'function'){
            coordSeq = feature.getGeometry().getCoordSeqs()[0]
        }else if(typeof(feature.getGeometry().getCoordSeq) === 'function'){
            coordSeq = feature.getGeometry().getCoordSeq();
        }
        let coordsArray;
        if(coordSeq){
            coordsArray = coordSeq.extractCoords();
            for(let i=0;i<coordsArray.length;i++){      //点数组
                points.push(new hmap.geom.Point(coordsArray[i]));
                let avgX,avgY,avgZ;
                if(i !== coordsArray.length - 1){            //中间点
                    avgX = 0.5*(coordsArray[i].getOrdinate("X")+coordsArray[i+1].getOrdinate("X"));
                    avgY = 0.5*(coordsArray[i].getOrdinate("Y")+coordsArray[i+1].getOrdinate("Y"));
                    avgZ = 0.5*(coordsArray[i].getOrdinate("Z")+coordsArray[i+1].getOrdinate("Z"));
                    midPointsObj.push({ctrlPointIndex:i,point:new hmap.geom.Point(new hmap.basetype.Coordinate(avgX,avgY,avgZ))});
                }
            }
        }else{
            if(feature.getGeometry() instanceof hmap.geom.Point){       //点情况特殊处理
                coordsArray = [feature.getGeometry().getCoordinate()];
            }else if(feature.getGeometry() instanceof hmap.geom.MultiPoint){       //点情况特殊处理
                coordsArray = feature.getGeometry().getCoordinates();
            }
            for(let i=0;i<coordsArray.length;i++){
                points.push(new hmap.geom.Point(coordsArray[i]));
            }
        }
        const obj = {};
        if(points.length !== 0){
            obj.points = points;
        }
        if(midPointsObj.length !== 0){
            obj.midPointsObj = midPointsObj;
        }
        return obj;
    }

    /**
     *  是否由控制点构造而成的特殊图形
     *  @private
     *  @param {hmap.feature.Vector} feature 要素
     */
    _isBuildByCtrlPoint(feature){
        return typeof(feature.getGeometry().getCtrlPoints)==='function';
    }

    /**
     *  编辑时,显示控制点
     *  @private
     */
    _addCtrlPoints(){
        if(this._plottingPoints.length !== 0){        //显示正在编辑的要素的坐标点
            const ctrlFeatures = [];
            for(let point of this._plottingPoints){
                ctrlFeatures.push(
                    new hmap.feature.Vector(    //控制点
                        point,{type:this.sketchPointType.CTRLPOINT},
                        this._editPointStyle
                    )
                )
            }
            if(this._ctrlFeatures){
                this._plotLayer.removeFeatures(this._ctrlFeatures);
            }
            this._ctrlFeatures = ctrlFeatures;
            this._plotLayer.addFeatures(this._ctrlFeatures);      //控制点以点要素的形式添加
        }
    }

    /**
     *  添加要素节点间的中间点
     *  @private
     */
    _addMidPoints(midPointsObj){
        if(midPointsObj && midPointsObj.length !== 0){
            const midPointFeatures = [];
            for(let point of midPointsObj){
                midPointFeatures.push(
                    new hmap.feature.Vector(    //节点的中间点
                        point.point,{type:this.sketchPointType.MIDPOINT,pointIndex:point.ctrlPointIndex,isChange:false},
                        this._midPointStyle
                    )
                )
            }
            if(this._midPointFeatures){
                this._plotLayer.removeFeatures(this._midPointFeatures);
            }
            this._midPointFeatures = midPointFeatures;
            this._plotLayer.addFeatures(this._midPointFeatures);      //控制点的中间点，以点要素的形式添加
        }
    }

    /**
     *  移除控制点
     *  @private
     */
    _removeCtrlPoints(){
        if(this._ctrlFeatures){
            this._plotLayer.removeFeatures(this._ctrlFeatures);
            this._ctrlFeatures = undefined;
        }
    }

    /**
     *  移除中间点
     *  @private
     */
    _removeMidPoints(){
        if(this._midPointFeatures){
            this._plotLayer.removeFeatures(this._midPointFeatures);
            this._midPointFeatures = undefined;
        }
    }

    /**
     *  将要素设置为编辑状态
     *  @private
     *  @param {hmap.feature.Vector} feature 要素
     *  @param {Array} points 控制点数组
     *  @param {Array} midPointsObj 中间点对象数组，包括中间点和索引
     */
    _addFeatureEdit(feature,points,midPointsObj){
        this._plottingPoints = points;
        this._plottingFeature = feature;
        this._type = this._plottingFeature.getGeometry().getType();
        if(this.plotEditType != this.editType.FEATURE){        //只编辑节点
            this._addCtrlPoints();
            if(midPointsObj){
                this._addMidPoints(midPointsObj);
            }else{
                this._removeMidPoints();
            }
        }
        this.selectedCtrlPoint = undefined;     //控制点
        this.selectedMidPoint = undefined;      //中间点
    }

    /**
     *  清除要素的编辑
     *  @private
     */
    _clearFeatureEdit(){
        if(this._plottingFeature){
            const data = {          //绘制完成，回调数据
                feature:this._plottingFeature,
                points:this._plottingPoints,
                type:this._type
            };
            this._fire(this.plotEventType.EDITFINISHED,data);
        }
        this._plottingPoints = [];
        this._plottingFeature = undefined;
        this._type = undefined;
        this._removeCtrlPoints();
        this._removeMidPoints();

        this.selectedCtrlPoint = undefined;     //控制点
        this.selectedMidPoint = undefined;      //中间点
    }

    /**
     *  鼠标单击事件处理
     *  @private
     *  @param {hmap.event} event 点击事件回调
     */
    _mouseClickHandler(event){
        if(!event.lonlat) return;
        /*const _x = event.lonlat.getOrdinate("X");
        const _y = event.lonlat.getOrdinate("Y");
        const _z = event.lonlat.getOrdinate("Z");
        if(this._isPlotting){           //标绘状态
            if(!this._type) return;
            this._plottingPoints.push(new hmap.geom.Point(new hmap.basetype.Coordinate(_x,_y,_z)));
            this._generateFeature([_x,_y,_z]);
            const data = {          //绘制完成，回调数据
                feature:this._plottingFeature,
                points:this._plottingPoints,
                type:this._type
            }
            this._fire(plotEventType.ADDPOINT,data);
        }*/
    }

    /**
     *   鼠标移动事件处理
     *   @param {hmap.event} event 鼠标平移事件回调
     *   @private
     */
    _mouseMoveHandler(event){
        if(!event.lonlat) return;
        this._isClick = false;
        const _x = event.lonlat.getOrdinate("X"), _y = event.lonlat.getOrdinate("Y"), _z = event.lonlat.getOrdinate("Z");
        if(this._isPlotting){
            if(!this._type) return;
            const pPoint  = new hmap.geom.Point(new hmap.basetype.Coordinate(_x,_y,_z));
            if(this._plottingPoints.length != 0){
                const lastPoint = this._plottingPoints[this._plottingPoints.length - 1];
                if(!pPoint.equals(lastPoint)){
                    if(this._plottingPoints.length == 1){
                        this._plottingPoints.push(pPoint);
                    }else{
                        if(this.freehandType[this._type]){      //自由绘制
                            this._plottingPoints.push(pPoint);
                        }else{
                            this._plottingPoints.pop();
                            this._plottingPoints.push(pPoint);
                        }
                    }
                    this._generateFeature([_x,_y,_z]);
                    if(this._isPlotting && this._plottingPoints.length != 0){       //正在标绘 新增点
                        const data = {          //鼠标平移，数据改变，回调
                            feature:this._plottingFeature,
                            points:this._plottingPoints,
                            type:this._type
                        };
                        this._fire(this.plotEventType.CHANGEPOINT,data);
                    }
                }
            }else{
                this._generateFeature([_x,_y,_z]);
            }
            this._plotLayer.redraw();
        }
        else if(this._isEditing){       //编辑状态
            let features = this._map.detectFeaturesAtPixel(event.mapPixel,[this._plotLayer.name],3);
            if(features && features.length !== 0){              //图层中要素无序
                let moverFeature,moverCtrlPoint,moverMidPoint;
                for(let i=0;i<features.length;i++){
                    if(features[i].getAttributes().type === this.sketchPointType.CTRLPOINT){
                        moverCtrlPoint = features[i];
                        break;
                    }
                }
                if(!moverCtrlPoint){
                    for(let i=0;i<features.length;i++){
                        if(features[i].getAttributes().type === this.sketchPointType.MIDPOINT){
                            moverMidPoint = features[i];
                            break;
                        }
                    }
                }
                moverFeature = moverCtrlPoint ? moverCtrlPoint:(moverMidPoint?moverMidPoint:features[0]);
                let cPoints;
                if(typeof(moverFeature.getGeometry().getCtrlPoints)==='function'){
                    cPoints = moverFeature.getGeometry().getCtrlPoints();
                }
                if(cPoints){                                        //拓展的图形要素
                    if(this._plottingFeature){      //选中之后平移到要素
                        if((!moverCtrlPoint && !moverMidPoint) && this.plotEditType == this.editType.POINT){
                        }else{
                            this._map.container.style.cursor = "move";
                        }
                    }else{
                        this._map.container.style.cursor = "pointer";
                    }
                }
                else{
                    if(moverFeature.getAttributes().type === this.sketchPointType.CTRLPOINT || moverFeature.getAttributes().type === this.sketchPointType.MIDPOINT){
                        this._map.container.style.cursor = "pointer";
                    }else{
                        if(this._plottingFeature){
                            if((!moverCtrlPoint && !moverMidPoint) && this.plotEditType == this.editType.POINT){
                            }else{
                                this._map.container.style.cursor = "move";
                            }
                        }else{
                            this._map.container.style.cursor = "pointer";
                        }
                    }
                }
            }else{
                this._map.container.style.cursor = "default";
            }
            const pPoint  = new hmap.geom.Point(new hmap.basetype.Coordinate(_x,_y,_z));
            if(this._mouseNotUp && this._plottingFeature){                  //点击拖动未抬起
                if(this.selectedCtrlPoint){         //拖动控制点
                    this._map.container.style.cursor = "pointer";
                    this.selectedCtrlPoint.setGeometry(pPoint);
                    if(this._midPointFeatures){
                        this._plotLayer.removeFeatures(this._midPointFeatures);
                    }
                    this._plotLayer.updateFeatures(this._ctrlFeatures);

                    const points = [];
                    for(let i=0;i<this._ctrlFeatures.length;i++){
                        const feature = this._ctrlFeatures[i];
                        points.push(feature.getGeometry());
                    }
                    this._plottingPoints = points;

                    this._generateFeature();
                }else if(this.selectedMidPoint){        //拖动中间点，新增控制点
                    this._map.container.style.cursor = "pointer";

                    this.selectedMidPoint.setGeometry(pPoint);
                    //this._plotLayer.updateFeatures(this._midPointFeatures);

                    const index = this.selectedMidPoint.getAttributes().pointIndex;
                    let isChange = this.selectedMidPoint.getAttributes().isChange;      //转变为控制点
                    if(!isChange){
                        for(let i=0;i<this._midPointFeatures;i++){
                            let point = this._midPointFeatures[i];
                            if(point.getId()===this.selectedMidPoint.getId()){
                                this._midPointFeatures.splice(i,0);     //移除
                            }
                        }
                        this._plotLayer.removeFeatures(this._midPointFeatures);

                        const convertFeatures = [];
                        for(let i=0;i<this._ctrlFeatures.length;i++){
                            convertFeatures.push(this._ctrlFeatures[i]);
                            if(i===index){
                                this.selectedMidPoint.setStyle(this._editPointStyle);       //设置节点的样式
                                convertFeatures.push(this.selectedMidPoint);
                            }
                        }
                        this._ctrlFeatures = convertFeatures;
                        this.selectedMidPoint.getAttributes().isChange = true;
                    }
                    this._plotLayer.updateFeatures(this._ctrlFeatures);

                    const points = [];
                    for(let i=0;i<this._ctrlFeatures.length;i++){
                        const feature = this._ctrlFeatures[i];
                        points.push(feature.getGeometry());
                    }
                    this._plottingPoints = points;
                    this._generateFeature();
                }else{                                  //选中了要素，拖动
                    if(this.plotEditType != this.editType.POINT){
                        this._map.container.style.cursor = "move";
                        const movement = {x:event.movementX,y:event.movementY};
                        let coordsOffset = this._getMovementCoords(event.lonlat,event.mapPixel,movement);       //获取坐标偏移
                        this._calculateMovedPoints(coordsOffset);
                        this._generateFeature();
                        this._updateCtrlPoints(coordsOffset);
                    }
                }
                this._plotLayer.redraw();      //刷新地图
                if(this._plottingFeature){
                    const data = {          //鼠标平移，数据改变，回调
                        feature:this._plottingFeature,
                        points:this._plottingPoints,
                        type:this._type
                    };
                    this._fire(this.plotEventType.EDITPOINT,data);
                }
            }
        }
    }

    /**
     *   设置指定要素为编辑状态
     *   @param {hmap.feature.Vector} feature 矢量要素
     *   @example
     *   polotControl.setFeatureEdit(feature);
     **/
    setFeatureEdit(feature){
        if(!(feature instanceof hmap.feature.Vector)){
            throw TypeError("parameter must be instanceof hmap.feature.Vector!")
        }
        if(this._isPlotting){       //正在绘制
            this._breakPlot();         //中断标绘
        }
        if(this._isEditing){       //正在编辑
            this. _clearFeatureEdit();
            this._isEditing = undefined;
        }
        if(this._isBuildByCtrlPoint(feature)){      //是否由控制点生成的图形
            let ctrlPoints = feature.getGeometry().getCtrlPoints();
            this._addFeatureEdit(feature,ctrlPoints);
        }else{
            let pointObj = this._getFeaturePoints(feature);
            this._addFeatureEdit(feature,pointObj.points,pointObj.midPointsObj);          //添加要素为编辑状态,添加控制节点和中间点
        }
        this._plotLayer.redraw();                  //地图刷新，禁止频繁刷新
        this._isEditing = true;
        if(this.pan && this.pan.getStatus()){
            this.pan.deactivate();
        }
    }

    /**
     *   鼠标双击事件处理
     *   @param {hmap.event.Event} event 鼠标双击事件回调
     *   @private
     */
    _dbClickHandler(event){
        if(!event.lonlat) return;
        const _x = event.lonlat.getOrdinate("X");
        const _y = event.lonlat.getOrdinate("Y");
        const _z = event.lonlat.getOrdinate("Z");
        if(this._isPlotting){
            if(!this._type) return;
            if(this._plottingPoints.length >2){     //双击的时候，多触发了两次单击，单击延迟检测不理想
                this._plottingPoints.pop();
            }
            this._generateFeature([_x,_y,_z]);
            if(this.dbclickEndType[this._type]){    //双击结束
                this._finishPlot();
            }
            this._plotLayer.redraw();      //刷新地图
        }else if(this._isEditing){

        }
    }

    /**
     *   鼠标抬起事件处理
     *   @param {hmap.event.Event} event 鼠标抬起事件回调
     *   @private
     * */
    _mouseUpHandler(event){
        if(!event.lonlat) return;
        if(this._isEditing){            //正在编辑
            if(this._plottingFeature){
                if((this.selectedCtrlPoint || this.selectedMidPoint) && !this._isBuildByCtrlPoint(this._plottingFeature)){      //非由控制点生成的图形
                    let pointObj = this._getFeaturePoints(this._plottingFeature);
                    this._addFeatureEdit(this._plottingFeature,pointObj.points,pointObj.midPointsObj);
                    this._plotLayer.redraw();
                }
                if(!this._isClick){
                    const data = {          //鼠标平移，数据改变，回调
                        feature:this._plottingFeature,
                        points:this._plottingPoints,
                        type:this._type
                    };
                    this._fire(this.plotEventType.EDITMOVEEND,data);
                }
            }
        }
        if(this.pan && !this.pan.getStatus()){
            this.pan.activate();
        }
        this._mouseNotUp = false;
        this._map.container.style.cursor = "default";
    }

    /**
     *  平移时获取坐标平移量
     *  @param {hmap.basetype.Coordinate} mapLonlat 当前坐标
     *  @param {hmap.basetype.Pixel} mapPixel 当前鼠标屏幕位置
     *  @param {Object} movement 鼠标平移量（像素）
     *  @return {Array} 坐标平移量数组
     *  @private
     * */
    _getMovementCoords(mapLonlat,mapPixel,movement){
        const pixel = new hmap.basetype.Pixel(mapPixel.getX()-movement.x,mapPixel.getY()-movement.y);
        const preLonlat = this._map.getCoordinateFromPixel(pixel);
        const coordsOffset = [mapLonlat.getOrdinate("X")-preLonlat.getOrdinate("X"),mapLonlat.getOrdinate("Y")-preLonlat.getOrdinate("Y"),mapLonlat.getOrdinate("Z")-preLonlat.getOrdinate("Z")];
        return coordsOffset;
    }

    /**
     *  计算经过移动的要素各个点的坐标
     *  @param {Array} coordsOffset 鼠标平移的坐标偏移数组
     *  @private
     * */
    _calculateMovedPoints(coordsOffset){
        const _Points = [];         //新
        for(let i=0;i<this._plottingPoints.length;i++){
            const coordinate = this._plottingPoints[i].getCoordinate();
            _Points.push(new hmap.geom.Point(new hmap.basetype.Coordinate(coordinate.getOrdinate("X")+coordsOffset[0],coordinate.getOrdinate("Y")+coordsOffset[1],coordinate.getOrdinate("Z")+coordsOffset[2])));
        }
        this._plottingPoints = _Points;
    }

    /**
     *  更新控制点
     *  @param {Array} coordsOffset 鼠标平移的坐标偏移数组
     *  @private
     * */
    _updateCtrlPoints(coordsOffset){
        if(this._ctrlFeatures && this._ctrlFeatures.length !== 0){     //更新控制点
            for(let i=0;i<this._ctrlFeatures.length;i++){
                const ctrlPoint = this._ctrlFeatures[i];
                const oldCoords = this._ctrlFeatures[i].getGeometry().getCoordinate();
                let newCoords = new hmap.basetype.Coordinate(oldCoords.getOrdinate("X")+coordsOffset[0],oldCoords.getOrdinate("Y")+coordsOffset[1],oldCoords.getOrdinate("Z")+coordsOffset[2]);
                ctrlPoint.setGeometry(new hmap.geom.Point(newCoords));
            }
            this._plotLayer.updateFeatures(this._ctrlFeatures);
        }
        if(this._midPointFeatures && this._midPointFeatures.length !== 0){     //更新控制点的中间点
            for(let i=0;i<this._midPointFeatures.length;i++){
                const midPoint = this._midPointFeatures[i];
                const oldCoords = this._midPointFeatures[i].getGeometry().getCoordinate();
                let newCoords = new hmap.basetype.Coordinate(oldCoords.getOrdinate("X")+coordsOffset[0],oldCoords.getOrdinate("Y")+coordsOffset[1],oldCoords.getOrdinate("Z")+coordsOffset[2]);
                midPoint.setGeometry(new hmap.geom.Point(newCoords));
            }
            this._plotLayer.updateFeatures(this._midPointFeatures);
        }
    }

    /**
     *  根据不同的绘制类型，进入不同的点处理流程
     *  @param {Array} position 用于更新鼠标位置图标
     *  @private
     * */
    _generateFeature(position){
        let finished = false;
        const points = [];
        for(let i=0;i<this._plottingPoints.length;i++){
            let point = this._plottingPoints[i];
            points.push(point);
        }
        if(this._isPlotting){
            if(!this._type) return;
            this._updateMovingPoint(position);
        }else if(this._isEditing){

        }
        if(this._type === hmap.control.PlotTypes.POINT.POINT){  //单点
            finished = this._handlePoint(points);
        }else if(this._type === hmap.control.PlotTypes.POINT.MULTIPOINT){  //多点
            finished = this._handleMultiPoint(points);
        }
        else if(this._type === hmap.control.PlotTypes.POLYLINE.POLYLINE){
            finished = this._handlePolyline(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.ARC){
            finished = this._handleArc(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.FREELINE){
            finished = this._handleFreeLine(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.BEZIER_CURVE2){
            finished = this._handleBezierCurve2(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.BEZIER_CURVE3){
            finished = this._handleBezierCurve3(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.BEZIER_CURVEN){
            finished = this._handleBezierCurveN(points);
        }else if(this._type === hmap.control.PlotTypes.POLYLINE.CARDINAL_CURVE){
            finished = this._handleCardinalCurve(points);
        }
        else if(this._type === hmap.control.PlotTypes.POLYGON.CIRCLE){
            finished = this._handleCircle(points)
        }else if(this._type === hmap.control.PlotTypes.POLYGON.ELLIPSE){
            finished = this._handleEllipse(points)
        }else if(this._type === hmap.control.PlotTypes.POLYGON.SECTOR){
            finished = this._handleSector(points)
        }else if(this._type === hmap.control.PlotTypes.POLYGON.LUNE){
            finished = this._handleLune(points)
        }else if(this._type === hmap.control.PlotTypes.POLYGON.RECTANGLE){
            finished = this._handleRectangle(points);
        }else if(this._type === hmap.control.PlotTypes.POLYGON.POLYGON){
            finished = this._handlePolygon(points);
        }else if(this._type === hmap.control.PlotTypes.POLYGON.FREE_POLYGON){
            finished = this._handleFreePolygon(points);
        }else if(this._type === hmap.control.PlotTypes.POLYGON.GATHERING_PLACE){
            finished = this._handleGatheringPlace(points);
        }else if(this._type === hmap.control.PlotTypes.POLYGON.ROUNDED_RECT){
            finished = this._handleRounedRect(points);
        }else if(this._type === hmap.control.PlotTypes.POLYGON.CLOSE_CURVE){
            finished = this._handleCloseCardinal(points);
        }
        else if(this._type === hmap.geom.GeometryExtType.FLAG.CURVE_FLAG){
            finished = this._handleCurveFlag(points);
        }else if(this._type === hmap.geom.GeometryExtType.FLAG.RECT_FLAG){
            finished = this._handleRectFlag(points);
        }else if(this._type === hmap.geom.GeometryExtType.FLAG.TRIANGLE_FLAG){
            finished = this._handleTriangleFlag(points);
        }
        else if(this._type === hmap.control.PlotTypes.ARROW.STRAIGHT_ARROW){          //StraightArrow
            finished = this._handleStraightArrow(points);
        }else if(this._type === hmap.control.PlotTypes.ARROW.DIAGONAL_ARROW){          //StraightArrow
            finished = this._handleDiagonalArrow(points);
        }else if(this._type === hmap.control.PlotTypes.ARROW.DOUBLE_ARROW){              //StraightArrow
            finished = this._handleDoubleArrow(points);
        }else if(this._type === hmap.control.PlotTypes.ARROW.DOVETAIL_STRAIGHT_ARROW){          //StraightArrow
            finished = this._handleDoveTailStraightArrow(points);
        }else if(this._type === hmap.control.PlotTypes.ARROW.DOVETAIL_DIAGONAL_ARROW){          //StraightArrow
            finished = this._handleDoveTailDiagonalArrow(points);
        }
        else if(this._type === hmap.control.PlotTypes.LARROW.POLYLINE_ARROW){          //StraightArrow
            finished = this._handlePolylineArrow(points);
        }else if(this._type === hmap.control.PlotTypes.LARROW.PARALLEL_SEARCH){          //StraightArrow
            finished = this._handleParallelSearch(points);
        }else if(this._type === hmap.control.PlotTypes.LARROW.SECTOR_SEARCH){          //StraightArrow
            finished = this._handleSectorSearch(points);
        }else if(this._type === hmap.control.PlotTypes.LARROW.BEZIER_CURVE_ARROW){          //StraightArrow
            finished = this._handleBezierCurveArrow(points);
        }else if(this._type == hmap.control.PlotTypes.LARROW.CARDINAL_CURVE_ARROW){
            finished = this._handleCardinalCurveArrow(points);
        }
        return finished;
    }

    /**
     *  更新绘制点的位置
     *  @param {Array} position
     *  @private
     * */
    _updateMovingPoint(position){
        let pointGeom = new hmap.geom.Point(new hmap.basetype.Coordinate(position[0],position[1],position[2]))
        if(!this._movingPoint){
            this._movingPoint = new hmap.feature.Vector(
                pointGeom,{},
                this._editPointStyle
            );
            this._plotLayer.addFeatures([this._movingPoint]);
        }else{
            this._movingPoint.setGeometry(pointGeom);
            this._plotLayer.updateFeatures([this._movingPoint]);
        }
    }

    /**
     *  处理点
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handlePoint(points){
        if(points && points.length === 1){
            let pointGeom = points[0];
            let finished = false
            if(!this._plottingFeature){
                this._plottingFeature = new hmap.feature.Vector(
                    pointGeom,
                    {},
                    this._style
                );
                this._plotLayer.addFeatures([this._plottingFeature]);
                finished = true;
                return finished;
            }else{
                this._plottingFeature.setGeometry(pointGeom);
                this._plotLayer.updateFeatures([this._plottingFeature]);
            }
        }
    }

    /**
     *  处理多点
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleMultiPoint(points){
        if(points && points.length != 0){
            let multiPointGeom = new hmap.geom.MultiPoint(points);
            if(!this._plottingFeature){
                this._plottingFeature = new hmap.feature.Vector(
                    multiPointGeom,
                    {},
                    this._style
                );
                this._plotLayer.addFeatures([this._plottingFeature]);
            }else{
                this._plottingFeature.setGeometry(multiPointGeom);
                this._plotLayer.updateFeatures([this._plottingFeature]);
            }
        }
    }

    /**
     *  处理线
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handlePolyline(points){
        if(points.length < 2){
            return;
        }
        let lineGeom = new hmap.geom.Line(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                lineGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(lineGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  三点圆弧
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleArc(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 3){
            //this._finishPlot();
            let finished = true;
            return finished;
        }
        let arcGeom;
        if(points.length === 2){
            arcGeom = new hmap.geom.Line(points);
        }else{
            arcGeom = new hmap.geomext.Arc(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                arcGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(arcGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  二次贝塞尔
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleBezierCurve2(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 3){
            //this._finishPlot();
            //return;
            let finished = true;
            return finished;
        }
        let bezierGeom;
        if(points.length === 2){
            bezierGeom = new hmap.geom.Line(points);
        }else{
            bezierGeom = new hmap.geomext.BezierCurve2(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                bezierGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(bezierGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  三次贝塞尔
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleBezierCurve3(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 4){
            //this._finishPlot();
            //return;
            let finished = true;
            return finished;
        }
        let bezierGeom;
        if(points.length === 2 || points.length === 3){
            bezierGeom = new hmap.geom.Line(points);
        }else{
            bezierGeom = new hmap.geomext.BezierCurve3(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                bezierGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(bezierGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  N次贝塞尔
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleBezierCurveN(points){
        if(points.length < 2){
            return;
        }
        let bezierGeom = new hmap.geomext.BezierCurveN(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                bezierGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(bezierGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  Cardinal曲线
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleCardinalCurve(points){
        points = this._checkPointsDistinct(points);
        if(points.length < 2){
            return;
        }
        let cardinalGeom;
        if(points.length === 2){
            cardinalGeom = new hmap.geom.Line(points);
        }else{
            cardinalGeom = new hmap.geomext.CardinalCurve(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                cardinalGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(cardinalGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  闭合Cardinal曲线
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleCloseCardinal(points){
        points = this._checkPointsDistinct(points);
        if(points.length < 2){
            return;
        }
        let closeCardinalGeom;
        if(points.length === 2){
            closeCardinalGeom = new hmap.geom.Line(points);
        }else{
            closeCardinalGeom = new hmap.geomext.CloseCurve(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                closeCardinalGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(closeCardinalGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  闭合Cardinal曲线
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleGatheringPlace(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        points = this._checkPointsDistinct(points);
        let gatherPlaceGeom = new hmap.geomext.GatheringPlace(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                gatherPlaceGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(gatherPlaceGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  检查末尾控制点的重复
     *  @private
     * */
    _checkPointsDistinct(pnts){
        const points = pnts;
        for(let i=points.length-1;i>=0;i--){
            if(points[i] && points[i-1] && points[i].equals(points[i-1])){
                points.pop();
            }else{
                break;
            }
        }
        return points;
    }


    /**
     *  处理面
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handlePolygon(points){
        if(points.length < 2){
            return;
        }
        let polygonGeom;
        if(points.length === 2){
            polygonGeom = new hmap.geom.Line(points);
        }else{
            polygonGeom = new hmap.geom.Polygon([new hmap.geom.LinearRing(points)]);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                polygonGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(polygonGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理圆
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleCircle(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            //this._finishPlot();
            //return;
            let finished = true;
            return finished;
        }
        let circleGeom = new hmap.geomext.Circle(points[0],points[1]);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                circleGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plotLayer.removeFeatures([this._plottingFeature]);

            this._plottingFeature = new hmap.feature.Vector(
                circleGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理椭圆
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleEllipse(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let ellipseGeom = new hmap.geomext.Ellipse(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                ellipseGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plotLayer.removeFeatures([this._plottingFeature]);

            this._plottingFeature = new hmap.feature.Vector(
                ellipseGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理扇形
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleSector(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 3){
            let finished = true;
            return finished;
        }
        let sectorGeom;
        if(points.length === 2){
            sectorGeom = new hmap.geom.Line(points);
        }else{
            sectorGeom = new hmap.geomext.Sector(points);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                sectorGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plotLayer.removeFeatures([this._plottingFeature]);

            this._plottingFeature = new hmap.feature.Vector(
                sectorGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理圆弧
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleLune(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 3){
            let finished = true;
            return finished;
        }
        let luneGeom = new hmap.geomext.Lune(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                luneGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plotLayer.removeFeatures([this._plottingFeature]);

            this._plottingFeature = new hmap.feature.Vector(
                luneGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理矩形
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleRectangle(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let rectGeom = new hmap.geomext.Rectangle(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                rectGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(rectGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理圆角矩形
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleRounedRect(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let rectGeom = new hmap.geomext.RoundedRect(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                rectGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(rectGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }


    /**
     *  直角旗标
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleRectFlag(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let rectFlagGeom = new hmap.geomext.RectFlag(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                rectFlagGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(rectFlagGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  三角旗标
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleTriangleFlag(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let rectFlagGeom = new hmap.geomext.TriangleFlag(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                rectFlagGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(rectFlagGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  曲线旗标
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleCurveFlag(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        let curveFlagGeom = new hmap.geomext.CurveFlag(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                curveFlagGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(curveFlagGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理流线
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleFreeLine(points){
        if(points.length < 2){
            return;
        }
        let fLineGeom = new hmap.geom.Line(points);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                fLineGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(fLineGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  处理流面
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleFreePolygon(points){
        if(points.length < 2){
            return;
        }
        let polygonGeom;
        if(points.length === 2){
            polygonGeom = new hmap.geom.Line(points);
        }else{
            polygonGeom = new hmap.geom.Polygon([new hmap.geom.LinearRing(points)]);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                polygonGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(polygonGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  直箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleStraightArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        if(distinctPoints.length < 2){
            return;
        }
        let straightArrowGeom = new hmap.geomext.StraightArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                straightArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(straightArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  直箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleDiagonalArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        if(distinctPoints.length < 2){
            return;
        }
        let straightArrowGeom = new hmap.geomext.DiagonalArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                straightArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(straightArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  燕尾直箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleDoveTailStraightArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }

        if(distinctPoints.length < 2){
            return;
        }
        let dtStraightArrowGeom = new hmap.geomext.DoveTailStraightArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                dtStraightArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(dtStraightArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  燕尾直箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleDoveTailDiagonalArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }

        if(distinctPoints.length < 2){
            return;
        }
        let dtStraightArrowGeom = new hmap.geomext.DoveTailDiagonalArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                dtStraightArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(dtStraightArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  双箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleDoubleArrow(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 4){
            let finished = true;
            return finished;
        }
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        let doubleArrowGeom;
        if(distinctPoints.length === 2){
            doubleArrowGeom = new hmap.geom.Line(distinctPoints)
        }else {
            if(distinctPoints.length === 3){
                const offX = distinctPoints[2].getCoordinate().getOrdinate("X") - distinctPoints[1].getCoordinate().getOrdinate("X");
                const offY = distinctPoints[2].getCoordinate().getOrdinate("Y") - distinctPoints[1].getCoordinate().getOrdinate("Y");
                let pnt3 =  new hmap.geom.Point(new hmap.basetype.Coordinate(distinctPoints[0].getCoordinate().getOrdinate("X")+offX,distinctPoints[0].getCoordinate().getOrdinate("Y")+offY,0))
                distinctPoints.push(pnt3)
            }
            doubleArrowGeom = new hmap.geomext.DoubleArrow(distinctPoints);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                doubleArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(doubleArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  折线箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handlePolylineArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }

        if(distinctPoints.length < 2){
            return;
        }
        let polylineArrowGeom = new hmap.geomext.PolylineArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                polylineArrowGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(polylineArrowGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  平行搜索区
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleParallelSearch(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        if(distinctPoints.length < 2){
            return;
        }
        let pSearchGeom;
        if(distinctPoints.length === 2){
            pSearchGeom = new hmap.geom.Line(distinctPoints);
        }else{
            pSearchGeom = new hmap.geomext.ParallelSearch(distinctPoints);
        }
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                pSearchGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(pSearchGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  扇形搜索区
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleSectorSearch(points){
        if(points.length < 2){
            return;
        }
        if(points.length > 2){
            let finished = true;
            return finished;
        }
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        let sSearchGeom = new hmap.geomext.SectorSearch(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                sSearchGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(sSearchGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  贝塞尔曲线箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     * */
    _handleBezierCurveArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        if(distinctPoints.length < 2){
            return;
        }
        let bcaGeom = new hmap.geomext.BezierCurveArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                bcaGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(bcaGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     *  Cardinal曲线箭头
     *  @param {Array<hmap.geom.Point>} points
     *  @private
     */
    _handleCardinalCurveArrow(points){
        const distinctPoints = [];
        for(let i=0;i<points.length;i++){           //去除重复
            const point = points[i];
            if(i===0){
                distinctPoints.push(point);
            }else{
                if(!point.equals(distinctPoints[distinctPoints.length - 1])){
                    distinctPoints.push(point);
                }
            }
        }
        if(distinctPoints.length < 2){
            return;
        }
        let ccaGeom = new hmap.geomext.CardinalCurveArrow(distinctPoints);
        if(!this._plottingFeature){
            this._plottingFeature = new hmap.feature.Vector(
                ccaGeom,
                {},
                this._style
            );
            this._plotLayer.addFeatures([this._plottingFeature]);
        }else{
            this._plottingFeature.setGeometry(ccaGeom);
            this._plotLayer.updateFeatures([this._plottingFeature]);
        }
    }

    /**
     * 返回控件的类型
     * @returns {string} 标绘控件类型的名称。
     */
    getControlType(){
        return hmap.control.controlType.Plot;
    }
};

/**
 *  枚举类,所有支持标绘的几何类型
 *  @example
 *  点类型：
 *  POINT.POINT         //标绘单点
 *  POINT.MULTIPOINT    //标绘多点
 *  线类型：
 *  POLYLINE.POLYLINE   //标绘折线
 *  POLYLINE.ARC        //标绘圆弧
 *  POLYLINE.FREELINE   //标绘自由线
 *  POLYLINE.BEZIER_CURVE2   //标绘二次贝塞尔曲线
 *  POLYLINE.BEZIER_CURVE3   //标绘三次贝塞尔曲线
 *  POLYLINE.BEZIER_CURVEN   //标绘N次贝塞尔曲线
 *  POLYLINE.CARDINAL_CURVE   //标绘Cardinal曲线
 *  面类型：
 *  POLYGON.CIRCLE    //标绘圆
 *  POLYGON.ELLIPSE   //标绘椭圆
 *  POLYGON.SECTOR    //标绘扇形
 *  POLYGON.LUNE      //标绘弓形
 *  POLYGON.RECTANGLE   //标绘矩形
 *  POLYGON.POLYGON    //标绘多边形
 *  POLYGON.FREE_POLYGON   //标绘手绘面
 *  POLYGON.GATHERING_PLACE   //标绘聚集区
 *  POLYGON.ROUNDED_RECT   //标绘圆角矩形
 *  POLYGON.CLOSE_CURVE   //标绘闭合曲线
 *  旗标：
 *  FLAG.CURVE_FLAG   //标绘曲线旗标
 *  FLAG.RECT_FLAG   //标绘直角旗标
 *  FLAG.TRIANGLE_FLAG   //标绘三角旗标
 *  箭头面：
 *  ARROW.STRAIGHT_ARROW   //标绘直箭头
 *  ARROW.DIAGONAL_ARROW   //标绘斜箭头
 *  ARROW.DOUBLE_ARROW   //标绘双箭头
 *  ARROW.DOVETAIL_STRAIGHT_ARROW   //标绘燕尾直箭头
 *  ARROW.DOVETAIL_DIAGONAL_ARROW   //标绘燕尾斜箭头
 *  箭头线：
 *  LARROW.POLYLINE_ARROW   //标绘折线箭头
 *  LARROW.PARALLEL_SEARCH   //标绘平行搜寻区
 *  LARROW.SECTOR_SEARCH   //标绘扇形搜寻区
 *  LARROW.BEZIER_CURVE_ARROW   //标绘贝塞尔曲线箭头
 *  LARROW.CARDINAL_CURVE_ARROW   //标绘Cardinal曲线箭头
 */
hmap.control.PlotTypes =
    {
        POINT:{
            POINT:"Point",                     //点
            MULTIPOINT:"MultiPoint"          //多点
        },
        POLYLINE:{
            POLYLINE:"Line",                //折线
            ARC:"Arc",                            //圆弧
            FREELINE:"FreeLine",                //自由线
            BEZIER_CURVE2:"BezierCurve2",      //二次贝塞尔曲线
            BEZIER_CURVE3:"BezierCurve3",      //三次贝塞尔曲线
            BEZIER_CURVEN:"BezierCurveN",      //N次贝塞尔曲线
            CARDINAL_CURVE:"CardinalCurve"     //Cardinal曲线
        },
        POLYGON:{
            CIRCLE:"CircleExt",                      //圆
            ELLIPSE:"Ellipse",                    //椭圆
            SECTOR:"Sector",                            //扇形
            LUNE:"Lune",                                 //弓形
            RECTANGLE:"Rectangle",                     //矩形
            POLYGON:"Polygon",                    //多边形
            FREE_POLYGON:"FreePolygon",               //手绘面
            GATHERING_PLACE:"GatheringPlace",        //聚集区
            ROUNDED_RECT:"RoundedRect",               //圆角矩形
            CLOSE_CURVE:"CloseCurve"                  //闭合曲线
        },
        FLAG:{
            CURVE_FLAG:"CurveFlag",          //曲线旗标
            RECT_FLAG:"RectFlag",            //直角旗标
            TRIANGLE_FLAG:"TriangleFlag"    //三角旗标
        },
        ARROW:{
            STRAIGHT_ARROW:"StraightArrow",            //直箭头
            DIAGONAL_ARROW:"DiagonalArrow",            //斜箭头
            DOUBLE_ARROW:"DoubleArrow",                    //双箭头
            DOVETAIL_STRAIGHT_ARROW:"DoveTailStraightArrow",  //燕尾直箭头
            DOVETAIL_DIAGONAL_ARROW:"DoveTailDiagonalArrow"   //燕尾斜箭头
        },
        LARROW:{
            POLYLINE_ARROW:"PolylineArrow",            //折线箭头
            PARALLEL_SEARCH:"ParallelSearch",          //平行搜寻区
            SECTOR_SEARCH:"SectorSearch",              //扇形搜寻区
            BEZIER_CURVE_ARROW:"BezierCurveArrow",    //贝塞尔曲线箭头
            CARDINAL_CURVE_ARROW:"CardinalCurveArrow" //Cardinal曲线箭头
        }
    };
;"use strict";
hmap.control=hmap.control || {};
/**
 * 测量控件
 * @type {hmap.control.Measure}
 * @extends hmap.control.Control
 * @example
 * let measureControl = new hmap.control.Measure();
 */
hmap.control.Measure=class extends hmap.control.Control {

    /**
     * 构造函数
     * @param {Object} options 可选项
     * @param {hmap.style.Style} options.plotStyle 绘制时的样式,区别于图层样式
     * @param {String} options.tipStyle 提示框的css样式，默认值为"position:absolute;color:black;font-size:13px;zIndex:999;line-height:15px;padding-left:8px;border:1px solid black;background:white"
     * @param {String} options.closePic 关闭按钮的png路径或base64编码后的字符串，默认值为 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAAtklEQVR42mP8//8/A+ng9Zu3FVUtjORphugnXzMQUFdzZydDQgKDuDi6wpcvGZYtYygsxK152jSG7GwGJSWGY8dQ9AN1Wlkx3LvHMGsWQ2oqDs1wRcj6sQpidzaaUiDAoRNHgMH1c3ODuF+/YtWJO7SB+pWVQdqAAGjE3btYgpAGmsl3NvkBRlFUEUwkc+YwJCfjdnZ3N0NcHFnJk0QwQJpfvya3MADqLK9uZmRkEyHDvSDEyAgA1PWx8n18D9YAAAAASUVORK5CYII='
     */
    constructor(options={}){
        super();
        this._map=null;
        this._init(options);
        this._language = hmap.language[hmap.initState.language];//将需要的语言存储起来，减少频繁的全局查询时间
        this._closePic = options.closePic|| 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAAnklEQVR42mP8//8/A1ng9Zu3jGRrBoLBpbmzkyEhgUFcHF385UuGZcsYCgtxa542jSE7m0FJieHYMRT9QJ1WVgz37jHMmsWQmopDM1wRsn6sgtidjaYUCLDpxB1gcP3c3CDu169YPIIvtIH6lZVB2oAAaMTdu5hBSAvN5Dubml+/fgsA8BOpYIL78vUAAAAASUVORK5CYII=';
        this.CLASS_NAME = "hmap.control.Measure";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 初始化测量控件需要的图层(矢量图层和叠加图层）及控件（提示控件和标绘控件）。
     * @param options
     * @private
     */
    _init(options){
        //初始化绘制图层
        const layerOpt = {enableHashCode:false};
        this._plotLayer = new hmap.layer.VectorLayer("measureLayer",layerOpt);
        if(options.plotStyle && options.plotStyle instanceof hmap.style.Style){
            this._plotLayer.setStyle(options.plotStyle);
        }else {
            this._plotLayer.setStyle(
                new hmap.style.Style({        //保存绘制要素的图层
                    fillSymbols: [new hmap.style.ColorFill(new hmap.style.Color(0, 136, 255, 0.2))],
                    markerSymbols: [new hmap.style.Circle({
                        "radius": 7,
                        "fillColor": new hmap.style.Color(255, 255, 255, 1.0),
                        "outlineColor": new hmap.style.Color(0, 136, 255, 1),
                        "outlineWidth": 3
                    })],
                    lineSymbols: [new hmap.style.LineSymbol({color: new hmap.style.Color(0, 136, 255, 1), width: 3})]
                })
            );
        }
        //初始化文字图层
        this._overlayLayer = new hmap.layer.OverlayLayer();

        //初始化提示控件
        const tipStyle = options.tipStyle||"position:absolute;color:black;font-size:13px;zIndex:999;line-height:15px;padding-left:8px;border:1px solid black;background:white";
        this._tipControl = new hmap.control.MouseTipControl({style:tipStyle,offsetX:10,offsetY:20}); //tip加一点儿偏移，否则地图的mousedown事件就不能被触发

        //初始化标绘控件
        this._plotControl = new hmap.control.Plot({layer:this._plotLayer});
    }

    /**
     * 将测量控件和地图进行绑定。绑定后，控件则处于激活状态。
     * @param {hmap.Map} map 地图
     */
    setMap(map){
        super.setMap(map);
        this._crs = map.getCrs();
        map.addLayer(this._plotLayer,null,'MeasureLayerCanvas');
        map.addLayer(this._overlayLayer);
        if(map.getControlByType(hmap.control.controlType.MouseTipControl)){
            map.removeControl(map.getControlByType(hmap.control.controlType.MouseTipControl))
        }
        map.addControl(this._tipControl);
        map.addControl(this._plotControl);
        this.activate();
    }

    /**
     * 激活该控件，只有将控件添加到地图上时才起作用。
     * @example
     * measureControl.activate();
     */
    activate(){

        super.activate();
        this._plotControl.activate();
        //状态设置为已激活
        this._status = true;
    }

    /**
     * 禁用控件，取消测量。
     * @example
     * measureControl.deactivate();
     */
    deactivate(){
        this.stopMeasure();
        this._plotControl.deactivate();
        this._status = false;
    }

    /**
     *  获取绘制控件的图层容器
     *  @returns {hmap.layer.VectorLayer} 矢量图层
     *
     */
    getLayer(){
        return this._plotLayer;
    }

    /**
     *  设置绘制时的样式
     *  @param {hmap.style.Style} style 绘制样式
     * */
    setStyle(style){
        if(!(style instanceof hmap.style.Style)){
            throw TypeError("param must be instanceof hmap.style.Style!");
        }
        this._style = style;
        this._plotLayer.setStyle(style);
    }

    /**
     * 启动测量距离功能。控件需处于激活状态，处于非激活状态时不能进行测量，请先激活该控件。
     * @example
     * let measureControl = new hmap.control.Measure();
     * map.addControl(measureControl);
     * measureControl.startMeasureDistance();
     */
    startMeasureDistance() {
        //如果控件处于未激活状态则不能开始测量
        if (this._status===undefined || this._status !==true){
            return;
        }
        if(!this._plotControl.getStatus()){//未处于激活状态
            this._plotControl.activate();
        }
        if(!this._tipControl.getStatus()){//未处于激活状态
            this._tipControl.activate();
        }

        //this._tipControl.setTipContent("单击左键确定位置，双击结束绘制。");
        this._tipControl.setTipContent(this._language.measureTip);
        this._plotControl.setPlotType("Line");
        const thisObj = this;
        const eventType = thisObj._plotControl.plotEventType;
        this._plotControl.on(eventType.NEWPOINT,function(data){
            //将点击处的点添加到地图上
            if(data.type==="Line"){
                const pointVec = new hmap.feature.Vector(data.points[data.points.length-1]);
                if(data.points.length===1){//如果是起点，显示起点标注
                    thisObj._showStartPoint(data.points[0],"undefined");
                    pointVec.setAttributes({measureId:"undefined"});
                }else{
                    const fid = data.feature.getFid();
                    //起点后面的第一个点时，为起点点要素和起点标注添加ID
                    if(data.points.length===3){
                        const startPoint = thisObj._plotLayer.getFeaturesByAttribute("measureId","undefined")[0];
                        startPoint.setAttributes({measureId:fid});
                        const startLabel = thisObj._overlayLayer.getOverlaysByDomId("undefined")[0];
                        startLabel.setDomId(fid);
                    }
                    thisObj._measurePartialLength(data.points,fid);
                    pointVec.setAttributes({measureId:fid});
                }
                thisObj._plotLayer.addFeature(pointVec);
            }
        });

        this._plotControl.on(eventType.PLOTFINISHED,function(data){
            if (data.type==="Line"){
                data.feature.setAttributes({measureId: data.feature.getFid()});
                //thisObj._measureDistance(data.points, data.feature.getFid());
                thisObj._measureDistance(data.feature);
                thisObj._plotControl.setPlotType(undefined);
                thisObj._tipControl.deactivate();
            }
        });
    }

    /**
     * 启动测量面积功能。控件需处于激活状态，处于非激活状态时，不能进行测量面积。
     */
    startMeasureArea() {
        //如果控件处于未激活状态则不能开始测量
        if (this._status===undefined || this._status !==true){
            return;
        }
        if(!this._plotControl.getStatus()){//未处于激活状态
            this._plotControl.activate();
        }
        if(!this._tipControl.getStatus()){//未处于激活状态
            this._tipControl.activate();
        }

        this._plotControl.setPlotType("Polygon");
        this._tipControl.setTipContent(this._language.measureTip);
        const thisObj = this;
        this._plotControl.on(thisObj._plotControl.plotEventType.PLOTFINISHED,function(data){
            if(data.type==="Polygon") {
                // thisObj._measureArea(data.points,data.feature.getFid());
                thisObj._measureArea(data.feature);
                thisObj._plotControl.setPlotType(undefined);
                thisObj._tipControl.deactivate();
            }
        });
    }

    /**
     * 测量距离的内部方法
     * @private
     * @param feature 传入的线要素，计算并显示总长度
     *
     */
    _measureDistance(feature){
        const line = feature.getGeometry();
        const featureId = feature.getFid();
        const length = line.getLength(this._crs.getSrid());
        //显示距离
        //const endPoint = points[points.length-1].getCoordinate();
        const endPoint = line.getCoordSeq().getLastCoordinate();
        const element = document.createElement("div");
        element.measureId = featureId;
        const labelDiv = document.createElement("div");

        labelDiv.style.font = "12px arial,simsun";
        labelDiv.style.border = "0px solid #FF0103";
        labelDiv.style.backgroundColor = "#FFFFFF";
        labelDiv.style.padding = "3px 23px 3px 3px";
        labelDiv.style.boxShadow = "0px 1px 5px rgba(0,0,0,0.5)";
        labelDiv.style.borderRadius = "2px";

        labelDiv.innerHTML = "<span>"+this._language.totalLength+"：" + (length/1000).toFixed(2) + this._language.km+"</span>";
        element.appendChild(labelDiv);
        //增加删除图标及其事件
        const closeDiv = document.createElement("div");
        closeDiv.title = this._language.clear;//"清除";
        closeDiv.style = "width: 20px;height: 20px;position: absolute;top: 0px;right: 0px;";
        // closeDiv.style.backgroundImage = "url('imgs/x.png')";
        closeDiv.style.backgroundImage = "url(" + this._closePic+ ")"

        const thisObj = this;
        closeDiv.onclick=function(){
            thisObj._plotControl.setPlotType(undefined);
            const fid = closeDiv.parentElement.measureId;
            //删除此次绘制产生的点要素和线要素
            const features = thisObj._plotLayer.getFeaturesByAttribute("measureId",fid);
            thisObj._plotLayer.removeFeatures(features);        //清空标绘的图层

            //删除此次测距产生的文字和图标
            thisObj._overlayLayer.removeOverlaysByAttribute("measureId",fid);
            const startOverlay = thisObj._overlayLayer.getOverlaysByDomId(fid)[0];
            thisObj._overlayLayer.removeOverlay(startOverlay);
        }

        element.appendChild(closeDiv);
        const overlay = new hmap.overlay.SimplePopup({element: element, location: endPoint,measureId:featureId});
        const offset = new hmap.basetype.Offset(8,0,0);
        this._overlayLayer.addOverlay(overlay);
        overlay.setOffset(offset);
    }

    /**
     * 计算面积的内部方法，根据传入的点数组计算并显示面积
     * @private
     * @param feature
     */
    _measureArea(feature){
        const featureId = feature.getFid();
        const polygon = feature.getGeometry();
        const crsType = this._crs.getCrsType();
        let area = polygon.getArea();
        //判断是否自相交
        if(crsType=='GeoCRS'){
            area = area *111.000 * 111.000;
        }else{
            area = area/1000000;//将平方米转成平方公里
        }
        //显示面积
        const center = polygon.getCentroid();
        const element = document.createElement("div");
        element.measureId = featureId;
        const labelDiv = document.createElement("div");

        labelDiv.style.font = "12px arial,simsun";
        labelDiv.style.border = "0px solid #FF0103";
        labelDiv.style.backgroundColor = "#FFFFFF";
        labelDiv.style.padding = "3px 23px 3px 3px";
        labelDiv.style.boxShadow = "0px 1px 5px rgba(0,0,0,0.5)";
        labelDiv.style.borderRadius = "2px";
        if(polygon.isSelfIntersects()){
            labelDiv.innerHTML = '<span>' + this._language.unknownArea +'</span>';
        }else{
            labelDiv.innerHTML = "<span>"+this._language.area+"：" + area.toFixed(2) + this._language.km2+"</span>";
        }

        element.appendChild(labelDiv);
        //增加删除图标及其事件
        const closeDiv = document.createElement("div");
        closeDiv.title = this._language.clear;//"清除";
        closeDiv.style = "width: 20px;height: 20px;cursor: pointer;position: absolute;top: 0px;right: 0px;";
        closeDiv.style.backgroundImage = "url(" + this._closePic + ")";

        const thisObj = this;
        closeDiv.onclick=function(){
            const fid = closeDiv.parentElement.measureId;
            if (thisObj._plotLayer) {
                thisObj._plotControl.setPlotType(undefined);
                //删除此次测面积产生的面要素
                const curFeature = thisObj._plotLayer.getFeatureByFid(fid);
                thisObj._plotLayer.removeFeature(curFeature);//删除当前面要素
            }
            //删除此次绘制产生的面积文字和图标
            thisObj._overlayLayer.removeOverlaysByAttribute("measureId",fid);
        }
        element.appendChild(closeDiv);
        const overlay = new hmap.overlay.SimplePopup({element: element, location: center,measureId:featureId});
        const offset = new hmap.basetype.Offset(-8,0,0);
        this._overlayLayer.addOverlay(overlay);
        overlay.setOffset(offset);
    }

    /**
     * 停止测量，停止之后不可以测量距离和面积。
     */
    stopMeasure(){
        //如果正在测量，清除掉未完成的内容
        if(this._plotControl._isPlotting&&this._plotControl._plottingFeature){
            const fid = this._plotControl._plottingFeature.getFid();
            //删除此次绘制产生的点要素和线要素
            const features = this._plotLayer.getFeaturesByAttribute("measureId",fid);
            this._plotLayer.removeFeatures(features);        //清空标绘的图层

            //删除此次测距产生的文字和图标
            this._overlayLayer.removeOverlaysByAttribute("measureId",fid);
            this._overlayLayer.removeOverlaysByAttribute("domId",'undefined');//删除起点
        }
        this._plotControl.setPlotType(undefined);

        this._tipControl.deactivate();
    }

    /**
     * 清除测量时在地图上产生的要素信息。
     */
    clear(){
        this._plotLayer.removeAllFeatures();        //清空标绘的图层
        //清除显示的文字
        this._overlayLayer.removeAllOverlays();

        this._plotControl.setPlotType(undefined);
        this._tipControl.deactivate();
    }

    /**
     * 显示起点的内部方法
     * @private
     * @param {hmap.geom.Point} point 点对象
     * @param {String} lineFeatureId 线要素的id
     */
    _showStartPoint(point,lineFeatureId){
        //显示起点
        const pos = point.getCoordinate();
        const startDiv = document.createElement("div");
        startDiv.measureId = lineFeatureId;

        startDiv.style.font = "12px arial,simsun";
        startDiv.style.border = "0px solid #FF0103";
        startDiv.style.backgroundColor = "#FFFFFF";
        startDiv.style.padding = "3px 2px 3px 3px";
        startDiv.style.boxShadow = "0px 1px 5px rgba(0,0,0,0.5)";
        startDiv.style.borderRadius = "2px";
        startDiv.innerHTML = "<span>"+this._language.start+"</span>";

        const overlay = new hmap.overlay.SimplePopup({element: startDiv, location: pos, domId:lineFeatureId});
        const offset = new hmap.basetype.Offset(8,0,0);
        this._overlayLayer.addOverlay(overlay);
        overlay.setOffset(offset);
    }

    /**
     * 计算并显示测距离时中间段的长度
     * @private
     * @param points
     */
    _measurePartialLength(points,lineFeatureId){
        const line = new hmap.geom.Line(points);
        const length = line.getLength(this._crs.getSrid());

        //显示距离
        const pos = points[points.length-1].getCoordinate();

        const labelDiv = document.createElement("div");

        labelDiv.style.font = "12px arial,simsun";
        labelDiv.style.border = "0px solid #FF0103";
        labelDiv.style.backgroundColor = "#FFFFFF";
        labelDiv.style.padding = "3px 2px 3px 3px";
        labelDiv.style.boxShadow = "0px 1px 5px rgba(0,0,0,0.5)";
        labelDiv.style.borderRadius = "2px";
        labelDiv.innerHTML = "<span>" + (length/1000).toFixed(2) + this._language.km+ "</span>";

        const overlay = new hmap.overlay.SimplePopup({element: labelDiv, location: pos,measureId:lineFeatureId});
        const offset = new hmap.basetype.Offset(8,0,0);
        this._overlayLayer.addOverlay(overlay);
        overlay.setOffset(offset);
    }

    /**
     * 设置关闭图标的路径或base64编码字符串
     * @param closePic
     * @example
     * const closePic ='../imgs/xxx.png';
     * measureControl.setClosePic(closePic);
     */
    setClosePic(closePic){
        this._closePic = closePic;
    }

    /**
     * 获得当前的关闭图标的路径或base64编码字符串
     * @returns {*}
     */
    getClosePic(){
        return this._closePic;
    }
    destroy(){
        super.destroy();
        this._plotControl.destroy();
        this._tipControl.destroy();
        this._map.removeLayer(this._plotLayer);
        this._map.removeLayer(this._overlayLayer);
        this._plotLayer = null;
        this._overlayLayer.destroy();
    }
    /**
     * 返回控件的类型
     * @returns {string}
     */
    getControlType(){
        return hmap.control.controlType.Measure;
    }
};
;"use strict";
hmap.control = hmap.control || {};
/**
 * 罗盘控件，用于显示或调整地图旋转角和方位角
 * @type {hmap.control.Compass}
 *
 * @extends {hmap.control.Control}
 * @example
 * let compass = new hmap.control.Compass({
 *      position:"topleft",
 *      outColor: {
 *          background: "red",
 *          button: "blue"
 *      },
 *      innerColor: {
 *          background: "green",
 *          north: "blue",
 *          south: "white"
 *      }
 * });
 */
hmap.control.Compass = class extends hmap.control.Control {
    /**
     * 创建控件
     * @param {String} options.position 控件位置，支持"topleft","topright"(默认),"bottomleft","bottomright"
     * @param {String} options.outColor.background 外圈背景色
     * @param {String} options.outColor.button  外圈按钮颜色
     * @param {String} options.innerColor.background 内圈背景色
     * @param {String} options.innerColor.north 内圈指北针颜色
     * @param {String} options.innerColor.south 内圈指南针颜色
     */
    constructor(options = {}) {
        super();
        this.CLASS_NAME = "hmap.control.Compass";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._status = false;         //激活状态
        this._deltaX = 0.0167 * 45;   //仰俯角跨度，每秒转动30°
        this._deltaZ = 0.0167 * 60;   //方位角跨度，每秒转动60°
        this._timer = null; //模拟长按事件
        this.compassCoontainer = null;
        this.options = options;
        this.globleId = null;
    }

    /**
     * 和地图对象进行绑定，并自动激活控件。
     * addControl的时候调用setMap()
     * @param {hmap.Map} map
     */
    setMap(map) {
        super.setMap(map);
        this._maxPitch = map._maxPitch;
        this._createCompassDom();
        this.domDisk = document.querySelector(".hmap-control-compass .center");
        this.domCompass = document.querySelector(".hmap-control-compass .center .icon-compass");
        this.activate();
        this.updateStyle(this.options);
    }

    /**
     * 激活控件。
     * @example
     * compass.activate();
     */
    activate() {
        if (this._status) return;
        super.activate();
        this._status = true;

        //监听
        this._map.event.addListener(EventType.MAPEVENT_ROTATING, this._updateCompassValue.bind(this));
        this._map.event.addListener(EventType.MAPEVENT_ROTATERESET, this._resetCompassValue.bind(this));

        //dom事件
        this.domDisk.addEventListener('click', this._resetCompassValue.bind(this), false);
        document.querySelector(".hmap-control-compass .top").addEventListener('mousedown', this._patchUpHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .bottom").addEventListener('mousedown', this._patchDownHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .right").addEventListener('mousedown', this._rotateClockwiseHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .left").addEventListener('mousedown', this._rotateAntiHandler.bind(this), false);

        document.addEventListener('mouseup', this._cancelAnimationFrame.bind(this), false);
    }

    /**
     * 更新样俯角和方位角
     * @param event
     * @private
     */
    _updateCompassValue(event) {
        if (!this._status) return;
        let degree = -this._map._camera._rotateZ;
        let patch = (90 + this._map._camera._rotateX) / 90;
        this.domDisk.style.setProperty('transform', 'scaleY(' + patch + ')', 'important');
        this.domCompass.style.setProperty('transform', 'rotate(' + degree + 'deg)', 'important');
    }

    /**
     * 重置旋转
     * @private
     */
    _resetCompassValue() {
        if (!this._status) return;
        this.domDisk.style.setProperty('transform', 'scaleY(1)', 'important');
        this.domCompass.style.setProperty('transform', 'rotate(0deg)', 'important');
        this._map._camera.resetRotate();
        this._map.redraw();
    }

    /**
     * 仰角旋转
     * @param event
     * @private
     */
    _patchUpHandler(event) {
        if (event.button == 0 && this._status) {
            this._status = true;
            this.globleId = window.requestAnimationFrame(this._patchHandler.bind(this, this._deltaX));
        }
    }

    /**
     * 仰角旋转
     * @param event
     * @private
     */
    _patchDownHandler(event) {
        if (event.button == 0 && this._status) {
            this._status = true;
            this.globleId = window.requestAnimationFrame(this._patchHandler.bind(this, -this._deltaX));
        }
    }

    /**
     * 处理仰俯角
     * @param value
     * @private
     */
    _patchHandler(value) {
        if (!this._status) {
            this._cancelAnimationFrame();
        }
        let rotateX = value;
        const pitch = -this._map._camera._rotateX;
        const newPitch = pitch + rotateX;
        if (newPitch > this._maxPitch || newPitch < 0) {
            this._cancelAnimationFrame();
        }
        rotateX = newPitch > this._maxPitch ? this._maxPitch - pitch : value;
        rotateX = newPitch < 0 ? 0 : rotateX;
        this._map._camera.rotateX(-rotateX);
        this._map.redraw();
        this._updateCompassValue();
        this.globleId = window.requestAnimationFrame(this._patchHandler.bind(this, value));
    }

    /**
     * 方位角顺时针旋转
     * @param event
     * @private
     */
    _rotateClockwiseHandler(event) {
        if (event.button == 0 && this._status) {
            this._status = true;
            this.globleId = window.requestAnimationFrame(this._rotateHandler.bind(this, -this._deltaZ));
        }
    }

    /**
     * 方位角逆时针旋转
     * @param event
     * @private
     */
    _rotateAntiHandler(event) {
        if (event.button == 0 && this._status) {
            this._status = true;
            this.globleId = window.requestAnimationFrame(this._rotateHandler.bind(this, this._deltaZ));
        }
    }

    /**
     * 方位角旋转
     * @param value
     * @private
     */
    _rotateHandler(value) {
        if (!this._status) {
            this._cancelAnimationFrame();
        }
        this._map._camera.rotateZ(value);
        this._map.redraw();
        this._updateCompassValue();
        this.globleId = window.requestAnimationFrame(this._rotateHandler.bind(this, value));
    }

    /**
     * 清除定时器
     * @param value
     * @private
     */
    _cancelAnimationFrame() {
        if (this.globleId) {
            window.cancelAnimationFrame(this.globleId);
        }
    }


    /**
     * 创建dom元素
     * @private
     */
    _createCompassDom() {
        //内联样式
        const style = `
        .hmap-control-compass {
            position: absolute;
            width: 60px;
            height: 60px;
            right: 20px;
            top: 20px;
            border-radius: 50%;
            background: -webkit-radial-gradient(circle closest-side, transparent 50%, #fafafa 50%);
            z-index: 9999;
            box-shadow: 0 0 5px gray;
        }

        .hmap-control-compass > div {
            position: relative;
            height: 100%;
            width: 100%;
        }

        .hmap-control-compass .center {
            position: relative;
            width: 51%;
            height: 51%;
            margin: auto;
            top: 24%;
            background: #fff;
            border-radius: 50%;
            border: 1px solid #e9e7e7;
        }

        .hmap-control-compass .side {
            position: absolute;
            background: transparent;
            display: flex;
            align-items: center;
        }

        .hmap-control-compass .left {
            height: 50%;
            width: 20%;
            left: 5%;
            top: 25%;
        }

        .hmap-control-compass .right {
            height: 50%;
            width: 20%;
            right: 5%;
            top: 25%;
        }

        .hmap-control-compass .top {
            width: 50%;
            height: 20%;
            left: 25%;
            top: 5%;
        }

        .hmap-control-compass .bottom {
            width: 50%;
            height: 20%;
            left: 25%;
            bottom: 5%;
        }

        .hmap-control-compass .arrow {
            position: relative;
            width: 0;
            height: 0;
            margin: auto;
            height: 25%;
            line-height: 50%;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
        }

        .hmap-control-compass .arrow-up {
            bottom: 24%;
            border-bottom: 5px solid #ccc;
        }

        .hmap-control-compass .arrow-down {
            top: 24%;
            border-top: 5px solid #ccc;
        }

        .hmap-control-compass .icon-compass {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .hmap-control-compass .icon-compass > div {
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            margin: auto;
        }

        .hmap-control-compass .icon-compass-north {
            border-bottom: 16px solid #fa6161;
        }

        .hmap-control-compass .icon-compass-south {
            border-top: 16px solid lightgray;
        }

        .hmap-control-compass .left > div, .right > div {
            position: absolute;
            display: inline-block;
        }

        .hmap-control-compass .left > .curve, .right > .curve {
            width: 100%;
            height: 77%;
            border-radius: 100%;
            border: 2px solid transparent;
        }

        .hmap-control-compass .left > .curve-head, .right > .curve-head {
            width: 10%;
            height: 6%;
            border-width: 4px;
            border-color: transparent;
            top: 75%;;
            transform: rotate(144deg);
            border-style: solid;
        }

        .hmap-control-compass .left .curve {
            border-left-color: inherit;
            left: 3px;
        }

        .hmap-control-compass .left .curve-head {
            border-left-color: inherit;
        }

        .hmap-control-compass .right .curve {
            border-right-color: inherit;
            right: 3px;
        }

        .hmap-control-compass .right .curve-head {
            border-right-color: inherit;
            transform: rotate(214deg);
            right: 0;
        }

        .hmap-control-compass .right {
            border-right-color: #ccc;
        }

        .hmap-control-compass .left {
            border-left-color: #ccc;
        }
        `;

        this.styleEl = document.createElement('style');
        this.styleEl.type = 'text/css';
        this.styleEl.innerHTML = style;
        this.styleEl.id = "compassStyle";
        //放到最上层，防止覆盖其他样式
        document.getElementsByTagName('head').item(0).prepend(this.styleEl);


        //dom元素
        const template = `
                <div>
                    <div class="side top ">
                        <div class="arrow arrow-up" style></div>
                    </div>
                    <div class="side bottom ">
                        <div class="arrow arrow-down" style></div>
                    </div>
                    <div class="side right ">
                            <div class="curve"></div>
                            <div class="curve-head"></div>
                    </div>
                    <div class="side left ">
                            <div class="curve"></div>
                            <div class="curve-head"></div>
                    </div>
                    <div class="center" style="transform: scaleY(1)">
                        <div class="icon-compass" style="transform: rotate(0deg)">
                            <div class="icon-compass-north"></div>
                            <div class="icon-compass-south"></div>
                        </div>
                    </div>
                </div>          
        `;

        this.compassCoontainer = document.createElement("div");
        this.compassCoontainer.className = "hmap-control-compass";
        this.compassCoontainer.style = "";
        this.compassCoontainer.innerHTML = template;
        this._map.container.parentNode.appendChild(this.compassCoontainer);
    }

    /**
     * 颜色样式更新
     * @param {String} options.position 控件位置，支持"topleft","topright"(默认),"bottomleft","bottomright"
     * @param {String} options.outColor.background 外圈背景色
     * @param {String} options.outColor.button  外圈按钮颜色
     * @param {String} options.innerColor.background 内圈背景色
     * @param {String} options.innerColor.north 内圈指北针颜色
     * @param {String} options.innerColor.south 内圈指南针颜色
     * @example
     * compass.updateStyle({
     *      position:"topleft",
     *      outColor: {
     *          background: "red",
     *          button: "blue"
     *      },
     *      innerColor: {
     *          background: "green",
     *          north: "blue",
     *          south: "white"
     *      }
     * })
     */
    updateStyle(options) {
        if (!options) return;
        if (options.position) {
            if (options.position == "bottomright") {
                this._setDomPositon("auto", "20px", "auto", "20px");
            } else if (options.position == "bottomleft") {
                this._setDomPositon("auto", "20px", "20px", "auto");
            } else if (options.position == "topleft") {
                this._setDomPositon("20px", "auto", "20px", "auto");
            } else { //默认"topright"
                this._setDomPositon("20px", "auto", "auto", "20px");
            }
        }
        if (options.outColor) {
            if (options.outColor.background) {
                this.compassCoontainer.style.setProperty("background", "-webkit-radial-gradient(circle closest-side, transparent 50%, " + options.outColor.background + " 50%)", "important")
            }
            if (options.outColor.button) {
                document.querySelector(".hmap-control-compass .arrow-up").style.setProperty("border-bottom-color", options.outColor.button, "important");
                document.querySelector(".hmap-control-compass .arrow-down").style.setProperty("border-top-color", options.outColor.button, "important");
                document.querySelector(".hmap-control-compass .left").style.setProperty("border-left-color", options.outColor.button, "important");
                document.querySelector(".hmap-control-compass .right").style.setProperty("border-right-color", options.outColor.button, "important");
            }
        }
        if (options.innerColor) {
            if (options.innerColor.background) {
                document.querySelector(".hmap-control-compass .center").style.setProperty("background", options.innerColor.background, "important");
            }
            if (options.innerColor.north) {
                document.querySelector(".hmap-control-compass .icon-compass-north").style.setProperty("border-bottom-color", options.innerColor.north, "important");
            }
            if (options.innerColor.south) {
                document.querySelector(".hmap-control-compass .icon-compass-south").style.setProperty("border-top-color", options.innerColor.south, "important");
            }
        }
    }

    /**
     * 设置控件位置
     * @param top
     * @param bottom
     * @param left
     * @param right
     * @private
     */
    _setDomPositon(top, bottom, left, right) {
        this.compassCoontainer.style.setProperty("top", top, "important");
        this.compassCoontainer.style.setProperty("bottom", bottom, "important");
        this.compassCoontainer.style.setProperty("left", left, "important");
        this.compassCoontainer.style.setProperty("right", right, "important");
    }

    /**
     * 禁用控件，禁用后不响应地图事件，不可互操作
     * @example
     * compass.deactivate();
     */
    deactivate() {
        if (!this._status) return;
        this._map.event.removeListener(EventType.MAPEVENT_ROTATING, this._updateCompassValue.bind(this));
        this._map.event.removeListener(EventType.MAPEVENT_ROTATERESET, this._resetCompassValue.bind(this));
        document.querySelector(".hmap-control-compass .top").removeEventListener('mousedown', this._patchUpHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .bottom").removeEventListener('mousedown', this._patchDownHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .left").removeEventListener('mousedown', this._rotateClockwiseHandler.bind(this), false);
        document.querySelector(".hmap-control-compass .right").removeEventListener('mousedown', this._rotateAntiHandler.bind(this), false);
        this._status = false;
    }

    /**
     * 销毁控件，释放占用的内存。
     * @example
     * compass.destroy();
     */
    destroy() {
        this.deactivate();
        this._map.container.parentNode.removeChild(this.compassCoontainer);
        let entries = Object.entries(this);
        for (let i = 0; i < entries.length; i++) {
            this[entries[i][0]] = null;
        }
        delete this;
    }

    /**
     * 返回控件的类型
     * @returns {String} 控件类型的名称
     */
    getControlType() {
        return hmap.control.controlType.Compass;
    }
}
;"use strict";
hmap.style = hmap.style||{};
/**
 * 用于矢量要素和矢量图层渲染的样式。通过set方法修改的样式，只有要素或图层重新使用该样式时才会生效。
 * @type {hmap.style.Style}
 * @example
 * let opts = {};
 * let fillSymbol = new hmap.style.ColorFill(new hmap.style.Color(255, 255, 0, 0.2));
 * let markerSymbol = new hmap.style.Circle();
 * let lineSymbol = new hmap.style.LineSymbol();
 * let textSymbol = new hmap.style.TextSymbol();
 * opts.fillSymbols = [fillSymbol];
 * opts.markerSymbols = [markerSymbol];
 * opts.lineSymbols = [lineSymbol];
 * opts.textSymbols = [textSymbol];
 * let style = new hmap.style.Style(opts);
 */
hmap.style.Style = class {
    /**
     * 构造函数。
     * @param {JSON} opts 样式的属性值，传入的值是key-value对象
     * @param {Array<hmap.style.MarkerSymbol>} opts.markerSymbols 标记符号数组
     * @param {Array<hmap.style.LineSymbol>} opts.lineSymbols 线符号数组
     * @param {Array<hmap.style.FillSymbol>} opts.fillSymbols 填充符号数组
     * @param {Array<hmap.style.TextSymbol>} opts.textSymbols 文本符号数组
     */
    constructor(opts) {
        this._markerSymbols=[];
        this._fillSymbols=[];
        this._textSymbols=[];
        this._lineSymbols=[];
        if(opts) {
            if (opts.fillSymbols){
                if(Array.isArray(opts.fillSymbols)){
                    this._fillSymbols = opts.fillSymbols;
                }else {
                    throw new TypeError("fillSymbols option should be Array type.");
                }
            }

            if (opts.lineSymbols){
                if(Array.isArray(opts.lineSymbols)) {
                    this._lineSymbols = opts.lineSymbols;
                }else {
                    throw new TypeError("lineSymbols option should be Array type.");
                }
            }
            if (opts.markerSymbols){
                if(Array.isArray(opts.markerSymbols)) {
                    this._markerSymbols = opts.markerSymbols;
                }else {
                    throw new TypeError("markerSymbols option should be Array type.");
                }
            }
            if (opts.textSymbols){
                if(Array.isArray(opts.textSymbols)) {
                    this._textSymbols = opts.textSymbols;
                }else{
                    throw new TypeError("textSymbols option should be Array type.");
                }
            }
            //zindex备用，确认不用后再删除
            this._zIndex = opts.zIndex ? opts.zIndex : 0;
        }
        // if (this._fillSymbols == null && this._markerSymbols == null && this._lineSymbols == null && this._textSymbols == null) {
        //     throw new Error("the style element is null");
        // }


        this.CLASS_NAME = "hmap.style.Style";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 获得填充符号数组。
     * @returns {Array<hmap.style.FillSymbol>} 返回填充符号对象的数组
     * @example
     * let style = new hmap.style.Style();
     * let fillSymbol = new hmap.style.ColorFill(new hmap.style.Color(0.5, 1.0, 0.0, 0.2));
     * style.setFillSymbols([fillSymbol]);
     * let result = style.getFillSymbols();//result=[new hmap.style.ColorFill(new hmap.style.Color(0.5, 1.0, 0.0, 0.2))]
     */
    getFillSymbols() {
        return this._fillSymbols;
    }

    /**
     * 设置填充符号。参数类型为FillSymbol数组。
     * @param {Array<hmap.style.FillSymbol>} fillSymbols 填充符号对象的数组。
     * @example
     * let style = new hmap.style.Style();
     * let fillSymbol = new hmap.style.ColorFill(new hmap.style.Color(0.5, 1.0, 0.0, 0.2));
     * style.setFillSymbols([fillSymbol]);
     */
    setFillSymbols(fillSymbols) {
        this._fillSymbols = fillSymbols;
    }

    /**
     * 获取点符号数组。
     * @returns {Array<hmap.style.MarkerSymbol>} 返回点符号数组
     * @example
     * let style = new hmap.style.Style();
     * let markerSymbol = new hmap.style.Circle();
     * style.setMarkerSymbols([markerSymbol]);
     * let result = style.getMarkerSymbols();//result=[new hmap.style.Circle()]
     */
    getMarkerSymbols() {
        return this._markerSymbols;
    }

    /**
     * 设置点符号。参数类型为MarkerSymbol数组。
     * @param {Array<hmap.style.MarkerSymbol>} markerSymbols 点符号对象的数组。
     * @example
     * let style = new hmap.style.Style();
     * let markerSymbol = new hmap.style.Circle();
     * style.setMarkerSymbols([markerSymbol]);
     */
    setMarkerSymbols(markerSymbols) {
        this._markerSymbols = markerSymbols;
    }

    /**
     * 获取线符号数组。
     * @returns {Array<hmap.style.LineSymbol>} 返回线符号的数组
     * @example
     * let style = new hmap.style.Style();
     * let lineSymbol = new hmap.style.LineSymbol();
     * style.setLineSymbols([lineSymbol]);
     * let result = style.getLineSymbols();//result=[new hmap.style.LineSymbol()]
     */
    getLineSymbols() {
        return this._lineSymbols;
    }

    /**
     * 设置线符号。
     * @param {Array<hmap.style.LineSymbol>} lineSymbols 线符号对象的数组。
     * @example
     * let style = new hmap.style.Style();
     * let lineSymbol = new hmap.style.LineSymbol();
     * style.setLineSymbols([lineSymbol]);
     */
    setLineSymbols(lineSymbols) {
        this._lineSymbols = lineSymbols;
    }

    /**
     * 获取文本符号数组。
     * @returns {Array<hmap.style.TextSymbol>} 返回文本符号的数组
     * @example
     * let style = new hmap.style.Style();
     * let textSymbol = new hmap.style.TextSymbol();
     * style.setTextSymbols([textSymbol]);
     * let result = style.getTextSymbols();//result=[new hmap.style.TextSymbol()]
     */
    getTextSymbols() {
        return this._textSymbols;
    }

    /**
     * 设置文本符号。
     * @param {Array<hmap.style.TextSymbol>} textSymbols 文本符号的数组。
     * @example
     * let style = new hmap.style.Style();
     * let textSymbol = new hmap.style.TextSymbol();
     * style.setTextSymbols([textSymbol]);
     */
    setTextSymbols(textSymbols) {
        this._textSymbols = textSymbols;
    }
    /**
     * 获取z索引值。 暂未启用。
     * @return {Number}
     */
    getZIndex() {
        return this._zIndex;
    }
    /**
     * 设置z索引值。暂未启用。
     * @param {int} zIndex
     * let style = new hmap.style.Style();

     */
    setZIndex(zIndex) {
        this._zIndex = zIndex;
    }

    /**
     * 创建并返回默认样式。
     * @returns {hmap.style.Style} 返回默认样式
     * @example
     * let style = new hmap.style.Style();
     * let result = hmap.style.Style.getDefault();
     * //result=new hmap.style.Style({
     * //        fillSymbols:[new hmap.style.ColorFill(new hmap.style.Color(0.5, 1.0, 0.0, 1))],
     * //        markerSymbols:[new hmap.style.Circle()],
     * //        lineSymbols:[new hmap.style.LineSymbol()],
     * //        textSymbols:[new hmap.style.TextSymbol()]
     * //});
     */
    static getDefault() {
        let opts = {};
        opts.fillSymbols = [new hmap.style.ColorFill(new hmap.style.Color(0.5, 1.0, 0.0, 1))];
        opts.markerSymbols = [new hmap.style.Circle()];
        opts.lineSymbols = [new hmap.style.LineSymbol()];
        opts.textSymbols = [new hmap.style.TextSymbol()];
        return new hmap.style.Style(opts);
    }

    /**
     * 将传入的对象转换为style函数。暂未启用。
     * 分为以下几种情况：
     * 1.如果传入的本身就是函数，则函数不会被改变，直接返回。
     * 2.如果传入的是Style数组或单个Style对象，将会包装成style函数并返回。
     * @param {Object} obj 函数或Style数组或单个Style对象
     * @returns {Function} 返回style函数
     * @private
     * @example
     * //函数传入
     *   let fun = function(){
     *      let style1 = hmap.style.Style.getDefault();
     *       let style2 = hmap.style.Style.getDefault();
     *       return [style1,style2];
     *  };
     *   let styleFunc = hmap.style.Style.createFunction(fun);
     *   console.log(styleFunc());
     * //传入数组
     *  let style1 = hmap.style.Style.getDefault();
     *   let style2 = hmap.style.Style.getDefault();
     *  let styleFunc2 = hmap.style.Style.createFunction([style1,style2]);
     *   console.log(styleFunc2());
     * //传入单个style
     *   let style = hmap.style.Style.getDefault();
     *  let styleFunc3 = hmap.style.Style.createFunction(style);
     *   console.log(styleFunc3());
     */
    static createFunction(obj) {
        let styleFunction;
        if(typeof obj=== 'function'){
            styleFunction = obj;
        }else{
            let styles;
            if(Array.isArray(obj)){
                styles = obj;
            }else{
                if(obj instanceof hmap.style.Style){
                    styles = [obj];
                }else{
                    throw new TypeError("The parameter is not an object of hmap.style.Style.");
                }
            }
            styleFunction = function(){
                return styles;
            }
        }
        return styleFunction;
    }
    /**
     * 克隆样式。
     * @returns {hmap.style.Style} 新的样式对象。
     * @example
     * let style = new hmap.style.Style();
     * let newStyle = style.clone();
     */
    clone(){
        let opts = {};
        opts.fillSymbols = this._fillSymbols?this._deepCopy(this._fillSymbols):null;
        opts.markerSymbols = this._markerSymbols?this._deepCopy(this._markerSymbols):null;
        opts.lineSymbols = this._lineSymbols?this._deepCopy(this._lineSymbols):null;
        opts.textSymbols = this._textSymbols?this._deepCopy(this._textSymbols):null;
        return new hmap.style.Style(opts);
    }

    /**
     * 深拷贝符号数组
     * @param {Array} symbolArr 符号数组
     * @returns {Array} 深拷贝出来的符号数组
     * @private
     */
    _deepCopy(symbolArr){
        let symbolCopy = [];
        for(const symbol of symbolArr){
            symbolCopy.push(symbol.clone());
        }
        return symbolCopy;
    }

};

;"use strict";
hmap.style=hmap.style||{};
/**
 * 颜色类，用来储存颜色值的类。颜色值按照数组形式储存，该数组包含r,g,b和a 4个未归一化的元素。
 * @example
 * let color = new hmap.style.Color(255,1,1,1);
 */
hmap.style.Color=class {
    /**
     * 构造函数
     * @param r {Number} 颜色值中的红色分量，0~255  默认为0。
     * @param g {Number} 颜色值中的绿色分量，0~255,默认为0
     * @param b {Number} 颜色值中的蓝色分量，0~255,默认为0
     * @param a {Number} 颜色透明度，0~1,默认为1
     */
    constructor(r=0,g=0,b=0,a=1){
        //if(r,g,b,a) {
        //    this._color = this._isColorArr(color);
        //}else{
        //    this._color = [0,0,0,1.0];//默认颜色为黑色
        //}
        this._color =[r,g,b,a];
        if(!(r>=0 && r<=255 && g>=0 && g<=255 && b>=0 && b<=255 && a>=0 && a<=1)){
            throw new RangeError("the color parameter was out of range!");
        }
        //将[0,0,0,0]定为特殊值，用户传入的透明颜色一律用[255,255,255,0]代替
        // this._color = (a==0)&&(r==0)&&(g==0)&&(b==0)?[255,255,255,0]:[r,g,b,a];
        this.CLASS_NAME = "hmap.style.Color";
    }

    /**
     * 判断是否为合格的颜色数组.
     * @private
     * @param {Array} color 颜色值数组
     * @returns {Array} 返回具有RGBA四个元素的数组。
     * @throws 传入的参数不是3元素或4元素组成的数组。
     */
    _isColorArr(color){
        if(!(color instanceof Array) || color.length<3 ||color.length>4){
            throw new TypeError("color must be an Array of RGB or RGBA!");
        }

        for(let i=0;i<color.length;i++){
            let flags;
            if(i<3){//判断rgb的范围
                (color[i]>=0 && color[i]<256)?flags=true:flags=false;
            }else{//判断透明度的范围
                (color[i]>=0 && color[i]<=1)? flags=true:flags=false;
            }
            if(flags=false){
                throw new RangeError("the color parameter was out of range!");
            }
        }
        if(color.length<4){color[3]=1;}
        return color;
    }

    /**
     * 返回归一化后的颜色数组
     * @private
     * @param {Array} color 元素数为3或4的颜色数组。
     * @returns {Array} 归一化后的颜色数组
     * @throws 传入的参数不是3元素或4元素的数组。
     *
     */
    _isNorColorArr(color){
        if(!(color instanceof Array) || color.length<3 ||color.length>4){
            throw new TypeError("color must be an Array");
        }

        for(let i=0;i<color.length;i++){
            let flags;
            if(i<3){
                (color[i]>=0 && color[i]<=1)?flags=true:flags=false;
            }else{
                (color[i]>=0 && color[i]<=1)? flags=true:flags=false;
            }
            if(flags===false){
                throw new RangeError("the color parameter was out of range!");
            }
        }
        if(color.length<4){color[3]=1;}
        return color;
    }

    /**
     * 获取颜色值，是未归一化的数组形式。
     * @returns {Array} 未归一化的颜色值。
     * @example
     * let colorArray = color.toArray();
     */
    toArray(){
        return this._color;
    }
    /**
     * 根据颜色数组设置颜色值
     * @param {Array} color 颜色值数组，包含4个元素，前三个元素是未归一化的r,g,b值。
     * @example
     * color.fromArray([255,1,1,1]);
     */
    fromArray(color){
         this._color = this._isColorArr(color);
    }
    /**
     * 复制一个新的颜色对象
     * @example
     * let newColor = color.clone();
     */
    clone(){
        const color = this._color;
        return new hmap.style.Color(color[0],color[1],color[2],color[3]);
    }

    /**
     * 设置颜色中的透明度
     * @param {Number} opacity 透明度值，大于等于0，小于等于1。
     * @returns {Array} 包含r、g、b和a 4个元素的颜色数组，数组中的元素r、g、b范围均为0~255。
     * @example
     * let newColor = color.setOpacity(1);
     */
    setOpacity(opacity){
        if(!(Number.isFinite(opacity)) || opacity<0||opacity>1){
            throw new TypeError("paramater was not a number or not between 0 to 1!");
        }
        this._color[3]=opacity;
        return this._color;
    }
    /**
     * 获取颜色中的透明度
     * @returns {Number} 透明度。
     * @example
     * let opacity = color.getOpacity();
     */
    getOpacity(){
        return this._color[3];
    }

    
    /**
     * 获取归一化后的颜色数组，即将rgb值的范围控制在0~1之间。
     * @returns {Array} 返回归一化后的颜色数组。
     * @example
     * let colorNormalArray = color.toNormalizeArray();
     */
    toNormalizeArray(){
        // [255...]=>[1...]
        const norColor = [];
        for(let i=0; i<3; i++){
            norColor.push(this._color[i]/255);
        }
        norColor.push(this._color[3]);
        return norColor;
    }

    
    /**
     * 获取十六进制表示的颜色值。
     * @returns {String} 返回十六进制格式的颜色字符串。
     * @example
     * let hexColor = color.toHexColor();
     *
     */
    toHexColor(){
        // 非归一化的色值[]=>十六进制
        let HXColor = "#";
        let val;
        for(let i=0,len = this._color.length; i<len-1; i++){
            val = this._color[i].toString(16);
            if(this._color[i]<16){
                val = "0" + val;
            }
            HXColor += val;
        }
        return HXColor;
    }

    
    /**
     * 将颜色对象转化成rgba('red','green','blue','alpha')形式的颜色字符串。
     * @returns {String} rgba()形式的字符串。
     * @example
     * let rgbaColor = color.toRGBAColor();
     */
    toRGBAColor(){
        // 非归一化的色值[]=>rgba()
        const r=this._color[0];
        const g=this._color[1];
        const b=this._color[2];
        const a=this._color[3];
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    }

    
    /**
     * 将颜色对象转化成rgb('red','green','blue')形式的颜色字符串。
     * @returns {String} rgb()形式的字符串。
     * @example
     * let rgbColor = color.toRGBColor();
     */
    toRGBColor(){
        // 非归一化的色值[]=>rgb()
        const r=this._color[0];
        const g=this._color[1];
        const b=this._color[2];
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }


    /**
     * 根据归一化的颜色数组设置颜色值。
     * @param {Array} color 归一化后的颜色值数组。可以是包含r、g和b3个元素的数组，也可以是包含r、g、b和a4个元素的数组。
     * @returns {Boolean} 设置成功返回true;设置失败返回false
     * @example
     * let result = color.fromNormalizeArray([0.2,0.1,1,1]);
     */
    fromNormalizeArray(color){
        // [1...]=>[255...]
        // 如果不是[1..]该格式，则不会设置成功
        if(color instanceof Array && (color.length===3||color.length===4)){
            const nowColor = [];
            for(let i=0; i<3; i++){
                const val = color[i]*255;
                if(val<0 || val>255){
                    return false;
                }
                nowColor.push(val);
            }
            nowColor[3] = (nowColor.length>3)?nowColor[3]:1;
            this._color = nowColor;
            return true;
        }else{
            return false;
        }
    }

    
    /**
     * 根据十六进制格式的颜色字符串来设置颜色值。
     * @param {String} hexColor 十六进制格式表示的颜色值。
     * @returns {Boolean} 设置成功返回true;设置失败返回false
     * @example
     * let result = color.fromHexColor("#00FF00");
     */
    fromHexColor(hexColor){
        // 十六进制=>非归一化的色值[255...]
        //位数为：3, 4, 6, or 8的十六进制颜色值的正则表达式
        const HEX_COLOR = /^#(?:[0-9a-f]{3,4}){1,2}$/i;
        if (HEX_COLOR.exec(hexColor)) {
            const num = hexColor.length - 1; 
            let d; 
            if (num <= 4) {
              d = 1;
            } else {
              d = 2;
            }
            const r = parseInt(hexColor.substr(1, d), 16);
            const g = parseInt(hexColor.substr(1 + 1 * d, d), 16);
            const b = parseInt(hexColor.substr(1 + 2 * d, d), 16);
            let a;
            if (num === 4 || num === 8) {
              a = parseInt(hexColor.substr(1 + 3 * d, d), 16);
            } else {
              a = 1;
            }
            this._color = [r, g, b, a];
            return true;
        }else{
            return false;
        }
    }

    
    /**
     * 根据rgb()或rgba()格式的颜色值来设置Color对象的颜色值。
     * @param {String} rgbaColor 颜色值，是'rgba(r,g,b)'或者'rgb(r,g,b,a)'格式。
     * @returns {Boolean} 设置成功返回true;设置失败返回false
     * @example
     * let result = color.fromRGBAColor("rgba(255,0,0,1)");
     */
    fromRGBAColor(rgbaColor){
        // rgba=>非归一化的色值[]
        if (rgbaColor.indexOf('rgba(') === 0) { // rgba()
            this._color = rgbaColor.slice(5, -1).split(',').map(Number);
            return true;
        } else if (rgbaColor.indexOf('rgb(') === 0) { // rgb()
            const color = rgbaColor.slice(4, -1).split(',').map(Number);
            color.push(1);
            this._color = color;
            return true;
        }else{
            return false;
        }
    }
    //将颜色每个通道都按照scale比例加深 >1加深 不超过255
    deepen(scale){
        this._color[0]=Math.min(this._color[0]*scale,255);
        this._color[1]=Math.min(this._color[1]*scale,255);
        this._color[2]=Math.min(this._color[2]*scale,255);
        return this;
    }

    /**
     * 根据颜色数组创建一个带有图像信息的ImageData对象，图像的寬高均为2px。
     * @param {Array} color 归一化的颜色数组
     * @returns {ImageData} ImageData对象,包含图像的大小和颜色信息。
     */
    static getTextureByColor(color){
        let _imgData=new ImageData(2,2);
        let len=_imgData.data.length;
        for(let i=0;i<len;i=i+4){
            _imgData.data[i+0]=color[0]*255;
            _imgData.data[i+1]=color[1]*255;
            _imgData.data[i+2]=color[2]*255;
            _imgData.data[i+3]=color[3];
        }
        return _imgData;
    }
};
;"use strict";
hmap.strategy=hmap.strategy || {};
/**
 * 图集类
 * @private
 * @type {hmap.strategy.Atlas}
 */
hmap.strategy.Atlas=class{
    /**
     * 创建一个纹理
     * @param {Number} size  图集大小，像素单位
     * @param {Number} space
     * @param {Boolean} normalize 
     */
    constructor(size,space=1, normalize=true){
        this.CLASS_NAME="hmap.strategy.Atlas";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._size=size;
        this._space=space;
        this._normalize=normalize;
        
        this._empty = {width:size-this._space,height:size-this._space};// 管理空区域
        this._maxHeight = 0;
        this._context=document.createElement('CANVAS').getContext('2d');// 创建canvas画布
        this.setCanvas();
        this._canvasInfos = new Map();// 保存canvas数据  x y width height
        this._atlasInfos = new Map();// 保存归一化数据  x y width height
        this._textProp = null;
        this.hasChange = false;          //图集是否发生了变动
    }
    getAtlasInfos(){
        return this._atlasInfos;
    }
    
    /**
     * 重新设置canvas的宽高
     * @param {*} width 
     * @param {*} height 
     */
    setCanvas(width=this._size,height=this._size){
        const canvas = this._context.canvas;
        canvas.width = width;
        canvas.height = height;
        //整个canvas的透明度
        this._context.globalAlpha = 0.0;
        this._context.fillRect(0, 0, width, height);
    }

    _createUnique(options){
        let id;
        const symbol = options.symbol;
        const className = symbol.CLASS_NAME;
        switch(className){
            case "hmap.style.TextSymbol":
                const noStrokeId = options.text+symbol.getFontFace() +symbol.getFontWeight()+symbol.getFontStyle();//+symbol.getBackgroundColor().toHexColor();//+symbol.getFontSize()

                if(symbol.getHaloWidth()>0 && symbol.getHaloColor().getOpacity()>0){//带描边
                   id = noStrokeId+symbol.getFontColor().toHexColor()+symbol.getHaloColor().toHexColor()+symbol.getHaloWidth()+symbol.getBackgroundColor().toHexColor();
                }else{//不带描边
                    id = noStrokeId;
                }
                break;
            case "hmap.style.Icon":
                id = symbol.getImgSrc();
                break;
            case "hmap.style.IconFont":
                id = symbol.getUnicode()+symbol.getFontSize()+symbol.getFontFamily()+symbol.getOutlineColor().toHexColor()+symbol.getOutlineWidth();
                break;
            case "hmap.style.Circle":
                id = symbol.getRadius()+symbol.getFillColor().toHexColor()+symbol.getOutlineColor().toHexColor()+symbol.getOutlineWidth();
                break;
            default:
                throw new TypeError("the parameter type is illegal.");
        }
        return id;
    }
    /**
     * 在纹理上，添加文字，返回添加后文字的大小和位置信息。
     * @param {String} text 
     * @param {FontType} txtSym 
     */
    addText(text,txtSym){
        this.getTextProp(text,txtSym);
        const id = this._createUnique({"text":text,"symbol":txtSym});
        let info = this._atlasInfos.get(id);

        // 若存在，则不再存放
        if(info){
            return info;
        }else{
            this.addInfo(this._textProp.textWidth,this._textProp.textHeight,id);
            const canvasInfo = this._canvasInfos.get(id);
            this.makeTextTexture(text,txtSym,canvasInfo.x,canvasInfo.y);
            this.hasChange = true;
         
            return this._atlasInfos.get(id);
        }
    }

    getTextProp(text,txtSym){
        this._context.save();
        this._textProp = {
            fontWeight: txtSym._fontWeight,
            fontStyle: txtSym.getFontStyle(),
            fontSize: txtSym.getFontSize(),
            fontFace: txtSym.getFontFace(),
            color: txtSym.getFontColor().clone(),
            haloColor: txtSym.getHaloColor(),
            haloWidth: txtSym.getHaloWidth(),
            backgroundColor: txtSym.getBackgroundColor()
        };
        this._context.font = this._textProp.fontWeight+" "+this._textProp.fontStyle+" "+this._textProp.fontSize+"px"+" "+this._textProp.fontFace;
        // 文字的"位置信息"，x：0，y:0，width和height如下。获取位置信息可通过文字绘制背景框大小查看。
        const addH = this._textProp.fontSize/15;//给高多加的值,为了尽量满足更多的字体类型
        const addW = this._textProp.fontSize/9;//给宽多加的值,为了尽量满足更多的字体类型eg:斜体
        const haloOpacity = this._textProp.haloColor.getOpacity();
        const textWidth = this._context.measureText(text).width;
        const textHeight = this._textProp.fontSize;
        if(haloOpacity>0&&this._textProp.haloWidth>0){//有描边
            const halo = this._textProp.haloWidth*2;
            this._textProp.textWidth=textWidth+halo+addW;
            this._textProp.textHeight=textHeight+halo+addH;
        }else{//无描边
            this._textProp.textWidth=textWidth+addW;
            this._textProp.textHeight=textHeight+addH;
        }
    }
   
    addIconfont(iFontSym,callback){
        const iFontSize = iFontSym.getFontSize()+iFontSym.getOutlineWidth()*2;
        const id = this._createUnique({"symbol":iFontSym});
        let info = this._atlasInfos.get(id);

        if(info){
            callback(info);
        }else{
            this.addInfo(iFontSize,iFontSize,id);
            this.hasChange = true;
            info = this._atlasInfos.get(id);

            let dom = document.createElement("span");
            dom.style.display = "inline-block";
            // this._dom.visibility = "hidden";
            dom.className = "Microsoft Yahei";
            dom.innerHTML = iFontSym.getUnicode();
            document.body.appendChild(dom);
            let width = dom.clientWidth;
            dom.className = iFontSym.getClassName();
            let second = 0;
            let interval = setInterval(function(){
                const canvasInfo = this._canvasInfos.get(id);
                second++;
                if(width!==dom.clientWidth){
                    if(this.makeIconfontTexture(dom,iFontSym,canvasInfo.x,canvasInfo.y)){
                        clearInterval(interval);
                        document.body.removeChild(dom);
                        callback(info);
                    }
                }else if(second===10){
                }else if(second===100){
                    if(this.makeIconfontTexture(dom,iFontSym,canvasInfo.x,canvasInfo.y)){
                        clearInterval(interval);
                        document.body.removeChild(dom);
                        callback(info);
                    }
                }
            }.bind(this),second);
        }
    }

    /**
     * 在纹理上，添加图标，返回添加后图标的大小和位置信息。
     */
    addIcon(iconSym){
        let me = this;
        const id = this._createUnique({"symbol":iconSym});
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.src = iconSym.getImgSrc();
            img.onload = function(){
                let info = me._atlasInfos.get(id);
                if(info){
                    resolve(info);
                }else{
                    me.addInfo(img.width,img.height,id);
                    me.hasChange = true;
                    info = me._atlasInfos.get(id);
                    const canvasInfo = me._canvasInfos.get(id);
                    if(me.makeIconTexture(img,iconSym,canvasInfo.x,canvasInfo.y)){
                        resolve(info);
                    }
                }
            };
            img.onerror = function() {
                throw new URIError('Could not load image at ' + iconSym._imgSrc);
            };

        })
    }

    addCircle(circleSym,callback){
        const circleSize = circleSym.getRadius()*2+circleSym.getOutlineWidth()*2;
        const id = this._createUnique({"symbol":circleSym});
        let info = this._atlasInfos.get(id);
        if(info){
            callback(info);
            return info;
        }else{
            this.addInfo(circleSize,circleSize,id);
            this.hasChange = true;
            info = this._atlasInfos.get(id);
            const canvasInfo = this._canvasInfos.get(id);
            this.makeCircleTexture(circleSym,canvasInfo.x,canvasInfo.y);
            callback(info);
            return info;
        }
    }

    addInfo(width,height,id){
        this.info={};
        if(width<=this._size&&height<=this._size){
            if(width<=this._empty.width){//同行画
                this._analizeHeight(width,height);
            }else{//换行画
                this._empty.width = this._size-this._space;
                this._empty.height = this._empty.height-this._maxHeight;
                this._maxHeight = 0;
                this._analizeHeight(width,height);
            }
            // 记录canvas绘制位置信息
            this._canvasInfos.set(id,this.info);
            // 记录信息
            (this._normalize)?
            (this._atlasInfos.set(id,{"x": this.info.x/this._size,"y": this.info.y/this._size,"width": width/this._size,"height": height/this._size})):
            (this._atlasInfos.set(id,this.info));


        }else{//一个图标的大小比图集都大
            throw new RangeError("The size of Atlas is not enough");//图集不够用
        }
    }

    _analizeHeight(width,height){
        if(height<=this._empty.height){
            // 可以画
            this.info = {"x":this._size-this._empty.width,"y":this._size-this._empty.height,"width":width,"height":height};
            this._empty.width = this._empty.width-width-this._space;
            this._maxHeight = (height+this._space)>this._maxHeight?(height+this._space):this._maxHeight;
        }else{
            // 不可以画
            // 需要重新创建一个图集
            throw new RangeError("The size of Atlas is not enough");//图集不够用
        }
    }

    getTextInfo(text,txtSym){
        const id = this._createUnique({"text":text,"symbol":txtSym});
        return this._atlasInfos.get(id);
    }

    getIconfontInfo(iFontSym){
        const id = this._createUnique({"symbol":iFontSym});
        return this._atlasInfos.get(id);
    }

    getIconInfo(iconSym){
        const id = this._createUnique({"symbol":iconSym});
        return this._atlasInfos.get(id);
    }

    getCircleInfo(circleSym){
        const id = this._createUnique({"symbol":circleSym});
        return this._atlasInfos.get(id);
    }
    /**
     * 获取纹理的canvas对象。
     */
    getCanvas(){
        return this._context.canvas;
    }
    /**
     * 获取纹理canvas对象的上下文。
     */
    getContext(){
        return this._context;
    }
    /**
     * 将要添加的文字，绘制在canvas上。
     * @param {String} text 
     * @param {hmap.style.Style} txtSym 
     * @param {Number} positionX 
     * @param {Number} positionY 
     */
    makeTextTexture(text,txtSym,positionX,positionY){
      /*获取文字符号的属性值*/
      const textCtx = this._context;
      // 文字"绘制"的左上角的x值、y值：
      const x = (this._textProp.haloColor.getOpacity()>0)?(positionX+this._textProp.haloWidth):positionX;
      const y = (this._textProp.haloColor.getOpacity()>0)?(positionY+this._textProp.fontSize*12/13+this._textProp.haloWidth):(positionY+this._textProp.fontSize*12/13);

      textCtx.textAlign = "left";
      textCtx.textBaseline = "alphabetic";//若设置为其他值，当字体类型变化时，文字绘制的顶端位置发生变化；
      if(this._textProp.haloColor.getOpacity()>0 && this._textProp.haloWidth>0){//有描边的字
        
        // 设置文字背景框,即返回文字的位置范围
          if(this._textProp.backgroundColor.getOpacity() !== 0){//不透明
            textCtx.globalAlpha = this._textProp.backgroundColor.getOpacity();
            textCtx.fillStyle = this._textProp.backgroundColor.toHexColor();
            textCtx.fillRect(positionX,positionY,this._textProp.textWidth,this._textProp.textHeight);
          }

        //绘制描边
        textCtx.globalAlpha = this._textProp.haloColor.getOpacity();
        textCtx.lineWidth = this._textProp.haloWidth;
        textCtx.strokeStyle = this._textProp.haloColor.toHexColor();
        textCtx.strokeText(text, x, y);
        //绘制文字本身
        textCtx.globalAlpha = this._textProp.color.getOpacity();
        textCtx.fillStyle = this._textProp.color.toHexColor();
        textCtx.fillText(text, x, y);

      }else{//不带描边

        // 设置文字背景框,即返回文字的位置范围;没有描边的背景色，都设置为透明，在着色器中上色。
        this._textProp.backgroundColor.fromArray([0,0,0,0]);
        textCtx.globalAlpha = this._textProp.backgroundColor.getOpacity();
        textCtx.fillStyle = this._textProp.backgroundColor.toHexColor();
        textCtx.fillRect(positionX,positionY,this._textProp.textWidth,this._textProp.textHeight);

        // 文字为纯白色，由着色器上色
        this._textProp.color.fromArray([255,255,255,1]);
        textCtx.globalAlpha = this._textProp.color.getOpacity();
        textCtx.fillStyle = this._textProp.color.toHexColor();
        textCtx.fillText(text, x, y);
      }
      // 绘制参考点
      // this._context.globalAlpha = 1;
      // this._context.fillStyle = "yellow";
      // this._context.fillRect(positionX, positionY, 1, 1);
      // this._context.fillRect(positionX+this._textProp.textWidth, positionY+this._textProp.textHeight, 1, 1);
    }
    /**
     * 绘制iconfont纹理
     * @param {Dom} dom 
     * @param {*} iFontSym 
     * @param {Number} positionX 
     * @param {Number} positionY 
     */
    makeIconfontTexture(dom,iFontSym,positionX,positionY){
        const canvas = this._context.canvas;
        const context = this._context;
        // context.beginPath();
        const fontSize = iFontSym.getFontSize();
        const fontFamily = iFontSym.getFontFamily();
        const fillColor = iFontSym.getFillColor();
        const outlineColor = iFontSym.getOutlineColor();
        const outlineWidth = iFontSym.getOutlineWidth();

        const x = positionX+outlineWidth;
        const y = positionY+outlineWidth;
        // const x = positionX;
        // const y = positionY;
        const iconfWidth = fontSize+outlineWidth;
        const iconfHeight = fontSize+outlineWidth;

        // context.globalAlpha = 1;
        // context.fillStyle = new hmap.style.Color(255,0,0).toHexColor();
        // context.fillRect(positionX,positionY,iconfWidth+outlineWidth,iconfHeight+outlineWidth);

        // 字体图标
        //context.font = fontSize+"px"+" "+fontFamily;
        context.font=500+" "+fontSize+"px"+" "+fontFamily;
        context.textAlign = "left";
        context.textBaseline = "top";


        if(fillColor.getOpacity()!==0){//绘制iconfont符号
            context.globalAlpha = fillColor.getOpacity();
            context.fillStyle = fillColor.toHexColor();
            context.fillText(dom.textContent,x,y);
        }

        if(outlineColor.getOpacity()!==0 && outlineWidth!==0){// 描边
            context.save();
            context.globalAlpha = outlineColor.getOpacity();
            context.lineWidth = outlineWidth;
            context.strokeStyle = outlineColor.toHexColor();
            context.strokeText(dom.textContent,x,y);
            context.restore();
        }
        // context.closePath();
        return true;
    }

    makeIconTexture(img,iconSym,positionX,positionY){
        this._context.globalAlpha = 1;
        this._context.drawImage(img,0,0,img.width,img.height,positionX,positionY,img.width,img.height);
        return true;
    }

    makeCircleTexture(circleSym,positionX,positionY){
        const radius = circleSym.getRadius();
        const fillColor = circleSym.getFillColor();
        const outLineColor = circleSym.getOutlineColor();
        const outLineWidth = circleSym.getOutlineWidth();
        this._context.beginPath();
        this._context.globalAlpha = 1;
        this._context.arc(positionX+radius+outLineWidth,positionY+radius+outLineWidth,radius,0,Math.PI*2,true);
        
        if(fillColor.getOpacity()!==0){
            this._context.globalAlpha = fillColor.getOpacity();
            this._context.fillStyle=fillColor.toHexColor();
            this._context.fill();
        }

        //绘制边框线
        if(outLineColor.getOpacity()!==0 && outLineWidth!==0){
            this._context.globalAlpha = outLineColor.getOpacity();
            this._context.strokeStyle=outLineColor.toHexColor();
            this._context.lineWidth = outLineWidth;
            this._context.stroke();
        }
        this._context.closePath();
        return true;
    }
};
;"use strict";
hmap.strategy=hmap.strategy||{};
/**
 * 图集管理类
 * @private
 * @type {hmap.strategy.AtlasManager}
 */
hmap.strategy.AtlasManager=class{
    /**
     * 构造图集管理器
     * @param {Number} atlasSize  用于图集大小，宽高相等，默认256，单位“像素”。
     * @param {Number} atlasSpace 在保存标记符号的图集中，符号和符号之间的间隔。单位“像素”
     * @param {Boolean} normalize 图集中每个文字或者标记符号的位置信息是否要归一化。true代表归一化；false代表不归一化。
     * @private
     */
    constructor(atlasSize=256,atlasSpace=1,normalize=true){
        this.CLASS_NAME = "hmap.strategy.AtlasManager";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        if(Number.isInteger(atlasSpace)&&(atlasSpace>=0&&atlasSpace<=50)
            &&Number.isInteger(atlasSize)&&(atlasSize>=0&&atlasSize<=2048)
            &&((typeof normalize) === "boolean")){
            this._atlasSpace=atlasSpace;
            this._atlasSize=atlasSize;
            this._normalize = normalize;
        }else{
            throw new Error("The parameters of Atlas are illegal,please check");
        }
        
        this._atlas = new hmap.strategy.Atlas(this._atlasSize,this._atlasSpace,this._normalize);

        // 保存加载过的iconfont样式文件，同一文件只加载一次
        this._iFontFiles = [];
        this.iconPromises = new Map();      //保存图标的异步加载promise，键为imgSrc
    }

    get atlas(){
        return this._atlas;
    }

    /**
     * 在图集上添加文字。 添加成功：返回纹理上的文字信息; 添加失败：返回null
     * @param {String} text 文字内容
     * @param {hmap.style.TextSymbol} txtSym 文本符号对象
     * @private
     */
    addText(text,txtSym){
        if((typeof text)==="string" && (txtSym instanceof hmap.style.TextSymbol)){
            return this._atlas.addText(text,txtSym);
        }else{
            throw new TypeError("the parameter is illegal.");
        }
    }

    /**
     * 添加标记符号
     * @param {hmap.style.MarkerSymbol} markerSym 标记符号对象
     * @param {Function} callback 回调函数
     * @private
     */
    addMarker(markerSym,callback){
        if(!markerSym || !markerSym.CLASS_NAME){
            throw new Error("the parameter is illegal");
        }
        const className = markerSym.CLASS_NAME;
        switch(className){
            case "hmap.style.Icon":
                let imgSrc = markerSym.getImgSrc();
                this.iconPromises.set(imgSrc,this._addIcon(markerSym));
                return this.iconPromises.get(imgSrc);           //返回这个异步promise
                break;
            case "hmap.style.IconFont":
                this._addIconfont(markerSym,callback);
                break;
            case "hmap.style.Circle":
                return this._addCircle(markerSym,callback);
            default:
                throw new TypeError("the parameter is illegal.");
        }
    }
    /**
     * 根据文字内容和样式，获取文字纹理坐标等信息 若不存在，则进行添加，添加后返回文字的信息。
     * @param {String} text 
     * @param {hmap.style.TextSymbol} txtSym 文字符号的对象
     * @private
     */
    getTextInfo(text,txtSym){
        if((typeof text)==="string" && (txtSym instanceof hmap.style.TextSymbol)){
            return this._atlas.getTextInfo(text,txtSym);
        }else{
            throw new TypeError("the parameter is illegal.");
        }
    }
    /**
     * 获取图标符号的信息
     * @param {hmap.style.MarkerSymbol} markerSym 标记符号的对象
     * @private
     */
    getMarkerInfo(markerSym){
        if(!markerSym || !markerSym.CLASS_NAME){
            throw new TypeError("the parameter is illegal.");
        }
        const className = markerSym.CLASS_NAME;
        switch(className){
            case "hmap.style.Icon":
                return this._atlas.getIconInfo(markerSym);
            case "hmap.style.IconFont":
                return this._atlas.getIconfontInfo(markerSym);
            case "hmap.style.Circle":
                return this._atlas.getCircleInfo(markerSym);
            default:
                throw new TypeError("the parameter is illegal.");
        }
    }
    /**
     * 获取图集的canvas画布
     * @returns {Object} canvas画布对象。
     * @private
     */
    getAtlasCanvas(){
        return this._atlas.getCanvas();
    }

    /**
     * 获取图集的像素数据
     * @returns {ImageData}
     * @private
     */
    getAtlasImageData(){
        let ctx=this._atlas.getContext();
        return ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
    }
    /**
     * 获取图集所有的绘制信息
     * @private
     */
    getAtlasInfos(){
        return this._atlas.getAtlasInfos();
    }
    /**
     * 先查找是否存在，不存在则添加字体图标
     * @param {hmap.style.IconFont} iFontSym 字体图标符号
     * @param {Function} callback 回调函数
     * @private
     */
    _addIconfont(iFontSym,callback){

        // 添加iconfont文件,只加载一次
        const iFontFileUrl = iFontSym.getFileUrl();
        const len = this._iFontFiles.length;
        if(len===0){
            iFontSym.addCss();
            this._iFontFiles.push(iFontFileUrl);
        }else{
            for(let i=0;i<len;i++){
                if(iFontFileUrl === this._iFontFiles[i]){//文件存在
                   break;
                }else if(i===len-1){ //不存在
                    iFontSym.addCss();
                    this._iFontFiles.push(iFontFileUrl);
                }
            }
        }
        this._atlas.addIconfont(iFontSym,callback);
    }
    /**
     * 在图集上添加图标。 添加成功：返回纹理上的Icon信息; 添加失败：返回null
     * @param {hmap.style.IconFont} iconSym 
     * @param {Function} callback
     * @private
     */
    _addIcon(iconSym){
        return this._atlas.addIcon(iconSym);
    }
    /**
     * @param {hmap.style.Circle} circleSym 圆形符号对象
     * @param {function} callback 回调函数
     * @private
     */
    _addCircle(circleSym,callback){
        return this._atlas.addCircle(circleSym,callback);
    }

    /**
     * 获取正在加载的promise
     * @private
     */
    getLoadingPromise(iconSym){
        return this.iconPromises.get(iconSym.getImgSrc());
    }

    /*****
     * 获取AtlasManager中的唯一实例，如果不存在则创建一个，如果存在则直接返回实例。
     * @param {Number} markerAtlasSize 图标图集的大小
     * @param {Number} textAtlasSize 文字图集的大小
     * @returns {hmap.strategy.AtlasManager} 返回图集管理器的实例化对象
     */
    // static getInstance(atlasSize){
    //     if(!this._instance) {
    //         this._instance = new hmap.strategy.AtlasManager(atlasSize);
    //     }
    //     return this._instance;
    // }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 标记符号，也叫点符号。是Icon、IconFont、RegularShape、Circle的基类。
 * 注意：当使用旋转功能时，出现图标被切角的情况时，请参考矢量图层的说明文档。
 * @abstract
 * @type {hmap.style.MarkerSymbol}
 */
hmap.style.MarkerSymbol = class{
    /**
     * 用于创建子类的基类，不能在程序中被实例化。
     * @param {Object} options 点符号的可选属性
     * @param {Number} options.opacity 透明度 范围为0~1.
     * @param {hmap.basetype.Offset} options.offset 点符号的偏移量，单位是像素。
     * @param {Number} options.rotation 旋转角度，单位是度。角度为正值进行逆时针旋转;角度为负值进行顺时针旋转。
     * @param {Number} options.sprite 是否使用雪碧图
     */
    constructor(options) {
        if (new.target === hmap.style.MarkerSymbol) {
            throw new SyntaxError("The MarkerSymbol is an abstract class,can not be instantiated!");
        }
        this._opacity = options.hasOwnProperty("opacity")?options.opacity:1.0;
        this._offset = options.hasOwnProperty("offset")?options.offset:new hmap.basetype.Offset(0,0,0);
        // this._atlasMgr = hmap.style.AtlasManager.getInstance();
        if(!((Number.isFinite(this._opacity)&&this._opacity>=0&&this._opacity<=1) && (this._offset instanceof hmap.basetype.Offset))){
            throw new TypeError("The extent of the parameter 'opacity' is [0,1] and parameter 'offset' must be hmap.basetype.Offset");
        }
        this._rotation = Number.isFinite(options.rotation)?options.rotation:0;

        //目前这两个参数都取默认值，绘制的代码中还没有使用这两个值
        this._rotateWithView = (typeof options.rotateWithView)==="boolean"?options.rotateWithView:false;
        this._scale = Number.isFinite(options.scale)?options.scale:1.0;
        this.sprite= options.sprite || false;//是否使用雪碧图
        this.CLASS_NAME = "hmap.style.MarkerSymbol";
    }

    /**
     * 获取符号的透明度。
     * @returns {Number} 透明度
     */
    getOpacity(){
        return this._opacity;
    }
    /**
     * 获得符号是否跟着地图旋转。
     * @returns {Boolean} 如果旋转返回true;如果不旋转，返回false
     * @example
     * let iconSymbol = new hmap.style.Icon();
     * let result = iconSymbol.getRotateWithView();//result=false
     */
    getRotateWithView(){
        return this._rotateWithView;
    }

    /**
     * 获取符号的旋转角度。
     * @returns {Number} 旋转角度,单位弧度
     */
    getRotation(){
        return this._rotation;
    }

    /**
     * 获取符号的缩放级别。
     * @returns {Number} 缩放级别
     */
    getScale(){
        return this._scale;
    }

    /**
     * 获取偏移量对象
     * @returns {hmap.basetype.Offset} 偏移量
     */
    getOffset(){
        return this._offset;
    }

    /**
     * 设置透明度。
     * @param {Number} opacity 透明度,透明度的范围是0~1.
     * @throws opacity参数的值不在0~1之间。
     */
    setOpacity(opacity){
        if(Number.isFinite(opacity)&&opacity>=0&&opacity<=1){
            this._opacity = opacity;
        }else{
            throw new TypeError("The extent of the parameter 'opacity' is [0,1]");
        }
    }
    /**
     * 设置是否跟着视图旋转。 暂未启用。
     * @param {Boolean} rotateWithView  旋转是true;不旋转是false
     * @throws 传入的参数rotateWithView不是布尔类型。
     * @example
     * let iconSymbol = new hmap.style.Icon();
     * iconSymbol.setRotateWithView(true);
     * let result = iconSymbol.getRotateWithView();//result=true
     */
    setRotateWithView(rotateWithView){
        if(typeof rotateWithView ==="boolean") {
            this._rotateWithView = rotateWithView;
        }else{
            throw new TypeError("The rotateWithView should be boolean type");

    }  }

    /**
     * 设置旋转角度,单位是角度。
     * @param {Number} rotation 旋转角度
     */
    setRotation(rotation){
        if(!Number.isFinite(rotation)){
            throw new TypeError("The opacity should be a number");
        }
        this._rotation = rotation;
    }
    /**
     * 设置符号的缩放级别。 暂未启用。
     * @param {Number} scale
     */
    setScale(scale){
       if(!Number.isFinite(scale)){
           throw new TypeError("The scale should be a number");
       }
        this._scale = scale;
    }

    /**
     * 设置偏移量。
     * @param {hmap.basetype.Offset} offset 偏移值
     */
    setOffset(offset){
        if(!(offset instanceof hmap.basetype.Offset)){
            throw new TypeError("The parameter must be a hmap.basetype.Offset");
        }
        this._offset = offset;
    }

};
;"use strict";
hmap.style = hmap.style || {};
/**
 * 文本符号。
 * 注意：当使用文字倾斜或旋转功能时，出现文字被切角的情况时，请参考矢量图层的说明文档。
 * @type {hmap.style.TextSymbol}
 * @example
 * let textSymbol = new hmap.style.TextSymbol({
    fontWeight: 'normal',//字的粗细
    fontStyle: "normal",//斜体等
    fontSize: 16,//字大小
    fontFace: "Microsoft YaHei",//字体
    text: "江南大道",
    offset: new hmap.basetype.Offset(1,1,0),
    placement: "point",//文本的放置方式
    rotateWithView: false,//是否跟着视图旋转
    rotation: 0,//旋转角度，单位为度
    textAlign: "center",//文本横向排列方式，分为center、left、right，end，start
    textBaseline: "top",//文本纵向排列方式，分为top、middle、bottom
    overflow: false,//是否允许文本超出多边形或线的路径长度
    fontColor: new hmap.style.Color(6,6,6,1),//字体填充颜色
    haloColor: new hmap.style.Color(255,1,1,1),//字体描边颜色
    haloWidth: 1,//字体描边宽
    backgroundColor: new hmap.style.Color(157,200,247,1),//背景填充颜色
    maxAngle: Math.PI/4,   //允许相邻文字之间的最大角度，单位弧度
    opacity: 0.5
 * });
 */
hmap.style.TextSymbol=class{
    /**
     * 构造函数。
     * @param {Object} options 文本符号的可选属性
     * @param {String} options.fontWeight 字体的粗细，默认值为'normal'。其他可选值为‘bold’和'bolder'。
     * @param {String} options.fontStyle 字体类型，默认为'normal'。
     * @param {int} options.fontSize 字体大小，默认值为20.
     * @param {String} options.fontFace 字体族 与ccs中的font-family相同。默认值为'Microsoft YaHei'。
     * @param {String} options.text 要显示的文字内容。如果要根据要素中属性字段名确定内容，请使用‘{name}’这种格式定义，name为字段名。
     * @param {hmap.basetype.Offset} options.offset 文字符号的偏移量,单位是像素。
     * @param {Number} options.rotation 旋转角度，默认值为0.
     * @param {String} options.textAlign 文字的水平（左右）排列方式，默认值为'center',其他可选值为'left'、'right'。
     * @param {String} options.textBaseline 文字的垂直（上下）排列方式，默认值为'middle',其他可选值为'top'、'bottom'。
     * @param {hmap.style.Color} options.fontColor 字体颜色值，默认为黑色。
     * @param {hmap.style.Color} options.haloColor 字体描边颜色，默认为完全透明的白色。
     * @param {Number} options.haloWidth 描边的宽度，单位为像素，默认为0.
     * @param {hmap.style.Color} options.backgroundColor 字体的背景颜色 默认为完全透明的白色。
     * @param {Number} options.rotation 旋转角度，单位是度。角度为正值进行逆时针旋转;角度为负值进行顺时针旋转。
     * @param {Number} options.rowTextCount 单行字的个数
     * @param {Number} options.opacity 透明度
     */
    constructor(options){
        options = options || {};
        this._fontWeight =options.hasOwnProperty("fontWeight")?this.setFontWeight(options.fontWeight):400;//字粗细
        this._opacity =options.hasOwnProperty("opacity")?this.setOpacity(options.opacity):1.0;//透明度
        this._fontStyle = options.hasOwnProperty("fontStyle")?this.setFontStyle(options.fontStyle):"normal";//字体类型eg：斜体
        this._fontSize = options.hasOwnProperty("fontSize")?this.setFontSize(options.fontSize):20;//字体大小
        this._fontFace = options.hasOwnProperty("fontFace")?this.setFontFace(options.fontFace):"Microsoft YaHei";//字体类型
        this._text = options.hasOwnProperty("text")?this.setText(options.text):"";//文本内容
        this._offset = options.hasOwnProperty("offset")?this.setOffset(options.offset):new hmap.basetype.Offset(0,0,0);
        this._placement = options.hasOwnProperty("placement")?this.setPlacement(options.placement):"point";//文本的放置方式
        this._rotateWithView = options.hasOwnProperty("rotateWithView")?this.setRotateWithView(options.rotateWithView):false;//是否跟着视图旋转
        this._rotation = options.hasOwnProperty("rotation")?this.setRotation(options.rotation):0;//旋转角度
        this._textAlign = options.hasOwnProperty("textAlign")?this.setTextAlign(options.textAlign):"center";//文本水平（左右）排列方式,point或者line都默认是center.
        this._textBaseline = options.hasOwnProperty("textBaseline")?this.setTextBaseline(options.textBaseline):"middle";//文本基线
        this._overflow = options.hasOwnProperty("overflow")?this.setOverflow(options.overflow):false;//是否允许溢出
        this._fontColor = options.hasOwnProperty("fontColor")?this.setFontColor(options.fontColor):new hmap.style.Color(0,0,0,1);//填充样式。默认黑色
        this._haloColor = options.hasOwnProperty("haloColor")?this.setHaloColor(options.haloColor):new hmap.style.Color(255,255,255,0);//描边样式，默认没有描边
        this._haloWidth = options.hasOwnProperty("haloWidth")?this.setHaloWidth(options.haloWidth):0;//描边的宽
        this._backgroundColor = options.hasOwnProperty("backgroundColor")?this.setBackgroundColor(options.backgroundColor):new hmap.style.Color(255,255,255,0);//背景填充样式
        this._maxAngle = options.hasOwnProperty("maxAngle")?this.setMaxAngle(options.maxAngle):Number((Math.PI*0.25).toFixed(6));//当放置方式为line时，允许相邻字符之间的最大角度,默认45度，传入弧度
        this._rowTextCount = options.hasOwnProperty("rowTextCount")?this.setRowTextCount(options.rowTextCount):6;//单行字的个数
        this.CLASS_NAME = "hmap.style.TextSymbol";
        this.sprite= options.sprite || false;//是否使用雪碧图
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }
    /**
     * 克隆一个新的文本符号
     * @example
     * let newTextSymbol = textSymbol.clone();
     */
    clone(){
        return new hmap.style.TextSymbol({
            fontWeight: this._fontWeight,
            fontStyle: this._fontStyle,
            fontSize: this._fontSize,
            fontFace: this._fontFace,
            text: this._text,
            offset: this._offset,
            placement: this._placement,
            rotateWithView: this._rotateWithView,
            rotation: this._rotation,
            textAlign: this._textAlign,
            textBaseline: this._textBaseline,
            overflow: this._overflow,
            maxAngle: this._maxAngle,
            opacity: this._opacity,
            fontColor: this._fontColor.clone(),
            haloColor: this._haloColor.clone(),
            haloWidth: this._haloWidth,
            backgroundColor: this._backgroundColor.clone(),
            rowTextCount:this._rowTextCount
        });
    }
    /**
     * 获取透明系数
     * @returns {Number} 透明系数
     * @example
     * let opacity = textSymbol.getOpacity();
     */
    getOpacity(){
        return this._opacity;
    }

    /**
     * 设置文字整体的透明系数
     * @param {Number} opacity 透明系数
     * @returns {hmap.style.TextSymbol} 返回文字对象
     * @example
     * textSymbol.setOpacity(0.5);
     */
    setOpacity(opacity){
        this._opacity = opacity;
        return this._opacity;
    }

    /**
     * 获取背景填充颜色
     * @returns {hmap.style.Color} 背景颜色值
     * @example
     * let backgroundColor = textSymbol.getBackgroundColor();
     */
    getBackgroundColor(){
        return this._backgroundColor;
    }

    /**
     * 获取填充颜色
     * @returns {hmap.style.Color} 字体颜色值
     * @example
     * let fontColor = textSymbol.getFontColor();
     */
    getFontColor(){
        return this._fontColor;
    }

    /**
     * 获取字体粗细
     * @returns {String} 字体的粗细
     * @example
     * let fontWeight = textSymbol.getFontWeight();
     */
    getFontWeight(){
        const fontWeight = this._fontWeight;
        if(fontWeight===700){
            return "bold";
        }else if(fontWeight===900){
            return "bolder";
        }else{
            return "normal";
        }
    }

    /**
     * 获取字体类型eg：斜体
     * @returns {String} 字体的类型。
     * @example
     * let fontStyle = textSymbol.getFontStyle();
     */
    getFontStyle(){
        return this._fontStyle;
    }

    /**
     * 获取字体大小
     * @returns {int} 字体大小。
     * @example
     * let fontSize = textSymbol.getFontSize();
     */
    getFontSize(){
        return this._fontSize;
    }

    /**
     * 获取字体的字族，比如'宋体'。
     * @returns {String} 返回字体的字族
     * @example
     * let fontFace = textSymbol.getFontFace();
     */
    getFontFace(){
        return this._fontFace;
    }

    /**
     * 获取相邻字符之间允许的最大夹角。 暂未启用。
     * @private
     * @example
     * let maxAngle = textSymbol.getMaxAngle();
     */
    getMaxAngle(){
        return this._maxAngle;
    }

    /**
     * 获取偏移量
     * @returns {hmap.basetype.Offset} 文字的偏移量。
     * @example
     * let offset = textSymbol.getOffset();
     */
    getOffset(){
        return this._offset;
    }


    /**
     * 获取是否允许溢出。暂未启用。
     * @private
     * @example
     * let overflow = textSymbol.getOverflow();
     */
    getOverflow(){
        return this._overflow;
    }

    /**
     * 获取放置方式。暂未启用。
     * @private
     * @example
     * let placement = textSymbol.getPlacement();
     */
    getPlacement(){
        return this._placement;
    }

    /**
     * 获取是否跟着视图旋转。暂未启用。
     * @returns {Boolean} 文字跟着地图视图旋转而旋转，返回true；不随着视图旋转而旋转，返回false.
     * @private
     * @example
     * let isRotateWithView = textSymbol.getRotateWithView();
     */
    getRotateWithView(){
        return this._rotateWithView;
    }

    /**
     * 获取旋转角度
     * @returns {Number} 文字的旋转角度。
     * @example
     * let rotation = textSymbol.getRotation();
     */
    getRotation(){
        return this._rotation;
    }

    /**
     * 获取文本内容
     * @returns {String} 文本内容。
     * @example
     * let text = textSymbol.getText();
     */
    getText(){
        return this._text;
    }

    /**
     * 获取文本水平（左右）排列方式
     * @returns {String} 'left'、'center'、'right'三者之一。
     * @example
     * let textAlign = textSymbol.getTextAlign();
     */
    getTextAlign(){
        return this._textAlign;
    }

    /**
     * 获取描边颜色
     * @returns {hmap.style.Color} 文字的描边颜色。
     * @example
     * let haloColor = textSymbol.getHaloColor();
     */
    getHaloColor(){
        return this._haloColor;
    }

    /**
     * 获取描边宽度
     * @returns {Number} 文字描边的宽度。
     * @example
     * let haloWidth = textSymbol.getHaloWidth();
     */
    getHaloWidth(){
        return this._haloWidth;
    }

    /**
     * 获取文本基线，即上下排列的方式。
     * @returns {String} ’top‘、’bottom‘、’middle‘三者之一。
     * @example
     * let textBaseline = textSymbol.getTextBaseline();
     */
    getTextBaseline(){
        return this._textBaseline;
    }

    /**
     * 获取每行文字个数的最大值
     * @returns {Number} 每行文字个数的最大值
     * @example
     * let rowTextCount = textSymbol.getRowTextCount();
     */
    getRowTextCount(){
        return this._rowTextCount;
    }

    /**
     * 设置每行文字个数的上限
     * @param {Number} rowTextCount  文字个数的上限
     * @returns {Number} 修改后的每行文字个数的上限
     * @example
     * let rowTextCount = textSymbol.setRowTextCount(rowTextCount);
     */
    setRowTextCount(rowTextCount){
        if(!Number.isInteger(rowTextCount)||rowTextCount<0){
            throw new TypeError("Parameter should be a number and greater than or equal to zero!");
        }
        this._rowTextCount = rowTextCount;
        return this._rowTextCount;
    }


    /**
     * 设置背景填充颜色
     * @param {hmap.style.Color} color  背景填充色
     * @returns {hmap.style.Color} 修改后的背景填充色
     * @example
     * let color = new hmap.style.Color(255,0,0,1);
     * let backgroundColor = textSymbol.setBackgroundColor(color);
     */
    setBackgroundColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw new TypeError("Parameter 'color' must be hmap.style.Color");
        }
        this._backgroundColor = color;
        return this._backgroundColor;
    }

    /**
     * 设置字体粗细，默认是"normal"。可以传入的值包括："normal"、"bold"、"bolder",传入其它异常值，会导致不可预估的错误！
     * @param {String} fontWeight 字体粗细
     * @returns {String} 返回修改后的字体粗细
     * @example
     * textSymbol.setFontWeight("bold");
     * let result = textSymbol.getFontWeight();//result="bold"
     */
    setFontWeight(fontWeight){
        switch(fontWeight){
            case "normal":
                this._fontWeight = 400;
                break;
            case "bold":
                this._fontWeight = 700;
                break;
            case "bolder":
                this._fontWeight = 900;
                break;
            default:
                this._fontWeight = fontWeight;
                break;
        }
        return this._fontWeight;
    }

    /**
     * 设置字体样式。默认是“normal”，可取的值包括“normal”、“italic”、“oblique”。
     * normal  默认值。浏览器显示一个标准的字体样式。
     * italic  浏览器会显示一个斜体的字体样式。
     * oblique 浏览器会显示一个倾斜的字体样式。
     * @param {String} fontStyle 字体样式
     * @returns {String} 字体样式
     * @example
     * let fontStyle = textSymbol.setFontStyle("italic");
     */
    setFontStyle(fontStyle){
        if(fontStyle === "normal"||fontStyle === "italic"||fontStyle === "oblique"){
            this._fontStyle = fontStyle;
            return this._fontStyle;
        }else{
            throw new TypeError("Parameter 'fontStyle' must be string,for example: 'normal'、'italic'、'oblique'");
        }
    }

    /**
     * 设置字体大小。
     * @param {Number} fontSize  字体大小,单位像素。默认是20。理论上支持所有的非负整数，根据一般需求，建议定义13-64之间的整数。
     * @returns {Number} 返回修改后的字体大小
     * @example
     * let result = textSymbol.setFontSize(25);
     */
    setFontSize(fontSize){
        if(!Number.isInteger(fontSize)||fontSize<0){
            throw new TypeError("Parameter should be a number and greater than or equal to zero!");
        }
        this._fontSize = fontSize;
        return this._fontSize;
    }


    /**
     * 设置字体族名称。参数fontFace即css中的fontFamily,但是只支持单个字体族名称，不支持多个字体族组成的列表。 默认值是“Microsoft YaHei”，其他可取的值包括："arial"、"serif"、"sans-serif"、"monospace"、"fantasy"、"cuisive"等， 中文字体："宋体"、"微软雅黑"、"华文细黑"、"黑体"等。
     * @param {String} fontFace 字体族名称
     * @returns {String} 返回修改后的字体族名称
     * @example
     * textSymbol.setFontFace("楷体");
     * let result = textSymbol.getFontFace();//result="楷体"
     */
    setFontFace(fontFace){
        if(!fontFace||(typeof fontFace !== "string")){
            throw new TypeError("Parameter 'fontFace' must be string");
        }
        this._fontFace = fontFace;
        return this._fontFace;
    }

    /**
     * 设置字体的颜色
     * @param {hmap.style.Color} color 字的填充色。
     * @returns {hmap.style.Color} 返回修改后的字的填充色
     * @example
     * let color = new hmap.style.Color(255,0,0,1);
     * let result = textSymbol.setFontColor(color);
     */
    setFontColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw new TypeError("Parameter 'color' must be hmap.style.Color");
        }
        this._fontColor = color;

        return this._fontColor;
    }

    /**
     * 设置字的描边颜色
     * @param {hmap.style.Color} color 描边颜色
     * @returns {hmap.style.Color} 返回修改后的字的描边色
     * @throws 传入的color参数值不是Color对象。
     * @example
     * let color = new hmap.style.Color(255,1,1,1);
     * let haloColor = textSymbol.setHaloColor(color);
     */
    setHaloColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw new TypeError("Parameter 'color' must be hmap.style.Color");
        }
        this._haloColor = color;
        return this._haloColor;
    }

    /**
     * 设置描边宽度
     * @param {Number} width 大于等于0
     * @returns {Number} 描边的宽度。
     * @throws 传入的width参数不是数字类型，或小于0.
     * @example
     * let haloWidth = textSymbol.setHaloWidth(3);
     */
    setHaloWidth(width){
        if(!Number.isFinite(width)||width<0){
            throw new TypeError("Parameter 'width' must be number");
        }
        this._haloWidth = width;
        return this._haloWidth;
    }

    /**
     * 设置相邻字符间允许的最大角度（暂未启用）。
     * @param {Number} maxAngle 角度
     * @private
     * @example
     * let maxAngle = textSymbol.setMaxAngle(Math.PI/4);
     */
    setMaxAngle(maxAngle){
        if(!Number.isFinite(maxAngle)){
            throw new TypeError("Parameter 'maxAngle' must be number");
        }
        this._maxAngle = maxAngle;
        return this._maxAngle;
    }

    /**
     * 设置文字标注的偏移量。
     * @param {hmap.basetype.Offset} offset 偏移量。表示文字相对于坐标点的偏移量，Offset对象的xyz分别表示在X、Y、Z轴上的偏移，单位为像素。z值一般为0,x、y的取值根据文字离坐标点的距离来设定。
     * @returns {hmap.basetype.Offset} 返回修改后的偏移量
     * @example
     * let offset = new hmap.basetype.Offset(1,1,0);
     * textSymbol.setOffset(offset);
     * let result = textSymbol.getOffset();//result=new hmap.basetype.Offset(1,1,0)
     */
    setOffset(offset){
        if(!(offset instanceof hmap.basetype.Offset)){
            throw new TypeError("Parameter 'offset' must be hmap.basetype.Offset");
        }
        this._offset = offset;
        return this._offset;
    }

    /**
     * (暂未启用)用于面的标注和放置方式为line的情况下，是否允许文本超出多边形或线的路径长度
     * @param {Boolean} overflow 设置是否允许溢出。
     * @returns {Boolean} 返回修改后的设置值
     * @private
     * @example
     * textSymbol.setOverflow(false);
     * let result = textSymbol.getOverflow();//result=false
     */
    setOverflow(overflow){
        if(!(typeof overflow === "boolean")){
            throw new TypeError("Parameter 'overflow' must be boolean");
        }
        this._overflow = overflow;
        return this._overflow;
    }

    /**
     * 设置文本的放置方式，包括"point"和"line"两种。
     * @param {String} placement 放置方式
     * @returns {String} 返回修改后的放置方式
     * @private
     * @example
     * textSymbol.setPlacement("point");
     * let result = textSymbol.getPlacement();//result="point"
     */
    setPlacement(placement){
        if(placement!=="point" && placement!=="line"){
            throw new TypeError("Parameter 'placement' must be string");
        }
        this._placement = placement;
        return this._placement;
    }

    /**
     * (暂未开启)设置文本是否旋转
     * @param {Boolean} rotateWithView
     * @returns {Boolean}
     * @private
     * @example
     * let result = textSymbol.setRotateWithView(false);
     */
    setRotateWithView(rotateWithView){
        if(!(typeof rotateWithView === "boolean")){
            throw new TypeError("Parameter 'rotateWithView' must be boolean");
        }
        this._rotateWithView = rotateWithView;
        return this._rotateWithView;
    }

    /**
     * 设置旋转角度
     * @param {Number} rotation 旋转角度。单位弧度
     * @returns {Number} 返回修改后的旋转角度
     * @example
     * textSymbol.setRotation(Math.PI/4);
     * let result = textSymbol.getRotation();//result=Math.PI/4
     */
    setRotation(rotation){
        if(!Number.isFinite(rotation)){
            throw new TypeError("Parameter 'rotation' must be number");
        }
        this._rotation = rotation;
        return this._rotation;
    }

    /**
     * 设置文本内容
     * @param {String} text 文本内容
     * @returns {String} 返回修改后的文本内容
     * @example
     * textSymbol.setText("江陵路");
     * let result = textSymbol.getText();//result="江陵路"
     */
    setText(text){
        if(!(typeof text === "string")){
            throw new TypeError("Parameter 'text' must be string");
        }
        this._text = text;
        return this._text;
    }

    /**
     * 设置文本排列方式
     * @param {String} textAlign 文本横向排列方式。枚举值是：'left'，'right'，'center'。
     * @returns {String} 返回修改后的横向排列方式
     * @example
     * textSymbol.setTextAlign("left");
     * let result = textSymbol.getTextAlign();//result="left"
     */
    setTextAlign(textAlign){
        if(textAlign==="left"||textAlign==="right"||textAlign==="center"||textAlign==="end"||textAlign==="start"){
            this._textAlign = textAlign;
        }else{
            throw new TypeError("Parameter 'textAlign' must be string");
        }
        return this._textAlign;
    }

    /**
     * 设置文本基线
     * @param {String} textBaseline 纵向排列方式。枚举值是："middle" "bottom" "top"
     * @returns {String} 返回修改后的纵向排列方式
     * @example
     * textSymbol.setTextBaseline("bottom");
     * let result = textSymbol.getTextBaseline();//result="bottom"
     */
    setTextBaseline(textBaseline){
        if(textBaseline==="middle"||textBaseline==="bottom"||textBaseline==="top"){
            this._textBaseline = textBaseline;
        }else{
            throw new TypeError("Parameter 'textBaseline' must be string");
        }
        return this._textBaseline;
    }

    /**
     * 给图层VectorLayer调用的，用来返回文字个数（textNum）、纹理大小（size）、透明度（opacity）、偏移量（offset）、颜色值（color）、纹理位置坐标（x、y、w、h）。
     * @param {Object} options 可选项
     * @param {String} options.text 文本符号的内容
     * @param {Function} callback 回调函数
     * @private
     */
    getRenderData(options,callback){
        const atlasMgr = options.atlasMgr;
        // const resolution=options.resolution;
        const text = options.text;
        let textNum,    //文字个数
            sizeArr = [],    //点大小
            opacityArr = [], //点透明度
            offsetArr = [],	 //点偏移
            fontColorArr = [],//文字颜色
            haloColorArr = [],//描边色
            bgColorArr = [],//背景色
            textureCoord = [],//纹理坐标
            rotation=[],//旋转角度
            haloWidthArr=[];//描边宽

        //文字个数
        textNum = text.length;

        // 透明系数
        const opacity = this.getOpacity();

        //文字大小
        const fontSize = this.getFontSize();
        //const wdis=fontSize;
        const hasHalo = this.getHaloWidth()?true:false;

        const haloWidth = this.getHaloWidth();
        const fontColor = this.getFontColor().toNormalizeArray();
        const haloColor = this.getHaloColor().toNormalizeArray();
        const bgColor = this.getBackgroundColor().toNormalizeArray();
        //先计算文字中心的位置
        const xOffset = this.getOffset().getValue("X");
        const yOffset = -this.getOffset().getValue("Y");
        const align = this.getTextAlign();
        const baseline = this.getTextBaseline();
        const angle = this.getRotation()*Math.PI/180;
        const rowTextNum = this.getRowTextCount();//每行字数量的最大值

        // 按行存储，words=[一行字，二行字....];
        let words=[];
        for(let i=0,len=Math.ceil(textNum/rowTextNum);i<len;i++){
            if(i==len-1){
                words.push(text.substr(i*rowTextNum));
                break;
            }
            words.push(text.substr(i*rowTextNum, rowTextNum));
        }

        // 按行循环
        for(let i=0,rowNum=words.length;i<rowNum;i++){

            const rowWords=words[i];//每一行所有字
            const wordNum=rowWords.length;
            const rowByteLen = this._calulateTotalByteLen(rowWords);
            const rowHalfSize = fontSize/2*rowByteLen/2;
            const colHalfSize = rowNum*fontSize/2;

            //计算水平方向的偏移
            let alignOffset=0;
            switch(align){
                case "left":
                    alignOffset = -rowHalfSize;
                    break;
                case "right":
                    alignOffset = rowHalfSize;
                    break;
                case "center":
                    alignOffset = 0;
                    break;
            }
            let finalXOffset = xOffset + alignOffset;

            //计算垂直方向的偏移
            let rowYOffset;//每行偏移不同的量
            if(rowNum%2){//奇数行
                const middleRow = Math.floor(rowNum/2);
                rowYOffset = (middleRow-i)*fontSize;
            }else{//偶数行
                const middleRow = Math.floor(rowNum/2)-0.5;
                rowYOffset = (middleRow-i)*fontSize;
            }
            let baselineOffset = 0;
            switch(baseline){
                case "top":
                    baselineOffset = rowYOffset  + colHalfSize;
                    break;
                case "bottom":
                    baselineOffset = rowYOffset - colHalfSize;
                    break;
                case "middle":
                    baselineOffset = rowYOffset;
                    break;
            }
            let finalYOffset = yOffset+baselineOffset;

            // 由于旋转，每行中心不在一列上
            const adjustX = -rowYOffset*Math.sin(angle);
            const adjustY = rowYOffset*Math.cos(angle)-rowYOffset;
            finalXOffset+=adjustX;
            finalYOffset+=adjustY;
            //循环计算每个文字的偏移量
            let leftSize=0;
            const singleByteSize = fontSize/2;
            const doubleByteSize = fontSize;
            for(let j=0;j<wordNum;j++){
                const wordSize = rowWords.charCodeAt(j)<255?singleByteSize:doubleByteSize;
                leftSize += rowWords.charCodeAt(j)<255?0:0;//调整字间隔
                leftSize+=wordSize/2;
                const l = -rowHalfSize+leftSize;
                leftSize+=wordSize/2;
                leftSize += rowWords.charCodeAt(j)<255?-1:-1;//调整字间隔

                const wordXoffset = l*Math.cos(angle);
                const wordYoffset = l*Math.sin(angle);

                let textInfo = atlasMgr.addText(rowWords[j],this);
                textureCoord.push(textInfo.x);
                textureCoord.push(textInfo.y);
                textureCoord.push(textInfo.width);
                textureCoord.push(textInfo.height);

                //文字大小
                sizeArr.push(fontSize);
                sizeArr.push(fontSize);

                //偏移量 单位为像素，着色器内根据分辨率计算地图单位的偏移量
                offsetArr.push(finalXOffset+wordXoffset);
                offsetArr.push(finalYOffset+wordYoffset);
                // offsetArr.push(0.0);

                //颜色值
                for(let j=0; j<4; j++){
                    fontColorArr.push(fontColor[j]);
                    haloColorArr.push(haloColor[j]);
                    bgColorArr.push(bgColor[j]);
                }
                // 描边宽
                haloWidthArr.push(haloWidth);

                //透明系数
                opacityArr.push(opacity);

                //旋转角度
                rotation.push(angle);

            }
        }
        let resJson = {};//保存返回的结果
        resJson.textNum = textNum;
        resJson.size = sizeArr;
        resJson.opacity = opacityArr;
        resJson.offset = offsetArr;
        resJson.textureCoord = textureCoord;
        resJson.angle = rotation;
        resJson.fontColor = fontColorArr;
        resJson.haloColor = haloColorArr;
        resJson.bgColor = bgColorArr;
        resJson.haloWidth = haloWidthArr;

        if(callback)
            callback(resJson);
        return resJson;

    }

    // *
    //  * 判断一个字符是否为单字节。
    //  * @param word
    //  * @returns {Boolean} 单字节返回true，双字节返回false。
    //  * @private

    // _isSingleByte(word) {
    //     return word.charCodeAt() < 255;
    // }

    /**
     * 计算总字节长度
     * @param {String} words 汉字、数字或字母构成的字符串
     * @returns {Number}
     * @private
     */
    _calulateTotalByteLen(words){
        let byteLen=0;
        for(let i=0,num=words.length;i<num;i++){
            if(words.charCodeAt(i)<255){
                byteLen +=1;
            }else{
                byteLen +=2;
            }
        }
        return byteLen;
    }
};;"use strict";
hmap.style = hmap.style||{};
/**
 * 规则形状的矢量点符号。
 * @abstract
 * @type {hmap.style.RegularShape}
 * @extends hmap.style.MarkerSymbol
 */
hmap.style.RegularShape = class extends hmap.style.MarkerSymbol{
    /**
     * 构造函数
     * @param {Object} options 规则矢量符号的可选项
     * @param {hmap.style.Color}  options.fillColor 填充颜色对象
     * @param {hmap.style.Color} options.outlineColor 边框颜色对象
     * @param {Number}  options.outlineWidth 外边框的宽度，单位是像素
     * @private
     */
    constructor(options){
        if (new.target === hmap.style.RegularShape) {
            throw new SyntaxError("The RegularShape is an abstract class,can not be instantiated!");
        }
        super(options);
        this._fillColor = options.hasOwnProperty("fillColor")?options.fillColor:new hmap.style.Color(255,0,0,1);
        this._outlineColor = options.hasOwnProperty("outlineColor")?options.outlineColor:new hmap.style.Color(0,0,0,1);
        this._outlineWidth = options.hasOwnProperty("outlineWidth")?options.outlineWidth:1;

        if(!((this._fillColor instanceof hmap.style.Color)&&(this._outlineColor instanceof hmap.style.Color)&&(Number.isFinite(this._outlineWidth)))){
            throw new TypeError("Parameter 'fillColor' and 'outlineColor' must be hmap.style.Color and parameter 'outlineWidth' must be a number");
        }
        this._vertexNum = options.vertexNum!==undefined?options.vertexNum:3;
        // // 其他多边形特有属性，删除
        // this._vertexNum = options.vertexNum!==undefined?options.vertexNum:3;
        // this._outerRadius = options.outerRadius?options.outerRadius:0;
        // this._innerRadius = options.innerRadius?options.innerRadius:0;
        // this._size = options.size?options.size:new hmap.basetype.Size(10,10);
        this.CLASS_NAME = "hmap.style.RegularShape";
    }

    /**
     * 设置填充颜色
     * @private
     * @param {hmap.style.Color} fillColor 填充颜色
     */
    setFillColor(fillColor){
        if(!(fillColor instanceof hmap.style.Color)) {
            throw new TypeError("Parameter 'fillColor' must be hmap.style.Color");
        }
        this._fillColor = fillColor;
    }

    /**
     * 获取填充颜色。
     * @returns {hmap.style.Color} 填充颜色
     */
    getFillColor(){
        return this._fillColor;
    }

    /**
     * 设置边框线符号的颜色。
     * @param {hmap.style.Color} color 边框线颜色
     */
    setOutlineColor(color) {
        if(!(color instanceof hmap.style.Color)) {
            throw new TypeError("Parameter 'color' must be hmap.style.Color");
        }
        this._outlineColor = color;
    }

    /**
     * 获取图形外边框的颜色
     * @returns {hmap.style.Color} 边框线颜色
     */
    getOutlineColor(){
        return this._outlineColor;
    }

    /**
     * 设置边框线符号的宽度。
     * @param {Number} width 边框线宽度
     * @throws width参数的值不是数字类型
     */
    setOutlineWidth(width){
        if(Number.isFinite(width)) {
            this._outlineWidth = width;
        }else{
            throw new TypeError("Parameter 'width' must be Number");
        }
    }

    /**
     * 获取边框线符号的宽度。
     * @returns {Number} 线符号的宽度
     */
    getOutlineWidth(){
        return this._outlineWidth;
    }

    /**
     * 获取符号大小。暂未启用。
     * @returns {Number} 符号大小
     */
    getSize(){
        return this._size;
    }

    /**
     * 设置大小。暂未启用。
     * @param {hmap.basetype.Size} size 大小
     */
    setSize(size){
        if(!(size instanceof hmap.basetype.Size)) {
            throw new TypeError("Parameter 'size' must be hmap.basetype.Size");
        }
        this._size = size;
    }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 圆形符号。
 * @type {hmap.style.Circle}
 * @extends hmap.style.RegularShape
 * @example
 * let circle = new hmap.style.Circle({
 *      "radius":20,
 *      "fillColor":new hmap.style.Color(255,0,0,1),
 *      "outlineColor":new hmap.style.Color(0,0,0,1),
 *      "outlineWidth":1,
 *      "rotation":0
 * });
 */
hmap.style.Circle = class extends hmap.style.RegularShape{
    /**
     * 构造函数
     * @param {Object} options 圆形符号的可选项
     * @param {Number} options.radius 圆符号的半径(单位:像素)
     */
    constructor(options){
        options = options||{};
        super(options);
        this._radius = options.hasOwnProperty("radius")?options.radius:10;
        if(!Number.isFinite(this._radius)){
            throw new TypeError('Parameter "radius" must be a number');
        }
        this.CLASS_NAME = "hmap.style.Circle";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 复制一个新的圆形符号。
     * @returns {hmap.style.Circle} 新的圆形符号，与被复制的相同。
     * @example
     * let circle = new hmap.style.Circle();
     * let result = circle.clone();
     */
    clone(){
        const options = {
            radius:this._radius,
            fillColor:this._fillColor.clone(),
            outlineColor:this._outlineColor.clone(),
            outlineWidth:this._outlineWidth,
            offset:this._offset.clone()
        };
        return new hmap.style.Circle(options);
    }
    /**
     * 获取符号半径
     * @returns {Number} 圆形符号的半径，像素单位
     * @example
     * let circle = new hmap.style.Circle();
     * let result = circle.getRadius();
     */
    getRadius(){
        return this._radius;
    }

    /**
     * 设置圆形符号半径
     * @param {Number} radius 圆形符号的半径，像素单位
     * @example
     * let circle = new hmap.style.Circle();
     * circle.setRadius(100);
     */
    setRadius(radius){
        if(!Number.isFinite(radius)){
            throw "The radius should be a number.";
        }
        this._radius = radius;
    }

    /**
     * 私有方法,返回渲染时需要的数据内容，内容如下：
     * size：圆形符号的大小
     * opacity：符号的透明度
     * offset：符号的偏移量
     * textColor：纹理的颜色，默认值为[0,0,0,0]
     * textureCoord：字体图标的纹理坐标
     * @private
     * @param options 可选项，备用。暂未启用。
     * @param callback 回调函数
     *
     */
    getRenderData(options,callback){
        const atlasMgr = options.atlasMgr;
        const sizeArr =[],    //点大小
            opacityArr=[], //点透明度
            offsetArr=[],	//点偏移
            textColorArr=[],//纹理颜色
            textureCoord=[],//纹理坐标
            rotation=[];//旋转角度
        //图标大小
        const circleSize = this.getRadius()*2;
        sizeArr.push(circleSize,circleSize);
        //透明度
        opacityArr.push(this.getOpacity());
        //图标最终的偏移量
        const xOffset = this.getOffset().getValue("X");
        const yOffset = this.getOffset().getValue("Y");
        offsetArr.push(xOffset);
        offsetArr.push(yOffset);

        //颜色值
        textColorArr.push(1.0);
        textColorArr.push(1.0);
        textColorArr.push(1.0);
        textColorArr.push(1.0);

        //旋转角度
        rotation.push(this.getRotation()*Math.PI/180);

        const resJson = {};//保存返回的结果
        resJson.size = sizeArr;
        resJson.opacity = opacityArr;
        resJson.offset = offsetArr;
        resJson.textColor = textColorArr;
        resJson.bgColor = [0.0,0.0,0.0,0.0];
        resJson.angle = rotation;
        resJson.hasHalo = [true];


        const iconInfo = atlasMgr.getMarkerInfo(this);
        //从图集中获取图标的纹理位置信息
        if(iconInfo){
            textureCoord.push(iconInfo.x);
            textureCoord.push(iconInfo.y);
            textureCoord.push(iconInfo.width);
            textureCoord.push(iconInfo.height);

            resJson.textureCoord = textureCoord;
            callback(resJson);//return resJson;//返回结果
        }else{
            atlasMgr.addMarker(this,function(iconInfo){
                    textureCoord.push(iconInfo.x);
                    textureCoord.push(iconInfo.y);
                    textureCoord.push(iconInfo.width);
                    textureCoord.push(iconInfo.height);

                    resJson.textureCoord = textureCoord;
                    callback(resJson);//return resJson;//返回结果
                }.bind(this)
            );
        }
    }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 图标符号。
 * @type {hmap.style.Icon}
 * @extends hmap.style.MarkerSymbol
 * @example
 * let icon = new hmap.style.Icon({
        "color":new hmap.style.Color(0.0,0.0,0.0,0.0),
        "imgSrc":"/images/logo.png",
        "size":new hmap.basetype.Size(32, 32),
        "anchor":[0.5,0.5],
        "offset":new hmap.basetype.Offset(0,0,0),
        "rotation":0
 * });
 */
hmap.style.Icon = class extends hmap.style.MarkerSymbol {
    /**
     * 构造函数
     * @param {JSON} options Icon图标符号的可选项参数
     * @param {String} options.imgSrc 图片的路径，相对路径或绝对路径都可以
     * @param {hmap.basetype.Size} options.size 图片的大小。图片宽高比例不变，按照options.size第一个值缩放。单位为像素。默认宽为32。
     * @param {Array} options.anchor 锚点坐标，分数单位，默认将锚点定为图标的中心点，即[0.5,0.5]。图标的左上角为[0,0],右下角为[1,1]。
     * @param {Boolean} options.sprite 是否是雪碧图图标，默认为false。如果矢量图层使用雪碧图，且参数imgSrc为雪碧图中的图标，该参数需要为true。
     */
   constructor(options){
       options = options||{};
       super(options);
       this._color =options.hasOwnProperty("color")?options.color:new hmap.style.Color(0.0,0.0,0.0,0.0);
       this._imgSrc = options.imgSrc?options.imgSrc:"";
       this._size = options.size instanceof hmap.basetype.Size?options.size:(new hmap.basetype.Size(32, 32));
       this._anchor = options.anchor?options.anchor:[0.5,0.5];//锚点坐标，分数单位,默认将锚点定为图标的中心
       if(!(this._color instanceof hmap.style.Color)){
            throw new TypeError('Parameter "color" must be hmap.style.Color');
       }
       this.CLASS_NAME = "hmap.style.Icon";
       this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
   }

    /**
     * 克隆一个Icon对象
     * @returns {hmap.style.Icon} 克隆后的图标对象
     * @example
     * let newIcon = icon.clone();
     */
   clone(){
       const options = {
           color:this.getColor().clone(),
           imgSrc:this.getImgSrc(),
           offset:this.getOffset(),
           size:this.getSize(),
           anchor:this.getAnchor(),
           opacity:this.getOpacity()
       };
       return new hmap.style.Icon(options);
   }

    /**
     * 获取设置的color颜色。
     * @returns {Array} 颜色数组
     * @example
     * let color = icon.getColor();
     */
   getColor(){
       return this._color;
   }

    /**
     * 获取图标的图片地址
     * @returns {String} 图片地址
     * @example
     * let imgSrc = icon.getImgSrc();
     */
   getImgSrc(){
       return this._imgSrc;
   }

    /**
     * 获取符号的像素大小。
     * @returns {hmap.basetype.Size}
     * @example
     * let size = icon.getSize();
     */
   getSize(){
       return this._size;
   }
    /**
     * 获取锚点值。
     * @returns {Array}
     * @example
     * let anchor = icon.getAnchor();
     */
    getAnchor(){
       return this._anchor;
    }
    /**
     * 设置颜色值。暂未启用。
     * @param {hmap.style.Color} color 颜色值
     * @example
     * let color = new hmap.style.Color(255,1,1,1);
     * icon.setColor(color);
     */
   setColor(color){
       if(!(color instanceof hmap.style.Color)){
            throw new TypeError('Parameter "color" must be hmap.style.Color');
       }
       this._color = color;
   }

   /**
    * 设置图标的图片地址
    * @param {String} imgSrc 图片请求路径
    * @example
    * icon.setImgSrc("images/logo.png");
    */
   setImgSrc(imgSrc){
       this._imgSrc = imgSrc;
   }

    /**
     * 设置图标的大小，包括宽度和高度。
     * @param {hmap.basetype.Size} size
     * @example
     * icon.setSize(new hmap.basetype.Size(12,12));
     */
    setSize(size){
        if(size instanceof hmap.basetype.Size){
            this._size=size;
        }
    }

    /**
     * 设置图标符号的锚点。
     * @param {Array} anchor 锚点
     * @example
     * icon.setAnchor([0.5,0.5]);//锚点在图标的正中心
     * icon.setAnchor([0,0]);//锚点在图标的左上角
     * icon.setAnchor([0.5,1]);//锚点在图标的下边线的中心
     * icon.setAnchor([0.5,0]);//锚点在图标的上边线的中心
     * icon.setAnchor([1,0.5]);//锚点在图标的右边线的中心
     * icon.setAnchor([0,0.5]);//锚点在图标的左边线中心
     */
    setAnchor(anchor){
        if(anchor instanceof Array && anchor.length===2) {
            this._anchor[0] = anchor[0];
            this._anchor[1] = anchor[1];
        }else{
            throw new TypeError("The anchor should be Array.");
        }
    }

    /**
     * 返回渲染需要的数据内容（私有方法）
     * @private
     * @param options 暂未启用，留作后续扩展。
     * @param callback
     */
    getRenderData(options,callback){
        const atlasMgr = options.atlasMgr;
        let sizeArr =[],    //点大小
            opacityArr=[], //点透明度
            offsetArr=[],	//点偏移
            textColorArr=[],//文字颜色
            textureCoord=[],//纹理坐标
            rotation=[];//旋转角度
        //图标大小
        const pointSize = this.getSize();
        sizeArr.push(pointSize.getWidth(),pointSize.getHeight());
        //透明度
        opacityArr.push(this.getOpacity());
        //图标最终的偏移量
        let xOffset = pointSize.getWidth()*(0.5 - this.getAnchor()[0]) + this.getOffset().getValue("X");
        let yOffset = pointSize.getHeight()*(this.getAnchor()[1] - 0.5) - this.getOffset().getValue("Y");
        offsetArr.push(xOffset);
        offsetArr.push(yOffset);
        // offsetArr.push(0.0);

        //颜色值
        textColorArr.push(1.0);
        textColorArr.push(1.0);
        textColorArr.push(1.0);
        textColorArr.push(1.0);

        //旋转角度
        rotation.push(this.getRotation()*Math.PI/180);

        let resJson = {};//保存返回的结果
        resJson.size = sizeArr;
        resJson.opacity = opacityArr;
        resJson.offset = offsetArr;
        resJson.textColor = textColorArr;
        resJson.bgColor = [0.0,0.0,0.0,0.0];
        resJson.angle = rotation;
        resJson.hasHalo = [true];

        const iconInfo = atlasMgr.getMarkerInfo(this);
        if(iconInfo){                       //直接获取
            textureCoord.push(iconInfo.x);
            textureCoord.push(iconInfo.y);
            textureCoord.push(iconInfo.width);
            textureCoord.push(iconInfo.height);

            resJson.textureCoord = textureCoord;
            callback(resJson);//返回结果
        }else{
            let promise = atlasMgr.getLoadingPromise(this);       //是否正在加载
            if(!promise){
                promise = atlasMgr.addMarker(this)
            }
            promise.then(function(iconInfo){
                textureCoord.push(iconInfo.x);
                textureCoord.push(iconInfo.y);
                textureCoord.push(iconInfo.width);
                textureCoord.push(iconInfo.height);
                resJson.textureCoord = textureCoord;
                callback(resJson);
            })
        }
    }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 自定义字体图标类
 * @type {hmap.style.IconFont}
 * @extends hmap.style.MarkerSymbol
 * @example
 * let iconFont = new hmap.style.IconFont({
 *    "unicode":"&#61492;",//unicode编码
 *    "fileUrl":"./mapicon.ttf",//ttf文件的加载路径
 *    "opacity":1.0,//整个iconfont图标的透明度
 *    "anchor":[0,0],//偏移量，单位分数
 *    "fontSize":16,//大小
 *    "fillColor":new hmap.style.Color(255,255,255,0),//填充色
 *    "outlineColor":new hmap.style.Color(0,0,0,1),//外边框颜色
 *    "outlineWidth":1,//外边框宽度
 *    "rotation":0
 * });
 */
hmap.style.IconFont = class extends hmap.style.MarkerSymbol{
    /**
     * Iconfont的构造函数。 options参数中:fileUrl、unicode是必需的。其他属性是可选项。
     * @param {*} options
     * @param {String} options.fileUrl,字体文件(.ttf)的路径。
     * @param {String} options.unicode 字体图标的唯一标识，该标识需要是传入的ttf文件中存在的标识。
     * @param {Integer} options.fontSize 字体大小，对应的是图标的大小。
     * @param {hmap.style.Color} options.fillColor 字体图标的填充颜色，默认为白色，完全透明。
     * @param {hmap.style.Color} options.outlineColor 字体图标的描边颜色，默认为黑色。
     * @param {Number} options.outlineWidth 字体图标的描边宽度，默认值为1,单位是px.
     */
   constructor(options){
       options = options||{};
       super(options);
       this.CLASS_NAME = "hmap.style.IconFont";
       this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
       //以下两项父类中已有，不需要重复赋值。
        //this._opacity = (Number.isFinite(options.opacity)&&(options.opacity>=0.0)&&(options.opacity<=1.0))?options.opacity:1.0;
       this._anchor = options.anchor?options.anchor:[0.5,0.5];//锚点坐标，分数单位

       this._fontSize = Number.isInteger(options.fontSize)?options.fontSize:16;
       this._unicode = ((typeof options.unicode) === "string")?options.unicode:null;
       this._fillColor = (options.hasOwnProperty("fillColor")&&options["fillColor"])?options.fillColor:new hmap.style.Color(255,255,255,0);
       this._outlineColor = (options.hasOwnProperty("outlineColor")&&options["outlineColor"])?options.outlineColor:new hmap.style.Color(0,0,0,1);
       this._outlineWidth = Number.isInteger(options.outlineWidth)?options.outlineWidth:1;
       if((typeof options.fileUrl)==="string"){
          this._fileUrl = options.fileUrl;
          let fileArr = this._fileUrl.split("/");
          let arr = fileArr[fileArr.length-1].split(".");
          this._fontFamily = arr[0];
          switch(arr[1]){
            case "ttf":
              this._fileType = "truetype";break;
          }
       }else{
          this._fileUrl = null;
          this._fontFamily = null;
          this._fileType = null;
       }
       if(!(this._fillColor instanceof hmap.style.Color)||!(this._outlineColor instanceof hmap.style.Color)){
          throw new TypeError('Parameter "fillColor" and "outlineColor" must be hmap.style.Color');
       }

   }

   /**
    * 克隆一个字体图标符号。
    * @returns {hmap.style.IconFont}
    * @example
    * let newIconFont = iconFont.clone();
    */
   clone(){
      return new hmap.style.IconFont({
        rotateWithView: this._rotateWithView,
        rotation: this._rotation,
        scale: this._scale,
        fontSize: this._fontSize,
        unicode: this._unicode,
        fillColor: this._fillColor.clone(),
        outlineColor: this._outlineColor.clone(),
        outlineWidth: this._outlineWidth,
        fileUrl: this._fileUrl,
        opacity:this._opacity,
        anchor:this._anchor.slice()
      });
   }
   /**
    * 获取锚点的位置。
    * @returns {Array}
    * @example
    * let anchor = iconFont.getAnchor();
    */
   getAnchor(){
       return this._anchor;
   }
   /**
    * 获取字体图标的大小。
    * @returns {Number}
    * @example
    * let size = iconFont.getFontSize();
    */
   getFontSize(){
      return this._fontSize;
   }
   /**
    * 获取自定义字体图标的样式名
    * @returns {String}
    * @example
    * let fontFamily = iconFont.getFontFamily();
    */
   getFontFamily(){
      return this._fontFamily;
   }
   /**
    * 获取unicode
    * @returns {String}
    * @example
    * let unicode = iconFont.getUnicode();
    */
   getUnicode(){
      return this._unicode;
   }
   /**
    * 获取填充色
    * @returns {hmap.style.Color}
    * @example
    * let fillColor = iconFont.getFillColor();
    */
   getFillColor(){
      return this._fillColor;
   }
   /**
    * 获取描边颜色
    * @returns {hmap.style.Color}
    * @example
    * let outLineColor = iconFont.getOutlineColor();
    */
   getOutlineColor(){
      return this._outlineColor;
   }
   /**
    * 获取描边的宽度
    * @returns {Number}
    * @example
    * let outLineWidth = iconFont.getOutlineWidth();
    */
   getOutlineWidth(){
      return this._outlineWidth;
   }
   /**
    * 获取自定义字体图标的文件地址
    * @returns {String}
    * @example
    * let fileUrl = iconFont.getFileUrl();
    */
   getFileUrl(){
      return this._fileUrl;
   }
   /**
    * 获取自定义字体图标的文件类型
    * @returns {String}
    * @example
    * let fileType = iconFont.getFileType();
    */
   getFileType(){
      return this._fileType;
   }
   /**
    * 私有方法
    * @private
    */
   addCss(){
      let cssContent = `
            @font-face { 
                font-family:'`+ this._fontFamily +`';
                src: url('`+ this._fileUrl +`') format('`+ this._fileType +`');
            }
            .`+this._fontFamily+`{ 
                font-family:"`+ this._fontFamily +`"!important; 
            }
      `;
      let style = document.createElement("style");
      style.type = "text/css";
      style.innerHTML = cssContent;
        if(document.head){
          document.head.appendChild(style);
        }else{
          let interval = setInterval(function(){
            if(document.head){
              document.head.appendChild(style);
              clearInterval(interval);
            }
          },5);
        }
   }

   /**
    * 私有方法，返回字体样式名称。
    * @private
    * @returns {String} 字体样式名
    */
   getClassName(){
      return this._fontFamily;
   }
   /**
    * 设置锚点位置。
    * @param {Array} anchor
    * @example
    * iconFont.setAnchor([0.1,0.1]);
    */
   setAnchor(anchor){
       if(anchor instanceof Array && anchor.length===2) {
           this._anchor[0] = anchor[0];
           this._anchor[1] = anchor[1];
       }else{
           throw new TypeError("The anchor should be Array.");
       }
   }
   /**
    * 设置字体图标的大小。
    * @param {Number} fontSize
    * @example
    * iconFont.setFontSize(20);
    */
   setFontSize(fontSize){
      if(Number.isInteger(fontSize)){
        this._fontSize = fontSize;
      }
   }
   /**
    * 设置填充色
    * @param {hmap.style.Color} fillColor 填充色
    * @example
    * let fillColor = new hmap.style.Color(255,2,2,1);
    * iconFont.setFillColor(fillColor);
    */
   setFillColor(fillColor){
      if(!(fillColor instanceof hmap.style.Color)){
        throw new TypeError('Parameter "fillColor" must be hmap.style.Color');
      }
      this._fillColor = fillColor;
   }
   /**
    * 设置描边色
    * @param {hmap.style.Color} outlineColor 描边色
    * @example
    * let color = new hmap.style.Color(2,255,2,1);
    * iconFont.setOutlineColor(color);
    */
   setOutlineColor(outlineColor){
      if(!(outlineColor instanceof hmap.style.Color)){
        throw new TypeError('Parameter "outlineColor" must be hmap.style.Color');
      }
      this._outlineColor = outlineColor;
   }
   /**
    * 设置描边宽
    * @param {Number} outlineWidth 描边宽
    * @example
    * iconFont.setOutlineWidth(2);
    */
   setOutlineWidth(outlineWidth){
      if(Number.isInteger(outlineWidth)){
        this._outlineWidth = outlineWidth;
      }
   }
   /**
    * 设置unicode编码
    * @param {String} unicode
    * @example
    * iconFont.setUnicode("&#61489;");
    */
   setUnicode(unicode){
      if((typeof unicode) === "string"){
        this._unicode = unicode;
        return true;
      }
        return false;
   }
   /**
    * 设置字体图标文件的路径。
    * @param {String} fileUrl 字体图标文件的路径
    * @example
    * iconFont.setFileUrl("./mapicon.ttf");
    */
   setFileUrl(fileUrl){
      if((typeof fileUrl)==="string"){
          this._fileUrl = fileUrl;
          let fileArr = this._fileUrl.split("/");
          let arr = fileArr[fileArr.length-1].split(".");
          this._fontFamily = arr[0];
          switch(arr[1]){
            case "ttf":
              this._fileType = "truetype";break;
          }
          return true;
       }
        return false;
   }
   /**
    * 返回渲染时需要的内容，内容如下：
    * size：字体图标大小
    * opacity：字体图标的透明度
    * offset：图标的偏移量
    * textColor：字体图标的颜色,默认为[0,0,0,0]
    * textureCoord：字体图标的纹理坐标
    * @private
    * @param {Object} options 可选项，暂未启用。
    * @param {Function} callback 回调函数
    */

   getRenderData(options,callback){
       const atlasMgr = options.atlasMgr;
       let sizeArr =[],    //点大小
           opacityArr=[], //点透明度
           offsetArr=[],	//点偏移
           textColorArr=[],//纹理颜色
           textureCoord=[],//纹理坐标
           rotation=[];//旋转角度
       //图标大小
       const fontSize = this.getFontSize();
       sizeArr.push(fontSize,fontSize);
       //透明度
       opacityArr.push(this.getOpacity());
       //图标最终的偏移量
       let xOffset = (0.5 - this.getAnchor()[0])*fontSize + this.getOffset().getValue("X");
       let yOffset = (this.getAnchor()[1] - 0.5)*fontSize - this.getOffset().getValue("Y");
       offsetArr.push(xOffset);
       offsetArr.push(yOffset);
       // offsetArr.push(0.0);

       //颜色值
       textColorArr.push(1.0);
       textColorArr.push(1.0);
       textColorArr.push(1.0);
       textColorArr.push(1.0);

       //旋转角度
       rotation.push(this.getRotation()*Math.PI/180);

       let resJson = {};//保存返回的结果
       resJson.size = sizeArr;
       resJson.opacity = opacityArr;
       resJson.offset = offsetArr;
       resJson.textColor = textColorArr;
       resJson.bgColor = [0.0,0.0,0.0,0.0];
       resJson.angle = rotation;
       resJson.hasHalo = [true];


       const iconInfo = atlasMgr.getMarkerInfo(this);
       //从图集中获取图标的纹理位置信息
       if(iconInfo){
           textureCoord.push(iconInfo.x);
           textureCoord.push(iconInfo.y);
           textureCoord.push(iconInfo.width);
           textureCoord.push(iconInfo.height);

           resJson.textureCoord = textureCoord;
           callback(resJson);//返回结果
       }else{
           atlasMgr.addMarker(this,function(iconInfo){
                   textureCoord.push(iconInfo.x);
                   textureCoord.push(iconInfo.y);
                   textureCoord.push(iconInfo.width);
                   textureCoord.push(iconInfo.height);
                   resJson.textureCoord = textureCoord;
                   callback(resJson);//返回结果
               }.bind(this)
           );
       }
   }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 填充符号。是ColorFill和TextureFill的基类，不能被实例化。
 * @type {hmap.style.FillSymbol}
 * @abstract
 */
hmap.style.FillSymbol=class{
   constructor(options={}){
      if (new.target === hmap.style.FillSymbol) {
            throw new SyntaxError("The FillSymbol is an abstract class,can not be instantiated!");
      }
      this.CLASS_NAME = "hmap.style.FillSymbol";
      this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
      this._offset = options.hasOwnProperty("offset")?options.offset:new hmap.basetype.Offset(0,0);
   }
   setOffset(offset) {
      if (offset instanceof hmap.basetype.Offset) {
         throw('parameter offset must be instance of hmap.basetype.Offset');
      }
      this._offset = offset;
      return this;
   }
   /**
    * 获取面样式偏移
    * @return {hmap.basetype.Offset|*}
    */
   getOffset(){
      return this._offset;
   }
   /**
    * 设置透明度，子类来实现。
    * @param {Number} opacity 透明度
    */
   setOpacity(opacity){

   }
   /**
    * 获取透明度,子类来实现
    * @returns {Number} 透明度
    */
   getOpacity(){

   }
};
;"use strict";
hmap.style=hmap.style||{};
/**
 * 纯颜色填充符号类
 * @type {hmap.style.ColorFill}
 * @extends hmap.style.FillSymbol
 * @example
 * let colorFill = new hmap.style.ColorFill(new hmap.style.Color(0,255,0,1));
 */
hmap.style.ColorFill=class extends hmap.style.FillSymbol{
    /**
     * 构造函数。
     * @param {hmap.style.Color | hmap.style.GradientFill} color Color对象表示的颜色值。
     */
    constructor(color){
        super();
        if(!(color instanceof hmap.style.Color||color instanceof hmap.style.GradientFill)){
            throw new TypeError("color must be hmap.style.Color or hmap.style.GradientFill!");
        }

        this._color=color;
        this.CLASS_NAME = "hmap.style.ColorFill";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
     }

    /**
     * 获取颜色值。
     * @returns {hmap.style.Color} 返回颜色值
     * @example
     * let result = colorFill.getColor();
     */
     getColor(){
        return this._color;
     }

    /**
     * 设置颜色值
     * @param {hmap.style.Color} color 颜色对象
     * @example
     * let color = new hmap.style.Color(255,0,0,1);
     * colorFill.setColor(color);
     * let result = colorFill.getColor();//
     */
     setColor(color){
        if(!(color instanceof hmap.style.Color|| color instanceof hmap.style.GradientColor)){
            throw new TypeError('Parameter "color" must be hmap.style.Color or hmap.style.GradientColor');
        }
        this._color=color;
     }
     /**
      * 克隆一个颜色填充符号
      * @returns {hmap.style.ColorFill} 颜色填充符号
      * @example
      * let newColorFill = colorFill.clone();
      */
     clone(){
        return new hmap.style.ColorFill(this._color.clone());
     }

     /**
      * 设置透明度
      * @param opacity {Number} 透明度，范围从0到1，0表示完全透明，1表示完全不透明。
      * @example
      * colorFill.setOpacity(0.5);
      */
     setOpacity(opacity){
        this._color.setOpacity(opacity);
     }

     /**
      * 获取透明度
      * @returns {Number} 透明度
      * @example
      * let opacity = colorFill.getOpacity();
      */
     getOpacity(){
        return this._color.getOpacity();
     }

};
;"use strict";
hmap.style=hmap.style||{};
/**
 * @private
 * @type {hmap.style.Cursor}
 */
hmap.style.Cursor=class{
    /**
     * 构造函数
     * @private
     */
    constructor(){
        this.CLASS_NAME="hmap.style.Cursor";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * @private
     * @param dom
     * @param cursorName
     */
    static set(dom,cursorName){
        if(typeof(dom)==="string"){
            dom=document.getElementById(dom);
        }
        switch (cursorName){
            case "HAND_RELEASE":
                  dom.style.cursor='default';
                break;
            case "HAND_DRAG":
                  dom.style.cursor='Move';
                break;
            case "HAND_OVER":
                  dom.style.cursor='pointer';
                  break;
            default:
                dom.style.cursor="default";
        }
    }

    /**
     * @private
     * @param dom
     * @return {Boolean}
     */
    static isOnMap(dom) {
        if (typeof(dom) === "string") {
            dom = document.getElementById(dom);
        }
        return (dom.style.cursor === 'url("../../theme/img/HAND_RELEASE.png"), default' || dom.style.cursor === 'url("../../theme/img/HAND_DRAG.png"), default');
    }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 线符号。
 * @type {hmap.style.LineSymbol}
 * @example
 * let lineSymbol = new hmap.style.LineSymbol({
 *      color:new hmap.style.Color(0,0,200,1),//线的颜色值
 *      lineCap:"square",//线端头形状"butt”、“square"、"round"
 *      lineJoin:"bevel",//线连接处形状"bevel"平角、 “miter"尖角、round圆角
 *      lineStyle:"solid",//线型，默认为实线solid。有 [dot | dash | dashdot | longdash | longdashdot | solid]。
 *      lineOffset:new hmap.basetype.Offset(3, 3),//线的偏移量,单位为像素，默认在X、Y方向偏移量均为0。
 *      miterLimit:10,//尖角的最小值限制，默认10度
 *      width:5//线的像素宽度，默认为1个像素
 * });
 */
hmap.style.LineSymbol=class{

    /**
     * 构造函数。参数options是key-value对象，
     * @param options 线符号对象的可选属性。
     * @param {hmap.style.Color | Array} options.color 线的颜色。当参数类型为hmap.style.Color时，线的颜色为纯色。当参数类型为数组时（如[0, new hmap.style.Color(255,
     * 0, 0), 0.3, new hmap.style.Color(0, 255, 0), 0.5, new hmap.style.Color(0, 255, 255), 1.0, new hmap.style.Color(0, 0, 255)]），线的颜色为渐变色，其中数组中每
     * 两个元素组成一组，依次为比例（第一组的比例为0，最后一组的比例为1，其余介于0和1之间，最多一位小数点）、颜色，分别代表线上的位置（从起点开始计算占线段总长的比
     * 例），以及在该位置的颜色。
     * @param {String} options.lineCap 线端头的形状，包括'butt'(平头)、'square'(方头，暂未实现)、'round'(圆头，暂未实现)，默认为'butt'。
     * @param {String} options.lineJoin 线连接处的形状。包括'bevel'(平角)、'miter'(尖角，暂未实现)、'round'(圆角，暂未实现)，默认为'bevel'。
     * @param {String} options.lineStyle 线型，包括'dot'、'dash'、'dashdot'、'longdash'、'longdashdot'和 'solid'，默认为'solid'（实线）。
     * @param {hmap.basetype.Offset} options.lineOffset 线的偏移量，像素单位，默认在X、Y方向偏移量均为0。
     * @param {Number} options.miterLimit 尖角的最小限制值，默认为10度，暂未实现。
     * @param {Number} options.width  线的像素宽度，默认为1个像素。
     */
    constructor(options){
    	options = options || {};
        this._color = options.hasOwnProperty("color")?this.setColor(options.color):new hmap.style.Color(0,0,200,1);//颜色值
        this._lineCap = options.hasOwnProperty("lineCap")?this.setLineCap(options.lineCap):"round";//线端头形状"butt” “square""round"
        this._lineJoin = options.hasOwnProperty("lineJoin")?this.setLineJoin(options.lineJoin):"round";//线连接处形状"bevel"平角、 “miter"尖角、round圆角
        this._lineStyle = options.hasOwnProperty("lineStyle")?this.setLineStyle(options.lineStyle):"solid";//默认为实线solid
        this._lineOffset = options.hasOwnProperty("lineOffset")?this.setLineOffset(options.lineOffset):new hmap.basetype.Offset(0,0);//线的偏移量,默认为“0,0”
        this._miterLimit = options.hasOwnProperty("miterLimit")?this.setMiterLimit(options.miterLimit):10;//尖角的最小值限制，默认10度
        this._width = options.hasOwnProperty("width")?this.setWidth(options.width):1;//线的像素宽度，默认为1个像素
        // this._borderWidth = options.hasOwnProperty("borderWidth")?this.setBorderWidth(options.borderWidth):0;
        // this._borderColor = options.hasOwnProperty("borderColor")?this.setBorderColor(options.borderColor):new hmap.style.Color(0,0,0,1);
        this.CLASS_NAME = "hmap.style.LineSymbol";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }


    /**
     * 克隆一个线符号对象。
     * @returns {hmap.style.LineSymbol}线符号对象
     * @example
     * let newLineSymbol = lineSymbol.clone();
     */
    clone(){
    	return new hmap.style.LineSymbol({
    		color: this._color.clone(),
    		lineCap: this._lineCap,
    		lineJoin: this._lineJoin,
    		lineStyle: this._lineStyle,
    		lineOffset: this._lineOffset,
    		miterLimit: this._miterLimit,
    		width: this._width,
            // borderWidth: this._borderWidth,
            // borderColor: this._borderColor
    	});
    }

    /******
     * 设置线的边框宽度,单位是像素
     * @param {Number} borderWidth 边框宽度。大于等于0
     * @returns {Number} 返回修改后的边框宽度
     * @example
     * let borderWidth = lineSymbol.setBorderWidth(5);
     */
    // setBorderWidth(borderWidth){
    //     if(Number.isFinite(borderWidth) && borderWidth>=0){
    //         this._borderWidth = borderWidth;
    //     }else{
    //         throw new TypeError("borderWidth should be number and not less zero");
    //     }
    //     return this._borderWidth;
    // }

    /*****
     * 获取线的边框宽度
     * @example
     * let borderWidth = lineSymbol.getBorderWidth();
     * @returns {Number} 线的边框宽度
     */
    // getBorderWidth(){
    //     return this._borderWidth;
    // }

    /**
     * 获取颜色值
     * @example
     * let color = lineSymbol.getColor();
     * @returns {hmap.style.Color} 线的颜色对象
     */
    getColor(){
    	return this._color;
    }

    /*****
     * 设置线的边框颜色。
     * @param {hmap.style.Color} borderColor 线的边框颜色
     * @returns {hmap.style.Color} 返回修改后的边框颜色
     * @example
     * let borderColor = new hmap.style.Color(255,0,0,1);
     * lineSymbol.setBorderColor(borderColor);
     */
    // setBorderColor(borderColor){
    //     if(!(borderColor instanceof hmap.style.Color)){
    //         throw new TypeError('Parameter "borderColor" must be hmap.style.Color');
    //     }
    //     this._borderColor = borderColor;
    //     return this._borderColor;
    // }

    /*****
     * 获取边框颜色对象
     * @example
     * let borderColor = lineSymbol.getBorderColor();
     * @returns {hmap.style.Color} 线的边框颜色对象
     */
    // getBorderColor(){
    //     return this._borderColor;
    // }


    /**
     * 获取线端头形状。
     * @example
     * let lineCap = lineSymbol.getLineCap();
     * @returns {String} 合法的值是"butt”、“square"、"round"三者之一。
     */
    getLineCap(){
    	return this._lineCap;
    }


    /**
     * 获取线型类型。
     * @example
     * let lineStyle = lineSymbol.getLineStyle();
     * @returns {String} 表示线型的字符串。
     */
    getLineStyle(){
    	return this._lineStyle;
    }

    /**
     * 获取线的偏移。
     * @returns {Number|hmap.basetype.Offset}线的偏移值。
     * @example
     * let lineOffset = lineSymbol.getLineOffset();
     */
    getLineOffset(){
    	return this._lineOffset;
    }

    /**
     * 获取连接处的形状。
     * @returns {String}表示连接处形状的字符串。
     * @example
     * let lineJoin = lineSymbol.getLineJoin();
     */
    getLineJoin(){
    	return this._lineJoin;
    }

    /**
     * 获取尖角的限制值。
     * @returns {Number} 尖角的最小限制值。
     * @example
     * let miterLimit = lineSymbol.getMiterLimit();
     */
    getMiterLimit(){
    	return this._miterLimit;
    }

    /**
     * 获取线宽,单位是像素。
     * @returns {Number} 线宽
     * @example
     * let width = lineSymbol.getWidth();
     */
    getWidth(){
    	return this._width;
    }

    /**
     * 设置线的颜色值。
     * @param {hmap.style.Color} color 线的颜色值
     * @returns {hmap.style.Color} 返回修改后的颜色值
     * @example
     * let color = new hmap.style.Color(255,0,0,1);
     * let lineColor = lineSymbol.setColor(color);
     */
    setColor(color){
        // if(!(color instanceof hmap.style.Color)){
        //     throw new TypeError('Parameter "color" must be hmap.style.Color');
        // }
        this._color = color;
        return this._color;
    }


    /**
     * 设置线端头的形状。
     * @param {String} lineCap 线端头形状"butt” “square""round"
     * @returns {String} 返回修改后的线端头形状
     * @example
     * let lineCap = lineSymbol.setLineCap("butt");
     */
    setLineCap(lineCap){
    	if((lineCap==="butt")||(lineCap==="square")||(lineCap==="round")){
    		this._lineCap = lineCap;
    	}else{
            throw new RangeError("lineCap should be 'square'、'butt' or 'round'");
        }
        return this._lineCap;
    }

    /**
     * 设置线型类型。
     * @param {String} lineStyle 线型，默认为实线solid。可供选择的线型有 [dot | dash | dashdot | longdash | longdashdot | solid]。
     * @returns {String} 返回修改后的线型类型
     * @example
     * let lineStyle = lineSymbol.setLineStyle("dash");
     */
    setLineStyle(lineStyle){
    	if(typeof lineStyle === "string" && (lineStyle==="dot"||lineStyle==="dash"||lineStyle==="dashdot"||lineStyle==="longdash"||lineStyle==="longdashdot"||lineStyle==="solid")){
    		this._lineStyle = lineStyle;
    	}else{
            throw new RangeError("lineStyle should be 'dot'、'dash'、'dashdot'、'longdash'、'longdashdot'、or 'solid'");
        }
    	return this._lineStyle;
    }

    /**
     * 设置线的偏移。
     * @param {hmap.basetype.Offset} lineOffset 偏移量，单位为像素
     * @returns {hmap.basetype.Offset} 返回修改后的偏移量
     * @example
     * let lineOffset = lineSymbol.setLineOffset(new hmap.basetype.Offset(60,10,0));
     */
    setLineOffset(lineOffset){
        if(!Number.isFinite(lineOffset) && !(lineOffset instanceof hmap.basetype.Offset)){
            throw new TypeError("lineOffset should be number or hmap.basetype.Offset");
        }
        this._lineOffset = lineOffset;
    	return this._lineOffset;
    }


    /**
     * 设置线的连接处的形状。
     * @param {String} lineJoin 线连接处形状"bevel"平角、“miter"尖角、“round”圆角
     * @returns {String} 返回设置值
     * @example
     * let lineJoin = lineSymbol.setLineJoin("bevel");
     */
    setLineJoin(lineJoin){

    	if((lineJoin==="bevel")||(lineJoin==="miter")||(lineJoin==="round")){
    		this._lineJoin = lineJoin;
    	}else{
            throw new RangeError("lineJoin should be 'bevel'、'miter' or 'round'");
        }
    	return this._lineJoin;
    }

    /**
     * 设置尖角的限制值，即尖角角度的最小值。
     * @param {Number} miterLimit
     * @example
     * let miterLimit = lineSymbol.setMiterLimit(12);
     */
    setMiterLimit(miterLimit){
    	if(Number.isFinite(miterLimit)){
    		this._miterLimit = miterLimit;
    	}else{
            throw new TypeError("miterLimit should be number");
        }
    	return this._miterLimit;
    }

    /**
     * 设置线的宽度,单位是像素
     * @param {Number} width 线的宽度。大于等于0
     * @returns {Number} 返回修改后的线宽值
     * @example
     * let width = lineSymbol.setWidth(5);
     */
    setWidth(width){
    	if(Number.isFinite(width) && width>=0){
    		this._width = width;
    	}else{
            throw new TypeError("width should be number and not less zero");
        }
    	return this._width;
    }

};
;"use strict";
hmap.style=hmap.style||{};
/**
 * 纹理填充符号。
 * @type {hmap.style.TextureFill}
 * @extends hmap.style.FillSymbol
 */
hmap.style.TextureFill=class extends hmap.style.FillSymbol{
    /**
     * 构造函数
     * @param {String} imgSrc 纹理图片路径，必须提供
     * @param {Object} options 可选项
     * @param {Number} options.unitHeight 纹理图片在不缩放的情况下，覆盖的地理范围的纬度差，单位同多边形几何对象的单位一致。默认为多边形几何体范围的纬度差。
     * @param {Number} options.unitWidth 纹理图片在不缩放的情况下，覆盖的地理范围的经度差，单位同多边形几何对象的单位一致。默认为多边形几何体范围的经度差。
     * @param {string} options.texture_wrap_s 可选项。纹理坐标在超出[0.0，1.0]范围时，纹理图片在S轴环绕方式，可以为REPEAT、CLAMP_TO_EDGE、MIRRORED_REPEAT中的一种，默认为REPEAT。
     * @param {string} options.texture_wrap_t 可选项。纹理坐标在超出[0.0，1.0]范围时，纹理图片在T轴环绕方式，可以为REPEAT、CLAMP_TO_EDGE、MIRRORED_REPEAT中的一种，默认为REPEAT。
     * @param {string} options.texture_mag_filter 可选项。纹理图片放大过滤的方式，可以为LINEAR、NEAREST中的一种，默认LINEAR。
     * @param {string} options.texture_min_filter 可选项。纹理图片缩小过滤的方式，可以为LINEAR、NEAREST中的一种，默认LINEAR，暂不支持NEAREST_MIPMAP_NEAREST、LINEAR_MIPMAP_NEAREST、NEAREST_MIPMAP_LINEAR、LINEAR_MIPMAP_LINEAR。
     */
    constructor(imgSrc, options = {}){
        super();
        if (typeof imgSrc !== 'string')
            throw TypeError('The param of imgSrc must be string');
        this._imgSrc = imgSrc;
        this.unitHeight = options.unitHeight;
        this.unitWidth = options.unitWidth;
        this.wrap_s = options.texture_wrap_s || 'REPEAT';
        this.wrap_t = options.texture_wrap_t || 'REPEAT';
        this.mag_filter = options.texture_mag_filter || 'LINEAR';
        this.min_filter = options.texture_min_filter || 'LINEAR';
        this.promise = this.loadImg();
        this.CLASS_NAME = "hmap.style.TextureFill";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 请求纹理图片
     * @returns {Promise<any>} 返回请求纹理图片的Promise对象
     * @private
     */
    loadImg() {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.onload = function() {
                this._texture = img;
                this._imgSrc = img.src;
                resolve(this);
            }.bind(this);
            img.crossOrigin = 'anonymous';
            img.src = this._imgSrc;
        })
    }

    /**
     * 获取纹理信息。
     * @returns {Image} 纹理填充符号中的纹理图片
     */
    getTexure(){
        return this._texture;
    }
    /**
     * 设置纹理信息。
     * @param {Image} image 图片
     */
    setTexture(image){
        if(!(image instanceof Image)){
            throw new TypeError("parameter was not a type of Image!");
        }
        this._texture=image;
        this._imgSrc = image.src;
    }

    /**
     * 克隆一个纹理填充符号。
     * @returns {hmap.style.TextureFill}
     */
    clone(){
        let opt ={
            unitHeight: this.unitHeight,
            unitWidth: this.unitWidth,
            texture_wrap_s: this.wrap_s,
            texture_wrap_t: this.wrap_t,
            texture_mag_filter: this.mag_filter,
            texture_min_filter: this.min_filter,
        };
        return new hmap.style.TextureFill(this._imgSrc, opt);
    }

    /**
     * 获得该纹理填充符号的纹理图片路径
     * @returns {String} 纹理图片路径
     */
    getImgSrc() {
        return this._imgSrc;
    }

    /**
     * 获得该纹理填充符号的ID
     * @returns {String} 该纹理填充符号的ID
     */
    getId() {
        return this._id;
    }
};
;"use strict";
hmap.style=hmap.style||{};
/**
 * 用于矢量切片样式文件规则的解析
 * @private
 * @type {hmap.style.StyleRuleManager}
 */
hmap.style.StyleRuleManager=class{
    /**
     * 构造函数
     * @param {JSON} styleJson 样式文件的JSON对象
     */
    constructor(styleJson){
        this.CLASS_NAME = "hmap.style.StyleRuleManager";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._styleMap=new Map();
        this.updateStyle(styleJson);
     }

    /**
     * 根据styleJson更新样式对象
     * @param styleJson 样式的json对象
     */
     updateStyle(styleJson){
        if(!styleJson) return;
        this._styleJson = styleJson;
        this._ttfUrl = styleJson.totalConfig.ttfUrl || "mapicon.ttf";
        this._styleMap = this.createStyleMap(styleJson);
     }

    /**
     * 根据要素类型和级别返回要素对应的样式
     * @param {String} featureType 要素类的名称
     * @param {int} level 对应的地图级别
     * @returns {hmap.style.Style} 单个样式对象
     */
    getStyleByTypeLevel(featureType,level){
        if(this._styleMap===null || this._styleMap.size===0){
            return null;
        }
        let key=featureType;
        if(key!=="LAND" && key!=="FOG")
            key=key+"_"+level;
        if(this._styleMap.has(key)){
            return this._styleMap.get(key);
        }else{
            return new hmap.style.Style();
        }
    }

    /**
     * 根据styleJson创建样式Map对象。
     * @param {JSON} styleJson 样式文件的json对象
     * @returns {Map<String, hmap.style.Style>}
     */
    createStyleMap(styleJson){
        //styleMap的结构为{"BANK_PT": rules}
        for(let key in styleJson){//针对每一类要素进行处理
            const rulesJson = styleJson[key].rules;
            const weight=styleJson[key].weight;
            if(!rulesJson){
                continue;
            }
            let rules = [];
            for(let i=0,len=rulesJson.length; i<len; i++){
                const ruleJson = rulesJson[i];
                const minLevel = ruleJson.minLevel;
                const maxLevel = ruleJson.maxLevel;
                //处理symbols构建style
                const style = this._createStyleBySymbols(ruleJson.symbols,weight);
                for(let i=minLevel;i<=maxLevel;i++){
                    if(key==="FOG"||key==="LAND"){
                        this._styleMap.set(key,style);
                        break;//因为FOG和LAND只存一次
                    }else{
                        //建筑物按照设置的范围显示相应拉伸体
                        if(key==="BUILDING_PG"){
                            let stretch = ruleJson.stretch;
                            if(stretch && i>=stretch.min ){
                                const sty = style.clone();
                                sty.getFillSymbols()[0].display = style.getFillSymbols()[0].display;
                                sty.getFillSymbols()[0].weight = style.getFillSymbols()[0].weight;
                                sty.stretch = stretch.type ;
                                this._styleMap.set(key+"_"+i,sty);
                                continue;
                            }
                        }
                        this._styleMap.set(key+"_"+i,style);
                    }
                }
            }
        }
        return this._styleMap;
    }

    /**
     * 返回styleMap对象
     * @returns {*|Map}
     */
    getStyleMap(){
        if(this._styleMap.size===0){
            this.createStyleMap(this._styleJson);
        }
        return this._styleMap;
    }

    /**
     * 根据符号json对象和权重weight创建样式对象
     * @private
     * @param {JSON} symbols 符号组成的json对象
     * @param {Number} weight 表示绘制上下顺序的权重值
     * @returns {hmap.style.Style} style对象
     */
    _createStyleBySymbols(symbols,weight=0) {
        let style = new hmap.style.Style();
        style.setMarkerSymbols([]);
        style.setLineSymbols([]);
        style.setFillSymbols([]);
        style.setTextSymbols([]);
        if (symbols.markerSymbols) {
            const markerSymbols = symbols.markerSymbols;
            let markerSymArr = [];
            for (let i = 0; i < markerSymbols.length; i++) {
                //处理填充色
                const fillColorJson = markerSymbols[i].fillColor;
                if(fillColorJson&&fillColorJson.indexOf("#")!==-1){
                    let color = new hmap.style.Color();
                    color.fromHexColor(fillColorJson);
                    markerSymbols[i].fillColor = color;
                }
                //处理描边色
                const outerColorJson = markerSymbols[i].outlineColor;
                if(outerColorJson&&outerColorJson.indexOf("#")!==-1){
                    let color = new hmap.style.Color();
                    color.fromHexColor(outerColorJson);
                    markerSymbols[i].outlineColor = color;
                }

                markerSymbols[i].fileUrl=this._ttfUrl;

                const symbol = new hmap.style.IconFont(markerSymbols[i]);
                symbol.weight=weight;
                symbol.display=markerSymbols[i].display;
                markerSymArr.push(symbol);
                // if(markerSymbols[i].display) {//当display为true时添加符号
                //     markerSymArr.push(symbol);
                // }
            }
            style.setMarkerSymbols(markerSymArr);
        }
        if (symbols.lineSymbols) {
            const lineSymbols = symbols.lineSymbols;
            let lineSymArr = [];
            for (let i = 0; i < lineSymbols.length; i++) {
                const colorJson = lineSymbols[i].color;
                if(colorJson&&colorJson.indexOf("#")!==-1){
                    let color = new hmap.style.Color();
                    color.fromHexColor(colorJson);
                    lineSymbols[i].color = color;
                    //存在透明度，则设置
                    if(lineSymbols[i].hasOwnProperty("opacity")){
                        lineSymbols[i].color.setOpacity( lineSymbols[i].opacity );
                    }
                }
                const symbol = new hmap.style.LineSymbol(lineSymbols[i]);
                symbol.weight=weight+i*0.2;
                symbol.display=lineSymbols[i].display;
                lineSymArr.push(symbol);
                // if(symbol.display) {//当display为true时添加符号
                //     lineSymArr.push(symbol);
                // }
            }
            style.setLineSymbols(lineSymArr);
        }
        if (symbols.fillSymbols) {
            const fillSymbols = symbols.fillSymbols;
            let fillSymArr = [];
            for (let i = 0, len = fillSymbols.length; i < len; i++) {
                const colorJson = fillSymbols[i].color;
                if(colorJson&&colorJson.indexOf("#")!==-1){
                    let color = new hmap.style.Color();
                    color.fromHexColor(colorJson);
                    fillSymbols[i].color = color;
                }
                const symbol = new hmap.style.ColorFill(fillSymbols[i].color);
                symbol.setOpacity(fillSymbols[i].opacity);
                symbol.weight=weight;
                symbol.display=fillSymbols[i].display;
                fillSymArr.push(symbol);
                // if(fillSymbols[i].display) {//当display为true时添加符号
                //     fillSymArr.push(symbol);
                // }
            }
            style.setFillSymbols(fillSymArr);
        }
        if (symbols.textSymbol) {
            const textSymJson = symbols.textSymbol;
            const colorJson = textSymJson.haloColor;
            if(colorJson&&colorJson.indexOf("#")!==-1){
                let color = new hmap.style.Color();
                color.fromHexColor(colorJson);
                textSymJson.haloColor = color;
            }

            const fontColor = textSymJson.fontColor;
            if(fontColor&&fontColor.indexOf("#")!==-1){
                const color = new hmap.style.Color();
                color.fromHexColor(fontColor);
                textSymJson.fontColor = color;
            }

            if (textSymJson.offset) {
                const offsetArr = textSymJson.offset;
                textSymJson.offset = new hmap.basetype.Offset(offsetArr[0], offsetArr[1], offsetArr[2]);
            }
            const textSymbol = new hmap.style.TextSymbol(textSymJson);
            textSymbol.weight=weight;
            textSymbol.display=textSymJson.display;
            style.setTextSymbols([textSymbol]);
            // if(textSymJson.display) {//当display为true时添加符号
            //     style.setTextSymbols([textSymbol]);
            // }
        }
        return style;
    }

    /**
     * 对应之前的updateMapByRules方法，配置界面保存时调用
     * @param {hmap.layer.VectorTileLayer} vtLayer 矢量切片图层对象
     * @param {JSON} styleJson json格式的样式
     */
    updateMapByStyleJson(vtLayer,styleJson){
        this.createStyleMap(styleJson);
        vtLayer.redraw();
    }

    /**
     * 样式更新时调用
     * @param {String} featureType 要素类的名称
     * @param {int} level 对应的级别
     * @param {JSON} styleJson  json格式的style
     */
    updateStyleMap(featureType,level,styleJson){
        const styleMap = this.getStyleMap();
        const  key = featureType + "_" + level;
        let style = this._createStyleBySymbols(styleJson,0);
        styleMap.set(key,style);
    }

    /**
     * 根据子类型更新样式
     * @param {Array<String>} subTypeArr  子类型名称组成的数组
     * @param {JSON} symbolsJson json格式的符号
     * @param {int} level 级别
     */
    updateStyleBySubTypes(subTypeArr,symbolsJson,level){
        const styleMap = this.getStyleMap();
        let objKeys = [...styleMap.keys()];
        if(objKeys.length<1) {
            return false;
        }
        for(let i=0,len=subTypeArr.length;i<len;i++){
            const style = styleMap.get(subTypeArr[i]+"_" + level);
            if(!style){
                continue;
            }
            if(symbolsJson.markerSymbols){
                const markerSymJson = symbolsJson.markerSymbols;
                const markerSymbols = style.getMarkerSymbols();

                for(let j=0;j<markerSymJson.length;j++){
                    const markerSym = markerSymJson[j];
                    markerSymbols[j].display=markerSym.display;
                    if(markerSym.fontSize){
                        markerSymbols[j].setFontSize(markerSym.fontSize);
                    }
                    if(markerSym.unicode){
                        markerSymbols[j].setUnicode(markerSym.unicode);
                    }
                    if(markerSym.fillColor){
                        const color = new hmap.style.Color();
                        color.fromHexColor(markerSym.fillColor);
                        markerSymbols[j].setFillColor(color);
                    }
                    if(markerSym.outlineColor){
                        const color = new hmap.style.Color();
                        color.fromHexColor(markerSym.outlineColor);
                        markerSymbols[j].setOutlineColor(color);
                    }
                }
            }else if(symbolsJson.lineSymbols){
                const lineSyms = symbolsJson.lineSymbols;
                for(let k=0;k<lineSyms.length;k++){
                    if(lineSyms[k].color){
                        const color = new hmap.style.Color();
                        color.fromHexColor(lineSyms[k].color);
                        style.getLineSymbols()[k].setColor(color);
                        style.getLineSymbols()[k].display=lineSyms[k].display;
                    }
                }
            }else if(symbolsJson.fillSymbols){
                const fillSymJson = symbolsJson.fillSymbols;
                if(fillSymJson.length > 0) {
                    style.getFillSymbols()[0].display=fillSymJson[0].display;
                    if (fillSymJson[0].color) {
                        const color = new hmap.style.Color();
                        color.fromHexColor(fillSymJson[0].color);
                        style.getFillSymbols()[0].setColor(color);
                    }
                    if (fillSymJson[0].opacity!==undefined) {
                        style.getFillSymbols()[0].setOpacity(fillSymJson[0].opacity);
                    }
                    if (fillSymJson.length === 2) {
                        style.getFillSymbols()[1].display=fillSymJson[1].display;
                        if (fillSymJson[1].color) {
                            const  color = new hmap.style.Color();
                            color.fromHexColor(fillSymJson[1].color);
                            style.getFillSymbols()[1].setColor(color);
                        }
                        if (fillSymJson[1].opacity!==undefined) {
                            style.getFillSymbols()[1].setOpacity(fillSymJson[1].opacity);
                        }
                    }
                }
            }

            if(symbolsJson.textSymbol){
                const textSymJson = symbolsJson.textSymbol;
                const textSymbol = style.getTextSymbols()[0];
                textSymbol.display=textSymJson.display;
                if(textSymJson.fontSize){
                    textSymbol.setFontSize(textSymJson.fontSize);
                }
                if(textSymJson.fontColor){
                    const color = new hmap.style.Color();
                    color.fromHexColor(textSymJson.fontColor);
                    textSymbol.setFontColor(color);
                }
                if(textSymJson.haloColor){
                    const color = new hmap.style.Color();
                    color.fromHexColor(textSymJson.haloColor);
                    textSymbol.setHaloColor(color);
                }
            }

        }
    }

    /**
     * 将十六进制的颜色值转成Color对象
     * @param {Object} colorJson json格式的颜色值。
     * @return {hmap.style.Color} color对象
     * @private
     */
    _colorHexToArray(colorJson){
        if(colorJson&&colorJson.indexOf("#")!==-1){
            let color = new hmap.style.Color();
            color.fromHexColor(colorJson);
            return color;
        }else{
            return colorJson;
        }
    }
};
;"use strict";
hmap.style = hmap.style||{};
/**
 * 光照
 * @type {hmap.style.Light}
 * @private
 * @example
 * let light = new hmap.style.Light({
		emissiveColor: [0.0,0.0,0.0],//自发光颜色
		emissiveFactor: 1.0,//自发光强度因子
		emissive: [0.0,0.0,0.0],//强度下的自发光色值

		ambientColor: [0.0,0.0,0.0],//环境光颜色
		ambientFactor: 1.0,//环境光强度因子
		ambient: [0.0,0.0,0.0],//强度下的环境光色值

		diffuseColor: [1.0,1.0,1.0],//反射光颜色
		diffuseFactor: 1.0,//反射光强度因子
		diffuse: [0.0,0.0,0.0],//强度下的反射光色值

		lightDirection: [0.0,0.0,0.0],//平行光的光源位置
		pointLightPosition: [0.0,0.0,0.0],//点光源位置

		specularColor: [0.0,0.0,0.0],//镜面高光颜色
		specularFactor: 1.0,//高光强度因子
		specular: [0.0,0.0,0.0],//强度下的高光色值
		shininess: 23,//高光尖锐程度的指数值
 * });
 */
hmap.style.Light = class {
	// 颜色是0-1的值
	constructor(options={}){

		this.emissiveColor = options.emissiveColor?options.emissiveColor:[0.0,0.0,0.0];
		this.emissiveFactor = options.emissiveFactor?options.emissiveFactor:1.0;
		this.emissive = options.emissive?options.emissive:[0.0,0.0,0.0];

		this.ambientColor = options.ambientColor?options.ambientColor:[0.0,0.0,0.0];
		this.ambientFactor = options.ambientFactor?options.ambientFactor:1.0;
		this.ambient = options.ambient?options.ambient:[0.0,0.0,0.0];

		this.diffuseColor = options.diffuseColor?options.diffuseColor:[1.0,1.0,1.0];
		this.diffuseFactor = options.diffuseFactor?options.diffuseFactor:1.0;
		this.diffuse = options.diffuse?options.diffuse:[0.0,0.0,0.0];
		this.lightDirection = options.lightDirection?options.lightDirection:[0.0,0.0,0.0];
		this.pointLightPosition = options.pointLightPosition?options.pointLightPosition:[0.0,0.0,0.0];

		this.specularColor = options.specularColor?options.specularColor:[0.0,0.0,0.0];
		this.specularFactor = options.specularFactor?options.specularFactor:1.0;
		this.specular = options.specular?options.specular:[0.0,0.0,0.0];
		this.shininess = options.shininess?options.shininess:0.0;
		// 注：点光源下的高光：和视点位置、点光源照射方向有关。
	}
	isHasValue(value){
		return (value[0]==0)&&(value[1]==0)&&(value[2]==0)?false:true;
	}

// 自发光
	setEmissiveColor(emissiveColor){
		this.emissiveColor = emissiveColor;
	}
	setEmissiveFactor(emissiveFactor){
		this.emissiveFactor = emissiveFactor;
	}
	setEmissive(emissive){
		this.emissive = emissive;
	}
	getEmissive(){
		this.emissive = this.isHasValue(this.emissive)?this.emissive:this.emissiveColor.map(item=>item*this.emissiveFactor);
		return this.emissive;
	}

// 环境光
	setAmbientColor(ambientColor){
		this.ambientColor = ambientColor;
	}
	setAmbientFactor(ambientFactor){
		this.ambientFactor = ambientFactor;
	}
	setAmbient(ambient){
		this.ambient = ambient;
	}
	getAmbient(){
		this.ambient = this.isHasValue(this.ambient)?this.ambient:this.ambientColor.map(item=>item*this.ambientFactor);
		return this.ambient;
	}
// 漫反射光
	setDiffuseColor(diffuseColor){
		this.diffuseColor = diffuseColor;
	}
	setDiffuseFactor(diffuseFactor){
		this.diffuseFactor = diffuseFactor;
	}
	setDiffuse(diffuse){
		this.diffuse = diffuse;
	}
	getDiffuse(){
		this.diffuse = this.isHasValue(this.diffuse)?this.diffuse:this.diffuseColor.map(item=>item*this.diffuseFactor);
		return this.diffuse;
	}
	/**
	 * 设置平行光方向
	 * @param {Array} lightDirection	
	 */
	setLightDirection(lightDirection){
		this.lightDirection = lightDirection;
	}
	getLightDirection(){
		return this.lightDirection;
	}
	getLightDirectionVector(){
		let lightDirection = new Vector3(this.lightDirection);
		lightDirection.normalize();
		return lightDirection;
	}
	/**
	 * 设置点光源位置
	 * @param {Array} pointLightPosition
	 */
	 setPointLightPosition(pointLightPosition){
	 	this.pointLightPosition = pointLightPosition;
	 }
	 getPointLightPosition(){
	 	return this.pointLightPosition;
	 }
	 getPointLightPositionVector(){
		return new Vector3(this.pointLightPosition);
	 }


// 镜面高光
	setSpecularColor(specularColor){
		this.specularColor = specularColor;
	}
	setSpecularFactor(specularFactor){
		this.specularFactor = specularFactor;
	}
	setSpecular(specular){
		this.specular = specular;
	}
	getSpecular(){
		this.specular = this.isHasValue(this.specular)?this.specular:this.specularColor.map(item=>item*this.specularFactor);
		return this.specular;
	}
	setShininess(shininess){
		this.shininess = shininess;
	}
	getShininess(){
		return this.shininess;
	}


};"use strict";
hmap.style = hmap.style||{};

/**
 * 渐变色填充符号
 * @type {hmap.style.GradientFill}
 */
hmap.style.GradientFill = class {
    /**
     * 构造函数
     * @param fromColor {hmap.style.Color} 渐变色的起始颜色
     * @param toColor {hmap.style.Color} 渐变色的终止颜色
     * @param angle {Number} 角度值，表示从多边形的某个角度开始渐变。以x轴正方向为起始角度0度，逆时针旋转，范围在0到180之间，其中为0时从正东往正西方向渐变，
     * 值为90时从正北往正南方向渐变，值为180时，从正西往正东方向渐变，默认值为0。
     */
    constructor(fromColor, toColor, angle = 0) {
        if (typeof angle !== 'number' || angle < 0 || angle > 180) {
            throw Error('angle must be a number between 0 and 180');
        }
        this.fromColor = fromColor;
        this.toColor = toColor;
        this.angle = angle;
        this.CLASS_NAME = 'hmap.style.GradientFill';
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
    }
}
;"use strict";
hmap.overlay=hmap.overlay||{};
/**
 * 叠加物类,即：根据地理坐标，显示在地图上的div元素。抽象类。随着弹框数量增多，渲染性能会有明显下降。
 * @type {hmap.overlay.Overlay}
 */
hmap.overlay.Overlay=class{
    /**
     * 构造函数。
     * @param {Object} options       
     * @param {Boolean} options.visible  控制叠加物的显示隐藏
     * @param {String} options.domId    叠加物的div元素的id值
     * @param {DOM} options.element  叠加物的div元素内容
     * @param {hmap.basetype.Coordinate} options.location  叠加物的地理坐标
     * @param {hmap.basetype.Offset} options.offset  叠加物的地理坐标与真实位置之间的偏移量
     */
    constructor(options){
        if (new.target === hmap.overlay.Overlay) {
            throw new Error("The Overlay is an abstract class,and can not be instanced!");
        }
        this.CLASS_NAME="hmap.overlay.Overlay";

        this._userData = options;//object格式，传入的参数json

        this._visible = options.hasOwnProperty("visible")?options.visible:true;//控制弹框显示隐藏
        //总体的dom
        this._container=document.createElement("DIV");
        this._container.style.cursor = "default";
        this._container.style.display = (this._visible==true)?"block":"none";

        this._layer = null;
        this._domId=options.hasOwnProperty("domId")?options.domId:"";
        this._container.id = this._domId;

        const isDOM=( typeof HTMLElement === "object") ? options.element instanceof HTMLElement :
                    options.element && typeof options.element === "object" && options.element.nodeType === 1 && typeof options.element.nodeName === "string";
        this._element=(options.hasOwnProperty("element")&&isDOM)?options.element:null;
        this._location=(options.hasOwnProperty("location")&&(options.location instanceof hmap.basetype.Coordinate))?options.location:null;
        this._offset=options.hasOwnProperty("offset")?options.offset:new hmap.basetype.Offset(0,0);

        if(this._element && !isDOM){throw new TypeError("The element in options must be a DOM!");}
        if(!(this._offset instanceof hmap.basetype.Offset)){throw new TypeError("The offset in options must be hmap.basetype.Offset!");}
        if(!this._location){throw new Error("The location in options must be set and a Coordinate!");}
        this._userData.element=null;
        this._userData.location=null;
        this._userData.offset=null;
    }

    /**
     * 设置叠加物的可见性。仅设置叠加物的显示隐藏，而叠加物本身依然存在。
     * @param {Boolean} visible 显示设置true，隐藏设置false
     */
    setVisibility(visible = true) {
        if (!(typeof(visible) === "boolean")) {
            throw new TypeError("visible must be boolean type!");
        }
        if(this._visible !== visible){
            this._visible = visible;
            this._container.style.display = (visible==true)?"block":"none";
        }
    }

    /**
     * 获取构造叠加物的属性options中，key对应的value值
     * @param {String} key 属性options中的键
     * @returns {Object} 键对应的value值；若不存在则返回null
     */
    get(key){
        if(this._userData){
            return this._userData[key];
        }
        return null;
    }

    /**
     * 重新设置叠加物的地理坐标，默认叠加物的左上角位于地理坐标位置上。
     * @param {hmap.basetype.Coordinate} location 地理坐标
     * @returns {hmap.overlay.Overlay} 返回设置后的叠加物对象
     */
    setLocation(location){
        if(!(location instanceof hmap.basetype.Coordinate)){
            throw new Error("the parameter must be hmap.basetype.Coordinate!");
        }
        this._location=location;
        if(this._layer){
           this._reAdjust();
        }
        return this;
    }

    /**
     * 获取叠加物的地理坐标。
     * @returns {hmap.basetype.Coordinate} 地理坐标
     */
    getLocation(){
        // 要把偏移量加进去
        if(this._offset.getValue("x")===0 && this._offset.getValue("y")===0 && this._offset.getValue("z")===0){
            return this._location;
        }else{
            const pixel = this.getPixelPos();
            return this._layer.getMap().getCoordinateFromPixel(pixel);
        }
    }

    /**
     * 获取在叠加物地理坐标上增加的偏移量
     * @returns {hmap.basetype.Offset}  偏移量对象。
     */
    getOffset(){
        return this._offset;
    }

    /**
     * 基于叠加物的地理坐标，再给叠加物增加偏移量
     * @param {hmap.basetype.Offset} offset 偏移量对象
     * @returns {hmap.overlay.Overlay} 返回设置后的叠加物对象
     */
    setOffset(offset){
        if(!(offset instanceof hmap.basetype.Offset)){
            throw new Error("the parameter must be hmap.basetype.Offset!");
        }
        this._offset=offset;
        if(this._layer){
            this._reAdjust();
        }
        return this;
    }

    /**
     * 获取当前叠加物内容中的DOM元素
     * @returns {DOM} 返回叠加物的DOM内容
     */
    getElement(){
        return this._element;
    }

    /**
     * 重新设置叠加物中的DOM内容
     * @param {DOM} element DOM对象
     * @returns {hmap.overlay.Overlay} 返回设置后的叠加物对象
     */
    setElement(element){
        if(typeof element === "object"){
            if(this._element){
                this._popupDom.removeChild(this._element);
            }
            this._popupDom.appendChild(element);
            this._element = element;
        }
        return this;
    }

    /**
     * 获取叠加物的div元素的id值
     * @returns {String} id值
     */
    getDomId(){
        return this._domId;
    }

    /**
     * 设置叠加物的div元素的id值
     * @param {String} domId id值
     * @returns {hmap.overlay.Overlay} 返回设置后的叠加物对象
     */
    setDomId(domId){
        this._domId = domId;
        this._container.id = this._domId;
        return this;
    }

    /**
     * 将叠加物对象添加到叠加物图层上
     * @param {hmap.layer.OverlayLayer} layer 叠加物图层
     * @returns {hmap.overlay.Overlay} 返回设置后的叠加物对象
     * @private
     */
    setLayer(layer){
        if(layer instanceof hmap.layer.OverlayLayer){
            this._layer = layer;
            this._reAdjust();
            this._layer.container.appendChild(this._container);
        }else{
            throw new Error("the parameter must be a Map!");
        }
        return this;
    }

    /**
     * 获取叠加物所在图层对象
     * @returns {hmap.layer.OverlayLayer|NULL} 图层对象；若叠加物对象没有加到图层上，则返回null。
     */
    getLayer(){
        if(this._layer){
            return this._layer;
        }else{
            return null;
        }
    }

    /**
     * 获取叠加物锚点的像素位置。锚点:叠加物的左上角点。
     * @returns {hmap.basetype.Pixel} 像素对象
     * @private
     */
    getPixelPos(){
        // 要把偏移量加进去
        if(this._layer){
            let pixel = this._layer.getMap().getPixelFromCoordinate(this._location);
            let x = pixel.getX()+this._offset.getValue("X");
            let y = pixel.getY()+this._offset.getValue("Y");
            return new hmap.basetype.Pixel(x,y);
        }else{
            throw new Error("The map parameter must be set,your popup must add to layer ang the layer must add to map");
        }
    }
};;"use strict";
hmap.overlay = hmap.overlay || {};
/**
 * 简易弹框，即：用div元素呈现在地图地理坐标上的简易弹框。随着弹框数量增多，渲染性能会有明显下降。
 * @type {hmap.overlay.SimplePopup}
 * @extends hmap.overlay.Overlay
 */
hmap.overlay.SimplePopup=class extends hmap.overlay.Overlay {
    /**
     * 构造函数。
     * @param {Object} options  
     * @param {Boolean} options.visible  控制叠加物的显示隐藏
     * @param {String} options.domId    叠加物的div元素的id值
     * @param {DOM} options.element  叠加物的div元素内容
     * @param {hmap.basetype.Coordinate} options.location  叠加物的地理坐标
     * @param {hmap.basetype.Offset} options.offset  叠加物的地理坐标与真实位置之间的偏移量
     * @example
     * let  content = document.createElement("div");
     * content.innerHTML = "弹框内容";
     * let location = new hmap.basetype.Coordinate(120, 30, 0);
     * let simplePopup = new hmap.overlay.SimplePopup({
     *      "location":location,
     *      "domId":"domId",
     *      "element":content
     * });
     */
    constructor(options){
        options = options||{};
        super(options);
        this.CLASS_NAME="hmap.overlay.SimplePopup";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        this._container.appendChild(this._element);
        this._popupDom = this._container;
    }

    _reAdjust(){
        // 默认弹框左上角放在地图坐标位置，通过偏移量调整弹框
        const pixelPosition = this.getPixelPos();
        this._container.style.position="absolute";
        this._container.style.top=pixelPosition.getY()+"px";
        this._container.style.left=pixelPosition.getX()+"px";
        this._container.style.zIndex="10";
    }

};;"use strict";
hmap.overlay = hmap.overlay || {};
/**
 * 带引导线的弹框。可灵活调整引导线和弹框的位置。随着弹框数量增多，渲染性能会有明显下降。
 * @type {hmap.overlay.ArrawPopup}
 * @extends hmap.overlay.Overlay
 */
hmap.overlay.ArrawPopup=class extends hmap.overlay.Overlay {
    /**
     * 构造函数。
     * @param {Object} options  
     * @param {Boolean} options.visible  控制叠加物的显示隐藏
     * @param {String} options.domId    叠加物的div元素的id值
     * @param {DOM} options.element  叠加物的div元素内容
     * @param {hmap.basetype.Coordinate} options.location  叠加物的地理坐标
     * @param {hmap.basetype.Offset} options.offset  叠加物的地理坐标与真实位置之间的偏移量
     * @param {String} options.anchorType  锚点的形状,只支持:椭圆"ellipse"、矩形"rect"。锚点:引导线的起始点
     * @param {Number} options.anchorWidth   锚点形状的宽
     * @param {Number} options.anchorHeight   锚点形状的高
     * @param {hmap.style.Color} options.anchorFillColor   锚点形状的填充色
     * @param {hmap.style.Color} options.anchorStrokeColor  锚点形状的描边色
     * @param {Number} options.anchorStrokeWidth  锚点形状的描边宽
     * @param {Array<hmap.basetype.Offset>} options.linePointOffsetArr  线上拐点(包括终点)，距线起始点的偏移量
     * @param {Number} options.lineWidth  线宽
     * @param {hmap.style.Color} options.lineColor  线的颜色
     * @param {hmap.basetype.Offset} options.popOffsetLine  弹框左上角点距离线终点的偏移量
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "带引导线的弹框内容";
     * let location = new hmap.basetype.Coordinate(120.435078, 30.19345, 0);
     * let arrawPopup = new hmap.overlay.ArrawPopup({  
     *      "visible":true,
     *      "domId":"a",
     *      "element":content,
     *      "location":location,
     *      "offset": new hmap.basetype.Offset(10,10),
     *      "anchorType": "ellipse",
     *      "anchorWidth": 2,
     *      "anchorHeight": 2,
     *      "anchorFillColor": new hmap.style.Color(0,0,0,1),
     *      "anchorStrokeColor": new hmap.style.Color(255,0,0,1),
     *      "anchorStrokeWidth": 2,
     *      "linePointOffsetArr": [new hmap.basetype.Offset(10,10),new hmap.basetype.Offset(20,10)],
     *      "lineWidth": 5,
     *      "lineColor": new hmap.style.Color(0,0,0,1),
     *      "popOffsetLine": new hmap.basetype.Offset(0,0)
     * });
     */
    constructor(options){
        options = options||{};
        super(options);
        this.CLASS_NAME="hmap.overlay.ArrawPopup";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        //弹框左上角点距离线终点的偏移量
        this._popOffsetLine = options.hasOwnProperty("popOffsetLine")?options.popOffsetLine:new hmap.basetype.Offset(0,0);
        //线上点距始点的偏移量的数组、线宽、线颜色
        this._linePointOffsetArr = options.hasOwnProperty("linePointOffsetArr")?options.linePointOffsetArr:[new hmap.basetype.Offset(10,10)];
        this._lineWidth = options.hasOwnProperty("lineWidth")?options.lineWidth:0;
        this._lineColor = options.hasOwnProperty("lineColor")?options.lineColor:new hmap.style.Color(0,0,0,0);
        this._lineDom = document.createElement('div');
        //锚点：像素坐标位置
        this._anchorType = options.hasOwnProperty("anchorType")?options.anchorType:"ellipse";//椭圆ellipse、矩形rect
        this._anchorWidth = options.hasOwnProperty("anchorWidth")?options.anchorWidth:0;
        this._anchorHeight = options.hasOwnProperty("anchorHeight")?options.anchorHeight:0;
        this._anchorFillColor = options.hasOwnProperty("anchorFillColor")?options.anchorFillColor:new hmap.style.Color(0,0,0,0);
        this._anchorStrokeColor = options.hasOwnProperty("anchorStrokeColor")?options.anchorStrokeColor:new hmap.style.Color(0,0,0,1);
        this._anchorStrokeWidth = options.hasOwnProperty("anchorStrokeWidth")?options.anchorStrokeWidth:2;
        //弹框dom
        this._popupDom = document.createElement("div");
        this._popupDom.appendChild(this._element);
        //总dom
        this._container.appendChild(this._popupDom);
        this._container.appendChild(this._lineDom);
    }

    _reAdjust(){
        //颜色、宽度
        const lineColor = this._lineColor.toRGBAColor();
        const lineWidth = this._lineWidth;
        //线起点像素
        const pixelPosition = this.getPixelPos();
        const startX = pixelPosition.getX();
        const startY = pixelPosition.getY();
        //中间点
        let pointStr = ' ';
        let endX,endY;
        if(this._linePointOffsetArr.length>0){
            for(let i=0,len=this._linePointOffsetArr.length;i<len;i++){
                const offset = this._linePointOffsetArr[i];
                const x = startX+offset.getValue("x");
                const y = startY-offset.getValue("y");
                pointStr += x+','+y+' ';
                if(i==len-1){
                   //线终点像素
                    endX = x;
                    endY = y;
                }
            }
        }

        this._lineStr = '<polyline points="'+startX+','+startY+pointStr+endX+','+endY+'" style="fill:rgba(0,0,0,0);stroke:'+lineColor+';stroke-width:'+lineWidth+'"/>';
        // 锚点
        const anchorFillColor = this._anchorFillColor.toRGBAColor();
        const anchorStrokeColor = this._anchorStrokeColor.toRGBAColor();
        if(this._anchorType=="ellipse"){
            this._anchorStr = '<ellipse cx="'+startX+'" cy="'+startY+'" rx="'+this._anchorWidth/2+'" ry="'+this._anchorHeight/2+'" style="fill:'+anchorFillColor+';stroke:'+anchorStrokeColor+';stroke-width:'+this._anchorStrokeWidth+'"/>';
        }else{
            this._anchorStr = '<rect x="'+startX+'" y="'+startY+'" width="'+this._anchorWidth/2+'" height="'+this._anchorHeight/2+'" style="fill:'+anchorFillColor+';stroke:'+anchorStrokeColor+';stroke-width:'+this._anchorStrokeWidth+';"/>';
        }

        let str = '';
        str += '<svg width="100%" height="100%" style="position:absolute">';
        str += this._anchorStr;
        str += this._lineStr;
        str += '</svg>';

        this._lineDom.innerHTML = str;

        //弹框
        const popupX = endX+this._popOffsetLine.getValue("x");
        const popupY = endY-this._popOffsetLine.getValue("y");
        this._popupDom.style.position="absolute";
        this._popupDom.style.top=popupY+"px";
        this._popupDom.style.left=popupX+"px";
        this._popupDom.style.zIndex="10";

    }

};;"use strict";
hmap.overlay = hmap.overlay || {};
/**
 * 自适应弹框，即在拖动地图时，弹框会随地图拖动而改变位置，使弹框尽量在屏幕内显示。随着弹框数量增多，渲染性能会有明显下降。
 * @type {hmap.overlay.AdaptPopup}
 * @extends hmap.overlay.Overlay
 */
hmap.overlay.AdaptPopup=class extends hmap.overlay.Overlay {
    /**
     * 构造函数。
     * @param {Object} options     
     * @param {Boolean} options.visible  控制叠加物的显示隐藏
     * @param {String} options.domId    叠加物的div元素的id值
     * @param {DOM} options.element  叠加物的div元素内容
     * @param {hmap.basetype.Coordinate} options.location  叠加物的地理坐标
     * @param {hmap.basetype.Offset} options.offset  叠加物的地理坐标与真实位置之间的偏移量
     * @example
     * let content = document.createElement("div");
     * content.innerHTML = "适配弹框内容";
     * let location = new hmap.basetype.Coordinate(120.435078, 30.19345, 0);
     * let adaptPopup = new hmap.overlay.AdaptPopup({  
     *      "visible":true,
     *      "domId":"a",
     *      "element":content,
     *      "location":location,
     *      "offset": new hmap.basetype.Offset(10,10)
     * });
     */
    constructor(options){
        options = options||{};
        super(options);
        this.CLASS_NAME = "hmap.overlay.AdaptPopup";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        this._status = ["top","left"];//初始状态

        //弹窗dom 
        this._popupDom = document.createElement("div");
        this._popupDom.appendChild(this._element);
        //总dom
        this._container.appendChild(this._popupDom);
    }

    _reAdjust(){

        //线起点像素
        const anchor = this.getPixelPos();
        const anchorX = anchor.getX();
        const anchorY = anchor.getY();
        const layerw = this._layer.container.clientWidth;
        const layerh = this._layer.container.clientHeight;
        const popupw = this._element.clientWidth;
        const popuph = this._element.clientHeight;
        if(anchorY<popuph && (this._status[0]!="top")){
            this._status[0]="top";
        }else if(anchorY>(layerh-popuph) && (this._status[0]!="bottom")){
            this._status[0]="bottom";
        }
        if(anchorX<popupw && (this._status[1]!="left")){
            this._status[1]="left";
        }else if(anchorX>(layerw-popupw) && (this._status[1]!="right")){
            this._status[1]="right";
        }

        //线终点像素
        const endY = (this._status[0]=="top")?(anchorY):(anchorY);
        const endX = (this._status[1]=="left")?(anchorX):(anchorX);

        //弹窗像素位置
        const popupY = (this._status[0]=="top")?endY:(endY-popuph);
        const popupX = (this._status[1]=="left")?endX:(endX-popupw);
        this._popupDom.style.position="absolute";
        this._popupDom.style.top=popupY+"px";
        this._popupDom.style.left=popupX+"px";
        this._popupDom.style.zIndex="10";
    }

};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 三维电子围墙类。如果有多个电子围墙，需要先添加内圈，再添加外圈。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.EleWall、hmap.geosolution.math.EleWallModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.EleWall}
 */
hmap.geosolution.EleWall=class{
    /**
     * 构建一个电子围墙。
     * @param {object} options 对象包含的属性如下：
     * @param {hmap.basetype.CoordSeq} options.CoordSeq 围墙的拐点坐标序列，必须项
     * @param {Boolean} options.needSimple 原始坐标是否需要简化,默认false
     * @param {Number} options.densityDistance 加密(密集)的距离，单位米，默认20，最小5，参数小于5则赋值为5
     * @param {Number} options.waveDistance 波浪动画的波距，单位米，默认为40倍加密距离,参数小于densityDistance则赋值为densityDistance的值。
     * @param {Number} options.height 围墙高度，单位米,取值为[0,无穷大),默认为100米
     * @param {hmap.style.Color} options.color 围墙颜色，hmap中color类，不考虑参数中的透明度，默认值为new hmap.style.Color(0,0,255)，围墙透明度在顶部透明度和底部透明度之间渐变
     * @param {Number} options.bottomOpacity 围墙底部的透明度，默认为0.3,取值[0,1]，参数小于0则取值为0，参数大于1则赋值为1
     * @param {Number} options.topOpacity 围墙顶部的透明度，默认为0.1,取值[0,1]，参数小于0则取值为0，参数大于1则赋值为1
     * @param {Number} options.speed 速度等级，默认为5，取值[1-10]，参数小于1则取值为1，参数大于10则赋值为10
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.EleWall";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        /****必要的属性*****/
        this.coordSeq = options.coordSeq;                                       //电子围墙的坐标序列
        this._detailCoords = [];                                                         //保存加密之后的坐标
        this._needSimple = options.needSimple ? options.needSimple : false;              //原始坐标是否需要简化
        this.densityDistance = options.densityDistance ? options.densityDistance:20;     //增密距离
        this.waveDistance = options.hasOwnProperty("waveDistance") ? options.waveDistance:40*this.densityDistance;       //波浪动画的波距
        this._minDistance = 5;             //增密的最小距离
        this._minHeight = 1/110000;        //高度的衡量单位，米
        this.height = options.hasOwnProperty("height") ? options.height*this._minHeight : 100;                          //电子围墙的高度
        this.color = options.color ? options.color:new hmap.style.Color(0.0,0.0,255.0,1.0);                     //电子围墙的颜色
        this.bottomOpacity = options.hasOwnProperty("bottomOpacity") ? options.bottomOpacity:0.3;
        this.topOpacity = options.hasOwnProperty("topOpacity") ? options.topOpacity:0.1;
        this.speed = options.hasOwnProperty("speed") ? options.speed :5;                                  //速度等级
        this.group = [];                        //透明度数组
        this.dataReady = false;
        this._init();
}

    /**
     * 初始化
     * @private
     */
    _init(){
        if(this.height < 0){
            throw "height of elewall can not be less than 0!";
        }
        this.waveDistance = (this.waveDistance < this.densityDistance ? this.densityDistance:this.waveDistance);        //最小为增密距离

        this._generateDetailCoords();
        this._initGroup();
    }

    /**
     * 计算用于动画的详细坐标,计算结果保存在 this._detailCoords 中
     * @private
     */
    _generateDetailCoords(){
        if(!(this.coordSeq instanceof hmap.basetype.CoordSeq)){
            throw TypeError("coordSeq format must be hmap.basetype.CoordSeq!");
        }
        if(this._needSimple){
            this.coordSeq = this.coordSeq.simplify();
            if(this.coordSeq.getCoordCount() < 2){
                throw "coordinates count after simplify must more than 1";
            }
        }
        let coordinatesArray = this.coordSeq.extractCoords();       //序列解析成数组
        let detailPoints = [];
        for(let i=0;i<coordinatesArray.length;i++){
            if(i==0){
                let thisP = coordinatesArray[i];
                detailPoints.push([thisP.getOrdinate("X"),thisP.getOrdinate("Y"),thisP.getOrdinate("Z")]);
            }
            if(i!=0){
                let thisP = coordinatesArray[i];
                let preP = coordinatesArray[i-1];
                var midnum = this._generateMidPointNum([preP,thisP]);           //计算中间点的个数
                var thisArray = this._getCoordArray(thisP);
                var preArray = this._getCoordArray(preP);
                if(midnum==0){
                    detailPoints.push([thisArray[0],thisArray[1],thisArray[2]]);
                }else{      //大于0
                    for(let j=0;j<midnum;j++){
                        detailPoints.push([preArray[0]+(thisArray[0]-preArray[0])*(j+1)/midnum,preArray[1]+(thisArray[1]-preArray[1])*(j+1)/midnum,preArray[2]+(thisArray[2]-preArray[2])*(j+1)/midnum]);
                    }
                }
            }
        }
        this._detailCoords = detailPoints;
        this.dataReady = true;      //动画基础数据准备好
    }

    /**
     * 获取一个地理坐标对象的对应数组eg：[x,y,z]
     * @private
     * @param {hmap.basetype.Coordinate} coordinate 地理坐标对象
     * @returns {Array} 返回数组[x,y,z]
     */
    _getCoordArray(coordinate){
        return [
            coordinate.getOrdinate("X"),
            coordinate.getOrdinate("Y"),
            coordinate.getOrdinate("Z")
        ];
    }

    /**
     * 根据开始点和结束点，计算中间点的数量
     * @private
     * @param {Array<hmap.basetype.Coordinate>} coordsArray 地理坐标的数组
     * @returns {Number} 中间点的个数
     */
    _generateMidPointNum(coordsArray){
        let coord1 = coordsArray[0];
        let coord2 = coordsArray[1];
        let result = coord1.get3Dist(coord2);               //计算两个三维坐标之间的距离
        return Math.floor(result/(this.densityDistance < this._minDistance ? this._minDistance:this.densityDistance));
    }

    /**
     * 初始化围墙元素组
     * @private
     */
    _initGroup(){
        if(!(this.color instanceof  hmap.style.Color)){
            throw TypeError("color must be instanceof hmap.style.Color!");
        }
        this.colorArr = this.color.toArray();
        this.group = [];
        let detailCoords = this._detailCoords;
        for(let i=0;i<detailCoords.length;i++){
            let item = new Object();
            item.coords = detailCoords[i];      //[[x,y,z]...]
            this.group.push(item);
        }
        this.group.aniParam = 0;    //控制正弦函数的波动
    }

    /**
     * 获取自动生成的id
     * @returns {Number} 自动生成的id
     */
    getId(){
        return this._id;
    }

    /**
     * 设置id
     * @param {Number} id 设置的id
     */
    setId(id){
        this._id = id;
    }

    /**
     * 设置增密距离
     * @param {Number} dDistance 距离，单位米
     */
    setDensityDistance(dDistance){
        this.densityDistance = (dDistance < this._minDistance ? this._minDistance:dDistance);   //最小为5

        this._generateDetailCoords();       //密度更改，需要重新计算动画坐标数组和动画点组
        this._initGroup();
    }

    /**
     * 设置曲线的波峰距离
     * @param {Number} wDistance 距离，单位米
     */
    setWaveDistance(wDistance){
        this.waveDistance = (wDistance < this.densityDistance ? this.densityDistance:wDistance);   //最小为增密距离
    }

    /**
     * 设置围墙高度，单位米
     * @param {Number} height 高度
     */
    setHeight(height){
        this.height = this._minHeight*height;
    }

    /**
     * 获取围墙高度，单位米
     * @returns {Number} 高度
     */
    getHeight(){
        return this.height/this._minHeight;
    }

    /**
     * 设置颜色
     * @param {hmap.style.Color} color 颜色，这里不考虑透明度参数
     * @throws 当参数color类型不对时，抛出异常。
     * @example
     * eleWall.setColor(new hmap.style.Color(255.0,0.0,0.0));
     */
    setColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw TypeError("color must be instance of hmap.style.Color");
        }
        this.color = color;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 电子围墙的图层类。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.EleWall、hmap.geosolution.math.EleWallModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.EleWallLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.EleWallLayer=class extends hmap.layer.Layer{
    /**
     * 创建电子围墙的图层对象。
     * @param {Object} options 可选项
     * @param {Boolean} options.isWave 围墙是否需要动画波动，默认false
     * @param {Number} options.pattern 绘制模式。 0表示只绘制面，1表示只绘制线，2表示同时绘制。默认为0
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.EleWallLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container=null;                //图层容器
        this._map=null;                      //地图对象
        this._dataMap = {};                   //所有的数据
        this._eleWalls = [];                  //图层中所有的电子围墙
        this.isWave = (options && options.isWave) ? options.isWave:false;                    //是否需要波动
        this.pattern = (options && options.pattern) ? options.pattern : 0;                      //绘制模式
    }

    /**
     * 获取图层的类型
     * @returns {String} 返回图层的类型
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 添加一个电子围墙
     * @param {hmap.geosolution.EleWall} eleWall 电子围墙
     * @throws 当参数eleWall不符合参数类型时，抛出异常。
     */
    addEleWall(eleWall){
        if(!(eleWall instanceof hmap.geosolution.EleWall)){
            throw TypeError("parameter must be a hmap.geosolution.EleWall!");
        }
        this._eleWalls.push(eleWall);
    };

    /**
     * 根据id获取电子围墙
     * @param {Number} id 电子围墙id
     * @returns {hmap.geosolution.EleWall} 返回获取的电子围墙；若没有则返回null
     */
    getEleWallById(id){
        let result = null;
        for(let eleWall of this._eleWalls){
            if(id && eleWall.getId()==id){
                result = eleWall;
            }
        }
        return result;
    }

    /**
     * 获取全部的电子围墙
     * @returns {Array<hmap.geosolution.EleWall>} 所有电子围墙的数组
     */
    getEleWalls(){
        return this._eleWalls;
    }

    /**
     * 根据电子围墙的id移除电子围墙
     * @param {Number} id 电子围墙的id
     */
    removeEleWallById(id){
        let eleWall = this.getEleWallById(id);
        if(eleWall){
            this.remove(eleWall);
        }
    }

    /**
     * 移除一个电子围墙
     * @param {hmap.geosolution.EleWall} eleWall 电子围墙
     * @throws 当参数eleWall不是电子围墙类型时，抛出异常。
     */
    remove(eleWall){
        if(!(eleWall instanceof hmap.geosolution.EleWall)){
            throw TypeError("parameter must be a hmap.geosolution.EleWall!");
        }
        if(eleWall){
            this._eleWalls.splice(this._eleWalls.findIndex(v => v.getId() === eleWall.getId()), 1);      //从数组中移除
        }
    }

    /**
     * 移除全部的电子围墙
     */
    removeAll(){
        if(this._eleWalls.length != 0){
            this._eleWalls = [];         //清空电子围墙
        }
    }

    /**
     * 设置是否波动
     * @param {Boolean} 波动设置true，不波动设置false
     */
    setWave(isWave){
        this.isWave = isWave;
    }

    /**
     * 设置绘制模式
     * @param {Number} 绘制模式。0表示只绘制面，1表示只绘制线，2表示同时绘制
     * @example
     * eleWalllayer.setPattern(2)
     */
    setPattern(pattern){
        this.pattern = pattern;
    }

    /**
     * 设置地图
     * @private
     */
    setMap(_map){
        super.setMap(_map);
        //初始化render
        this.vpMatrix=this._map.getVPMatrix();
        const posSize = this._isRTE ? 6 : 3;
        this.render=new hmap.EleWallRender(this.gl,posSize);
        this.getCullFaceStatus().setEnable(false);
        // this.getBlendStatus().setFunc({
        //     rgbSrcFactor:'SRC_ALPHA',
        //     rgbDstFactor:'ONE'
        // });
    }
    /**
     * 调render使用
     * @private
     */
    draw(){
        super.draw();
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    /**
     * 数据组织方法
     * @private
     */
    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;        //矩阵
        if(this._visibility){    //可见的情况
            this._updateEleWalls(false);
        }
        // 获取当前上下文的状态,如果为丢失则继续动画
        if(!this.gl.isContextLost() && this.isWave){
            this.animateId=requestAnimationFrame(function(){
                this.redraw();         //与map共用gl 则需要一直刷新地图
            }.bind(this));
        }
    }

    /**
     * 通过像素获取要素
     * @param {hmap.basetype.Pixel} pixel 像素坐标
     * @returns {Array} 以数组的形式返回所获取的要素
     */
    getFeaturesByPixel(pixel){
        cancelAnimationFrame(this.animateId);

        this._updateEleWalls(true);
        let pixels = new Uint8Array(4);
        const rect = this.container.getBoundingClientRect();
        const x_in_canvas = pixel.getX() - rect.left;
        const y_in_canvas = rect.bottom - pixel.getY();
        this.gl.readPixels(x_in_canvas,y_in_canvas,1,1,this.gl.RGBA,this.gl.UNSIGNED_BYTE,pixels);
        const index = this._getEleWallIndexBySelectionColor(pixels);
        this._updateEleWalls(false);
        const selectedFeature = this._eleWalls[index];
        if(index===-1||!selectedFeature){
            return [];
        }
        this.animateId=requestAnimationFrame(function(){this._tick()}.bind(this));
        return [selectedFeature];
    }

    /**
     * 根据电子墙的颜色获取id。在根据颜色编码对电子墙进行渲染时，根据该方法返回值的确定选中颜色对应的电子墙。
     * @param {array<Number>} color 颜色数组，数组元素为0到255的整数值，三个元素的值分别对应红、绿和蓝色。
     * @returns {Number} 电子墙id。
     * @private
     */
    _getEleWallIndexBySelectionColor(color){
        let index=0;
        index+=color[0];
        index+=color[1]<<8;
        index+=color[2]<<16;
        return index-1;
    }

    /**
     * 根据id获取电子墙的颜色。在根据颜色编码对电子墙进行渲染时，根据该方法的返回值确定所要渲染的电子墙颜色。
     * @param {Number} id 电子墙id。
     * @returns {Array<Number>} 颜色数组，数组元素为0到255的整数值，三个元素的值分别对应红、绿和蓝色。
     * @private
     */
    _getSelectionColor(id){
        id+=1;
        const color = new Array(3);
        color[0] = 255&id;
        id=id>>8;
        color[1] = 255&id;
        id=id>>8;
        color[2] = 255&id;
        return color;
    }

    /**
     * 更新电子围墙动画
     * @private
     * @param {Boolean} isSelectionMode 为true时开启选择模式。在点击鼠标的瞬间启用该模式进行颜色编码渲染，在该模式渲染完毕后要将该参数设为false参数再调用一次，以显示电子墙原来的颜色。
     */
    _updateEleWalls(isSelectionMode){
        const positions = [];
        const colors = [];
        const sizes = [];
        const indices=[];
        let indexLen=0;
        for(let i=0;i<this._eleWalls.length;i++){
            let eleWall = this._eleWalls[i];
            if(eleWall.dataReady){
                let eleWallHeight = eleWall.height;     //根据高度计算线坐标
                let eleWallColor;
                if(isSelectionMode) {
                    eleWallColor = this._getSelectionColor(i);
                    this.gl.disable(this.gl.BLEND);
                }else{
                    eleWallColor = eleWall.color.toArray();       //围墙的颜色
                    this.gl.enable(this.gl.BLEND);
                }
                let eleWallGroup = eleWall.group;
                let aniParam = eleWallGroup.aniParam;       //参数，控制正弦函数的波动
                for(let j=0;j<eleWallGroup.length;j++){
                    let wallItem = eleWallGroup[j];
                    let position = wallItem.coords;     //处理节点坐标
                    let wavePointNum = Math.floor(eleWall.waveDistance/eleWall.densityDistance);  //一个(或者半个)曲线周期中的点数量
                    let height = this.isWave ? (eleWallHeight + Math.sin((j-aniParam)*Math.PI/wavePointNum)*eleWallHeight/6):eleWallHeight;
                    if (this._isRTE) {          //精度补偿
                        const xx = this._float32FromDouble64(position[0]);
                        const yy = this._float32FromDouble64(position[1]);
                        const zz_bottom = this._float32FromDouble64(position[2]);
                        const zz_top = this._float32FromDouble64(position[2]+height);
                        positions.push(xx[0], yy[0], zz_bottom[0], xx[1], yy[1], zz_bottom[1]);
                        positions.push(xx[0], yy[0], zz_top[0], xx[1], yy[1], zz_top[1]);
                    } else {
                        positions.push(position[0],position[1],position[2]);         //底部坐标
                        positions.push(position[0],position[1],position[2]+height);  //顶部坐标
                    }
                    colors.push(eleWallColor[0]/255,eleWallColor[1]/255,eleWallColor[2]/255,eleWall.bottomOpacity);   //底部颜色
                    colors.push(eleWallColor[0]/255,eleWallColor[1]/255,eleWallColor[2]/255,eleWall.topOpacity);     //顶部颜色
                    sizes.push(2);sizes.push(2);
                    indices.push(indexLen+2*j,indexLen+2*j+1);
                }
                indices.push(65535);
                indexLen = indices.length - (i+1);
                eleWallGroup.aniParam = eleWallGroup.aniParam + eleWall.speed;      //按速度跳跃性改变值
            }
        }
        if(indices.length != 0){
            indices.pop();
        }
        this._dataMap = {
            positions:positions,
            colors:colors,
            sizes:sizes,
            indices:indices
        };
        this._drawEleWalls();
    }

    /**
     * 根据dataMap数据绘制电子围墙
     * @private
     */
    _drawEleWalls(){
		const dataMap = this._dataMap;
        const camera = this._splitCameraPrecision();
        const uniforms = {
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: camera
        };
		switch(this.pattern){
            case 0:
                this.render.draw(dataMap,uniforms,"TRIANGLE_STRIP");               //只绘制面
                break;
            case 1:
                this.render.draw(dataMap,uniforms,"LINES");                          //只绘制线
                break;
            case 2:
                this.render.draw(dataMap,uniforms,"TRIANGLE_STRIP","LINES");      //同时绘制
                break;
            default:
                this.render.draw(dataMap,uniforms,"TRIANGLE_STRIP");               //只绘制面
        }
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 柱状图图层,使用方式如其他图层,当与其它图层同时存在时,建议该图层置于其他图层之上
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Bar、hmap.geosolution.math.BarModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Pillar}
 * @extends hmap.layer.Layer
 * @example
 * let pillarLayer = new hmap.geosolution.Pillar();
 */
hmap.geosolution.Pillar=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this._map=null;
        this.render=null;
        this.gl=null;
        this.pillars=new Array();//柱状图数组
        this.maxWeight=0;
        this.programs=null;
        this.locations=null;
        this.CLASS_NAME = "hmap.geosolution.Pillar";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 刷新绘图缓冲区中的数据。
     * @param {String} id 柱状图唯一标识。唯一性由用户来保证，hmap仅给出一个可检索的字段。
     * @param {hmap.basetype.Coordinate}   coord 地理坐标，用于确定柱状图所在的地理位置。注意，一般情况下z值为0，表示柱状图不是悬在空中。
     * @param {String} label 柱状图的属性，用来区分柱状图，不支持显示
     * @param {Number} weight 权重，一个大于0的数值，决定了当前柱状图的高度，用柱状图的实际数据表示。在加入柱状图层的所有数据中，权重越大，高度越大。
     * @param {hmap.style.Color} color 当前柱状图的颜色。
     * @param {scale}  scale X,Y两个方向上的缩放倍数。默认宽高是地图单位。
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let color = new hmap.style.Color((255, 0, 0, 1);
     * let scale = [0.05, 0.05];
     * pillarLayer.addPillar("pillar_1", coord, "标注", 80, color, scale);
     */
    addPillar(id,coord,label,weight,color,scale){
        if(!(color instanceof hmap.style.Color)){
            throw TypeError ("color must be a hmap.style.Color!");
        }
        const colorA=color.toArray();
        this.pillars.push(id,coord,label,weight,colorA,scale);
        //确保柱状图最大值
        if(weight>=this.maxWeight){
            this.maxWeight=weight;
        }
    }

    /**
     * 绘制
     * @private
     * @example
     * let coord = new hmap.basetype.Coordinate(120,30,0);
     * let color = [1, 0, 0, 1];
     * let scale = [0.05, 0.05];
     * pillarLayer.addPillar("pillar_1", coord, "标注", 80, color, scale);
     * pillarLayer.redraw();
     */
    draw(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render.vpMatrix=this.vpMatrix;
        this.render.fogColor = this._map.getFogColor();
        this.render.fogDist = this._map.getFogDist();
        this.render.resolution=this._map.getResolution();
        this.render.cameraH=this._map._camera._getEyeZByResolution(this.render.resolution);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        //填充新数据
        const res=this._map.getResolution();
        //本级别最大值对应的最大GL高程比率
        //const heightRate=Math.round(0.8*this._map._camera._getEyeZByResolution(res)/this.maxWeight*100000)/100000;
        const heightRate=0.5*this._map._camera._getEyeZByResolution(res)/this.maxWeight;

        for(let i=0;i<this.pillars.length;i=i+6){
            const coord=this.pillars[i+1];
            const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
            const label=this.pillars[i+2];
            const  weight=this.pillars[i+3];
            const color=this.pillars[i+4];
            const scale=this.pillars[i+5];
            const glHeight=weight*heightRate;//柱状图在Webgl的高度
            scale[2]=0.007*weight;
            this.render.draw(x,y,z, label, weight, color, scale);
        }
    }

    /**
     * 给图层设置地图对象,将该图层与地图挂接,初始化渲染环境
     * @private
     * @param {hmap.Map} _map map对象
     */
    setMap(_map){
        super.setMap(_map);
        this.programs=this._glProgram();
        this.locations=this._glLocations();
        //渲染器初始化
        this.render=new hmap.PillarRender(this.gl,this.programs,this.locations);
    }

    /**
     * @private
     */
    _glProgram(){
        return{
            pillar:this.createPrograms(hmap.shader.modelShader.vsShader,hmap.shader.modelShader.fsShader),
        }
    }

    /**
     * @private
     */
    _glLocations(){
        let gl=this.gl;
        let programs=this.programs;
        return{
            pillar:hmap.modelShader.getLocations(gl,programs.pillar),
        }
    }


    /**
     * 初始化着色器程序
     * @private
     */
    createPrograms(vs,fs){
        let gl=this.gl;
        const shaderMap=this.initShaders(vs,fs);
        const vsShader=shaderMap.get("vsShader"),fsShader=shaderMap.get("fsShader");
        let program = gl.createProgram();
        // Attach pre-existing shaders
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = this.gl.getProgramInfoLog(program);
            throw 'Could not compile WebGL program. \n\n' + info;
        }
        return program;
    }


    /**
     * 初始化着色器
     * @private
     */
    initShaders(vs,fs){
        let gl=this.gl;
        const vsShader=this.compileShader(vs,gl.VERTEX_SHADER);
        const fsShader=this.compileShader(fs,gl.FRAGMENT_SHADER);
        const shaderMap=new Map();
        shaderMap.set("vsShader",vsShader).set("fsShader",fsShader);
        return shaderMap;
    }

    /**
     * 编译渲染用到的着色器代码
     * @private
     */
    compileShader(shaderSrc, shaderType) {
        let gl=this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 蝌蚪型的线动画
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Tadpole、hmap.geosolution.math.TadpoleModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Tadpole}
 */
hmap.geosolution.Tadpole=class{
    /**
     * 构造函数
     * @param {object} options 
     * @param {Number} options.maxWidth 最大线宽，单位像素
     * @param {Number} options.minWidth 最小线宽，单位像素
     * @param {hmap.style.Color} options.color 飞线颜色值，默认值为new hmap.style.Color(200.0,200.0,200.0,1.0)
     * @param {hmap.basetype.CoordSeq} options.coordSeq 线动画的坐标序列，必填项
     * @param {Number} options.flyingLength 飞线长度，单位为米，默认50
     * @param {Number} options.flyingSpeed 飞行速度，单位为米/秒，默认20，等量等长的情况下,蝌蚪图性能主要和飞行速度相关。速度越慢，耗费性能越多。
     */
    constructor(options,callback){
        this.CLASS_NAME="hmap.geosolution.Tadpole";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);    //自动生成
        /****添加需要的属性*****/
        this._flyingSpeed = options.flyingSpeed ? options.flyingSpeed:20;             //蝌蚪图飞行速度 默认20米/秒

        this._flyingLength = options.flyingLength ? options.flyingLength : 50;          //蝌蚪图飞行的长度，默认为50米

        this._maxWidth = options.maxWidth ? options.maxWidth:10;                    //最大线宽
        this._minWidth = options.minWidth ? options.minWidth:5;                     //最小线宽

        this._pointDensity = this._flyingLength/((this._flyingLength/this._flyingSpeed)*30);         //一分钟按30帧计算,30帧跑完一个蝌蚪，计算出加密距离

        this._color = options.color ? options.color:new hmap.style.Color(200.0,200.0,200.0,1.0);      //动画的颜色

        this.coordSeq = options.coordSeq;                                               //线动画的坐标序列

        this.detailCoords = [];                                   //线动画的详细坐标[[经度，纬度，高度]...]
        this.turningPoints = {};                //保存所有拐点的索引号

        this.callback = callback;

        this.movers_num = Math.floor(this._flyingLength/this._pointDensity);              //蝌蚪图组成点的数量

        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this._generateDetailCoords();
        this._initTadpole();              //初始化所有的动画点
    }

    /**
     * 计算用于动画的详细坐标,计算结果保存在 this._detailCoords 中
     * @private
     */
    _generateDetailCoords(){
        if(!(this.coordSeq instanceof hmap.basetype.CoordSeq)){
            throw TypeError("coordSeq format must be hmap.basetype.CoordSeq!");
        }
        if(this.coordSeq.getCoordCount() < 2){
            throw "coordinates count after simplify must more than 1";
        }
        const coordinatesArray = this.coordSeq.extractCoords();       //序列解析成数组
        const detailPoints = [];
        detailPoints.push([coordinatesArray[0].getOrdinate("X"),coordinatesArray[0].getOrdinate("Y"),coordinatesArray[0].getOrdinate("Z")]);        //i=0的情况
        this.turningPoints[detailPoints.length-1] = 0;
        for(let i=1;i<coordinatesArray.length;i++){
            let thisP = coordinatesArray[i],preP = coordinatesArray[i-1];
            var midnum = this._generateMidPointNum([preP,thisP]);
            var thisArray = [thisP.getOrdinate("X"),thisP.getOrdinate("Y"),thisP.getOrdinate("Z")];
            var preArray = [preP.getOrdinate("X"),preP.getOrdinate("Y"),preP.getOrdinate("Z")];
            if(midnum==0){
                detailPoints.push([thisArray[0],thisArray[1],thisArray[2]]);
            }else{
                for(let j=0;j<midnum;j++){
                    detailPoints.push([preArray[0]+(thisArray[0]-preArray[0])*(j+1)/midnum,preArray[1]+(thisArray[1]-preArray[1])*(j+1)/midnum,preArray[2]+(thisArray[2]-preArray[2])*(j+1)/midnum]);
                }
            }
            this.turningPoints[detailPoints.length-1] = i;
        }
        this.detailCoords = detailPoints;
    }

    /**
     * 初始化蝌蚪图的组成点
     * @private
     */
    _initTadpole(){
        if(!(this._color instanceof hmap.style.Color)){
            throw TypeError("color must be instance of hmap.style.Color");
        }
        this.point_num = this.detailCoords.length;          //动画总的点数
        this.colorArr = this._color.toArray();
        const scales = [],colors = [];
        for (let i = 0; i < this.movers_num; i++) {
            scales.push(this._getScale(i));
            colors.push(this.colorArr[0]/255,this.colorArr[1]/255,this.colorArr[2]/255,this._getOpacity(i));      //归一化的颜色数组
        }
        this.offset = - this.movers_num;        //默认偏移是负的长度
        this.dataMap = {
            xyzPositions:this.detailCoords,
            scales:scales,
            colors:colors,
            pointOffset:this.offset,
            routePointNum:this.point_num,
            groupPointNum:this.movers_num
        }
        this.isActive = true;
    }

    /**
     * 将坐标对象转换为数组
     * @private
     * @param {hmap.basetype.Coordinate} coordinate 坐标
     * @returns {Array} 坐标的数组格式[x,y,z]
     */
    _getCoordArray(coordinate){
        return [
            coordinate.getOrdinate("X"),
            coordinate.getOrdinate("Y"),
            coordinate.getOrdinate("Z")
        ];
    }

    /**
     * 根据开始点和结束点，计算中间点的数量
     * @private
     * @param {Array} coordsArray 经度、纬度、高度数组 [[lon1,lat1,height1],[lon2,lat2,height2]]
     * @returns {Number} 中间点的个数
     */
    _generateMidPointNum(coordsArray){
        let coord1 = coordsArray[0];
        let coord2 = coordsArray[1];
        let result = coord1.get3Dist(coord2);           //根据已有的方法计算两个三维坐标之间的距离
        return Math.floor(result/this._pointDensity);
    }

    /**
     * 根据点序号，获取点的scale
     * @private
     * @param {Number} index 点序号
     * @returns {Number} scale
     */
    _getScale(index){
        return this._minWidth + (this._maxWidth - this._minWidth)*Math.pow(((index+1)/this.movers_num),2)
    }

    /**
     * 不同的点序号，返回不同的透明度
     * @private
     * @param {Number} index 点序号
     * @returns {Number} opacity 透明度
     */
    _getOpacity(index){
        let result = 1.0;
        if(this.colorArr && this.colorArr.length == 4){
            result = this.colorArr[3]*Math.pow((index+1)/this.movers_num,1);
        }
        return result;
    }

    /**
     * 获取id
     * @returns {Number} 一个飞线动画的id
     * @example
     * let plId = pointLine.getId();
     */
    getId(){
        return this._id;
    }

    /**
     * 到达拐点，回调函数
     * @param {} data
     */
    returnPoint(data){
        if(typeof(this.callback) === "function"){
            this.callback (data);
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 流线要素
 * @type {hmap.geosolution.Flow}
 */
hmap.geosolution.Flow=class{
    /**
     * 构造函数
     * @param {object} options 
     * @param {hmap.style.Color} options.color 流线颜色值，默认值为new hmap.style.Color(200.0,200.0,200.0,1.0)
     * @param {hmap.basetype.CoordSeq} options.coordSeq 线动画的坐标序列，必填项
     * @param {Number} options.flyingLength 流线长度，单位为米，默认50
     * @param {Number} options.flyingSpeed 飞行速度，单位为米/秒，默认20，等量等长的情况下,流线性能主要和飞行速度相关。速度越慢，耗费性能越多。
     */
    constructor(options,callback){
        this.CLASS_NAME="hmap.geosolution.Flow";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);    //自动生成
        /****添加需要的属性*****/
        this._flyingSpeed = options.flyingSpeed ? options.flyingSpeed:20;             //蝌蚪图飞行速度 默认20米/秒

        this._flyingLength = options.flyingLength ? options.flyingLength : 50;          //蝌蚪图飞行的长度，默认为50米

        this._pointDensity = this._flyingLength/((this._flyingLength/this._flyingSpeed)*30);         //一分钟按30帧计算,30帧跑完一个蝌蚪，计算出加密距离

        this._color = options.color ? options.color:new hmap.style.Color(200.0,200.0,200.0,1.0);      //动画的颜色

        this.coordSeq = options.coordSeq;                                               //线动画的坐标序列

        this.detailCoords = [];                                   //线动画的详细坐标[[经度，纬度，高度]...]
        this.turningPoints = {};                                  //保存所有拐点的索引号

        this.callback = callback;

        this.movers_num = Math.floor(this._flyingLength/this._pointDensity);              //蝌蚪图组成点的数量

        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this._generateDetailCoords();
        this._initFlow();              //初始化所有的动画点
    }

    /**
     * 计算用于动画的详细坐标,计算结果保存在 this._detailCoords 中
     * @private
     */
    _generateDetailCoords(){
        if(!(this.coordSeq instanceof hmap.basetype.CoordSeq)){
            throw TypeError("coordSeq format must be hmap.basetype.CoordSeq!");
        }
        if(this.coordSeq.getCoordCount() < 2){
            throw "coordinates count after simplify must more than 1";
        }
        const coordinatesArray = this.coordSeq.extractCoords();       //序列解析成数组
        const detailPoints = [];
        detailPoints.push([coordinatesArray[0].getOrdinate("X"),coordinatesArray[0].getOrdinate("Y"),coordinatesArray[0].getOrdinate("Z")]);        //i=0的情况
        this.turningPoints[detailPoints.length-1] = 0;
        for(let i=1;i<coordinatesArray.length;i++){
            let thisP = coordinatesArray[i],preP = coordinatesArray[i-1];
            var midnum = this._generateMidPointNum([preP,thisP]);
            var thisArray = [thisP.getOrdinate("X"),thisP.getOrdinate("Y"),thisP.getOrdinate("Z")];
            var preArray = [preP.getOrdinate("X"),preP.getOrdinate("Y"),preP.getOrdinate("Z")];
            if(midnum==0){
                detailPoints.push([thisArray[0],thisArray[1],thisArray[2]]);
            }else{
                for(let j=0;j<midnum;j++){
                    detailPoints.push([preArray[0]+(thisArray[0]-preArray[0])*(j+1)/midnum,preArray[1]+(thisArray[1]-preArray[1])*(j+1)/midnum,preArray[2]+(thisArray[2]-preArray[2])*(j+1)/midnum]);
                }
            }
            this.turningPoints[detailPoints.length-1] = i;
        }
        this.detailCoords = detailPoints;
    }

    /**
     * 初始化流线图的组成点
     * @private
     */
    _initFlow(){
        if(!(this._color instanceof hmap.style.Color)){
            throw TypeError("color must be instance of hmap.style.Color");
        }
        this.point_num = this.detailCoords.length;          //动画总的点数
        this.colorArr = this._color.toArray();
        const colors = [];
        for (let i = 0; i < this.movers_num; i++) {
            colors.push(this.colorArr[0]/255,this.colorArr[1]/255,this.colorArr[2]/255,this._getOpacity(i));      //归一化的颜色数组
        }
        this.offset = - this.movers_num;        //默认偏移是负的长度
        this.dataMap = {
            xyzPositions:this.detailCoords,
            colors:colors,
            pointOffset:this.offset,
            routePointNum:this.point_num,
            groupPointNum:this.movers_num
        }
        this.isActive = true;
    }

    /**
     * 将坐标对象转换为数组
     * @param {hmap.basetype.Coordinate} coordinate 坐标
     * @returns {Array} 坐标的数组格式[x,y,z]
     * @private
     */
    _getCoordArray(coordinate){
        return [
            coordinate.getOrdinate("X"),
            coordinate.getOrdinate("Y"),
            coordinate.getOrdinate("Z")
        ];
    }

    /**
     * 根据开始点和结束点，计算中间点的数量
     * @param {Array} coordsArray 经度、纬度、高度数组 [[lon1,lat1,height1],[lon2,lat2,height2]]
     * @returns {Number} 中间点的个数
     * @private
     */
    _generateMidPointNum(coordsArray){
        let coord1 = coordsArray[0];
        let coord2 = coordsArray[1];
        let result = coord1.get3Dist(coord2);           //根据已有的方法计算两个三维坐标之间的距离
        return Math.floor(result/this._pointDensity);
    }

    /**
     * 不同的点序号，返回不同的透明度
     * @param {Number} index 点序号
     * @returns {Number} opacity 透明度
     * @private
     */
    _getOpacity(index){
        let headOpacity = (this.colorArr && this.colorArr[3])?this.colorArr[3]:1;
        let opacity = headOpacity * ((index+1)*2/this.movers_num);
        let result = opacity<1 ? opacity : 1;
        return result;
    }

    /**
     * 获取id
     * @returns {Number} 一个流线的id
     * @example
     * let plId = flow.getId();
     */
    getId(){
        return this._id;
    }

    /**
     * 到达拐点，回调函数
     * @param {Object} data
     * @private
     */
    returnPoint(data){
        if(typeof(this.callback) === "function"){
            this.callback (data);
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 蝌蚪型的线动画图层。备注：将该图层添加到地图上时，不要和底图图层共用画板（图层容器），否则底图会跟着频繁刷新。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Tadpole、hmap.geosolution.math.TadpoleModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.TadpoleLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.TadpoleLayer=class extends hmap.layer.Layer{
    /**
     * 蝌蚪型的线动画图层
     * @param {object} options 
     * @param {Boolean} options.needLoop 线动画是否循环播放
     * @param {Boolean} options.disableBlend 是否禁用颜色混合,默认false
     */
    constructor(options={}){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.TadpoleLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container = null;    //图层容器
        this._map = null;         //地图对象
        this.gl = null;           //webgl的绘图环境

        this.tadpoles = [];                //图层中所有的线动画

        this._isStart = false;             //动画开始的标记
        //this.deleteIfEnd = options.deleteIfEnd ? options.deleteIfEnd:false;         //播放结束后是否删除
        this.needLoop = options.needLoop ? options.needLoop:false;                  //是否循环播放
        this.disableBlend = options.disableBlend ? options.disableBlend:false;         //是否禁用颜色混合,默认false
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType() {
        return this.CLASS_NAME;
    }

    /**
     * 添加一个动画线
     * @param {hmap.geosolution.Tadpole} Tadpole 线动画
     * @throws 当参数tadpole的类型不对时，抛出异常。
     * @example
     * let coordSeq = [new hmap.basetype.Coordinate(120.13,30.19,0.0),new hmap.basetype.Coordinate(120.43,30.19,0.0)];
     * let tadpole = new hmap.geosolution.Tadpole({coordSeq:coordSeq});
     * tadpoleLayer.addTadpole(tadpole);
     */
    addTadpole(tadpole) {
        if (!(tadpole instanceof hmap.geosolution.Tadpole)) {
            throw "parameter must be a hmap.geosolution.Tadpole!"
        }
        this.tadpoles.push(tadpole);
    };

    /**
     * 根据id获取线动画
     * @param {Number} id 线动画id
     * @returns {hmap.geosolution.Tadpole} Tadpole 线动画
     * @example
     * let tadpole = tadPolelayer.getTadpoleById(id);
     */
    getTadpoleById(id) {
        let result = undefined;
        for (let tadpole of this.tadpoles) {
            if (id && tadpole.getId() == id) {
                result = tadpole;
            }
        }
        return result;
    }

    /**
     * 获取全部的线动画
     * @returns {Array<hmap.geosolution.Tadpole>} Tadpole 线动画集合
     * @example
     * let tadpoles = tadPolelayer.getTadpoles();
     */
    getTadpoles() {
        return this.tadpoles;
    }

    /**
     * 根据线动画的id移除线动画
     * @param {Number} id 线动画的id
     * @example
     * tadPolelayer.removeTadpoleById(id)
     */
    removeTadpoleById(id) {
        let tadpole = this.getTadpoleById(id);
        if (tadpole) {
            this.remove(tadpole);
        }
    }

    /**
     * 移除一个线动画
     * @param {hmap.geosolution.Tadpole} tadpole 线动画
     * @throws 当参数tadpole类型不对时，抛出异常。
     * @example
     * tadPolelayer.remove(tadpole)
     */
    remove(tadpole) {
        if (!(tadpole instanceof hmap.geosolution.Tadpole)) {
            throw "parameter must be a hmap.geosolution.Tadpole!"
        }
        if (tadpole) {
            this.tadpoles.splice(this.tadpoles.findIndex(v => v.getId() === tadpole.getId()), 1);      //从数组中移除
        }
    }

    /**
     * 移除全部的线动画
     * @example
     * tadPolelayer.removeAll()
     */
    removeAll() {
        if (this.tadpoles.length != 0) {
            this.tadpoles = [];         //清空线动画
        }
    };

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map) {
        super.setMap(_map);
        //初始化render
        this.vpMatrix = this._map.getVPMatrix();
        //设置render使用顶点缓冲区的方式,组成每个顶点的数量
        const posSize = this._isRTE ? 6 : 3;
        this.render = new hmap.TadpoleRender(this.gl, posSize,this.disableBlend);
    }

    /**
     * 重新绘制
     * @private
     */
    draw() {
        super.draw();
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    /**
     * @private
     */
    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;        //矩阵

        if(this._isStart && !this._isMGL){       //不和map共用gl
            this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);        //清除
        }
        if(this._visibility){
            this.updateTadpoles();
        }
        //获取当前上下文的状态,如果为丢失则继续动画
        if(this._isStart && !this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){
                if(!this._isMGL){       //不和map共用gl
                    this._tick();
                }else{
                    this.redraw();         //与map共用gl 则需要一直刷新地图
                }
            }.bind(this));
        }
    }

    /**
     * 开启动画
     */
    start() {
        this._isStart = true;
        this.redraw();
    }

    /**
     * 暂停动画
     */
    pause() {
        this._isStart = false;
    }

    /**
     * 将飞线数据添加到render的buffer中，每次删除或者更新操作都需要执行此方法
     */
    readyToRender(){
        const positions = [],sizes = [],colors = [];
        for(let i=0;i<this.tadpoles.length;i++){
            const tadpole = this.tadpoles[i],tadpoleData = tadpole.dataMap;
            const xyzPositions = tadpoleData.xyzPositions,tadpoleSizes = tadpoleData.scales,tadpoleColors = tadpoleData.colors;
            for(let j=0;j<xyzPositions.length;j++){
                const xyzPosition = xyzPositions[j];
                if (this._isRTE) {
                    const xx = this._float32FromDouble64(xyzPosition[0]);
                    const yy = this._float32FromDouble64(xyzPosition[1]);
                    const zz = this._float32FromDouble64(xyzPosition[2]);
                    positions.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                } else {
                    positions.push(xyzPosition[0], xyzPosition[1], xyzPosition[2]);
                }
            }
            sizes.push(...tadpoleSizes);        //比例数组
            colors.push(...tadpoleColors);      //颜色数组
        }
        const dataToBuffer = {                  //将要添加到缓存的数据
            positions:positions,
            sizes:sizes,
            colors:colors
        }
        this.render.addBufferData(dataToBuffer,"tadpole");               //向render中的buffer填充数据
        if(!this._isStart){
            this.start();           //开始动画
        }
    }

    /**
     * 更新飞线动画，回调到达的拐点和当前到达的点
     * @private
     */
    updateTadpoles() {
		const camera = this._splitCameraPrecision();
        const uniforms = {
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: camera
        };
        let totalPointSum = 0,groupPointsSum = 0;         //蝌蚪当前开始位置的索引
        for(let i=0;i<this.tadpoles.length;i++){
            let tadpole = this.tadpoles[i],tadpoleData = tadpole.dataMap;
            const totalPointNum =  tadpoleData.routePointNum,groupPointNum = tadpoleData.groupPointNum;         //蝌蚪路线点和组成点
            if(!tadpole.isActive){
                totalPointSum += totalPointNum;groupPointsSum += groupPointNum;
                continue;
            }
            let pointOffset = tadpoleData.pointOffset;
            let offset = totalPointSum + (pointOffset<0 ? 0 : pointOffset),offsetOther = groupPointsSum;        //position偏移和其他属性偏移
            let count = 0;                      //一个蝌蚪 需要绘制的点数
            if(pointOffset < 0){
                count = pointOffset + groupPointNum;
            }else if(pointOffset > totalPointNum - groupPointNum){
                count = totalPointNum - pointOffset;
            }else{
                count = groupPointNum;
            }
            if(count > 0){
                const dataParam = {
                    offsetPos:offset,
                    offsetOther:offsetOther,
                    count:count
                };
                this.render.draw(uniforms,dataParam);
            }
            const headPointIndex = pointOffset + groupPointNum;                      //回调蝌蚪图到达的点序号
            const returnPointIndex = tadpole.turningPoints[headPointIndex];
            if(returnPointIndex != undefined){
                tadpole.returnPoint(returnPointIndex);      //回调到达的端点
            }
            totalPointSum += totalPointNum;groupPointsSum += groupPointNum;     //递增
			if(this._isStart){
                tadpoleData.pointOffset ++;
            }
            

            if(tadpoleData.pointOffset > totalPointNum){                //到达终点
                if(this.needLoop){                                      //需要循环播放
                    tadpoleData.pointOffset = - groupPointNum;
                }else{
                    tadpole.isActive = false;
                }
            }
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 流线图层
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Flow、hmap.geosolution.math.FlowsModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.FlowsLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.FlowsLayer=class extends hmap.layer.Layer{
    /**
     * 流线动画图层，与蝌蚪图类似，缺点是不能设置线宽
     * @param {object} options 
     * @param {Boolean} options.needLoop 流线动画是否循环播放
     * @param {Boolean} options.disableBlend 是否禁用颜色混合,默认false
     */
    constructor(options={}){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.FlowsLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container = null;    //图层容器
        this._map = null;         //地图对象
        this.gl = null;           //webgl的绘图环境

        this.flows = [];                //图层中所有的线动画

        this._isStart = false;             //动画开始的标记
        this.needLoop = options.needLoop ? options.needLoop:false;                  //是否循环播放
        this.disableBlend = options.disableBlend ? options.disableBlend:false;         //是否禁用颜色混合,默认false
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType() {
        return this.CLASS_NAME;
    }

    /**
     * 添加一个流线要素
     * @param {hmap.geosolution.Flow} flow 流线要素
     * @throws 当参数flow的类型不对时，抛出异常。
     * @example
     * let coordSeq = [new hmap.basetype.Coordinate(120.13,30.19,0.0),new hmap.basetype.Coordinate(120.43,30.19,0.0)];
     * let flow = new hmap.geosolution.Flow({coordSeq:coordSeq});
     * flowsLayer.addFlow(flow);
     */
    addFlow(flow) {
        if (!(flow instanceof hmap.geosolution.Flow)) {
            throw "parameter must be a hmap.geosolution.Flow!"
        }
        this.flows.push(flow);
    };

    /**
     * 根据id获取线动画
     * @param {Number} id 线动画id
     * @returns {hmap.geosolution.Flow} Flow 流线要素
     * @example
     * let flow = flowlayer.getFlowById(id);
     */
    getFlowById(id) {
        let result = undefined;
        for (let flow of this.flows) {
            if (id && flow.getId() == id) {
                result = flow;
            }
        }
        return result;
    }

    /**
     * 获取全部的线动画
     * @returns {Array<hmap.geosolution.Flow>} flows 流线要素集合
     * @example
     * let flows = flowslayer.getFlows();
     */
    getFlows() {
        return this.flows;
    }

    /**
     * 根据线动画的id移除线动画
     * @param {Number} id 线动画的id
     * @example
     * flowsLayer.removeFlowById(id)
     */
    removeFlowById(id) {
        let flow = this.getFlowById(id);
        if (flow) {
            this.remove(flow);
        }
    }

    /**
     * 移除一个线动画
     * @param {hmap.geosolution.Flow} flow 流线要素
     * @throws 当参数flow类型不对时，抛出异常。
     * @example
     * flowsLayer.remove(flow)
     */
    remove(flow) {
        if (!(flow instanceof hmap.geosolution.Flow)) {
            throw "parameter must be a hmap.geosolution.Flow!"
        }
        if (flow) {
            this.flows.splice(this.flows.findIndex(v => v.getId() === flow.getId()), 1);      //从数组中移除
        }
    }

    /**
     * 移除全部的线动画
     * @example
     * flowsLayer.removeAll()
     */
    removeAll() {
        if (this.flows.length != 0) {
            this.flows = [];         //清空线动画
        }
    };

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map) {
        super.setMap(_map);
        //初始化render
        this.vpMatrix = this._map.getVPMatrix();
        //设置render使用顶点缓冲区的方式,组成每个顶点的数量
        const posSize = this._isRTE ? 6 : 3;
        this.render = new hmap.FlowsOldRender(this.gl, posSize,this.disableBlend);
    }

    /**
     * 重新绘制
     * @private
     */
    draw() {
        super.draw();
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    /**
     * @private
     */
    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;        //矩阵

        if(this._isStart && !this._isMGL){       //不和map共用gl
            this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);        //清除
        }
        if(this._visibility){
            this.updateFlows();
        }
        //获取当前上下文的状态,如果为丢失则继续动画
        if(this._isStart && !this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){
                if(!this._isMGL){       //不和map共用gl
                    this._tick();
                }else{
                    this.redraw();         //与map共用gl 则需要一直刷新地图
                }
            }.bind(this));
        }
    }

    /**
     * 开启动画
     */
    start() {
        this._isStart = true;
        this.redraw();
    }

    /**
     * 暂停动画
     */
    pause() {
        this._isStart = false;
    }

    /**
     * 将流线数据添加到render的buffer中，每次删除或者更新操作都需要执行此方法
     */
    readyToRender(){
        const positions = [],colors = [];
        for(let i=0;i<this.flows.length;i++){
            const flow = this.flows[i],flowData = flow.dataMap;
            const xyzPositions = flowData.xyzPositions,flowColors = flowData.colors;
            for(let j=0;j<xyzPositions.length;j++){
                const xyzPosition = xyzPositions[j];
                if (this._isRTE) {
                    const xx = this._float32FromDouble64(xyzPosition[0]);
                    const yy = this._float32FromDouble64(xyzPosition[1]);
                    const zz = this._float32FromDouble64(xyzPosition[2]);
                    positions.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                } else {
                    positions.push(xyzPosition[0], xyzPosition[1], xyzPosition[2]);
                }
            }
            colors.push(...flowColors);      //颜色数组
        }
        const dataToBuffer = {                  //将要添加到缓存的数据
            positions:positions,
            colors:colors
        }
        this.render.addBufferData(dataToBuffer);               //向render中的buffer填充数据
        if(!this._isStart){
            this.start();           //开始动画
        }
    }

    /**
     * 更新流线动画，回调到达的拐点和当前到达的点
     * @private
     */
    updateFlows() {
        const camera = this._splitCameraPrecision();
        const uniforms = {
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: camera
        };
        const blend = this.getBlendStatus();
        blend.setFunc({
            rgbSrcFactor:hmap.status.BlendFactor.SRC_ALPHA,         //颜色叠加混合
            rgbDstFactor: hmap.status.BlendFactor.ONE,
            rgbMode: hmap.status.BlendFunc.FUNC_ADD
        })
        blend.active(this.gl);

        let totalPointSum = 0,groupPointsSum = 0;                   //流线当前开始位置的索引
        for(let i=0;i<this.flows.length;i++){
            let flow = this.flows[i],flowData = flow.dataMap;
            const totalPointNum =  flowData.routePointNum,groupPointNum = flowData.groupPointNum;         //流线路线点和组成点
            if(!flow.isActive){
                totalPointSum += totalPointNum;groupPointsSum += groupPointNum;
                continue;
            }
            let pointOffset = flowData.pointOffset;
            let offset = totalPointSum + (pointOffset<0 ? 0 : pointOffset),offsetOther = groupPointsSum;        //position偏移和其他属性偏移
            let count = 0;                      //一个流线 需要绘制的点数
            if(pointOffset < 0){
                count = pointOffset + groupPointNum;
            }else if(pointOffset > totalPointNum - groupPointNum){
                count = totalPointNum - pointOffset;
            }else{
                count = groupPointNum;
            }
            count = (count > totalPointNum)?totalPointNum:count;
            if(count > 0){
                const dataParam = {
                    offsetPos:offset,
                    offsetOther:offsetOther,
                    count:count
                };
                this.render.draw(uniforms,dataParam);
            }
            const headPointIndex = pointOffset + groupPointNum;                      //回调流线到达的点序号
            const returnPointIndex = flow.turningPoints[headPointIndex];
            if(returnPointIndex != undefined){
                flow.returnPoint(returnPointIndex);      //回调到达的端点
            }
            totalPointSum += totalPointNum;groupPointsSum += groupPointNum;     //递增
			if(this._isStart){
				flowData.pointOffset ++;
			}

            if(flowData.pointOffset > totalPointNum){                //到达终点
                if(this.needLoop){                                      //需要循环播放
                    flowData.pointOffset = - groupPointNum;
                }else{
                    flow.isActive = false;
                }
            }
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 热力图。热力图本质上是一种密度图，默认红色区域表示分析要素的密度大，而蓝色区域表示分析要素的密度小。只要点密集，就会形成聚类区域。
 * 调用者只需关心业务，权重色只有四色渐变，蓝、绿、黄、红
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Heatpoint、hmap.geosolution.math.HeatmapModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Heatmap}
 * @extends hmap.layer.Layer
 * @example
 * let heatmap = new hmap.geosolution.Heatmap();
 */
hmap.geosolution.Heatmap=class extends hmap.layer.Layer{

    /**
     * 构造函数。
     */
    constructor(options){
        super(options);
        //绘图环境
        this.container=null;
        //热力点数组
        this.heatPoints=[];
        //所有点的热力最大值
        this.maxVal=0;
        //热力点的像素直径
        this.size=40.0;
        this._programs=null;
        this._locations=null;
        //控制各个区间是否显示的透明度,数值只有0和1
        this._opacities=[1.0,1.0,1.0,1.0];
        //控制各个区间的颜色值,区间根据热力点的value有小到大排列
        this._colors=[[0.0,0.0,1.0,this._opacities[0]],[0.0,1.0,0.0,this._opacities[1]],
            [1.0,1.0,0.0,this._opacities[2]],[1.0,0.0,0.0,this._opacities[3]]];
        this.CLASS_NAME="hmap.geosolution.Heatmap";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //使用最低颜色的一半初始化基础颜色
        this._tColors=[this._colors[0][0]*0.5,this._colors[0][1]*0.5,this._colors[0][2]*0.5,this._colors[0][3]*0.5].concat(this._colors.reduce(function (a, b) { return a.concat(b)} ));
        this._maxValFlag=true;//默认使用热力点的最大值,false则使用设定
        this._heatMaxValue=0;//热力图的热力最大值
    }

    /**
     * 与地图挂接，初始化绘图环境
     * @private
     */
    setMap(_map){
        super.setMap(_map);
        // this._map = _map;
        // this.container = this._map.canvas;
        // this.gl=_map.gl;
        //绘制前准备,初始化programs,locations,buffers,frameBuffer等
        this._initRender();
    }

    /**
     * 初始化渲染所需
     * @private
     */
    _initRender(){
        this._programs=this._glPrograms();
        this._locations=this._glLocations();
        this._buffers=this._createBuffer();
        this._frameBuffer=this._createFrameBuffer(this.gl.canvas.clientWidth,this.gl.canvas.clientHeight,0);
        this._renderData=this._getRenderData();
        this._colorFrame=this._createFrameBuffer(this.gl.canvas.clientWidth,this.gl.canvas.clientHeight,1);
        this._colorData=this._getRenderColor();
        this._vaos={"render":this.gl.createVertexArray(),
            "texture":this.gl.createVertexArray(),
            "color":this.gl.createVertexArray()
        };
    }

    /**
     * 重新绘制热力图
     * @private
     */
    draw(){
        super.draw();
        //首先计算最值
        let gl=this.gl;
        this.gl.polygonOffset(-10,-10);
        this.vpMatrix=this._map.getVPMatrix();
        this._fogColor = this._map.getFogColor();
        this._fogDist = this._map.getFogDist();
        //draw texture,绘制帧缓冲区
        {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._frameBuffer.depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.canvas.clientWidth, gl.canvas.clientHeight);

            gl.bindTexture(gl.TEXTURE_2D, this._frameBuffer.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            //render to our targetTexture by binding the framebufffer
            gl.bindFramebuffer(gl.FRAMEBUFFER,this._frameBuffer.frameBuffer);
            //tell webgl how to convert from clip space to pixel
            gl.viewport(0, 0, gl.canvas.clientWidth,gl.canvas.clientHeight);
            //clear the canvas and the depth buffer
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ONE);
            gl.disable(gl.DEPTH_TEST);
            this._drawTexture();
        }
        //draw color,绘制帧缓冲区
        {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._colorFrame.depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.canvas.clientWidth, gl.canvas.clientHeight);

            gl.bindTexture(gl.TEXTURE_2D, this._colorFrame.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            //render to our targetTexture by binding the framebufffer
            gl.bindFramebuffer(gl.FRAMEBUFFER,this._colorFrame.frameBuffer);
            //tell webgl how to convert from clip space to pixel
            gl.viewport(0, 0, gl.canvas.clientWidth,gl.canvas.clientHeight);
            //clear the canvas and the depth buffer
            // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO);
            // gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
            // gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE);
            // gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);
            gl.disable(gl.DEPTH_TEST);
            this._drawColor();
        }
        //draw render,将帧缓冲区绘制到屏幕上
        {
            //render to the canvas
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            //render th cube with the texture we just rendered to
            // gl.bindTexture(gl.TEXTURE_2D, this._frameBuffer.texture);
            //tell webgl how to converse from clip space to pixels
            // gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
            // gl.clearColor(0, 0, 0, 0);
            // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            // gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE);
            this._drawRender();
            gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE);
        }
    }

    /**
     * 添加热力图
     * @param {hmap.basetype.Coordinate} coord 坐标点
     * @param {Number} val 
     * @example
     * let coordinate = new hmap.basetype.Coordinate(120,30,0);
     * heatmap.addHeatPoint(coordinate,10);
     */
    addHeatPoint(coord,val){
        if(!Number.isNaN(val)){
            if(val>=this.maxVal){
                this.maxVal=val;
            }
            const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
            this.heatPoints.push(x,y,z,val);
        }
        if( this._maxValFlag){
            this._heatMaxValue=this.maxVal;
        }
    }

    /**
     * 设置最大热力值
     * @param {Number} value 最大热力值
     */
    setHeatMaxValue(value){
        this._heatMaxValue=value;
        this._maxValFlag=false;
    }

    /**
     * 获取最大热力值
     * @returns {Number} 返回最大热力值
     */
    getHeatMaxValue(){
        return this._heatMaxValue;
    }

    /**
     * 设置对应热度层级的透明度
     * @param {Number} level 热度层级，大于等于0的整数值
     * @param {Number} opacity 透明度
     */
    setColorOpacity(level,opacity){
        this._opacities[level]=opacity;
        this._colors[level][3]=opacity;
        this._tColors[7+level*4]=opacity;
    }

    /**
     * 设置热力图的基础颜色
     * @param {Float} r 范围0.0-1.0
     * @param {Float} g 范围0.0-1.0
     * @param {Float} b 范围0.0-1.0
     * @param {Float} a 范围0.0-1.0
     */
    setBaseColor(r,g,b,a=1.0){
        this._tColors.splice(0,4,r,g,b,a);
    }

    /**
     * 设置热力图的等级颜色
     * @param {Array} colorLev0 RGB颜色数组,密度最小的热力等级颜色 eg:[1,0,0]
     * @param {Array} colorLev1 RGB颜色数组,密度次小的热力等级颜色 eg:[0,1,1]
     * @param {Array} colorLev2 RGB颜色数组,密度大小为第二的热力等级颜色 eg[0,0,1]
     * @param {Array} colorLev3 RGB颜色数组,密度最大的热力等级颜色 eg:[0,0,0]
     * @example
     * heatmap.setColors([1,0,0],[0,1,0],[0,0,1],[0,0,0]); 以上四组颜色是热力图的四个等级颜色，每组为三色数组，没有透明度属性
     */
    setColors(colorLev0,colorLev1,colorLev2,colorLev3){
        const color0=[colorLev0[0],colorLev0[1],colorLev0[2],this._opacities[0]];
        const color1=[colorLev1[0],colorLev1[1],colorLev1[2],this._opacities[1]];
        const color2=[colorLev2[0],colorLev2[1],colorLev2[2],this._opacities[2]];
        const color3=[colorLev3[0],colorLev3[1],colorLev3[2],this._opacities[3]];
        this._colors=[color0,color1,color2,color3];
        const baseColor=this._tColors.slice(0, 4);
        this._tColors=baseColor.concat(this._colors.reduce(function (a, b) { return a.concat(b)} ));
    }

    /**
     * 获取当前热力图的等级颜色配置
     * @returns {Array} 返回各等级的RGBA颜色数组,颜色数组索引增大,表示热力图的等级密度也增大
     * @example
     * let colors = Heatmap.getColors();
     */
    getColors(){
        return this._colors;
    }

    /**
     * 根据热度等级设定是否显示该等级
     * @param {Boolean} flag 是否显示,显示为true；不显示为false。
     * @param {Number} level 热度等级0\1\2\3
     * @example
     * heatmap.setDisplayByLevel(false,1);
     */
    setDisplayByLevel(flag=false,level=0){

        if(flag==="true"||flag===true){
            this._opacities[level]=1.0;
            this._colors[level][3]=1.0;
        }else{
            this._opacities[level]=0.0;
            this._colors[level][3]=0.0;
        }
        const baseColor=this._tColors.slice(0, 4);
        this._tColors=baseColor.concat(this._colors.reduce(function (a, b) { return a.concat(b)} ));
    }

    /**
     * 设置热力图的基础点直径大小
     * @param {Number} size 点直径大小，单位像素
     * @example
     * heatmap.setSize(13);
     */
    setSize(size){
        this.size=size;
    }

    /**
     * 清除所有热力图的点
     */
    clearAllHeatPoints(){
        this.heatPoints=[];
        //热力最大值
        this.maxVal=0;
    }


    /**
     * 获取渲染所需program
     * @private
     * @returns {Object} 返回JSON格式的program
     */
    _glPrograms(){
        return{
            texture:this.createPrograms(this.frameVsShader,this.frameFsShader),
            render:this.createPrograms(this.vsShader,this.fsShader),
            color:this.createPrograms(this.colorVsShader,this.colorFsShader)
        };
    }

    /**
     * 获取渲染所需locations
     * @private
     * @returns {Object} 返回JSON格式的locations
     */
    _glLocations(){
        let gl=this.gl;
        let programs=this._programs;
        return {
            texture:this.getLocations(gl,programs.texture,"frame"),
            render:this.getLocations(gl,programs.render,"render"),
            color:this.getLocations(gl,programs.color,"color")
        };
    }

    /**
     * 渲染到canvas上使用的固定数据
     * @private
     * @returns {Object} 返回数据
     */
    _getRenderData(){
        let positions = [
            -1.0, 1.0,0.0,
            -1.0,-1.0,0.0,
            1.0, 1.0,0.0,
            1.0,-1.0,0.0
        ];
        let indices=[
            0,1,2,
            2,1,3
        ];

        let texCoords=[
            0,1,
            0,0,
            1,1,
            1,0
        ];
        return{
            positions:positions,
            texCoords:texCoords,
            indices:indices,
            count:6
        };
    }

    /**
     * 渲染颜色使用数据
     * @private
     * @returns {Object} 返回JSON格式的渲染颜色的数据
     */
    _getRenderColor(){
        let positions=[
            -1.0,0.0,0.0,
            -0.5,0.0,0.0,
            0.0,0.0,0.0,
            0.5,0.0,0.0,
            1.0,0.0,0.0
        ];
        let indices=[0,1,2,3,4];
        return{
            positions:positions,
            indices:indices,
            count:5
        };
    }

    /**
     * 绘制到canvas
     * @private
     */
    _drawRender(){
        const length=this.heatPoints.length;
        if(length<=0)return;
        let gl=this.gl;
        let data=this._renderData;
        let buffers=this._buffers;
        let program=this._programs.render;
        let locations=this._locations.render;

        gl.bindVertexArray(this._vaos.render);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
        gl.enableVertexAttribArray(locations.positionAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(data.positions),gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.texCoordBuffer);
        gl.enableVertexAttribArray(locations.texCoordAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(data.texCoords),gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.texCoordAttributeLocation,2, gl.FLOAT, false, 0, 0);

        const indicesBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(data.indices),gl.STATIC_DRAW);

        gl.useProgram(program);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._frameBuffer.texture);
        gl.uniform1i(locations.textureLocation, 0);
        gl.activeTexture(gl.TEXTURE0+1);
        gl.bindTexture(gl.TEXTURE_2D,this._colorFrame.texture);
        gl.uniform1i(locations.colorTexture,1);
        gl.uniform4fv(locations.fogColorLocation,this._fogColor);
        gl.uniform2fv(locations.fogDistLocation,this._fogDist);
        gl.drawElements(gl.TRIANGLES,data.count, gl.UNSIGNED_BYTE, 0);
        gl.bindVertexArray(null);
    }

    /**
     * 绘制纹理到frame
     * @private
     */
    _drawTexture(){
        const length=this.heatPoints.length;
        if(length<=0)return;
        let gl=this.gl;
        let buffers=this._buffers;
        let program=this._programs.texture;
        let locations=this._locations.texture;

        const values=new Float32Array(this.heatPoints);
        const FSIZE=values.BYTES_PER_ELEMENT;
        gl.bindVertexArray(this._vaos.texture);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,values,gl.STATIC_DRAW);
        gl.enableVertexAttribArray(locations.positionAttributeLocation);
        gl.vertexAttribPointer(locations.positionAttributeLocation, 3, gl.FLOAT, false, 4*FSIZE, 0);

        gl.enableVertexAttribArray(locations.valueAttributeLocation);
        gl.vertexAttribPointer(locations.valueAttributeLocation,1,gl.FLOAT,false,4*FSIZE,3*FSIZE);

        gl.useProgram(program);
        gl.uniform1f(locations.sizeLocation,this.size);
        gl.uniform1f(locations.maxValueLocation,this._heatMaxValue);
        gl.uniformMatrix4fv(locations.mvpMatrixLocation, false, this.vpMatrix.getElements());
        gl.drawArrays(gl.POINTS,0,this.heatPoints.length/4);
        gl.bindVertexArray(null);
    }

    /**
     * 绘制color到frame
     * @private
     */
    _drawColor(){
        const length=this._colorData.count;
        // if(length<=0)return;
        let gl=this.gl;
        let buffers=this._buffers;
        let program=this._programs.color;
        let locations=this._locations.color;
        let datas=this._colorData;

        const values=new Float32Array(datas.positions);
        gl.bindVertexArray(this._vaos.color);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,values,gl.STATIC_DRAW);
        gl.enableVertexAttribArray(locations.positionAttributeLocation);
        gl.vertexAttribPointer(locations.positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER,buffers.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(this._tColors),gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(locations.colorAttributeLocation);
        gl.vertexAttribPointer(locations.colorAttributeLocation,4,gl.FLOAT,false,0,0);

        gl.useProgram(program);
        gl.drawArrays(gl.LINE_STRIP,0,length);
        gl.bindVertexArray(null);
    }

    /**
     * 创建所需buffer,目前valuebuffer未使用,为后期数据拆分预留
     * @private
     * @returns {Object} 返回JSON格式的buffer
     */
    _createBuffer(){
        let gl=this.gl;
        const positionBuffer=gl.createBuffer();
        const valueBuffer=gl.createBuffer();
        const sizeBuffer=gl.createBuffer();
        const textureBuffer=gl.createBuffer();
        const colorBuffer=gl.createBuffer();
        return{
            positionBuffer:positionBuffer,
            valueBuffer:valueBuffer,
            sizeBuffer:sizeBuffer,
            texCoordBuffer:textureBuffer,
            colorBuffer:colorBuffer
        };
    }

    /**
     * 创建帧缓冲
     * @private
     * @param {Number} textureWidth 纹理宽
     * @param {Number} textureHeight 纹理高
     * @param {Number} texId 
     * @returns {Object}
     */
    _createFrameBuffer(textureWidth,textureHeight,texId=0){
        let gl=this.gl;

        //创建帧缓冲
        const frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        //创建渲染缓冲,设置大小,设定为帧缓冲的深度关联对象,实现隐藏面消除等
        const depthRenderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureWidth, textureHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);

        //纹理设置(数据),绘制是将帧缓冲作为纹理
        gl.activeTexture(gl.TEXTURE0 + texId);
        const fTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, fTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
        //设定帧缓冲的颜色关联对象,并指定纹理
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fTexture, 0);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        const e=gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if(e!==gl.FRAMEBUFFER_COMPLETE){
            throw "Framebuffer object is incomplete:"+e.toString();
        }

        return{frameBuffer:frameBuffer,
            depthRenderBuffer:depthRenderBuffer,
            texture:fTexture,unit:texId}
    }

    /**
     * 初始化着色器程序
     * @private
     */
    createPrograms(vs,fs){
        const shaderMap=this.initShaders(vs,fs);
        const vsShader=shaderMap.get("vsShader"),fsShader=shaderMap.get("fsShader");
        let program = this.gl.createProgram();
        // Attach pre-existing shaders
        this.gl.attachShader(program, vsShader);
        this.gl.attachShader(program, fsShader);
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            let info = this.gl.getProgramInfoLog(program);
            throw 'Could not compile WebGL program. \n\n' + info;
        }
        return program;
    }


    /**
     * 初始化着色器
     * @private
     */
    initShaders(vs,fs){
        const vsShader=this.compileShader(vs,this.gl.VERTEX_SHADER);
        const fsShader=this.compileShader(fs,this.gl.FRAGMENT_SHADER);
        const shaderMap=new Map();
        shaderMap.set("vsShader",vsShader).set("fsShader",fsShader);
        return shaderMap;
    }

    /**
     * 编译渲染用到的着色器代码
     * @private
     */
    compileShader(shaderSrc, shaderType) {
        let shader = this.gl.createShader(shaderType);
        this.gl.shaderSource(shader, shaderSrc);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            let info = this.gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 聚合类。
 * @type {hmap.geosolution.Cluster}
 */
hmap.geosolution.Cluster = class {
    /**
     * 创建聚合对象。
     * @param {Array} coordsArr [{coor:new hmap.basetype.Coorainate(),attr:{}},...]
     * @param {hmap.layer.Vector} layer 普通矢量图层
     * @param {hmap.Map} map 地图对象
     * @param {Object} options 选项。给出的属性都将应用在聚合类上
     * @param {hmap.style.TextSymbol} options.textSymbol 文字符号，可选项。
     * @param {hmap.style.MarkerSymbol} options.markerSymbol 图标符号，必选项。
     * @param {Number} options.gridSize 聚合网格大小,默认是100px
     * @param {Boolean} options.clusterOne 若为true则聚合网格内只有一个点的情况也参与聚合，在聚合图标上方显示1，
     * 若为false，则聚合网格内只有一个点的情况下不参与聚合，只显示图标，不显示数值。
     * @param {hmap.Map} map 地图对象
     * @example
     * //定义矢量图层
     * let vectorLayer = new hmap.layer.VectorLayer("矢量要素图层"); //定义矢量图层
     * map.addLayer(vectorLayer);//将矢量图层添加到map容器中
     * //创建点数组
     * let coords = [];//定义聚合的点数组
     * for(let i=0;i<=1000 ;i++){
     *   const coordinate = new hmap.basetype.Coordinate(119+Math.random()*2,29+Math.random()*2);
     *   coords.push(coordinate);
     *  }
     *  //聚合方法
     * let textSymbol = new hmap.style.TextSymbol({
     *    "fontSize":16,     //（可选项）
     *    "backgroundColor":new hmap.style.Color(255, 0, 0, 0.7), //（可选项）
     *    "fontColor":new hmap.style.Color(255.0, 255.0, 0.0, 1.0), //（可选项）
     *    "fontFace":"楷体" //（可选项）
     *    "offset":new hmap.basetype.Offset(0,0,0) //(可选项，聚合文字的偏移量，默认为0,0,0)
     *  });
     * let markerSymbol = new hmap.style.Icon({
     *   "opacity": 0.8,  //设置marker的透明度，可以为[0,1]区间内的任意值，0表示完全透明，1表示完全不透明 //（可选项）
     *   "imgSrc": "marker.png", //设置marker的图片路径 // 若传了markerSymbol属性，这个图片路径是（必选项）
     *   "size": new hmap.basetype.Size(40, 40), //设置marker的大小,单位为像素 //（可选项）
     *   "anchor": [-0.5, -0.5],  //设置图标在marker处的偏移量，为大于0的任意值，具体偏移多少可与下方的参考点作比较 //（可选项）
     *   "offset":new hmap.basetype.Offset(0,0,0) //（可选项）
     *  });
     * options={  //可选项
     *   markerSymbol:markerSymbol,   //聚合的图标样式，必须 //（必选项）
     *   textSymbol:textSymbol,    //textSymbol为聚合的文字样式，可以不传，不传将以默认样式 //（可选项）
     *   gridSize:200,   //聚合网格大小，可以不传，不传默认为100，单位为px //（可选项）
     *   clusterOne:false //（可选项）
     * }
     * cluster=new hmap.geosolution.Cluster(coords,vectorLayer,map,options);  //options为可选项
     * cluster.mesher();
     */
    constructor(coordsArr, layer, map, options = {}) {
        this.pointAfter = []; //聚合完成后的点位
        this._coordsArr = coordsArr.map(object=> {
            if (object instanceof hmap.basetype.Coordinate) {
                return {coor: object, attr: {}}
            }else if(object.coor) {
                if (!object.hasOwnProperty("attr")) {
                    object.attr = {};
                }
                return object;
            }
        });
        this._layer = layer;
        this._map = map;
        layer._style = null;
        if (!options.markerSymbol || !(options.markerSymbol instanceof hmap.style.Icon) || options.markerSymbol.getImgSrc().trim().length == 0) {
            throw new Error("options must have attribute markerSymbol, and markerSymbol must be instance of hmap.style.Icon with a valid imgSrc");
        }

        this._fontSize = options.textSymbol ? options.textSymbol.getFontSize() : 16;
        this._backgroundColor = (options.textSymbol && options.textSymbol.getBackgroundColor() &&
                (options.textSymbol.getBackgroundColor().toArray().toString() != new hmap.style.Color(255, 255, 255, 0).toArray().toString())) ?
            options.textSymbol.getBackgroundColor() : new hmap.style.Color(255, 0, 0, 0.7);

        this._textOffset = (options.textSymbol && options.textSymbol.getOffset() &&
            options.textSymbol.getOffset().toString() != "0,0,0") ? options.textSymbol.getOffset() : new hmap.basetype.Offset(0, 0, 0);

        this._fontColor = (options.textSymbol && options.textSymbol.getFontColor() &&
                options.textSymbol.getFontColor().toArray().toString() != new hmap.style.Color(0, 0, 0, 1).toArray().toString()) ?
            options.textSymbol.getFontColor() : new hmap.style.Color(255.0, 255.0, 0.0, 1.0);
        this._fontFace = (options.textSymbol && options.textSymbol.getFontFace() &&
            options.textSymbol.getFontColor() != "Microsoft YaHei") ? options.textSymbol.getFontFace() : "楷体";
        this._opacity = (options.markerSymbol.getOpacity() &&
            options.markerSymbol.getOpacity() != 1.0) ? options.markerSymbol.getOpacity() : 0.8;
        this._imgSrc = options.markerSymbol.getImgSrc()
        this._gridSize = options.gridSize ? options.gridSize : 100;
        this._size = options.markerSymbol.getSize() ? options.markerSymbol.getSize() : new hmap.basetype.Size(40, 40);
        this._anchor = options.markerSymbol.getAnchor() ? options.markerSymbol.getAnchor() : [-0.5, -0.5];

        this._offset = (options.markerSymbol.getOffset() &&
            options.markerSymbol.getOffset().toString() != "0,0,0") ? options.markerSymbol.getOffset() : new hmap.basetype.Offset(0, 0, 0);

        this._clusterOne = options.clusterOne !== undefined ? options.clusterOne : true; //(options && options.clusterOne)?options.clusterOne:true;
        this.CLASS_NAME = "hmap.geosolution.Cluster";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.eventListenner();
    }
    /**
     * 聚合函数
     */
    mesher() {
        this._layer.removeAllFeatures();
        const gridSize = this._gridSize;
        let mExtent = this._map.getExtent();
        let mapDivSize = this._map.getSize();
        let resolution = (mExtent.getRight() - mExtent.getLeft()) / mapDivSize._width;
        let gridLength = gridSize * resolution;
        let startR = Math.floor(mExtent.getLeft() / gridLength);
        let endR = Math.floor(mExtent.getRight() / gridLength);
        let startC = Math.floor(mExtent.getBottom() / gridLength);
        let endC = Math.floor(mExtent.getTop() / gridLength);
        let coordsIn = {};
        let len;
        for (let i = 0,len = this._coordsArr.length; i < len; i++) {
            if (!this._coordsArr[i] || !this._coordsArr[i].coor) {
                continue;
            }
            let coordRow = Math.floor(this._coordsArr[i].coor._x / gridLength);
            let coordCol = Math.floor(this._coordsArr[i].coor._y / gridLength);
            //在起止的行与列范围内的点，才参与聚合
            if (startR <= coordRow && coordRow <= endR && startC <= coordCol && coordCol <= endC) {
                let ranks = coordRow + "-" + coordCol;
                if (!coordsIn[ranks]) {
                    coordsIn[ranks] = [];
                }
                coordsIn[ranks].push(this._coordsArr[i]); //统计行列号相同的点，构成数组

            }
        }

        let lengthArr = [];
        this.pointAfter = [];
        for (let ranks in coordsIn) {
            lengthArr.push(coordsIn[ranks].length);
        }
        let features = [];
        for (let ranks in coordsIn) {
            let textNumber = String(coordsIn[ranks].length);
            let textSymbol = new hmap.style.TextSymbol({ //聚合的文字点样式
                "text": textNumber,
                "fontSize": this._fontSize,
                "backgroundColor": this._backgroundColor,
                "fontColor": this._fontColor,
                "fontFace": this._fontFace,
                "offset": this._textOffset
            });
            let markerSymbol = new hmap.style.Icon({ //聚合部分的图标点样式
                "opacity": this._opacity, //设置marker的透明度，可以为[0,1]区间内的任意值，0表示完全透明，1表示完全不透明
                "imgSrc": this._imgSrc, //设置marker的图片路径
                "size": this._size, //设置marker的大小,单位为像素
                "anchor": this._anchor, //设置图标在marker处的偏移量，为大于0的任意值，具体偏移多少可与下方的参考点作比较
                "offset": this._offset
            });
            let textStyle = new hmap.style.Style({
                "textSymbols": this._clusterOne ? [textSymbol] : (textNumber > 1 ? [textSymbol] : []),
                "markerSymbols": [markerSymbol]
            });

            if (textNumber > 1) {
                //取出第一个数组，构成marker，并显示数组长度
                let pointcluster = new hmap.geom.Point(coordsIn[ranks][0].coor);
                this.pointAfter.push(pointcluster);
                let textFeature = new hmap.feature.Vector(pointcluster, {count:coordsIn[ranks].length}, textStyle);
                features.push(textFeature);
            } else {
                //取出第一个数组，构成marker，并显示数组长度
                let point = new hmap.geom.Point(coordsIn[ranks][0].coor);
                this.pointAfter.push(point);
                let pointFeature = new hmap.feature.Vector(point, coordsIn[ranks][0]['attr'], textStyle);
                features.push(pointFeature);
            }
            
        }
        this._layer.addFeatures(features);
        this._layer.redraw();
    }

    /**
     * 添加监听，鼠标移动缩放时执行一次聚合
     * @private
     */
    eventListenner() {
        const me = this;
        me._map.event.addListener(EventType.MAPEVENT_MOVEEND, function (evt) {
            me.mesher();
        });
        me._map.event.addListener(EventType.MAPEVENT_ZOOMEND, function (evt) {
            me.mesher();
        });
    }

    /**
     * 返回聚合后的聚合点数组
     * @returns {Array<hmap.geom.Point>} 聚合后的点数组
     * @example
     * cluster.getPointAfter()
     */
    getPointAfter() {
        return this.pointAfter;
    }

    /**
     * @private
     */
    redraw() {
        this._layer.redraw();
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 网格热力图。网格热力图为将区域划分为若干网格，用网格颜色来区分热力值大小的一种表示方法。
 * @type {hmap.geosolution.GridHeat}
 */
hmap.geosolution.GridHeat =class{
    /**
     * 创建网格热力图。
     * @param {Array} coordsArr 地理坐标数组
     * @param {hmap.layer.Layer} layer 图层
     * @param {Object} options 可选项。网格聚合的参数
     * @param {Number} options.gridSize 可选项，网格大小，单位像素，若用户不传，则默认100px
     * @param {Array} options.propotionColor 可选项。定义聚合网格的颜色
     * @param {hmap.Map} map 地图对象
     * @example
     * //定义矢量图层并添加到地图上
     * vectorLayer = new hmap.layer.VectorLayer("矢量要素图层"); //定义矢量图层
     * map.addLayer(vectorLayer);//将矢量图层添加到map容器中
     * //创建网格热力点数组
     * let coords = [];
     * for(let i=0;i<=100000 ;i++){
     *   const coordinate = new hmap.basetype.Coordinate(119+Math.random()*2,29+Math.random()*2);
     *   coords.push(coordinate);
     * }
     * //执行网格热力图方法
     * options={  //可选项
     *   gridSize:100, //可选项。若不传，默认100px
     *   propotionColor:[[187,255,255,0],[187,255,255,0.8],[255,246,143,0.8],[255,106,106,0.8],[255,0,0,0.8]] //可选项，若不传，有默认值。其中第一个颜色在代表网格热力值最小，
     *   最后一个颜色值代表热力值最大（即单个网格内的点数量最多）。
     * }
     * gridHeat=new hmap.geosolution.GridHeat(coords,vectorLayer,map,options);  //options为可选项
     * gridHeat.mesher();
     */
    constructor(coordsArr,layer,map,options){
        this.CLASS_NAME = "hmap.geosolution.GridHeat";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._gridSize = (options && options.gridSize )?options.gridSize:100;
        this._propotionColor =(options && options.propotionColor)?options.propotionColor:[[0,0,255,0],[0,255,255,0.8],[0,255,0,0.8],[255,255,0,0.8],[255,0,0,0.8]];
        this._coordsArr=coordsArr;
        this._layer=layer;
        this._map = map;
        this.eventListenner();
    }
    /**
     * 聚合方法
     */
    mesher(){
        this._layer.removeAllFeatures();
        let mExtent=map.getExtent();
        let mapDivSize=map.getSize();
        let resolution = (mExtent.getRight()-mExtent.getLeft())/mapDivSize._width;
        let gridLength = this._gridSize*resolution;
        let startR = Math.floor(mExtent.getLeft()/gridLength);
        let endR = Math.floor(mExtent.getRight()/gridLength);
        let startC = Math.floor(mExtent.getBottom()/gridLength);
        let endC = Math.floor(mExtent.getTop()/gridLength);
        let coordsIn={};
        let len;
        for(let i=0; len = this._coordsArr.length,i<len;i++){
            let coordRow = Math.floor(this._coordsArr[i]._x/gridLength);
            let coordCol = Math.floor(this._coordsArr[i]._y/gridLength);
            //在起止的行与列范围内的点，才参与聚合
            if(startR<=coordRow && coordRow<=endR &&  startC <= coordCol && coordCol<= endC){
                let ranks = coordRow +"-"+coordCol;
                if (!coordsIn[ranks]) {
                    coordsIn[ranks] = [];
                }
                coordsIn[ranks].push(this._coordsArr[i]);//统计行列号相同的点，构成数组
            }
        }
        let lengthArr=[];
        for(let ranks in coordsIn){
            lengthArr.push(coordsIn[ranks].length);
        }
        let features=[];
        for(let ranks in coordsIn){
            let propotionColor;
            //************根据行列号相同的点数组中的元素长度，计算步长，确定热度颜色值******
            let propotion = (coordsIn[ranks].length-Math.min.apply(Math,lengthArr))/(Math.max.apply(Math,lengthArr)-Math.min.apply(Math,lengthArr));
            if(propotion == 0){
                propotionColor = this._propotionColor[0];
            }else if(propotion>0 && propotion <=0.25){
                propotionColor = this._propotionColor[1];
            }else if(propotion>0.25 && propotion <=0.5){
                propotionColor = this._propotionColor[2];
            }else if(propotion>0.5 && propotion <=0.75){
                propotionColor = this._propotionColor[3];
            }else if(propotion>0.75 && propotion <=1){
                propotionColor = this._propotionColor[4];
            }
            let polygonFillColor=new hmap.style.ColorFill(new hmap.style.Color(propotionColor[0],propotionColor[1],propotionColor[2],propotionColor[3]));//定义面的填充色
            const styles = new hmap.style.Style({fillSymbols:[polygonFillColor]});
            let R = ranks.split("-")[0]; let C = ranks.split("-")[1];
            //***************网格构造线环*********************
            let gridLeft = R*resolution*this._gridSize;
            let gridRight = gridLeft+resolution*this._gridSize;
            let gridBottom = C*resolution*this._gridSize;
            let gridTop = gridBottom+resolution*this._gridSize;
            let pointLeftTop = new hmap.geom.Point(new hmap.basetype.Coordinate(gridLeft,gridTop));
            let pointRightTop = new hmap.geom.Point(new hmap.basetype.Coordinate(gridRight,gridTop));
            let pointLeftBottom = new hmap.geom.Point(new hmap.basetype.Coordinate(gridLeft,gridBottom));
            let pointRightBottom = new hmap.geom.Point(new hmap.basetype.Coordinate(gridRight,gridBottom));
            let gridPolygon =new hmap.geom.Polygon([new hmap.geom.LinearRing([pointLeftTop,pointRightTop,pointRightBottom,pointLeftBottom])]);
            let feature = new hmap.feature.Vector(gridPolygon,{},styles);
            features.push(feature);
        }
        this._layer.addFeatures(features);
        this._layer.redraw();
    }
    /**
     * 添加监听，鼠标移动缩放时执行一次聚合
     * @private
     */
    eventListenner(){
        const me = this;
        me._map.event.addListener(EventType.MAPEVENT_MOVEEND,function(evt){
            me.mesher();
        });
        me._map.event.addListener(EventType.MAPEVENT_ZOOMEND,function(evt){
            me.mesher();
        });
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 可视域对象，需要添加到可视域图层上使用。形状类似四棱锥。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Viewshed、hmap.geosolution.math.ViewshedModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Viewshed}
 */
hmap.geosolution.Viewshed=class{
    /**
     * 构造函数。
     * @param {hmap.basetype.Coordinate} position 可视域的地理坐标。
     * @param {Number} vertAngle 可视域的垂直可视角。即垂直地面方向，可视域的张角，范围为大于0度小于180度。
     * @param {Number} horiAngle 可视域的水平可视角。即平行地面方向，可视域的张角，范围为大于0度小于180度。
     * @param {Number} radius 可视域的半径。即类似四棱锥的边长。与地理单位一致。大于0。
     * @param {Array} orien 朝向。由坐标系x,y,z定义的三维向量，内部处理成单位向量使用[x,y,z]。x的正方向是向东，y的正方向是向北，z的正方向是球心指向表面的法线方向。
     * @param {hmap.style.Color} color 可视域的颜色。
     */
    constructor(position,vertAngle,horiAngle,radius,orien,color){
        this.CLASS_NAME="hmap.geosolution.Viewshed";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        if(!(position instanceof hmap.basetype.Coordinate)){
            throw position +" must be the type of hmap.basetype.Coordinate!"
        }
        this._position=position;
        if(!Number.isFinite(vertAngle)||vertAngle<=0||vertAngle>=180){
            throw vertAngle+" must be a number that between 0 and 180!";
        }
        this._vertAngle=vertAngle;
        if(!Number.isFinite(horiAngle)||horiAngle<=0||horiAngle>=180){
            throw horiAngle+" must be a number that between 0 and 180!";
        }
        this._horiAngle=horiAngle;
        if((!Number.isFinite(radius))||radius<0){
            throw radius+" must be number and greater than 0!"
        }
        this._radius=radius;
        if(!(orien instanceof Array)||orien.length!==3){
            throw orien +" must be an object of Array with 3 number!";
        }
        this._orien=orien;
        if(!(color instanceof hmap.style.Color)){
            throw color+" must be a hmap.style.Color!"
        }
        this._color=color;
        this._sidesNormal=this._calcSideLengthNomal();
        this._colorArrayNormal=this._color.toNormalizeArray();
        this._label="";//保留字段

        // if(!(sideColor instanceof hmap.style.Color)){
        //     throw sideColor+" must be a hmap.style.Color!"
        // }
        this._colorSide=this._color;
        this._colorArrayNormalS=this._colorSide.toNormalizeArray();
    }

    /**
     * 根据夹角计算可视半径为1的状态下底面矩形边长和椎体高度
     * 改变可视半径,则直接根据三角形相似计算.真实可视域模型为得到的单位数据*可视域半径
     * @private
     */
    _calcSideLengthNomal(){
        //将垂直角度转换为弧度,计算出的边长应该对应y轴的变换
        const radiaV=this._vertAngle*(Math.PI/180);

        //将水平角度转换为弧度,计算出的边长应该对应x轴的变换
        const radiaH=this._horiAngle*(Math.PI/180);
        const tanV=Math.tan(radiaV/2);
        const tanH=Math.tan(radiaH/2);
        const sq=Math.sqrt(1+tanH*tanH+tanV*tanV);
        const sideV=2*tanV/sq;
        const sideH=2*tanH/sq;
        const h=1/sq;
        //默认方向向下
        return{sideV:sideV,sideH:sideH,h:h};
    }

    /**
     * 获取可视域的唯一标识符
     * @returns {String} 标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 设置可视域所在的地理坐标
     * @param {hmap.basetype.Coordinate} position 地理坐标
     * @throws 当参数position类型不对时，抛出异常
     */
    setPosition(position){
        if(!(position instanceof hmap.basetype.Coordinate)){
            throw position +" must be the type of hmap.basetype.Coordinate!"
        }
        this._position=position;
    }

    /**
     * 获取可视域所在的地理坐标
     * @returns {hmap.basetype.Coordinate} 地理坐标
     */
    getPosition(){
        return this._position;
    }

    /**
     * 设置可视域的颜色
     * @param {hmap.style.Color} 可视域颜色值
     * @throws 当参数color的类型不对时，抛出异常。
     */
    setColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw "parameter must be a hmap.style.Color!"
        }
        this._color=color;
        this._colorArrayNormal=this._color.toNormalizeArray();
    }

    /**
     * 获取可视域的颜色
     * @returns {hmap.style.Color} 可视域的颜色
     */
    getColor(){
        return this._color;
    }

    /**
     * 设置可视域边框的颜色
     * @param {hmap.style.Color} 可视域边框的颜色
     * @throws 当参数color的类型不对时，抛出异常。
     */
    setSideColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw "parameter must be a hmap.style.Color!"
        }
        this._colorSide=color;
        this._colorArrayNormalS=this._colorSide.toNormalizeArray();
    }

    /**
     * 获取边框颜色
     * @returns {hmap.style.Color} 边框颜色
     */
    getSideColor(){
        return this._colorSide;
    }

    /**
     * 设置可视半径
     * @param {Number} radius 可视半径
     * @throws 当参数类型不对时，抛出异常
     */
    setRadius(radius){
        if(!Number.isFinite(radius)){
            throw "parameter must be number!"
        }
        this._radius=radius;
    }

    /**
     * 获取可视半径
     * @returns {Number} 返回可视半径
     */
    getRadius(){
        return this._radius;
    }

    /**
     * 设置朝向
     * @param {Array} orien 朝向
     */
    setOrien(orien){
        this._orien=orien;
    }

    /**
     * 获取朝向
     * @returns {Array} 返回朝向
     */
    getOrien(){
        return this._orien;
    }

    /**
     * 设置垂直可视角
     * @param {Number} angle 垂直可视角，范围是（0,180），不包括0和180
     * @throws 当参数值超出范围时，抛出异常
     */
    setVertAngle(angle){
        if(!Number.isFinite(angle)||angle<=0||angle>=180){
            throw angle+" must be a number that between 0 and 180!";
        }
        this._vertAngle=angle;
        this._sidesNormal=this._calcSideLengthNomal();
    }

    /**
     * 获取垂直可视角
     * @returns {Number} 垂直可视角
     */
    getVertAngle(){
        return this._vertAngle;
    }

    /**
     * 设置水平可视角
     * @param {Number} angle 水平可视角，范围是（0,180），不包括0和180
     * @throws 当参数值超出范围时，抛出异常
     */
    setHoriAngle(angle){
        if(!Number.isFinite(angle)||angle<=0||angle>=180){
            throw angle+" must be a number that between 0 and 180!";
        }
        this._horiAngle=angle;
        this._sidesNormal=this._calcSideLengthNomal();
    }

    /**
     * 获取水平可视角
     * @returns {Number} 水平可视角
     */
    getHoriAngle(){
        return this._horiAngle;
    }

    /**
     * 设置保留字段
     * @param {String} label 保留字段
     */
    setLabel(label){
        this._label=label;
    }

    /**
     * 获取保留字段
     * @returns {String} 返回保留字段
     */
    getLabel(){
        return this._label;
    }

    /**
     * @private
     */
    _getPositionArray(){
        let pos=[];
        pos.push(this._position.getOrdinate("X"),this._position.getOrdinate("Y"),this._position.getOrdinate("Z"));
        return pos;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 呈现可视域对象的可视域图层。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Viewshed、hmap.geosolution.math.ViewshedModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.ViewshedLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.ViewshedLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.ViewshedLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._map=null;
        this.container=null;
        this.render=null;
        // this.vpMatrix=new hmap.util.Matrix4();
        this._viewshedMap=new Map();
        this._drawData={
            idArray:[],a_orien:[],a_radius:[],a_scale:[],a_color:[],a_location:[],a_label:[],a_colorSide:[],colorSide:[]};
        this._upFlag={
            index:null,
            isChange:false,
            update:null//"A":add,"R":change,"D":delete,"O"
        };
    }

    /**
     * 给图层设置地图对象
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
        super.setMap(_map);
        // this.vpMatrix=this._map.getVPMatrix();
        this.render=new hmap.ViewshedRender(this.gl);
    }


    /**
     * 添加可视域对象
     * @param {hmap.geosolution.Viewshed} viewshed 可视域对象
     * @throws 当参数的类型不对时，抛出异常
     */
    addViewshed(viewshed){
        if(!(viewshed instanceof hmap.geosolution.Viewshed)){
            throw viewshed+" must be the type of hmap.geosolution.Viewshed!";
        }
        this._viewshedMap.set(viewshed.getId(),viewshed);
    }

    /**
     * 根据id获取可视域对象
     * @param {String} id 可视域对象的id值
     * @returns {hmap.geosolution.Viewshed} 返回可视域对象
     */
    getViewshedById(id){
        if(!this._viewshedMap.size)return;
        return this._viewshedMap.get(id);
    }

    /**
     * 根据保留字段获取可视域对象
     * @param {String} label 可视域对象的保留字段
     * @returns {hmap.geosolution.Viewshed} 返回可视域对象
     */
    getViewshedByLabel(label){
        if(!this._viewshedMap.size)return;
        let me=this,viewshed=new Map();
        for(let key of me._viewshedMap.keys()){
            const lab=me._viewshedMap.get(key).getLabel();
            if(lab===label){
                viewshed.set(key,me._viewshedMap.get(key));
            }
        }
        return viewshed;
    }

    /**
     * 根据id删除可视域对象
     * @param {String} id 可视域对象的id值
     */
    deleteById(id){
        if(!this._viewshedMap.size)return;
        this._viewshedMap.delete(id);
    }

    /**
     * 通过保留字段批量删除
     * @param {String} label 可视域对象的保留字段
     */
    deleteByLabel(label){
        if(!this._viewshedMap.size)return;
        let me=this;
        for(let key of me._viewshedMap.keys()){
            const lab=me._viewshedMap.get(key).getLabel();
            if(lab===label){
                me._viewshedMap.delete(key);
            }
        }
    }


    /**
     * 清除图层中的所有可视域对象
     */
    clearViewsheds(){
        this._viewshedMap=new Map();
    }

    /**
     * 更新绘制使用数据.
     * 注:添加或者删除等更新可视域数据需调用该方法,图层绘制才会更新
     * @param {String} id id值
     */
    updateViewshed(id){
        if(id){
            //判断图层中是否存在数据
            if(this._viewshedMap.get(id)){
                const value=this._viewshedMap.get(id);
                let ind=this._drawData.idArray.indexOf(id);
                //add or change
                if(ind===-1){
                    this._drawData.idArray.push(value.getId());
                    this._drawData.a_orien.push(value.getOrien()[0],value.getOrien()[1],value.getOrien()[2]);
                    this._drawData.a_radius.push(value.getRadius());
                    this._drawData.a_color.push(value._colorArrayNormal[0],value._colorArrayNormal[1],value._colorArrayNormal[2],value._colorArrayNormal[3]);
                    this._drawData.a_scale.push(value._sidesNormal.sideH,value._sidesNormal.sideV,value._sidesNormal.h);
                    this._drawData.a_location.push(value._getPositionArray()[0],value._getPositionArray()[1],value._getPositionArray()[2]);
                    this._drawData.a_label.push(value.getLabel());
                    this._drawData.a_colorSide.push(value._colorArrayNormalS[0],value._colorArrayNormalS[1],value._colorArrayNormalS[2],value._colorArrayNormalS[3]);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    this._drawData.a_orien.splice(3*ind,3,value.getOrien()[0],value.getOrien()[1],value.getOrien()[2]);
                    this._drawData.a_radius.splice(ind,1,value.getRadius());
                    this._drawData.a_color.splice(ind*4,4,value._colorArrayNormal[0],value._colorArrayNormal[1],value._colorArrayNormal[2],value._colorArrayNormal[3]);
                    this._drawData.a_scale.splice(3*ind,3,value._sidesNormal.sideH,value._sidesNormal.sideV,value._sidesNormal.h);
                    this._drawData.a_location.splice(3*ind,3,value._getPositionArray()[0],value._getPositionArray()[1],value._getPositionArray()[2]);
                    this._drawData.a_label.splice(ind,1,value.getLabel());
                    this._drawData.a_colorSide.splice(ind*4,4,value._colorArrayNormalS[0],value._colorArrayNormalS[1],value._colorArrayNormalS[2],value._colorArrayNormalS[3]);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                let ind=this._drawData.idArray.indexOf(id);
                if(ind!==-1){
                    this._drawData.idArray.splice(ind,1);
                    this._drawData.a_orien.splice(3*ind,3);
                    this._drawData.a_radius.splice(ind,1);
                    this._drawData.a_color.splice(ind*4,4);
                    this._drawData.a_scale.splice(3*ind,3);
                    this._drawData.a_location.splice(3*ind,3);
                    this._drawData.a_label.splice(ind,1);
                    this._drawData.a_colorSide.splice(ind*4,4);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="D";
                }else{
                    this._upFlag.index=ind;this._upFlag.isChange=false;this._upFlag.update="D";
                }
            }

        }else{
            //update all
            let idArray=[],orienArray=[],radiusArray=[],colorArray=[],scaleArray=[],locationArray=[],labelArray=[],colorSideArray=[];
            for(let value of this._viewshedMap.values()){
                idArray.push(value.getId());
                orienArray.push(value.getOrien()[0],value.getOrien()[1],value.getOrien()[2]);
                radiusArray.push(value.getRadius());
                colorArray.push(value._colorArrayNormal[0],value._colorArrayNormal[1],value._colorArrayNormal[2],value._colorArrayNormal[3]);
                scaleArray.push(value._sidesNormal.sideH,value._sidesNormal.sideV,value._sidesNormal.h);
                locationArray.push(value._getPositionArray()[0],value._getPositionArray()[1],value._getPositionArray()[2]);
                labelArray.push(value.getLabel());
                colorSideArray.push(value._colorArrayNormalS[0],value._colorArrayNormalS[1],value._colorArrayNormalS[2],value._colorArrayNormalS[3]);
            }
            this._drawData.idArray=idArray;
            this._drawData.a_orien=orienArray;
            this._drawData.a_radius=radiusArray;
            this._drawData.a_color=colorArray;
            this._drawData.a_scale=scaleArray;
            this._drawData.a_location=locationArray;
            this._drawData.a_label=labelArray;
            this._drawData.a_colorSide=colorSideArray;
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }

    /**
     * 图层绘制方法.使用绘制数据渲染图层
     * @private
     */
    draw(){
        super.draw();
       if(this._drawData.idArray.length<=0)return;
    
        this.render._vpMatrix=this._map.getVPMatrix();
        this.render.draw(this._drawData,"TRIANGLES");
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 由地理坐标,颜色,大小,动态类型,文字标签等组合成的散点。散点添加到散点图层中使用。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.ScatterPoint、hmap.geosolution.math.ScatterModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Scatter}
 * @example
 * let coord = new hmap.basetype.Coordinate(120.43,30.19,0.0);
 * let color = [255,255,0.0,1.0];
 * let size = 30.0;
 * let type = hmap.geosolution.Scatter.PointType.normal;
 * let changeColor = [255,0.0,0.0,1.0];
 * let scatter = new hmap.geosolution.Scatter({
        coordinate:coord,
        color:color,
        size:size,
        scatterType:type,
        changeColor:changeColor
 * });
 */
hmap.geosolution.Scatter=class{
    /**
     * 构造一个散点对象
     * @param {Object} options 
     * @param {hmap.basetype.Coordinate} options.coordinate 地理坐标
     * @param {Array} options.color 点对象的颜色,默认为[255,0,0,1]，颜色单个分量的范围在0-255 如果<0则处理为0>255会处理为255
     * @param {Number} options.size 整数,点对象的大小,像素单位
     * @param {Array} options.changeColor 动态消失区域的颜色,hmap.geosolution.Scatter.PointType.bubble使用,默认为[0,0,246,1]，颜色单个分量的范围在0-255 如果<0则处理为0>255会处理为255
     * @param {hmap.geosolution.Scatter.PointType} options.scatterType 点状物的动画类型,{hmap.geosolution.Scatter.PointType}或{hmap.geosolution.Scatter.PointType.CircleType}的枚举值,默认为{hmap.geosolution.PointType.breath}
     * @param {String} options.lable 用户添加的标签
     * @throws 当点的地理坐标类型不对时或者颜色值类型不对时，抛出异常
     */
    constructor(options){
        // if(!((options.coordinate) instanceof hmap.basetype.Coordinate)){
        //     throw "options.coordinate must be an object of Coordinate!"
        // }
        this._coordinate=options.coordinate;

        const color=options.color?options.color:[255,0.0,0.0,1.0];
        if(!(color instanceof Array)||!(color.length===4)){
            throw "options.color must be an Array of RGBA!"
        }
        this._color=color;

        this._size=options.size?options.size:1.0;
        this._changeColor=options.changeColor?options.changeColor:[0.0,0.0,246.0,1.0];
        this._img=options.image?options.image:null;
        this.CLASS_NAME="hmap.geosolution.Scatter";
        this._aniStyle=options.scatterType?options.scatterType:hmap.geosolution.Scatter.PointType.breath;
        this._label=options.label?options.label:"";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
    }

    /**
     * 获取该点对象的唯一标识
     * @returns {String} 返回唯一标识
     * @example
     * let id = scatter.getId();
     */
    getId(){
        return this._id;
    }

    /**
     * 获取该点对象的类型
     * @returns {String} 返回类型
     * @example
     * let scatterType = scatter.getAniStyle();
     */
    getAniStyle(){
        return this._aniStyle;
    }

    /**
     * 设置该点对象的类型
     * @param {String} aniStyle 点对象类型
     * @example
     * point.setAniStyle(hmap.geosolution.Scatter.PointType.breath);
     */
    setAniStyle(aniStyle){
        this._aniStyle=aniStyle;
    }

    /**
     * 获取当前点对象的地理坐标数组
     * @returns {Array} 地理坐标数组[x,y,z]
     * @example
     * let coordArr = scatter.getCoordArray();
     */
    getCoordArray(){
        return [
            this._coordinate.getOrdinate("X"),
            this._coordinate.getOrdinate("Y"),
            this._coordinate.getOrdinate("Z")
        ];
    }

    /**
     * 获取当前点对象的颜色
     * @returns {Array} 点对象的颜色
     * @example
     * let color = scatter.getColor();
     */
    getColor(){
        return this._color;
    }

    /**
     * 获取当前点对象的大小
     * @returns {Number} 点对象的大小
     * @example
     * let size = scatter.getSize();
     */
    getSize(){
        return this._size;
    }

    /**
     * 获取当前点对象的渐变色
     * @returns {Array} 点对象的渐变色
     * @example
     * let changeColor = scatter.getChangeColor();
     */
    getChangeColor(){
        return this._changeColor;
    }

    /**
     * 获取当前点对象的纹理图像
     * @returns {Image} 纹理图像
     * @example
     * let image = scatter.getImage();
     */
    getImage(){
        return this._img;
    }

    /**
     * 获取当前点对象的标签
     * @returns {String} 标签内容
     */
    getLable(){
        return this._label;
    }

    /**
     * 设置当前点对象的颜色
     * @param {Array} color 点对象的颜色
     * @throws 当参数color类型不对时，抛出异常
     * @example
     * let color = [255,0,0,1];
     * scatter.setColor(color);
     */
    setColor(color){
        if(!(color instanceof Array)||!(color.length===4)){
            throw "color must be an Array of RGBA!"
        }
        this._color=color;
    }

    /**
     * 设置当前点对象的大小
     * @param {Number} size 点对象的大小
     * @example
     * let size = 15;
     * scatter.setSize(size);
     */
    setSize(size){
        if(!Number.isFinite(size)){
            return;
        }
        this._size=size;
    }

    /**
     * 设置当前点对象变化部分的颜色,该颜色值对hmap.geosolution.PointType.bubble有效
     * @param {Array} color 点对象变化部分的颜色
     * @example
     * let changeColor = [255,255,0.0,1.0];
     * scatter.setChangeColor(changeColor);
     */
    setChangeColor(color){
        if(!(color instanceof Array)||!(color.length===4)){
           return;
        }
        this._changeColor=color;
    }

    /**
     * 设置当前点对象的纹理图像,该接口只对hmap.geosolution.PointType.spark有效
     * @param {Image} img 纹理图像
     * @example
     * let img = new Image();
     * img.src = "logo.png";
     * scatter.setImage(img);
     */
    setImage(img){
        if(!(img instanceof Image)){
            return;
        }
        this._img=img;
    }

    /**
     * 设置当前点对象的标签
     * @param {String} label 标签内容
     */
    setLable(label){
        this._label=label;
    }
};

/**
 * 点状物的动画类型,枚举如下：
 * breath 呼吸效果,大小变换;
 * bubble 气泡效果,外层逐渐消失;
 * normal 通常的普通点;
 * spark 贴纹理的点
 * @example
 * hmap.geosolution.Scatter.PointType.breath//呼吸效果,大小变换
 * hmap.geosolution.Scatter.PointType.bubble//气泡效果,外层逐渐消失
 * hmap.geosolution.Scatter.PointType.normal//通常的普通点
 * hmap.geosolution.Scatter.PointType.spark//贴纹理的点
 */
hmap.geosolution.Scatter.PointType={
    breath:"breathPoint",
    bubble:"bubblePoint",
    normal:"ripplePoint",
    spark:"sparkPoint",
};
/**
 * 空心点状物的动画类型
 * 枚举值{ripple,breath,bubble,twinkle,normal}
 * ripple为波纹效果,类似于水波纹;breath为呼吸效果,大小变换;bubble为气泡效果,圆环逐渐变大,并消失;twinkle与bubble类似,但变化幅度没有bubble大;normal为通常的普通点;
 * @example
 * hmap.geosolution.CircleType.ripple//波纹效果,类似于水波纹
 * hmap.geosolution.CircleType.breath//呼吸效果,大小变换
 * hmap.geosolution.CircleType.bubble//气泡效果,圆环逐渐变大,并消失
 * hmap.geosolution.CircleType.twinkle//twinkle与bubble类似,但变化幅度没有bubble大
 * hmap.geosolution.CircleType.normal//通常的普通点
 */
hmap.geosolution.Scatter.CircleType={
    ripple:"rippleCircle",
    breath:"breathCircle",
    bubble:"bubbleCircle",
    twinkle:"twinkleCircle",
    normal:"normalCircle"
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案散点图层,用来加载散点
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.ScatterPoint、hmap.geosolution.math.ScatterModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.ScatterLayer}
 * @extends hmap.layer.Layer
 * @example
 * let scatterLayer = new hmap.geosolution.scatterLayer();
 */
hmap.geosolution.ScatterLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        //绘图环境
        this.container=null;
        this._map=null;
        this.gl=null;
        this.render=null;
        this.CLASS_NAME="hmap.geosolution.ScatterLayer";
        //参数
        this.locations=null;
        this.programs=null;
        this.vpMatrix=null;
        this.Points=new Map();
        this.dataMap={};
        this._initPointsMap();
        this._fun=null;//自调用函数
        this._enableAnimate=true;//动画标志
        this._vao=new Map();
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.sizeFlag=new Map();
        this._initPointsSizeFlag();
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 设置动画点能增加的最大像素半径。
     * @param {String} type 动画类型
     * @param {Number} num 动画点的大小
     */
    setSizeFlag(type,num){
        this.sizeFlag.set(type,num);
    }

    /**
     * 获取该图层的整体动画状态
     * @returns {Boolean} 动画开启返回true;动画关闭返回false
     * @example
     * let enableAnimate = scatterLayer.getAnimateLock();
     */
    getAnimateLock(){
        return this._enableAnimate;
    }

    /**
     * 锁定该图层动画整体状态,执行该操作后,所有动画状态停止,直至解锁
     * @example
     * scatterLayer.lockAnimation();
     */
    lockAnimation(){
        this._enableAnimate=false;
    }

    /**
     * 解锁图层动画整体状态
     * @example
     * scatterLayer.unlockAnimation();
     */
    unlockAnimation(){
        this._enableAnimate=true;
    }

    /**
     * 针对该图层添加点对象
     * @param {hmap.geosolution.Scatter} scatter 散点对象
     * @example
     * let coord = new hmap.basetype.Coordinate(120.43,30.19,0.0);
     * let scatter = new hmap.geosolution.Scatter({coordinate:coord});
     * scatterLayer.addScatter(scatter);
     * scatterLayer.updateDataMap();
     */
    addScatter(scatter){
        if(!(scatter instanceof hmap.geosolution.Scatter)){
            throw new TypeError("parameter must be a hmap.geosolution.Scatter!");
        }
        let value=this.Points.get(scatter.getAniStyle());
        this.Points.set(scatter.getAniStyle(),value.set(scatter.getId(),scatter));
    };

    /**
     * 根据id属性值删除该图层上匹配的点对象
     * @param {String} id 需要删除的点属性id值
     * @example
     * let coord = new hmap.basetype.Coordinate(120.43,30.19,0.0);
     * let scatter = new hmap.geosolution.Scatter({coordinate:coord});
     * scatterLayer.addScatter(scatter);
     * let id = scatter.getId();
     * scatterLayer.deleteScatterById(id);
     */
    deleteScatterById(id){
        let me=this;
        for(let point of me.Points.values()){
            point.delete(id);
        }
    }

    /**
     * 清空该图层上的所有点对象,同时清空绘制数组.
     * @example
     * scatterLayer.clearScatters();
     */
    clearScatters(){
        this._initPointsMap();
        this.dataMap={};
    }

    /**
     * 更新图层绘制数组.图层上更改的点对象在首次绘制前需要更新到绘制数组方可绘制到图层上.
     * @param {String} scatterType 动画类型，需要更新的绘制数组的动画类型.不设置则全部更新.
     * @example
     * let coord = new hmap.basetype.Coordinate(120.43,30.19,0.0);
     * let type = hmap.geosolution.Scatter.PointType.normal;
     * let scatter = new hmap.geosolution.Scatter({coordinate:coord,scatterType:type});
     * scatterLayer.addScatter(scatter);
     * scatterLayer.updateDataMap(type);
     */
    updateDataMap(scatterType=""){
        let me=this;
        // let keys=[...me.points.keys()];
        if(!scatterType){
            for(let key of me.Points.keys()){
                let points=me.Points.get(key);
                const positions=[];
                const colors=[];
                const sizes=[];
                const changeColors=[];
                for(let value of points.values()){
                    const coordArr=value.getCoordArray();
                    const color=value.getColor();
                    const size=value.getSize();
                    const changeColor=value.getChangeColor();
                    positions.push(coordArr[0],coordArr[1],coordArr[2]);
                    colors.push(color[0]/255,color[1]/255,color[2]/255,color[3]);
                    sizes.push(size);
                    changeColors.push(changeColor[0]/255,changeColor[1]/255,changeColor[2]/255,changeColor[3]);
                }
                this.dataMap[key]={
                    positions:positions,
                    colors:colors,
                    sizes:sizes,
                    changeColors:changeColors
                };
            }
        }else{
            let points=me.Points.get(scatterType);
            const positions=[];
            const colors=[];
            const sizes=[];
            const changeColors=[];
            for(let value of points.values()){
                const coordArr=value.getCoordArray();
                const color=value.getColor();
                const size=value.getSize();
                const changeColor=value.getChangeColor();
                positions.push(coordArr[0],coordArr[1],coordArr[2]);
                colors.push(color[0]/255,color[1]/255,color[2]/255,color[3]);
                sizes.push(size);
                changeColors.push(changeColor[0]/255,changeColor[1]/255,changeColor[2]/255,changeColor[3]);
            }
            this.dataMap[scatterType]={
                positions:positions,
                colors:colors,
                sizes:sizes,
                changeColors:changeColors
            };
        }

    }

    /**
     * 根据点的类型绘制实心点
     * @param {String} type 实心点的类型，hmap.geosolution.Scatter.PointType枚举值
     * @param {Image} image 纹理图像，当点的类型是hmap.geosolution.Scatter.PointType.spark时的纹理图像
     * @example
     * scatterLayer.drawPointsByType(hmap.geosolution.Scatter.PointType.normal);
     */
    drawPointsByType(type,image=null){
        const dataMap=this.dataMap[type];
        const count=this.render.bufferDataPoints(dataMap,type);
        switch (type){
            case hmap.geosolution.Scatter.PointType.bubble:
                this.render.drawPoints(type,count,this.render.sizeAdd.bubble,this.render.changeAlpha.bubble);
                break;
            case hmap.geosolution.Scatter.PointType.breath:
                this.render.drawPoints(type,count,this.render.sizeAdd.breath,this.render.changeAlpha.breath);
                break;
            case hmap.geosolution.Scatter.PointType.spark:
                this.render.drawSparkPoint(count,1.0,image);
                break;
            default:
                this.render.drawPoints(hmap.geosolution.Scatter.PointType.normal,count);
        }
    }

    /**
     * 根据点的类型绘制空心点
     * @param {String} type 空心点的类型，hmap.geosolution.Scatter.CircleType枚举值
     * @param {Number} div 组成circle的顶点数,默认为50.
     * @example
     * scatterLayer.drawCirclesByType(hmap.geosolution.Scatter.CircleType.ripple,100);
     */
    drawCirclesByType(type,div=50){
        const dataMap=this.dataMap[type];
        const count=this.bufferDataCircle(div);
        const length=dataMap.positions.length/3;
        for(let i=0;i<length;i++){
            let cData={};
            cData.center=[dataMap.positions[3*i],dataMap.positions[3*i+1],dataMap.positions[3*i+2]];
            cData.color=[dataMap.colors[4*i],dataMap.colors[4*i+1],dataMap.colors[4*i+2],dataMap.colors[4*i+3]];
            cData.size=dataMap.sizes[i];
            this.render.drawCircleType(cData,count,type);
        }
    }

    /**
     * 重新绘制
     * @private
     */
    draw(){
        super.draw();
        //是否开启动画
        const flag=this.getAnimateLock();
        if(flag){
            this.now=Date.now();
            this._tick(this._fun);
        }else{
            cancelAnimationFrame(this.animateId);
            this._staticDraw(this._fun);
        }
    }

    /**
     * 设置redraw调用函数
     * @param {Function} fun 以类型区分的绘制函数,主要是drawPointsByType()和drawCirclesByType()
     * @example
     * scatterLayer.setAnimateFun(function(){
            scatterLayer.drawPointsByType(hmap.geosolution.Scatter.PointType.normal);
            scatterLayer.drawCirclesByType(hmap.geosolution.Scatter.CircleType.ripple);
     * });
     */
    setAnimateFun(fun){
        if(!(fun instanceof Function))return;
        this._fun=fun;
    }

    /**
     * 根据type初始化this.Points的Map
     * @private
     */
    _initPointsMap(){
        let pointType=hmap.geosolution.Scatter.PointType;
        for(let key in pointType){
            this.Points.set(pointType[key],new Map());
        }
        let circleType=hmap.geosolution.Scatter.CircleType;
        for(let key in circleType){
            this.Points.set(circleType[key],new Map());
        }
    }

    /**
     * @private
     */
    _initPointsSizeFlag(){
        let pointType=hmap.geosolution.Scatter.PointType;
        for(let key in pointType){
            this.sizeFlag.set(pointType[key],20);
        }
        let circleType=hmap.geosolution.Scatter.CircleType;
        for(let key in circleType){
            this.sizeFlag.set(circleType[key],20);
        }
    }

    /**
     * 根据type类型初始化当前的vao
     * @private
     */
    _initVao(){
        let pointType=hmap.geosolution.Scatter.PointType;
        for(let key in pointType){
            this._vao.set(pointType[key],this.gl.createVertexArray());
        }
        this._vao.set("circle",this.gl.createVertexArray());
    }

    /**
     * 与地图挂接,同时初始化绘图环境
     * @private
     */
    setMap(_map){
        super.setMap(_map);
        this.render=new hmap.ScatterRender();
        this.vpMatrix=this._map.getVPMatrix();
        this.render.setGL(this.gl);
        this.programs=this._glProgram();
        this.locations=this._glLocations();
        this._initVao();
        this.render._vao=this._vao;
        this.render.setGLOptions({programs:this.programs,locations:this.locations,vaos:this._vao});
    }

    /**
     * 创建buffer并添加点数据
     * @private
     * @param {Object} dataMap positions,sizes,colors,changeColors
     * @param {String} type 类型,eg:breathPoint,bubble,ripple,sparkPoint
     * @returns {Number} 返回点的count
     */
    bufferDataPoints(dataMap,type="breathPoint"){
        return this.render.bufferDataPoints(dataMap,type);
    }

    /**
     * 添加circle的buffer数据,circle的边数放开后可以得到多边形数据
     * @private
     * @param {Number} div 空心点对象组成的边数
     * @returns {Number} 顶点数
     */
    bufferDataCircle(div){
        return this.render.bufferDataCircle(div);
    }

    /**
     * 绘制点
     * @private
     * @param {String} type breathPoint,bubblePoint,ripplePoint,除spark
     * @param {Object} dataMap 绘制使用的数据json格式
     * @param {Number} sizeAdd size加量
     * @param {Number} alpha 初始化的不透明度
     */
    drawPoints(type,dataMap,sizeAdd=0,alpha=1.0) {
        const count=this.render.bufferDataPoints(dataMap,type);
        return this.render.drawPoints(type, count, sizeAdd, alpha);
    }

    /**
     * 绘制单层,最简单circle
     * @private
     * @param {Object} dataMap size,center,color,alpha
     * @param {String} drawType 
     */
    drawCircle(dataMap,drawType="LINE_LOOP"){
        this.render.drawCircle(dataMap,drawType);
    }

    /**
     * 当动画停止时使用的绘制方法,动态的特效暂停为当前状态
     * @private
     * @param {Function} fun 调用的绘制方法,比如drawPointsByType(hmap.geosolution.Scatter.PointType.bubble);
     */
    _staticDraw(fun){
        if(!fun)return;
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        fun();
    }

    /**
     * 动态自调用,图层仅允许一个
     * @private
     * @param {Function} fun 调用的绘制方法
     */
    _tick(fun){
        if(!fun)return;
        // super.redraw();
        // let me=this;
        cancelAnimationFrame(this.animateId);
        // this._fun=fun;
        this.last=this.now;
        this.vpMatrix=this._map.getVPMatrix();
        this.render.vpMatrix=this.vpMatrix;
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        this._changeOptions();
        fun();
        //获取当前上下文的状态,如果为非则继续动画
        if(!this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){this._tick(fun)}.bind(this));
        }
    }

    /**
     * 依据时间改变的函数
     * @private
     * @param {Number} changeStep 
     * @returns {Number} 
     */
    animate(changeStep){
        this.now=Date.now();
        let elapsed=this.now-this.last;
        let newChange=changeStep*(elapsed/1000.0);
        return newChange%(changeStep/2.0);
    }

    /**
     * 开启所有随时间变化的量,该方法包括所有特效的改变量
     * @private
     */
    _changeOptions(){
        this._tickRipple();
        this._tickBubble();
        this._tickBreath();
        this._tickTwinkle();
    }

    /**
     * ripple使用的changeOption
     * @private
     * @param {Number} maxSize
     */
    _tickRipple(maxSize=30){
        this.render.rippeArr.sort((a,b)=>{return a-b;});
        if(this.render.rippeArr[this.render.rippeArr.length-1]>=maxSize){
            this.render.rippeArr.pop();
            this.render.rippeArr.unshift(0);
        }
        this.render.change=this.animate(this.render.changeStep);
    }

    /**
     * breath使用的changeOption
     * @private
     */
    _tickBreath(){
        let me=this;
        let addStep=me.render.addStep.breath;
        const sizeFlag=this.sizeFlag.get("breathPoint");
        if (me.render.flag.breath) {
            // sizeAdd += 0.5;
            me.render.changeAlpha.breath -= 0.01;
            me.render.sizeAdd.breath+=me.animate(addStep);
            // alpha=alpha-animate(alphaStep);
        } else {
            // sizeAdd -= 0.5;
            me.render.changeAlpha.breath += 0.01;
            me.render.sizeAdd.breath-=me.animate(addStep);
            // alpha=alpha+animate(alphaStep);
        }
        //缩放效果
        if (me.render.changeAlpha.breath < 0.1||me.render.sizeAdd.breath>=sizeFlag) {
            me.render.flag.breath = false;
        } else if (me.render.changeAlpha.breath > 1.0||me.render.sizeAdd.breath<=1) {
            me.render.flag.breath = true;
        }
    }

    /**
     * bubble使用的changeOption
     * @private
     */
    _tickBubble(){
        const addStep=this.render.addStep.bubble;
        this.render.changeAlpha.bubble -= 0.01;
        this.render.sizeAdd.bubble+=this.animate(addStep);
        if(this.render.changeAlpha.bubble<0.0){
            this.render.sizeAdd.bubble=this.render.sizeAdd.bubbleCopy;
            this.render.changeAlpha.bubble=this.render.changeAlpha.bubbleCopy;
        }
    }

    /**
     * twinkle使用的changeOption
     * @private
     */
    _tickTwinkle(){
        const addStep=this.render.addStep.twinkle;
        this.render.changeAlpha.twinkle -= 0.01;
        this.render.sizeAdd.twinkle+=this.animate(addStep);
    }

    /**
     * 所有programs
     * @private
     * @returns {Object} 返回JSON格式的数据{breathPoint: *, bubble: *, sparkTexture: *, circle: *, light: *}
     */
    _glProgram(){
        let gl=this.gl;
        return{
            breathPoint:this.createPrograms(breathPointShader.vs,breathPointShader.fs),
            ripplePoint:this.createPrograms(breathPointShader.vs,breathPointShader.fs),
            bubblePoint:this.createPrograms(bubbleShader.vs,bubbleShader.fs),
            sparkPoint:this.createPrograms(sparkPointShader.vs,sparkPointShader.fs),
            //circle使用,无光照
            circle:this.createPrograms(circleShader.vs,circleShader.fs),
            // //添加光照,无特殊处理的着色器
            // light:this.createPrograms(lightShader.vs,lightShader.fs)
        };
    }

    /**
     * 获取所有locations
     * @private
     * @returns {Object} 返回JSON格式的数据
     */
    _glLocations(){
        let gl=this.gl;
        let programs=this.programs;
        return{
            breathPoint:breathPointShader.getLocations(gl,programs.breathPoint),
            ripplePoint:breathPointShader.getLocations(gl,programs.ripplePoint),
            bubblePoint:bubbleShader.getLocations(gl,programs.bubblePoint),
            sparkPoint:sparkPointShader.getLocations(gl,programs.sparkPoint),
            circle:circleShader.getLocations(gl,programs.circle),
            // light:lightShader.getLocations(gl,programs.light)
        };
    }

    /**
     * 创建着色器程序
     * @private
     */
    createPrograms(vs,fs){
        let gl=this.gl;
        const shaderMap=this.initShaders(vs,fs);
        const vsShader=shaderMap.get("vsShader"),fsShader=shaderMap.get("fsShader");
        let program = gl.createProgram();
        // Attach pre-existing shaders
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = this.gl.getProgramInfoLog(program);
            throw 'Could not compile WebGL program. \n\n' + info;
        }
        return program;
    }


    /**
     * 初始化着色器
     * @private
     */
    initShaders(vs,fs){
        let gl=this.gl;
        const vsShader=this.compileShader(vs,gl.VERTEX_SHADER);
        const fsShader=this.compileShader(fs,gl.FRAGMENT_SHADER);
        const shaderMap=new Map();
        shaderMap.set("vsShader",vsShader).set("fsShader",fsShader);
        return shaderMap;
    }

    /**
     * 编译渲染用到的着色器代码
     * @private
     */
    compileShader(shaderSrc, shaderType) {
        let gl=this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }
};

;let modelData={};
/**
 * 简单模型数据
 * @private
 */
modelData.earth=function(){
    let W_DIV = 50;//划分纬度
    let J_DIV=50;//划分经度
    let r=1;//球的半径
    //按照经纬度进行地球顶点坐标的定义
    let positions=[];
    let texCoords=[];

    for (let j=0;j<=W_DIV;j++){
        //计算纬度的坐标对应y轴
        let za=j*Math.PI/W_DIV-Math.PI/2.0;//纬度
        let zp=r*Math.sin(za);
        let zr=r*Math.cos(za);//在某一纬度切面上,圆的半径

        //将某一纬度切面进行评分,获取经度坐标
        for(let i=0;i<=J_DIV;i++){
            //经度弧度
            let la=i*2*Math.PI/J_DIV-Math.PI;
            let xp=zr*Math.cos(la);
            let yp=zr*Math.sin(la);
            positions.push(xp);
            positions.push(zp);
            positions.push(yp);


            let u=i/J_DIV;
            let v=j/W_DIV;
            texCoords.push(u);
            texCoords.push(v);
        }
    }

    //计算顶点索引值
    let p1, p2;
    let indices = [];

    // Generate indices
    for (let j = 0; j < W_DIV; j++) {
        for (let i = 0; i < J_DIV; i++) {
            p1 = j * (J_DIV + 1) + i;
            p2 = p1 + (J_DIV + 1);

            indices.push(p1);
            indices.push(p2);
            indices.push(p1 + 1);

            indices.push(p1 + 1);
            indices.push(p2);
            indices.push(p2 + 1);
        }
    }

    return{
        positions:positions,
        texCoords:texCoords,
        indices:indices
    };
};

/**
 * 依照平面生成的数据,在顶点着色器中加工使用.
 * 默认中心点为(0,0),默认半径为单位1
 * @private
 */
modelData.circle=function(div=50){
    // let div=50;
    let r=1.0;
    let posArray=[];
    let eleArray=[];
    for(let i=0;i<=div;i++){
        const angle=2.0*Math.PI/div*i;
        const x=r*Math.cos(angle);
        const y=r*Math.sin(angle);
        posArray.push(x,y,0.0);
        eleArray.push(i);
    }
    return{
        positions:posArray,
        indices:eleArray,
        count:div
    };
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 闪烁的线
 * @private
 * @type {hmap.geosolution.SparkLine}
 * @extends hmap.layer.Layer
 * @example
 * let sparkLine = new hmap.geosolution.SparkLine();
 */
hmap.geosolution.SparkLine=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(){
        super();
        this.container=null;//图层容器
        this.map=null;//地图对象
        this.gl=null;//webgl的绘图环境
        this.enAbleAnimate=true;//是否启用动画效果
        this.lineLeft=[];//当前线的需绘制坐标数组
        this.lines=[];//所有线的Coordinate
        this.lineData=null;//当前线的Coordinate
        this.vector=null;//当前线的当前动画向量
        this.point=null;//当前线的动画端点
        this.index=null;//当前左侧点对应线数据的索引
        this.lineColor=[1,1,1,1];//线的颜色,
        this.pointColor=[1,1,1,1];//线的动态端点颜色
        this.CLASS_NAME="hmap.geosolution.SparkLine";
        this.aniFlag=0;//图层中线的运行状态,当为0时表示线动画运行到终止点,且刷新了一次
        this._primitive=new Map();//初始化状态的数据
        this._curStatus={};//当前动画状态的点数据
        this._initStatusMap();//初始化状态存储Map
        this._isLoop=false;//图层动画循环

        this.image = new Image();
        this.imgSize = 0;
    }

    getClassType(){
        return this.CLASS_NAME;
    }
    
    /**
     * 运动过程中，终止动画
     */
    stopAnimation(){
        this.rememberFlag = this.aniFlag;
        this.aniFlag=0;
    }

    /**
     * 重启动画
     */
    beginAnimation(){
        this.aniFlag = this.rememberFlag;
        this.tick();
    }

    setImg(imgObject,imgSize){
        this.image = imgObject;
        this.imgSize = imgSize;
    }

    /**
     * 绘制
     * @example
     * let sparkLine = new hmap.animation.SparkLine();
     * let startCoord = new hmap.basetype.Coordinate(120.10,30.20,0.0);
     * let midCoord = new hmap.basetype.Coordinate(120.30,30.20,0.20);
     * let endCoord = new hmap.basetype.Coordinate(120.60,30.20,0.0);
     * let bezier = new hmap.geomext.BezierCurve2([new hmap.geom.Point(startCoord),new hmap.geom.Point(midCoord),new hmap.geom.Point(endCoord)]);
     * let lineCoordArr = bezier.getCoordSeq().extractCoords();
     * sparkLine.addLine(lineCoordArr,[0,1,0,1],[1,1,1,1]);
     * sparkLine.redraw();
     */
    draw(){
        this.texMap=this.getGlTexture(this.gl,this.image);
        if(this.lines.length<=0)return;
        //参与动画的所有因素回到初始化状态
        this.now=Date.now();
        this.aniFlag=this._curStatus.aniFlag;
        this.tick(); //调用动画函数
    }

    /**
     * 设置颜色
     */
    setColor(lineColor,pointColor){
        this.lineColor=lineColor;//线的颜色,
        this.pointColor=pointColor;//线的动态端点颜色
    }

    /**
     * 装配线数据
     * @param {Array<hmap.basetype.Coordinate>} lineData 一条线的数据,由hmap.basetype.Coordinate组成的数组
     * @param {Array} color 归一化的RGBA颜色数组,该条线的颜色
     * @param {Array} pointColor 归一化的RGBA颜色数组,该条线动态端点的颜色
     * @example
     * let startCoord = new hmap.basetype.Coordinate(120.10,30.20,0.0);
     * let midCoord = new hmap.basetype.Coordinate(120.30,30.20,0.20);
     * let endCoord = new hmap.basetype.Coordinate(120.60,30.20,0.0);
     * let bezier = new hmap.geomext.BezierCurve2([new hmap.geom.Point(startCoord),new hmap.geom.Point(midCoord),new hmap.geom.Point(endCoord)]);
     * let lineCoordArr = bezier.getCoordSeq().extractCoords();
     * sparkLine.addLine(lineCoordArr,[0,1,0,1],[1,1,1,1]);
     */
    addLine(lineData,color=this.lineColor,pointColor=this.pointColor){

        if(!lineData){return;}

        const coord0=lineData[0];
        const x0=coord0.getOrdinate("X"),y0=coord0.getOrdinate("Y"),z0=coord0.getOrdinate("Z");
        const point=[x0,y0,z0];
        const lineLeft=[point,point];
        const index=0;
        const lineFlag=true;
        const coord1=lineData[1];
        const vector=this.subCoord(coord0,coord1);

        //存储状态数据
        this._primitive.get("linesLeft").push(lineLeft.slice());
        this._primitive.get("vectors").push(vector);
        this._primitive.get("points").push(point.slice());
        this._primitive.get("indexs").push(index);
        this._primitive.get("pointsColor").push(pointColor);
        this._primitive.get("linesColor").push(color);
        this._primitive.get("flags").push(lineFlag);
        this._primitive.set("aniFlag", this._primitive.get("aniFlag")+1);

        this._curStatus.linesLeft.push(lineLeft.slice());
        this._curStatus.vectors.push(vector);
        this._curStatus.points.push(point.slice());
        this._curStatus.indexs.push(index);
        this._curStatus.pointsColor.push(pointColor);
        this._curStatus.linesColor.push(color);
        this._curStatus.flags.push(lineFlag);
        this._curStatus.aniFlag+=1;

        //整体数据
        this.lines.push(lineData);
    }

    /**
     * 初始化状态存储Map,包括初始状态和当前状态
     * @private
     */
    _initStatusMap(){
        this._primitive.set("linesLeft",[]);
        this._primitive.set("vectors",[]);
        this._primitive.set("points",[]);
        this._primitive.set("indexs",[]);
        this._primitive.set("pointsColor",[]);
        this._primitive.set("linesColor",[]);
        this._primitive.set("flags",[]);
        this._primitive.set("aniFlag",1);

        this._curStatus.linesLeft=[];
        this._curStatus.vectors=[];
        this._curStatus.points=[];
        this._curStatus.indexs=[];
        this._curStatus.pointsColor=[];
        this._curStatus.linesColor=[];
        this._curStatus.flags=[];
        this._curStatus.aniFlag=1;
    }

    /**
     * 重新设置当前状态,使恢复初始状态,数组使用深拷贝
     * @private
     */
    _resetCurrentStatus(){
        //获取初始状态
        const linesLeft=this._primitive.get("linesLeft");
        const vectors=this._primitive.get("vectors");
        const points=this._primitive.get("points");
        const indexs=this._primitive.get("indexs");
        const pointsColor=this._primitive.get("pointsColor");
        const linesColor=this._primitive.get("linesColor");
        const flags=this._primitive.get("flags");
        const aniFlag=this._primitive.get("aniFlag");
        //进行深度拷贝
        for (let i = 0; i < this.lines.length; i++) {
            this._curStatus.linesLeft[i]=linesLeft[i].slice();
            this._curStatus.vectors[i]=vectors[i];
            this._curStatus.points[i]=points[i].slice();
        }
        this._curStatus.indexs=indexs.slice();
        this._curStatus.pointsColor=pointsColor;
        this._curStatus.linesColor=linesColor;
        this._curStatus.flags=flags.slice();
        this._curStatus.aniFlag=aniFlag;

        this.aniFlag=this._curStatus.aniFlag;
    }

    /**
     * 与地图挂接，初始化绘图环境
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
        this.map = _map;
        //为图层创建一个canvas,加入到地图容器的面板中
        this.container = document.createElement("canvas");
        this.container.height = this.map.container.clientHeight;
        this.container.width = this.map.container.clientWidth;
        this.container.style.position = "absolute";
        this.container.style.top = "0px";
        this.container.style.bottom = "0px";
        this.container.style.left = "0px";
        this.container.style.right = "0px";
        this.container.opacity=0.0;
        this.container.id=this._id;
        this.map.container.appendChild(this.container);
        this.gl = this.container.getContext('webgl2');
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);

        //考虑作为全局参数暴漏出去
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
        this.program= this.createPrograms();    //初始化program
        this.locations=this.getLocations();
    }

    /**
     * 依据时间改变的函数
     * @param {Number} changeStep
     * @returns {Number}
     */
    animate(changeStep){
        this.now=Date.now();
        let elapsed=this.now-this.last;
        let newChange=changeStep*(elapsed/1000.0);
        return newChange%(changeStep/2.0);
    }

    /**
     * 循环使用函数,该函数主要功能是获取当前状态,调用计算当前动态点和左侧需绘制的点数组的方法,
     * 更改当前各种状态参数
     * @private
     */
    tick() {
        cancelAnimationFrame(this.animateId);
        let me = this;
        let gl = this.gl;
        this.last = this.now;
        this.change = this.animate(0.05);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        for (let i = 0; i < this.lines.length; i++) {
            //取出需要的字段
            this.lineData = this.lines[i];
            this.lineCount = this.lineData.length;
            this.lineLeft =  this._curStatus.linesLeft[i];
            this.vector = this._curStatus.vectors[i];
            this.point = this._curStatus.points[i];
            this.index = this._curStatus.indexs[i];
            this.pointColor = this._curStatus.pointsColor[i];
            this.lineColor = this._curStatus.linesColor[i];
            this.lineFlag = this._curStatus.flags[i];

            this.pathDraw();
            const newData = this.linesCal();
            //如果有返回值,则使用返回值修改当前状态
            if (newData) {
                this._curStatus.linesLeft[i] = newData.lineLeft;
                this._curStatus.vectors[i] = newData.vector;
                this._curStatus.points[i] = newData.point;
                this._curStatus.indexs[i] = newData.index;
                this._curStatus.flags[i] = newData.lineFlag;
                this._curStatus.aniFlag=this.aniFlag;
            }
        }
        // >1动画中线维运行到端点,1最后一条线运行到端点,0刷新过一次
        if (this.aniFlag>1) {
            this.animateId=requestAnimationFrame(function () {
                me.tick();
            }.bind(this));
        }else if(this.aniFlag===1){
            this.aniFlag=0;
            me.tick();
         }else if(this._isLoop){
            this._resetCurrentStatus();
            me.tick();
         }  
    }

    /**
     * 计算不变点里的点
     * @private
     * @returns {Object} 返回JSON格式的数据{point: *, index: number, vector: vector3, this.lineLeft: *[], pointsCount: (Array.length|*)}
     */
    linesCal(){
        let index=this.index;
        let point=this.point;
        if(!this.lineFlag){
            return null;
        }
        //当前的点坐标
        let coord1=new hmap.basetype.Coordinate(point[0],point[1],point[2]);
        //change前一个固定点的坐标
        let coord2=this.lineData[index];
        //change点距离固定点的长度
        let vector01=this.subCoord(coord2,coord1);

        let len=this.vecLength(this.vector);
        let len01=this.vecLength(vector01);
        this.lineLeft.pop();
        if(len01<len){
            this.lineLeft.push(point);
        }else{
            index=index+1;
            const coordLeft=this.lineData[index];
            const xLeft=coordLeft.getOrdinate("X"),yLeft=coordLeft.getOrdinate("Y"),zLeft=coordLeft.getOrdinate("Z");
            this.lineLeft.push([xLeft,yLeft,zLeft],[xLeft,yLeft,zLeft]);
            point=[xLeft,yLeft,zLeft];
            if(index+1<this.lineCount){
                const coord=this.lineData[index+1];
                const coord0=this.lineData[index];
                this.vector=this.subCoord(coord0,coord);
            }else{
                this.lineLeft.pop();
                this.lineFlag=false;
                this.aniFlag-=1;
            }
        }
        this.point=point;
        this.index=index;
        const obj={
            point:point,
            index:index,
            vector:this.vector,
            lineLeft:this.lineLeft,
            pointsCount:this.lineLeft.length,
            lineFlag:this.lineFlag
        };
        return obj;
    }

    /**
     * 预计算线的动态端点,根据现有左侧数据绘制线的轨迹和动态端点
     * @private
     */
    pathDraw(){
        if(this.lineLeft.length<=0){
            return;
        }
        let gl=this.gl;
        let point=this.point;
        // this.change=0.02;
        let change=this.change;
        if(this.lineFlag){
            //新的change点
            const x=this.normalCoord(this.vector).getOrdinate("X");
            const y=this.normalCoord(this.vector).getOrdinate("Y");
            const z=this.normalCoord(this.vector).getOrdinate("Z");
            point=[point[0]+change*x,point[1]+change*y,point[2]+change*z];
            this.point=point;
        }
        gl.useProgram(this.program);
        let datas=this.lineLeft.reduce(function (a, b) { return a.concat(b)} );//.toLocaleString().split(",");
        let buffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
        gl.enableVertexAttribArray(this.locations.positionAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(datas),gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.locations.positionAttributeLocation,3,gl.FLOAT,false,0,0);
        gl.uniform1i(this.locations.textureIfLocation,0);
        gl.uniform4fv(this.locations.colorLocation,this.lineColor);
        const matrix = this.map.getVPMatrix();
        gl.uniformMatrix4fv(this.locations.mvpMatrixLocation,false,matrix.getElements());
        // if(this.lineFlag){//最后不要线
            gl.drawArrays(gl.LINE_STRIP,0,this.lineLeft.length);
        // }
        gl.uniform1i(this.locations.patternLocation,this.texMap.unit);
        gl.uniform1i(this.locations.textureIfLocation,1);
        gl.vertexAttrib1f(this.locations.sizeAttributeLocation,this.imgSize);
        gl.vertexAttrib4fv(this.locations.colorAttributeLocation,this.pointColor);
        gl.drawArrays(gl.POINTS,this.lineLeft.length-1,1);
    }

    /**
     * 向量的长度
     * @private
     */
    vecLength(coord){
        const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
        return Math.sqrt(x*x+y*y+z*z);
    }

    /**
     * 向量的归一化
     * @private
     */
    normalCoord(coord){
        const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
        let len=this.vecLength(coord);
        if(len===0)len=1.0;
        return new hmap.basetype.Coordinate(x/len,y/len,z/len);
    }

    /**
     * 向量减法
     * @private
     */
    subCoord(coord1,coord2){
        const x1=coord1.getOrdinate("X"),y1=coord1.getOrdinate("Y"),z1=coord1.getOrdinate("Z");
        const x2=coord2.getOrdinate("X"),y2=coord2.getOrdinate("Y"),z2=coord2.getOrdinate("Z");
        const xm=x2-x1,ym=y2-y1,zm=z2-z1;
        let coord=new hmap.basetype.Coordinate(xm,ym,zm);
        return coord;
    }

    /**
     * 在坐标之上再加一个增量
     * @private
     * @param {hmap.basetype.Coordinate} coordIn 坐标
     * @param {Number} change 坐标增量
     */
    addCoord(coord,change){
        const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
        coord.setOrdinate("X",x+change);
        coord.setOrdinate("Y",y+change);
        coord.setOrdinate("Z",z+change);
        return coord;
    }



   /**
    * 以下可以抽取为公共程序
    */


    getLocations(){
        let gl=this.gl;
        let program=this.program;
        return{
            positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
            colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
            sizeAttributeLocation:gl.getAttribLocation(program,"a_size"),
            mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
            patternLocation:gl.getUniformLocation(program,"u_pattern"),
            textureIfLocation:gl.getUniformLocation(program,"u_texIf"),
            colorLocation:gl.getUniformLocation(program,"u_color")
        };
    };


    /**
     * 初始化着色器程序
     * @private
     */
    createPrograms(){
        const shaderMap=this.initShaders();
        const vsShader=shaderMap.get("vsShader"),fsShader=shaderMap.get("fsShader");
        let program = this.gl.createProgram();
        // Attach pre-existing shaders
        this.gl.attachShader(program, vsShader);
        this.gl.attachShader(program, fsShader);
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            let info = this.gl.getProgramInfoLog(program);
            throw 'Could not compile WebGL program. \n\n' + info;
        }
        this.program = program;
        return program;
    }



    /**
     * 初始化着色器
     * @private
     */
    initShaders(){
        const vs=hmap.geosolution.SparkLine.prototype.vs;
        const fs=hmap.geosolution.SparkLine.prototype.fs;
        const vsShader=this.compileShader(vs,this.gl.VERTEX_SHADER);
        const fsShader=this.compileShader(fs,this.gl.FRAGMENT_SHADER);
        const shaderMap=new Map();
        shaderMap.set("vsShader",vsShader).set("fsShader",fsShader);
        return shaderMap;
    }

    /**
     * 编译渲染用到的着色器代码
     * @private
     */
    compileShader(shaderSrc, shaderType) {
        let shader = this.gl.createShader(shaderType);
        this.gl.shaderSource(shader, shaderSrc);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            let info = this.gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }

};"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案扇形类。是饼状图的组成部分，不单独使用。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Sector、hmap.geosolution.math.PieModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Sector}
 */
hmap.geosolution.Sector=class{
    /**
     * 构造函数。
     * @param {Object} options 必填项
     * @param {Number} options.areaWeight 扇形面积权重，用来计算在饼状图中的占比，对应需要统计的数据。
     * @param {hmap.style.Color} options.color 扇形颜色值
     * @param {String} options.label 自定义标签
     * @param {Number} options.heightWeight 扇形的高度权重（暂时不支持）
     * @throws 当options不存在，或者options.areaWeight不存在，或者options.color类型不对时，抛出异常
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.Sector";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        if(!options)throw "options must be given!";
        if(!Number.isFinite(options.areaWeight) || options.areaWeight <= 0){
            throw "AreaWeight must be given!"
        }
        // if(options && options.radius<=0) throw "radius must be larger than 0"
        this._areaWeight=options.areaWeight;
        if(!options.color){
            this._color=new hmap.style.Color(255,0.0,0.0,1.0);
        }else{
            if(!(options.color instanceof hmap.style.Color)){
                throw options.color +" must be a type of hmap.style.Color!";
            }
            this._color=options.color;
        }
        this._label=options.label?options.label:"";
        this._heightWeight=options.heightWeight?options.heightWeight:1.0;
        this._radius=(options && options.radius)?options.radius:1;
        this._aChange=true;//权重变化,单指面积权重发生变化
        this._oChange=true;//其他权重变化,当面积权重不发生变化时,饼状图不用重新计算各块权重
    }

    /**
     * 获取扇形id
     * @returns {String} 返回id值
     */
    getId(){
        return this._id;
    }

    /**
     * 获取扇形的颜色
     * @returns {hmap.style.Color} 返回扇形的颜色值
     */
    getColor(){
        return this._color;
    }

    /**
     * 获取扇形的面积权重
     * @returns {Number} 扇形的面积权重
     */
    getAreaWeight(){
        return this._areaWeight;
    }

    /**
     * 获取扇形的高度权重
     * @returns {Number} 扇形的高度权重
     * @private
     */
    getHeightWeight(){
        return this._heightWeight;
    }

    /**
     * 获取扇形的label
     * @returns {String} 扇形的标签内容
     */
    getLabel(){
        return this._label;
    }

    /**
     * 设置扇形的颜色
     * @param {hmap.style.Color} color 扇形颜色值
     * @throws 当参数color类型不对时，抛出异常
     */
    setColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw options.color +" must be a type of hmap.style.Color!";
        }
        this._color=color;
    }

    /**
     * 设置扇形的面积权重
     * @param {Number} number 扇形的面积权重
     */
    setAreaWeight(number){
        if(!Number.isFinite(number) || number <= 0){
            throw number+" must be given!"
        }
        this._areaWeight=number;
    }

    /**
     * 设置扇形的label
     * @param {String} label 扇形的标签内容
     */
    setLabel(label){
        this._label=label;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 饼状图。
 * 饼状图常用于统计学模型，饼状图显示一个数据系列中各项的大小与各项总和的比例。
 * 注意：需要添加到饼状图专属图层中才能显示，一个图层可以添加若干个饼图。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Sector、hmap.geosolution.math.PieModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.Pie}
 */
hmap.geosolution.Pie = class {
    /**
     * 构造一个饼图。
     * @param {Array<hmap.geosolution.Sector>} sectorArray 地理解决方案中扇形组成的数组。
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.position 饼状图的地理坐标
     * @param {Number} options.radius 饼状图的半径，地图对象中坐标系的单位，默认为1。
     * @param {Boolean} options.radiusAuto 饼状图中各扇形的半径是否按面积比例设置。false则全部使用radius设置，true则面积比重最大的扇形使用radius设置。
     */
    constructor(sectorArray, options) {
        this.CLASS_NAME = "hmap.geosolution.Pie";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);

        this._secArray = [...sectorArray];
        if(!options)throw "options must be given!";
        if(!options.position)throw "options.position must be given!";
        if(!(options.position instanceof hmap.basetype.Coordinate)){
            throw "options.position must be a type of hmap.basetype of Coordinate!";
        }
        if(options && options.radius<=0) throw "radius must be larger than 0";
        this._position = options.position;
        this._radius = (options && options.radius) ? options.radius :1.0;
        this._height = options.height ? options.height :1.0;
        // if(!options.color){
        //     this._color=new hmap.style.Color(255,0.0,0.0,1.0);
        // }else{
        //     if(!(options.color instanceof hmap.style.Color)){
        //         throw options.color +" must be a type of hmap.style.Color!";
        //     }
        //     this._color=options.color;
        // }

        // if(!(options.color instanceof hmap.style.Color)){
        //     throw options.color +" must be a type of hmap.style.Color!";
        // }
        // this._color=options.color;

        // this._texture = options.image ? options.image : null;
        this._radiusAuto = false;//当自动设定半径为true时,扇形半径大小和面占比为正相关
        if(options.radiusAuto){this._radiusAuto=true;}
        this._drawMap = new Map();//扇形自身数据存储,用来绘制
        this._secMap = new Map();//按id存储扇形要素
        this._lChange = true;//组成饼状图的扇形数组长度变化.当长度变化时,需要重新计算面积权重
        this._initSecMap();
    }

    /**
     * 构建以id为key值的map数据,方便绘制取用管理
     * @private
     */
    _initSecMap() {
        const len = this._secArray.length;
        for (let i = 0; i < len; i++) {
            const sec = this._secArray[i];
            this._secMap.set(sec.getId(), sec);
        }
    }

    /**
     * 获取id属性
     * @returns {String} 返回id属性
     */
    getId(){
        return this._id;
    }

    /**
     * 根据id移除扇形数据
     * @param {String} id 属性
     */
    deleteSecById(id) {
        const len = this._secArray.length;
        const me = this;
        for (let i = 0; i < len; i++) {
            const sId = me._secArray[i].getId();
            if (sId === id) {
                me._secArray.split(i, 1);
                break;
            }
        }
        this._secArray = me._secArray;
    }

    /**
     * 获取扇形对象的数组
     * @returns {Array} 扇形对象的数组
     */
    getSectorArray() {
        return this._secArray;
    }

    /**
     * 获取饼状图地理坐标位置
     * @returns {hmap.basetype.Coordinate} 地理坐标位置
     */
    getPosition() {
        return this._position;
    }

    // /**
    //  * 获取设定的高度
    //  * @returns {Number} 高度值
    //  */
    // getHeight() {
    //     return this._height;
    // }

    /**
     * 获取半径
     * @returns {Number} 半径值
     */
    getRadius() {
        return this._radius;
    }


    // /**
    //  * 获取饼状图的颜色
    //  * @returns {hmap.style.Color} 颜色值
    //  */
    // getColor() {
    //     return this._color;
    // }

    /**
     * 是否是半径自动计算模式
     * @returns {Boolean} 是返回true；不是返回false
     */
    isRadiusAuto() {
        return this._radiusAuto;
    }

    /**
     * 设置饼状图放置的地理坐标位置
     * @param {hmap.basetype.Coordinate} coord 地理坐标位置
     * @throws 当参数不是地理坐标对象时，抛出异常
     */
    setPosition(coord) {
        if(!(coord instanceof hmap.basetype.Coordinate)){
            throw coord +" must be a type of hmap.basetype.Coordinate!";
        }
        this._position = coord.clone();
    }

    /**
     * 设置饼状图的半径
     * @param {Number} number 饼状图半径值
     */
    setRadius(number) {
        this._radius = number;
    }

    // /**
    //  * 设置饼状图的颜色
    //  * @param {hmap.style.Color} color 颜色值
    //  * @throws 当参数color类型不正确时，抛出异常。
    //  */
    // setColor(color) {
    //     if(!(color instanceof hmap.style.Color)){
    //         throw color +" must be a type of hmap.style.Color!";
    //     }
    //     this._color = color;
    // }

    /**
     * 修改饼状图的类型
     * @param {Boolean} change
     */
    changeRadiusAuto(change) {
        this._radiusAuto = change;
    }

    /**
     * 初始化扇形自身数据存储数组
     * @private
     */
    _initDrawData() {
        let ids = [], colors = [], labels = [], aWeights = [], hWeights = [], radiuses = [];
        let me = this;
        for (let value of me._secMap.values()) {
            ids.push(value.getId());
            colors.push(value.getColor().toNormalizeArray());
            labels.push(value.getLabel());
            aWeights.push(value.getAreaWeight());
            hWeights.push(value.getHeightWeight());
            radiuses.push(this._radius);
        }
        let secData={
            ids:ids,
            colors:colors,
            labels:labels,
            aWeights:aWeights,
            hWeights:hWeights,
            radiuses:radiuses
        };
        this._drawMap.set("secData",secData);
    }

    /**
     * 更新扇形使用的数据
     */
    upSectorData() {
        this._initDrawData();
        this._termAreaW();
        this._createVers();
        this._changeToGL();
    }

    /**
     * 计算扇形面积占比和弧度
     * @private
     */
    _termAreaW() {
        let secData=this._drawMap.get("secData");
        const areas=secData.aWeights;
        let sumAreaW=areas.reduce(function(x,y){return x+y},0);
        let areaRatio=areas.map(x=>x/sumAreaW);
        let areaAngle=areas.map(x=>x/sumAreaW*2.0*Math.PI);
        secData.ratios=areaRatio;
        secData.angles=areaAngle;

        //半径是否根据权重分配
        if(this._radiusAuto){
            let radiuses=areas.map(x=>x/sumAreaW);
            let maxR=Math.max(...radiuses);
            secData.radiuses=radiuses.map(x=>x*(this._radius/maxR));
        }
        this._drawMap.set("secData",secData);
    }

    /**
     * 根据扇形所占弧度生成顶点数据(使用图元重启)
     * @private
     */
    _createVers(){
        let angleArr=this._drawMap.get("secData").angles;
        let radiuses = this._drawMap.get("secData").radiuses;
        let me=this,positions0=[],indices0=[],positionsH=[],indicesH=[],sidePos=[],sideInd=[],posLens=[],sideLens=[];
        const verData0=me._sectorModel(0,angleArr[0], radiuses[0]);
        positions0.push(...verData0.positions0);
        indices0.push(...verData0.indices0);
        indices0.push(65535);

        positionsH.push(...verData0.positionsH);
        indicesH.push(...verData0.indicesH);
        indicesH.push(65535);

        sidePos.push(...verData0.sidePos);
        sideInd.push(...verData0.sideInd);
        sideInd.push(65535);

        posLens.push(verData0.positions0.length/3);
        sideLens.push(verData0.sidePos.length/3);

        // const len0=indices0.length,lenH=indicesH.length,lenS=sideInd.length;
        const length=angleArr.length;
        let  angleStart=0;//扇形起始的角度
        let pos0Sum=verData0.positions0.length/3,sideSum=verData0.sidePos.length/3;
        for(let i=1;i<length;i++){
            angleStart+=angleArr[i-1];
            const verDatas=me._sectorModel(angleStart,angleArr[i], radiuses[i]);
            positions0.push(...verDatas.positions0);
            positionsH.push(...verDatas.positionsH);
            sidePos.push(...verDatas.sidePos);

            indices0.push(...verDatas.indices0.map(x=>x+pos0Sum));
            indicesH.push(...verDatas.indicesH.map(x=>x+pos0Sum));
            sideInd.push(...verDatas.sideInd.map(x=>x+sideSum));
            indices0.push(65535),indicesH.push(65535);
            sideInd.push(65535);

            posLens.push(verDatas.positions0.length/3);
            sideLens.push(verDatas.sidePos.length/3);
            pos0Sum+=verDatas.positions0.length/3;
            sideSum+=verDatas.sidePos.length/3;
        }

        const vers={
            positions0:positions0,
            indices0:indices0,
            positionsH:positionsH,
            indicesH:indicesH,
            positionsS:sidePos,
            indicesS:sideInd,
            posLens:posLens,
            sideLens:sideLens
        };
        this._drawMap.set("vers",vers);
    }

    /**
     * 将扇形数据转化为绘制使用的格式
     * 按顶点组装颜色数据,组装扇形的高度和长度
     * @private
     */
    _changeToGL() {
        let vers=this._drawMap.get("vers");
        const pLens=vers.posLens;//取出顶点数量数组,该数组长度表示扇形的数量
        const sLens=vers.sideLens;
        const secs=this._drawMap.get("secData");
        let colors=[],sideColors=[],hs=[],sideHs=[],radis=[],sideRadis=[];
        for(let i=0;i<pLens.length;i++){
            const count0=pLens[i];
            const color0=new Array(count0).fill(secs.colors[i]);
            colors.push(...color0);
            const h0=new Array(count0).fill(secs.hWeights[i]);
            hs.push(...h0);
            const radis0=new Array(count0).fill(secs.radiuses[i]);
            radis.push(...radis0);

            const count1=sLens[i];
            const color1=new Array(count1).fill(secs.colors[i]);
            sideColors.push(...color1);
            const h1=new Array(count1).fill(secs.hWeights[i]);
            sideHs.push(...h1);
            const r1=new Array(count1).fill(secs.radiuses[i]);
            sideRadis.push(...r1);
        }

        vers.colors=colors;
        vers.colorsS=sideColors;
        vers.hs=hs;
        vers.hsS=sideHs;
        vers.rs=radis;
        vers.rsS=sideRadis;

        this._drawMap.set("vers",vers);
    }

    /**
     * 生成扇形,默认扇形圆点为(0,0,0),默认扇形半径为1
     * @private
     * @param {Number} startA,起始弧度
     * @param {Number} diff,所占弧度
     * @param {Number} r,扇形半径
     * @param {Number} div,划分边数
     * @param {Number} h,扇形的高度,默认为1
     * @returns {Object} 以JSON格式返回扇形信息。 positions:顶面和底面数据;indices:顶面和底面的索引;sidePos:侧面的顶点数据;sideInd:侧面的顶点索引
     */
    _sectorModel(startA = 0, diff = Math.PI, r = 1, div = 50, h = 1.0) {
        let posArray0=[],indArray0=[],posArrayH=[],indArrayH=[],posArrayS=[],indArrayS=[];
        posArray0.push(0.0,0.0,0.0);
        indArray0.push(0);
        posArrayH.push(0.0,0.0,h);
        indArrayH.push(0);
        posArrayS.push(0.0,0.0,h,0.0,0.0,0.0);
        indArrayS.push();

        for (let i = 0; i <= div; i++) {
            const angle = diff / div * i;
            const x = r * Math.cos(startA+angle);
            const y = r * Math.sin(startA+angle);
            posArray0.push(x, y, 0.0);
            indArray0.push(i+1);
            posArrayH.push(x,y,h);
            indArrayH.push(i+1);
            posArrayS.push(x, y, h, x, y, 0.0);
            indArrayS.push(2 * i+2, 2 * i + 3);
        }
        return {
            positions0: posArray0,
            indices0: indArray0,
            positionsH:posArrayH,
            indicesH:indArrayH,
            sidePos:  posArrayS,
            sideInd: indArrayS,
            count: div
        };
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{}; 
/**
 * 饼状图图层。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Sector、hmap.geosolution.math.PieModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.PieLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.PieLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this._map=null;
        this.render=null;
        this.gl=null;
        this._chartMap=new Map();//按chart类型以id为key存储原始元素
        this._drawD=new Map();//存放所有chart的绘制数据,key为id
        this.CLASS_NAME = "hmap.geosolution.PieLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._initChartMap();
    }

    /**
     * 给图层设置地图对象
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
        super.setMap(_map);
        this.vpMatrix=this._map.getVPMatrix();
        this.render=new hmap.PieRender(this.gl);
    }

    /**
     * 初始化图表存放
     * @private
     */
    _initChartMap(){
        this._chartMap.set("pie",new Map());
    }

    /**
     * 添加饼状图要素
     * @param {hmap.geosolution.Pie} pie 饼状图要素
     * @throws 当参数pie不是饼状图对象时，抛出异常
     */
    addPie(pie){
        if(!(pie instanceof hmap.geosolution.Pie)){
            throw "parameter must be a hmap.chart.Pie!"
        }
        this._chartMap.get("pie").set(pie.getId(),pie);
    }

    /**
     * 根据id，删除对应的图表
     * @param {String} id id值
     */
    deleteById(id){
        if(!this._chartMap.get("pie"))return;
        this._chartMap.get("pie").delete(id);
    }

    /**
     * 清除图层中的所有饼状图要素
     */
    clearPies(){
        this._initChartMap();
    }

    /**
     * 更新绘制使用数据.注:添加或者删除等更改饼状图数据需调用该方法,图层绘制才会更新
     */
    updatePie(){
        let me=this;
        let newDraw=new Map();
        //顶点使用数组(顶点和半径只组织底面数据,高度数组交叉组织底部和顶部数据,使用偏移处理)
        let positions=[],colors=[],rs=[],hs=[],indices=[];
        let positionsS=[],colorsS=[],rsS=[],hsS=[],indicesS=[];
        //每个pie绘制数据包括的顶点数量counts包括circle和sides,索引顶点数量indCounts
        let counts=[],indCounts=[];
        //uniform使用数组,平移position
        let transArr=[];
        let pieMap=me._chartMap.get("pie");
        //按照饼状图的数量开始组织数据
        for(let key of pieMap.keys()){
            const pie=pieMap.get(key);
            const vers=pie._drawMap.get("vers");
            const pos=vers.positions0;
            const color=vers.colors.reduce((a,b)=>{return a.concat(b)});
            const radius=vers.rs;
            const height=vers.hs.map(a=>{return [0,a]}).reduce((a,b)=>{return a.concat(b)});
            const ind=vers.indices0;
            positions.push(...pos);
            colors.push(...color);
            rs.push(...radius);
            hs.push(...height);
            indices.push(...ind);

            counts.push(pos.length/3);
            indCounts.push(ind.length);

            const posSide=vers.positionsS;
            const colorSide=vers.colorsS.reduce((a,b)=>{return a.concat(b)});
            const radisSide=vers.rsS;
            const heightSide=vers.hsS.map(a=>{return [0,a]}).reduce((a,b)=>{return a.concat(b)});
            const indSide=vers.indicesS;
            positionsS.push(...posSide);
            colorsS.push(...colorSide);
            rsS.push(...radisSide);
            hsS.push(...heightSide);
            indicesS.push(...indSide);
            counts.push(posSide.length/3);
            indCounts.push(indSide.length);

            const trans=pie.getPosition();
            transArr.push([trans.getOrdinate("X"),trans.getOrdinate("Y"),trans.getOrdinate("Z")]);
        }
        let vertexes={
            positions:positions,//底面
            colors:colors,
            rs:rs,
            hs:hs,
            indices:indices,
            positionsS:positionsS,
            colorsS:colorsS,
            rsS:rsS,
            hsS:hsS,
            indicesS:indicesS,
            counts:counts,
            indCounts:indCounts,
            trans:transArr
        };

        this._drawD.set("drawVers",vertexes);
        this.render.addBuffer(vertexes);
    }

    /**
     * 图层绘制方法.使用绘制数据渲染图层.需要显式调用
     * @private
     */
    draw(){
        if(!this._drawD.get("drawVers"))return;
        super.draw();
        this.render._vpMatrix=this._map.getVPMatrix();
        this.render.draw(this._drawD.get("drawVers"));
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案泛光类。
 * ！！！兼容性实现，将于下个版本舍弃。由于该实现存在不可避免之问题，后续版本将更改实现模式，如有需要，请提需求。
 * @type {hmap.geosolution.Shine}
 */
hmap.geosolution.Shine=class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.geom.Geometry} options.geometry 地理几何，暂时只支持hmap.geom.Line和hmap.geom.Polygon
     * @param {Array} options.colorArr 归一化的颜色数组,默认值为[1,1,1,1]
     * @param {Number} options.scale 泛光宽度与预设宽度的比值，默认值为1
     */
    constructor(options,callback){
        this.CLASS_NAME="hmap.geosolution.Shine";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.geom = options.geometry;
        this.colorArr = options.colorArr ? options.colorArr:[1,1,1,1];                       //归一化的颜色数组
        this.scale = options.scale ? options.scale : 1.0;
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this.dataMap = this._generateShineByGeom(this.geom,this.colorArr);
    }

    /**
     * 获取泛光对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 设置泛光的id,有时需要和地理要素保持一致
     * @param {String} id id值
     */
    setId(id){
        this._id = id;
    }

    /**
     * 重新设置泛光的几何对象
     * @param {hmap.geom.Geometry} geom 几何对象
     * @throws 当参数geom类型不对时，抛出异常
     */
    resetGeom(geom){
        if(!(geom instanceof hmap.geom.Geometry)){
            throw "parameter geom must be instance of hmap.geom.Geometry"
        }
        this.geom = geom;
        this.dataMap = this._generateShineByGeom(this.geom,this.colorArr);
    }

    /**
     * 计算右侧坐标偏移，isClose是否闭合
     * @private
     */
    _gererateRightGo(positions,isClose){
        const prePositions = [],nextPositions = [];
        const positionCount = positions.length/3;   //坐标点的个数
        if(isClose){
            prePositions.push(positions[(positionCount-1)*3-3],positions[(positionCount-1)*3-2],positions[(positionCount-1)*3-1]);               //计算去路偏移
        }else{
            prePositions.push(positions[3*1-3],positions[3*1-2],positions[3*1-1]);               //计算去路偏移
        }
        nextPositions.push(positions[3*2-3],positions[3*2-2],positions[3*2-1]);       //下个点

        for(let i=1;i<positionCount-1;i++){
            prePositions.push(positions[3*(i-1)],positions[3*(i-1)+1],positions[3*(i-1)+2]);
            nextPositions.push(positions[3*(i+1)],positions[3*(i+1)+1],positions[3*(i+1)+2]);
        }

        prePositions.push(positions[(positionCount-1)*3-3],positions[(positionCount-1)*3-2],positions[(positionCount-1)*3-1]);
        if(isClose){
            nextPositions.push(positions[3*2-3],positions[3*2-2],positions[3*2-1]);               //计算去路偏移
        }else{
            nextPositions.push(positions[positionCount*3-3],positions[positionCount*3-2],positions[positionCount*3-1]);
        }

        return {
            positions:positions,
            prePositions:prePositions,
            nextPositions:nextPositions
        }
    }

    /**
     * 计算左侧坐标偏移,isClose是否闭合
     * @private
     */
    _gererateLeftGo(positions,isClose){
        const prePositions = [],nextPositions = [];
        const positionCount = positions.length/3;   //坐标点的个数
        if(isClose){
            nextPositions.push(positions[(positionCount-1)*3-3],positions[(positionCount-1)*3-2],positions[(positionCount-1)*3-1]);               //计算去路偏移
        }else{
            nextPositions.push(positions[0],positions[1],positions[2]);               //计算去路偏移
        }
        prePositions.push(positions[3*2-3],positions[3*2-2],positions[3*2-1]);       //下个点

        for(let i=1;i<positionCount-1;i++){
            nextPositions.push(positions[3*(i-1)],positions[3*(i-1)+1],positions[3*(i-1)+2]);
            prePositions.push(positions[3*(i+1)],positions[3*(i+1)+1],positions[3*(i+1)+2]);
        }

        nextPositions.push(positions[(positionCount-2)*3],positions[(positionCount-2)*3+1],positions[(positionCount-2)*3+2]);
        if(isClose){
            prePositions.push(positions[3*2-3],positions[3*2-2],positions[3*2-1]);               //计算去路偏移
        }else{
            prePositions.push(positions[positionCount*3-3],positions[positionCount*3-2],positions[positionCount*3-1]);
        }

        return {
            positions:positions,
            prePositions:prePositions,
            nextPositions:nextPositions
        }
    }

    /**
     * 根据几何类型，计算需要绘制的数据
     * @private
     * @param {hmap.geom.Geometry} geom 几何，暂时只支持面和线的几何。
     * @param {Array} color 归一化的颜色数组
     */
    _generateShineByGeom(geom,color){
        let coordArr,positions = [];
        if(typeof(geom.getCoordSeqs)==='function'){  //面
            coordArr = geom.getCoordSeqs()[0].extractCoords();
        }else if(typeof(geom.getCoordSeq) === 'function'){
            coordArr = geom.getCoordSeq().extractCoords();
        }                                   //解析出坐标数组，再复制三份
        if(coordArr.length < 2){
            throw "coordinates must be at least 2";
        }
        for(let i=0;i<coordArr.length;i++){
            positions.push(coordArr[i].getOrdinate("X"));
            positions.push(coordArr[i].getOrdinate("Y"));positions.push(coordArr[i].getOrdinate("Z"));          //[x,y,z]数组
        }
        let isClose = false;                //是否闭合
        if(coordArr[0].equals(coordArr[coordArr.length - 1])){
            isClose = true;
        }

        const triangleLeft = [],trianglePreLeft=[],triangleNextLeft=[],isOffsetLeft=[],colorsLeft=[],scalesLeft=[];
        let leftItem = this._gererateLeftGo(positions,isClose);
        if(leftItem){
            let leftPosition = leftItem.positions,prePositions = leftItem.prePositions,nextPosition = leftItem.nextPositions;
            for(let i=0,length=positions.length/3;i<length;i++){
                triangleLeft.push(positions[3*i],positions[3*i+1],positions[3*i+2]);
                triangleLeft.push(leftPosition[3*i],leftPosition[3*i+1],leftPosition[3*i+2]);
                trianglePreLeft.push(positions[3*i],positions[3*i+1],positions[3*i+2]);  //不偏移
                trianglePreLeft.push(prePositions[3*i],prePositions[3*i+1],prePositions[3*i+2]);
                triangleNextLeft.push(positions[3*i],positions[3*i+1],positions[3*i+2]);
                triangleNextLeft.push(nextPosition[3*i],nextPosition[3*i+1],nextPosition[3*i+2]);
                isOffsetLeft.push(0);isOffsetLeft.push(1);
                colorsLeft.push(color[0],color[1],color[2],color[3]);colorsLeft.push(0,0,0,0);
                scalesLeft.push(this.scale);scalesLeft.push(this.scale);
            }
        }

        const triangleRight = [],trianglePreRight=[],triangleNextRight=[],isOffsetRight=[],colorsRight=[],scalesRight=[];
        let rightItem = this._gererateRightGo(positions,isClose);
        if(rightItem){
            let rightPosition = rightItem.positions,prePositions = rightItem.prePositions,nextPosition = rightItem.nextPositions;
            for(let i=0,length=positions.length/3;i<length;i++){
                triangleRight.push(rightPosition[3*i],rightPosition[3*i+1],rightPosition[3*i+2]);
                triangleRight.push(positions[3*i],positions[3*i+1],positions[3*i+2]);
                trianglePreRight.push(prePositions[3*i],prePositions[3*i+1],prePositions[3*i+2]);
                trianglePreRight.push(positions[3*i],positions[3*i+1],positions[3*i+2]);            //不偏移
                triangleNextRight.push(nextPosition[3*i],nextPosition[3*i+1],nextPosition[3*i+2]);
                triangleNextRight.push(positions[3*i],positions[3*i+1],positions[3*i+2]);
                isOffsetRight.push(1);isOffsetRight.push(0);
                colorsRight.push(0,0,0,0);colorsRight.push(color[0],color[1],color[2],color[3]);
                scalesRight.push(this.scale);scalesRight.push(this.scale);
            }
        }
        //每个泛光 以2个三角环的形式绘制
        return {
            datas:[
            {
                positions:triangleLeft,
                prevPositions:trianglePreLeft,
                nextPositions:triangleNextLeft,
                colors:colorsLeft,
                isOffset:isOffsetLeft,
                scale:scalesLeft
            },
            {
                positions:triangleRight,
                prevPositions:trianglePreRight,
                nextPositions:triangleNextRight,
                colors:colorsRight,
                isOffset:isOffsetRight,
                scale:scalesRight
            }]
        }
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 添加泛光对象的图层。
 * ！！！兼容性实现，将于下个版本舍弃。建议使用hmap.geosolution.cell.Trail类来实现，详细请参考demo"地理解决方案/线纹理-泛光"
 * @type {hmap.geosolution.ShineLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.ShineLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.ShineLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container=null;    //图层容器
        this._map=null;         //地图对象
        this.gl=null;           //webgl的绘图环境

        this.dataMap = {};                 //所有的数据
        this.shines = [];                  //图层中所有的范光
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 添加一个泛光要素
     * @param {hmap.geosolution.Shine} shine 泛光要素
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120,30,0);
     * let coord2 = new hmap.basetype.Coordinate(121,30,0);
     * let point1 = new hmap.geom.Point(coord1);
     * let point2 = new hmap.geom.Point(coord2);
     * let lineGeom = new hmap.geom.Line([point1,point2]);
     * let shine = new hmap.geosolution.Shine({geometry:lineGeom})
     * shinelayer.addShine(shine);
     */
    addShine(shine){
        if(!(shine instanceof hmap.geosolution.Shine)){
            throw "parameter must be a hmap.geosolution.Shine!"
        }
        this.shines.push(shine);
    };

    /**
     * 根据id获取泛光要素
     * @param {Number} id 泛光要素id
     * @returns {hmap.geosolution.Shine} shine 泛光要素
     * @example
     * let shine = shinelayer.getShineById(id);
     */
    getShineById(id){
        let result = undefined;
        for(let shine of this.shines){
            if(id && shine.getId()==id){
                result = shine;
            }
        }
        return result;
    }

    /**
     * 获取全部泛光要素
     * @returns {Array<hmap.geosolution.Shine>} shine 全部泛光要素
     * @example
     * let shines = shinelayer.getShines();
     */
    getShines(){
        return this.shines;
    }

    /**
     * 根据id移除泛光要素
     * @param {Number} id 泛光要素的id
     * @example
     * shinelayer.removeShineById(id)
     */
    removeShineById(id){
        let shine = this.getShineById(id);
        if(shine){
            this.remove(shine);
        }
    }

    /**
     * 移除一个泛光要素
     * @param {hmap.geosolution.Shine} shine 泛光要素
     * @throws 当参数shine类型不对时，抛出异常
     * @example
     * shinelayer.remove(shine)
     */
    remove(shine){
        if(!(shine instanceof hmap.geosolution.Shine)){
            throw "parameter must be a hmap.geosolution.Shine!"
        }
        this.shines.splice(this.shines.findIndex(v => v.getId() === shine.getId()), 1);      //从数组中移除
    }

   /**
    * 移除全部的泛光要素
    * @example
    * shinelayer.removeAll()
    */
    removeAll(){
        if(this.shines.length != 0){
            this.shines = [];         //清空泛光
        }
    }

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
		super.setMap(_map);
        //初始化render
        this.vpMatrix=this._map.getVPMatrix();
        const posSize = this._isRTE ? 6 : 3;
        this.render=new hmap.ShineRender(this.gl,posSize);
    }

    /**
     * 设置上下文
     * @private
     */
    _configContext(){
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    }

    /**
     * 重新绘制
     * @private
     */
    draw(){
        super.draw();
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;
        this._drawShines();
    }

    /**
     * 将数组转为64
     * @private
     */
    _translateTo64(positions){
        const positionCount = positions.length/3;
        const positions_new=[];
        for(let i=0;i<positionCount;i++){
            const xx = this._float32FromDouble64(positions[3*i]);
            const yy = this._float32FromDouble64(positions[3*i+1]);
            const zz = this._float32FromDouble64(positions[3*i+2]);
            positions_new.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
        }
        return positions_new;
    }

    /**
     * 绘制范光
     * @private
     */
    _drawShines(){
        const blend = this.getBlendStatus();
        blend.setFunc({
            rgbSrcFactor:hmap.status.BlendFactor.SRC_ALPHA,
            rgbDstFactor: hmap.status.BlendFactor.ONE,
            rgbMode: hmap.status.BlendFunc.FUNC_ADD
        })
        blend.active(this.gl);

        const depth = this.getDepthStatus();
        depth.setEnable(false);
        depth.active(this.gl);

        let positions=[],prevPositions =[],nextPositions=[];
        const colors=[],isOffset=[],scale=[],indices=[];
        let indexLen=0;
        for(let i=0;i<this.shines.length;i++){
            let dataItem = this.shines[i].dataMap;
            const datas = dataItem.datas;
            if(datas){
                for(let j=0;j<datas.length;j++){        //每个范光有两个三角环，循环获取
                    const data = datas[j];
                    positions.push(...data.positions);
                    prevPositions.push(...data.prevPositions);
                    nextPositions.push(...data.nextPositions);
                    colors.push(...data.colors);
                    isOffset.push(...data.isOffset);
                    scale.push(...data.scale);

                    for(let k=0;k<data.positions.length/3;k++){         //每次都计算索引
                        indices.push(indexLen + k);
                    }
                    indices.push(65535);
                    indexLen = indices.length - (2*i+j+1);
                }
            }
        }
        if (this._isRTE) {
            positions = this._translateTo64(positions);
            prevPositions = this._translateTo64(prevPositions);
            nextPositions = this._translateTo64(nextPositions);
        }
        if(indices.length != 0){
            indices.pop();
        }
        let dataMapToDraw = {
            positions:positions,
            prevPositions:prevPositions,
            nextPositions:nextPositions,
            colors:colors,
            isOffset:isOffset,
            scale:scale,
            indices:indices
        }
        const camera = this._splitCameraPrecision();
        const uniforms = {
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: camera
        };

        this.render.draw(dataMapToDraw,uniforms);
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};

hmap.geosolution.FilledCircle=class{

    constructor(options){
        this.CLASS_NAME="hmap.geosolution.FilledCircle";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);

        const coord=options.center?options.center:new hmap.basetype.Coordinate();
        this._center=[coord.getOrdinate("X"),coord.getOrdinate("Y"),coord.getOrdinate("Z")];
        const color=options.color?options.color:new hmap.style.Color(255,0.0,0.0,1.0);
        this._color=color.toNormalizeArray();
        this._size=options.size?options.size:1.0;
        this._maxSize=options.maxSize?options.maxSize:this._size;
        this._freq=options.freq?options.freq:3000;
        this._threshold=options.threshold?options.threshold:[0.20,0.40,0.60,0.80];
        this._label=options.label?options.label:"";
        this._start=false;
        this._startTime=null;
    }

    isStart(bool){
        this._start=bool;
    }

    getId(){
        return this._id;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};

hmap.geosolution.FilledCircleLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME="hmap.geosolution.FilledCircleLayer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._circleMap=new Map();
        this._drawData={
            idArray:[],
            colors:[],
            sizes:[],
            maxSizes:[],
            freqs:[],
            centers:[],
            thresholds:[]
        };
        this._map=null;
        this.gl=null;
        this.render=null;
        this._startTime=null;
        this._upFlag={
            index:null,
            isChange:false,
            update:null
        };//"A":add,"R":change,"D":delete,"O":全刷数据.
        // 根据更新数据的模式判断更新Buffer数据的模式，
        //if(isChange==true){
        //              update=="R",根据index替换数据
        //             else:全部更新数据
        // }
    }

    setMap(_map){
        super.setMap(_map);
        this._posSize = this._isRTE ? 6 : 3;
        this.render=new hmap.FilledCircleRender(this.gl,this._posSize);
    }

    addFilledCircle(filledCircle){
        this._circleMap.set(filledCircle.getId(),filledCircle);
    }

    removeAll(){
        this._circleMap.clear();
        this._drawData={
            idArray:[],
            colors:[],
            sizes:[],
            maxSizes:[],
            freqs:[],
            centers:[],
            thresholds:[]
        };
        this.render._deleteBuffers();
        // this.render=new hmap.FilledCircleRender(this.gl,this._posSize);
    }

    removeFilledCircleById(id){

    }

    updateFilledCircles(id){
        if(id){
            //判断图层中是否存在数据
            if(this._circleMap.get(id)){
                const value=this._circleMap.get(id);
                let ind=this._drawData.idArray.indexOf(id);
                let center=[...value._center];
                if(this._isRTE){
                    const xx = this._float32FromDouble64(center[0]);
                    const yy = this._float32FromDouble64(center[1]);
                    const zz = this._float32FromDouble64(center[2]);
                    center=[xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
                }
                //add or change
                if(ind===-1){
                    this._drawData.idArray.push(value._id);
                    this._drawData.centers.push(...center);
                    this._drawData.colors.push(...value._color);
                    this._drawData.sizes.push(value._size);
                    this._drawData.maxSizes.push(value._maxSize);
                    this._drawData.freqs.push(value._freq);
                    this._drawData.thresholds.push(...value._threshold);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    this._drawData.centers.splice(this._posSize*ind,this._posSize,...center);
                    this._drawData.colors.splice(4*ind,4,...value._color);
                    this._drawData.sizes.splice(ind,1,value._size);
                    this._drawData.maxSizes.splice(ind,1,value._maxSize);
                    this._drawData.freqs.splice(ind,1,value._freq);
                    this._drawData.thresholds.splice(ind,4,...value._threshold);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                let ind=this._drawData.idArray.indexOf(id);
                if(ind!==-1){
                    this._drawData.idArray.splice(ind,1);
                    this._drawData.centers.splice(this._posSize*ind,this._posSize);
                    this._drawData.colors.splice(4*ind,4);
                    this._drawData.sizes.splice(ind,1);
                    this._drawData.maxSizes.splice(ind,1);
                    this._drawData.freqs.splice(ind,1);
                    this._drawData.thresholds.splice(ind,4);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="D";
                }else{
                    this._upFlag.index=null;this._upFlag.isChange=false;this._upFlag.update="D";
                }
            }

        }else{
            //update all
            let ids=[],centers=[],colors=[],sizes=[],maxSizes=[],freqs=[],thresholds=[];
            for(let value of this._circleMap.values()){
                if(this._isRTE){
                    const xx = this._float32FromDouble64(value._center[0]);
                    const yy = this._float32FromDouble64(value._center[1]);
                    const zz = this._float32FromDouble64(value._center[2]);
                    centers.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                }else{
                    centers.push(...value._center);
                }
                ids.push(value._id);
                colors.push(...value._color);
                sizes.push(value._size);
                maxSizes.push(value._maxSize);
                freqs.push(value._freq);
                thresholds.push(...value._threshold);
            }
            this._drawData.idArray=ids;
            this._drawData.centers=centers;
            this._drawData.colors=colors;
            this._drawData.sizes=sizes;
            this._drawData.maxSizes=maxSizes;
            this._drawData.freqs=freqs;
            this._drawData.thresholds=thresholds;
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }
    draw(){
        super.draw();
        if(this._drawData.idArray.length<=0)return;
        // const flag=this.getAnimateLock();
        if(flag){
            this._startTime=this._startTime?this._startTime:Date.now();
            if((!this.render._upBuffer)||this._upFlag.isChange){
                this.render._addChangeBufferD(this._drawData);
                this._upFlag.isChange=false;
            }
            this._tick();
        }

    };

    _tick(){
        window.cancelAnimationFrame(this.animateId);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        let _time=this._startTime?window.Date.now()-this._startTime:0;
        // const camera = this._splitCameraPrecision();
        const uniforms = {
            u_time:_time,
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: this._splitCameraPrecision(),
            u_res:this._isRTE?this._float32FromDouble64(this._map.getResolution()):[this._map.getResolution(),0]
        };
        this.render.draw(this._drawData,uniforms,"TRIANGLE_FAN");
        // 获取当前上下文的状态,如果为非则继续动画
        if(!this.gl.isContextLost()){
            // this.animateId=requestAnimationFrame(function(){this._tick()}.bind(this));
            this.animateId=window.requestAnimationFrame(()=>this._tick());
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 流光要素
 * @type {hmap.geosolution.FlowLight}
 */
hmap.geosolution.FlowLight=class{
    /**
     *  构建一个流光，构成流光的要素中，有流光路径，为坐标序列
     *  options {Object} 构造参数
     *  options.coordSeq {hmap.basetype.CoordSeq} 流光路径坐标序列
     *  options.color {hmap.style.Color} 流光颜色，默认为 new hmap.style.Color(255,0,0,1)
     *  options.speed {Number} 流光运动速度，单位"米/秒"，默认为5
     *  options.flowLength {Number} 流光飞行长度，单位米，默认100
     *  options.radius {Number} 流光最大宽度，地图单位，默认0.0008
     *  options.pointDensity {Number} 加密距离，地图单位,默认0.0002
     */
    constructor(options){
        this.CLASS_NAME = "hmap.geosolution.FlowLight";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.coordSeq = options.coordSeq;                                       //流光路径坐标序列
        this.color = options.hasOwnProperty("color") ? options.color : new hmap.style.Color(255,0,0,1);       //流光最内侧颜色，流光从内侧到外侧为渐变
        this.speed = options.hasOwnProperty("speed") ? options.speed : 5;                         //流光速度，单位米
        this.flowLength = options.hasOwnProperty("flowLength") ? options.flowLength : 100;
        this.radius = options.hasOwnProperty("radius") ? options.radius : 0.0008;
        this._pointDensity = options.hasOwnProperty("pointDensity") ? options.pointDensity : 0.0002;              //加密距离,地图单位
        this._init();
    }

    /**
     * 初始化流光
     * @private
     */
    _init(){
        this.offset = -this.flowLength;                            //流光相对于初始位置的偏移，单位为米，默认为0
        this.coordinates = this._generateDetailCoords();
    }

    /**
     * 计算并返回用于动画的详细坐标
     * @private
     */
    _generateDetailCoords(){
        let origin = this.coordSeq.extractCoords();       //初始坐标
        let coordinates = this._getDistinctCoords(origin);           //去除相邻重复的坐标点
        if(coordinates.length < 2){
            throw RangeError("param \"coordSeq\" must contain two distinct coordinates at least!");
        }
        const detailPoints = [];
        detailPoints.push(coordinates[0]);              //i=0的情况
        for(let i=1;i<coordinates.length;i++){
            let curP = coordinates[i],preP = coordinates[i-1];
            var midnum = this._generateMidPointNum(preP,curP);
            if(midnum==0){
                detailPoints.push([curP[0],curP[1],curP[2]]);
            }else{
                for(let j=0;j<midnum;j++){
                    detailPoints.push([preP[0]+(curP[0]-preP[0])*(j+1)/midnum,preP[1]+(curP[1]-preP[1])*(j+1)/midnum,preP[2]+(curP[2]-preP[2])*(j+1)/midnum]);
                }
            }
        }
        return detailPoints;
    }

    /**
     * 根据开始点和结束点，计算中间点的数量
     * @private
     * @param {Array} coordsArray 经度、纬度、高度数组 [[lon,lat,height],[lon,lat,height]]
     * @returns {Number} 中间点的个数
     */
    _generateMidPointNum(prev,cur){
        let prevCoordArr = prev, curCoordArr = cur;
        let minusX = prevCoordArr[0] - curCoordArr[0], minusY = prevCoordArr[1] - curCoordArr[1],
            minusZ = prevCoordArr[2] - curCoordArr[2];
        let result = Math.sqrt(minusX*minusX + minusY*minusY + minusZ*minusZ);
        return Math.floor(result/this._pointDensity);
    }

    /**
     * 获取坐标中的长度
     * @returns {Number} sum 长度，单位米
     * @private
     * */
    _getLength(coordinates){
        let sum = 0;
        for(let i=1;i<coordinates.length;i++){
            let prevCoord = coordinates[i-1],curCoord = coordinates[i];
            let curLength = prevCoord.get3Dist(curCoord);
            sum += curLength;
        }
        return sum;
    }

    /**
     *  去除相邻重复点
     *  @private
     * */
    _getDistinctCoords(coordinates){
        let distinct = [];
        if(coordinates.length > 0){
            distinct.push([coordinates[0].getOrdinate("X"), coordinates[0].getOrdinate("Y"), coordinates[0].getOrdinate("Z")]);
        }
        for(let i=1;i<coordinates.length;i++){
            let prevCoordinate = coordinates[i-1], curCoordinate = coordinates[i];
            if(!curCoordinate.equals(prevCoordinate)){
                distinct.push([curCoordinate.getOrdinate("X"), curCoordinate.getOrdinate("Y"), curCoordinate.getOrdinate("Z")]);
            }
        }
        return distinct;
    }

    /**
     * 获取流光要素的坐标数组
     * @returns {Array<hmap.basetype.Coordinate>} 坐标数组
     * */
    getCoordinates(){
        return this.coordinates;
    }

    /**
     * 获取自动生成的id
     * @returns {Number} 自动生成的id
     */
    getId(){
        return this._id;
    }

    /**
     * 设置自定义的id
     * @param {Number} id 设置的id
     */
    setId(id){
        this._id = id;
    }

    /**
     * 获取颜色
     * @returns {hmap.style.Color}
     * */
    getColor(){
        return this.color;
    }

    /**
     * 设置颜色
     * @param {hmap.style.Color} color颜色，这里不考虑透明度参数
     * @throws 当参数color类型不对时，抛出异常。
     * @example
     * eleWall.setColor(new hmap.style.Color(255.0,0.0,0.0));
     */
    setColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw TypeError("color must be instance of hmap.style.Color");
        }
        this.color = color;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 流光图层
 * ！！！兼容性实现，将于下个版本舍弃。建议使用hmap.geosolution.cell.Trail类来实现，详细请参考demo"地理解决方案/线纹理-光效流动"
 * @type {hmap.geosolution.FlowLightLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.FlowLightLayer=class extends hmap.layer.Layer{
    /**
     * 流光图层构造函数
     */
    constructor(name, options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.FlowLightLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container=null;                    //图层容器
        this._map=null;                         //地图对象
        this._dataMap = {};                     //所有的数据
        this._flowlights = [];                  //图层中所有的流光要素
        this._isAnimate = (options.animate != undefined) ? options.animate : true;      //是否开启动画，默认开启
        this.pattern = 0;
        this.originColorArr = options.colorArr ? options.colorArr : [0,100,100,0.5];
        this.init();
    }

    init(){
        let origin = this.originColorArr;
        this.colorArr = [origin[0]/255,origin[1]/255,origin[2]/255,origin[3]]
    }

    /**
     * 获取图层的类型
     * @returns {String} 返回图层的类型
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 添加一个流光要素
     * @param {hmap.geosolution.FlowLight} flowlight 流光
     * @throws 当参数flowlight不符合参数类型时，抛出异常。
     */
    addFlowLight(flowlight){
        if(!(flowlight instanceof hmap.geosolution.FlowLight)){
            throw TypeError("parameter must be a hmap.geosolution.FlowLight!");
        }
        this._flowlights.push(flowlight);
    }

    /**
     * 根据id获取流光要素
     * @param {Number} id 流光要素id
     * @returns {hmap.geosolution.FlowLight} 返回参数id对应的流光要素；若没有则返回null
     */
    getFlowLightById(id){
        let result = null;
        for(let flowlight of this._flowlights){
            if(id && flowlight.getId()==id){
                result = flowlight;
            }
        }
        return result;
    }

    /**
     * 获取全部的流光要素
     * @returns {Array<hmap.geosolution.FlowLight>} 所有流光要素的数组
     */
    getFlowLights(){
        return this._flowlights;
    }

    /**
     * 根据id移除流光要素
     * @param {Number} id 流光要素的id
     */
    removeFlowLightById(id){
        let flowlight = this.getFlowLightById(id);
        if(flowlight){
            this.remove(flowlight);
        }
    }

    /**
     * 移除一个流光要素
     * @param {hmap.geosolution.FlowLight} flowlight 流光要素
     * @throws 当参数flowlight不是流光类型时，抛出异常。
     */
    remove(flowlight){
        if(!(flowlight instanceof hmap.geosolution.FlowLight)){
            throw TypeError("parameter must be a hmap.geosolution.FlowLight!");
        }
        this._flowlights.splice(this._flowlights.findIndex(v => v.getId() === flowlight.getId()), 1);      //从数组中移除
    }

    /**
     * 移除全部的流光要素
     */
    removeAll(){
        if(this._flowlights.length != 0){
            this._flowlights = [];         //清空流光要素
        }
    }

    /**
     * 设置地图
     * @private
     */
    setMap(_map){
        super.setMap(_map);
        //初始化render
        this.vpMatrix=this._map.getVPMatrix();
        const posSize = this._isRTE ? 6 : 3;
        this.render=new hmap.FlowLightRender(this.gl,posSize);
    }

    /**
     * 调render使用
     * @private
     */
    draw(){
        super.draw();
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    /**
     * 数据组织方法
     * @private
     */
    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;        //矩阵
        if(this._visibility){    //可见的情况
            this._updateFlowLights();
        }
        // 获取当前上下文的状态,如果为丢失则继续动画
        if(!this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){
                this.redraw();
            }.bind(this));
        }
    }

    /**
     * 由两个坐标形成的向量的象限角度
     * @param x 增量X
     * @param y 增量Y
     * @returns {number} theta 象限角
     * @private
     */
    getQuadrantAngle(preCoord, nextCoord) {
        let x = nextCoord[0] - preCoord[0],y = nextCoord[1] - preCoord[1];
        let theta = Math.atan(y/x);
        if (x > 0 && y > 0){
            return theta;
        }else if (x > 0 && y < 0){
            return Math.PI * 2 + theta;
        }else if (x < 0 && y > 0){
            return theta + Math.PI;
        }else if (x < 0 && y < 0){
            return theta + Math.PI;
        }else{
            return theta;
        }
    }

    /**
     * 计算由相邻的三个点所形成的两个向量之间的夹角
     * @param preCoord  上一个点
     * @param midCoord  中间点
     * @param nextCoord 下一个点
     * @returns {Number} theta 弧度
     * @private
     */
    getIncludedAngel(preCoord, midCoord, nextCoord) {
        let innerProduct = (midCoord[0] - preCoord[0])
            * (nextCoord[0]- midCoord[0])
            + (midCoord[1]- preCoord[1])
            * (nextCoord[1] - midCoord[1]);
        let mode1 = Math.sqrt(Math.pow((midCoord[0] - preCoord[0]), 2.0)
            + Math.pow((midCoord[1] - preCoord[1]), 2.0));
        let mode2 = Math.sqrt(Math.pow((nextCoord[0] - midCoord[0]), 2.0)
            + Math.pow((nextCoord[1] - midCoord[1]), 2.0));
        return Math.acos(innerProduct / (mode1 * mode2));
    }

    /**
     * 获取相邻三个点所形
     * @param preCoord  上一个节点坐标
     * @param midCoord  中间节点坐标
     * @param nextCoord 下一个节点坐标
     * @returns {number} 相邻三个点所形成的两个向量的交叉乘积
     * @private
     */
    getVectorProduct(preCoord, midCoord, nextCoord) {
        return (midCoord[0] - preCoord[0]) * (nextCoord[1] - midCoord[1]) - (nextCoord[0] - midCoord[0]) * (midCoord[1] - preCoord[1]);
    }

    /**
     * 获取指定弧度范围之间的缓冲区圆弧拟合边界点
     * @param center 指定拟合圆弧的原点
     * @param startRadian 开始弧度
     * @param endRadian 结束弧度
     * @param radius 缓冲区半径
     * @return {Array} 缓冲区的边界坐标
     * @private
     */
    getBufferCoordsByRadian(center, startRadian, endRadian, radius) {
        let gamma = Math.PI / 6;
        let x = 0.0, y = 0.0;
        const coords = [];
        for (let phi = startRadian; phi <= endRadian + 0.000000000000001; phi += gamma) {
            x = center[0] + radius * Math.cos(phi);
            y = center[1] + radius * Math.sin(phi);
            coords.push([x,y,0.0])
        }
        return coords;
    }

    /**
     * 获取拐点处的缓冲坐标
     * @param {Array} prevCoord 上一个坐标点
     * @param {Array} curCoord  当前坐标点
     * @param {Number} radius 缓冲距离
     * @returns {Array} 坐标数组
     * @private
     * */
    getBufferCoords(prevCoord,curCoord,radius){
        let startRadian,endRadian;
        const detailCoords = [];
        let alpha = this.getQuadrantAngle(prevCoord, curCoord);
        if(alpha == 0){
            if(curCoord[0] > prevCoord[0]){
                startRadian = -Math.PI / 2;
                endRadian =  Math.PI/2;
            }else{
                startRadian = Math.PI / 2;
                endRadian =  3*Math.PI/2;
            }
        }else{
            startRadian = alpha + (3 * Math.PI) / 2;
            endRadian = alpha + 2 * Math.PI;
        }
        detailCoords.push(...this.getBufferCoordsByRadian(curCoord, startRadian, endRadian, radius));
        return detailCoords;
    }

    /**
     * 获取一侧缓冲坐标
     * @private
     * */
    getLeftBufferEdgeCoords(coords, radius,startIndex=0,reverse = false) {
        // 参数处理
        if (coords.length < 1){
            return;
        }
        const colorArr = this.colorArr;
        const positions = [], colors = [], indices=[];
        // 计算时所需变量
        let alpha = 0.0, delta = 0.0, l = 0.0;          //向量绕起始点沿顺时针方向旋转到X轴正半轴所扫过的角度 //前后线段所形成的向量之间的夹角 //前后线段所形成的向量的叉积
        let startRadian = 0.0, endRadian = 0.0;
        let beta = 0.0, x = 0.0, y = 0.0;
        let lastOffsetCoord;
        // 第一节点的缓冲区,在此程序中只生成2点
        {
            alpha = this.getQuadrantAngle(coords[0], coords[1]);
            if(Math.abs(alpha) == 0){
                startRadian = alpha;
                endRadian = alpha + Math.PI / 2;
            }else{
                startRadian = alpha + Math.PI;
                endRadian = alpha + (3 * Math.PI) / 2;
            }
            let startCoords = this.getBufferCoordsByRadian(coords[0], startRadian, endRadian, radius);
            if(startCoords.length > 1){
                for(let j=1;j<startCoords.length;j++){
                    let prevCood = startCoords[j-1], curCoord = startCoords[j];
                    lastOffsetCoord = curCoord;
                    positions.push(...coords[0]);
                    positions.push(...prevCood);
                    positions.push(...curCoord);
                    if(reverse){
                        colors.push(colorArr[0],colorArr[1],colorArr[2],colorArr[3],colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                    }else{
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                    }
                    let prevIndex = startIndex + indices.length;
                    indices.push(prevIndex + 0, prevIndex + 1, prevIndex + 2);
                }
            }
        }
        // 中间节点
        for (let i = 1; i < coords.length - 1; i++) {           //coords.length - 1
            alpha = this.getQuadrantAngle(coords[i], coords[i + 1]);
            delta = this.getIncludedAngel(coords[i - 1], coords[i], coords[i + 1]);
            l = this.getVectorProduct(coords[i - 1], coords[i], coords[i + 1]);
            let midCoords;              //中间一次性需要补足的点
            if(Math.abs(l)<0.000000000000001 || l < 0){
                if(Math.abs(l)<0.000000000000001){
                    if(Math.abs(alpha) == 0){
                        let val;
                        if(coords[i+1][0] > coords[i][0]){
                            val = - radius;
                        }else{
                            val = radius;
                        }
                        x = coords[i][0];
                        y = coords[i][1] + val;
                    }else{
                        beta = alpha - Math.PI / 2;
                        x = coords[i][0] + radius * Math.cos(beta);
                        y = coords[i][1] + radius * Math.sin(beta);
                    }
                }else{
                    beta = alpha - (Math.PI - delta) / 2
                    x = coords[i][0] + radius * Math.cos(beta);
                    y = coords[i][1] + radius * Math.sin(beta);
                }
                midCoords = [[x,y,0.0]];
                for(let j=0;j<midCoords.length;j++){
                    let prevCood = lastOffsetCoord, curCoord = midCoords[j];
                    lastOffsetCoord = curCoord;
                    let prevOriginCood = coords[i-1], curOriginCood = coords[i];
                    positions.push(...prevCood);
                    positions.push(...curOriginCood);
                    positions.push(...prevOriginCood);

                    positions.push(...prevCood);
                    positions.push(...curCoord);
                    positions.push(...curOriginCood);
                    if(reverse){
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-i/(coords.length-1)),colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-(i-1)/(coords.length-1)));
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-i/(coords.length-1)));
                    }else{
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],i*colorArr[3]/(coords.length-1),colorArr[0],colorArr[1],colorArr[2],(i-1)*colorArr[3]/(coords.length-1));
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],i*colorArr[3]/(coords.length-1));
                    }
                    let prevIndex = startIndex + indices.length;
                    indices.push(prevIndex + 0,prevIndex + 1,prevIndex + 2,prevIndex + 3,prevIndex + 4,prevIndex + 5);
                }
            }else{          //l>0
                startRadian = alpha + (3 * Math.PI) / 2 - delta;
                endRadian = alpha + (3 * Math.PI) / 2;
                midCoords = this.getBufferCoordsByRadian(coords[i], startRadian, endRadian, radius);
                {
                    let prevCood = lastOffsetCoord, prevOriginCood = coords[i-1], curOriginCood = coords[i];
                    positions.push(...prevCood);
                    positions.push(...curOriginCood);
                    positions.push(...prevOriginCood);
                    if(reverse){
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-i/(coords.length-1)),colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-(i-1)/(coords.length-1)));
                    }else{
                        colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*i/(coords.length-1),colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(i-1)/(coords.length-1));
                    }
                    let prevIndex = startIndex + indices.length;
                    indices.push(prevIndex + 0,prevIndex + 1,prevIndex + 2);
                }
                for(let j=0;j<midCoords.length;j++){
                    let prevCood = lastOffsetCoord, curCoord = midCoords[j];
                    lastOffsetCoord = curCoord;
                    positions.push(...coords[i]);
                    positions.push(...prevCood);
                    positions.push(...curCoord);
                    if(reverse){
                        colors.push(colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(1-i/(coords.length-1)),colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                    }else{
                        colors.push(colorArr[0],colorArr[1],colorArr[2],colorArr[3]*i/(coords.length-1),colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                    }
                    let prevIndex = startIndex + indices.length;
                    indices.push(prevIndex + 0,prevIndex + 1,prevIndex + 2);
                }
            }
        }
        // 最后一个点，在此程序中只生成2点
        {
            alpha = this.getQuadrantAngle(coords[coords.length - 2], coords[coords.length - 1]);
            if(alpha == 0){
                startRadian = -Math.PI / 2;
                endRadian =  0;
            }else{
                startRadian = alpha + (3 * Math.PI) / 2;
                endRadian = alpha + 2 * Math.PI;
            }
            let endCoords = this.getBufferCoordsByRadian(coords[coords.length - 1], startRadian, endRadian, radius)
            {                   //
                let prevCood = lastOffsetCoord, curCoord = endCoords[0];
                lastOffsetCoord = curCoord;
                let prevOriginCood = coords[coords.length-2], curOriginCood = coords[coords.length-1];
                positions.push(...prevCood);
                positions.push(...curOriginCood);
                positions.push(...prevOriginCood);

                positions.push(...prevCood);
                positions.push(...curCoord);
                positions.push(...curOriginCood);
                if(reverse){
                    colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*1/(coords.length-1));
                    colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]*1/(coords.length-1));
                }else{
                    colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3],colorArr[0],colorArr[1],colorArr[2],colorArr[3]*(coords.length-2)/(coords.length-1));
                    colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],colorArr[3]);
                }
                let prevIndex = startIndex + indices.length;
                indices.push(prevIndex + 0,prevIndex + 1,prevIndex + 2,prevIndex + 3,prevIndex + 4,prevIndex + 5);
            }
            for(let j=1;j<endCoords.length;j++){
                let prevCood = lastOffsetCoord, curCoord = endCoords[j];
                lastOffsetCoord = curCoord;
                positions.push(...coords[coords.length - 1]);
                positions.push(...prevCood);
                positions.push(...curCoord);
                if(reverse){
                    colors.push(colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                }else{
                    colors.push(colorArr[0],colorArr[1],colorArr[2],colorArr[3],colorArr[0],colorArr[1],colorArr[2],0.0,colorArr[0],colorArr[1],colorArr[2],0.0);
                }
                let prevIndex = startIndex + indices.length;
                indices.push(prevIndex + 0, prevIndex + 1, prevIndex + 2);
            }
        }
        return {
            positions:positions,
            colors:colors,
            indices:indices
        };
    }

    /**
     * 更新全部的流光要素
     * @private
     */
    _updateFlowLights(){
        for(let flowlight of this._flowlights){
            let start = flowlight.offset < 0? 0:flowlight.offset;
            let coordinates = flowlight.coordinates.slice(start, flowlight.offset + flowlight.flowLength);
            if(coordinates.length >= 2){
                let detailCoordinates = [...coordinates];
                let radius = flowlight.radius;
                let dataMap1 = this.getLeftBufferEdgeCoords(detailCoordinates,radius);
                detailCoordinates.reverse();                //颠倒顺序
                let dataMap2 = this.getLeftBufferEdgeCoords(detailCoordinates,radius,dataMap1.indices.length,true);

                this._dataMap = {
                    positions:dataMap1.positions.concat(dataMap2.positions),
                    colors:dataMap1.colors.concat(dataMap2.colors),
                    indices:dataMap1.indices.concat(dataMap2.indices)
                };
                this._drawFlowLights();
            }
            flowlight.offset++;
            if(flowlight.offset >= flowlight.coordinates.length){
                flowlight.offset -= (flowlight.coordinates.length + flowlight.flowLength);
            }
        }
    }

    /**
     * 根据dataMap数据绘制所有的流光要素
     * @private
     */
    _drawFlowLights(){
		const dataMap = this._dataMap;
        const camera = this._splitCameraPrecision();
        const uniforms = {
            u_ifRTE: this._isRTE,
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_camera: camera
        };
        this.render.draw(dataMap,uniforms);
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 *
 * 水特效填充
 * @type {hmap.geosolution.FillWater}
 * @private
 */
hmap.geosolution.FillWater=class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.CoordSeq} options.coordSeq
     */
    constructor(options,callback){
        this.CLASS_NAME="hmap.geosolution.FillWater";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.coordSeqs = options.coordSeqs;                       //归一化的颜色数组
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this.dataToDraw = this._triangulate(this.coordSeqs);
    }

    /**
     * 获取水填充对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 设置水填充特效的id,有时需要和地理要素保持一致
     * @param {String} id id值
     */
    setId(id){
        this._id = id;
    }

    /**
     * 将坐标序列进行三角化
     * @param coordSeqs
     * @returns {Object} like:{{a_position: *, index: *, positionCount: *[], indexCount: *[]}}
     * @private
     */
    _triangulate(coordSeqs) {
        let fill_xyzs, triIndices;
        const coordData = hmap.strategy.EarCut.getCoordDataFromCoordSeq(coordSeqs);
        //因为面构造为闭合，默认最后一个点和第一个点相同，故三点一面其实为四点
        if (coordData.coordData.length === 12) {
            fill_xyzs = coordData.coordData.slice(0, 9);
            triIndices = [0, 1, 2];
        } else {
            fill_xyzs = coordData.coordData;
            triIndices = hmap.strategy.EarCut.earcut(coordData.coordData, coordData.holeIndices, 3);
        }
        return {
            a_position: fill_xyzs,
            index: triIndices,
            positionCount: [fill_xyzs.length / 3],
            indexCount: [triIndices.length]
        };
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 水填充特效的图层。
 * @type {hmap.geosolution.FillWaterLayer}
 * @extends hmap.layer.Layer
 * @private
 */
hmap.geosolution.FillWaterLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.FillWaterLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container=null;    //图层容器
        this._map=null;         //地图对象
        this.gl=null;           //webgl的绘图环境

        this.dataMap = {};                 //所有的数据
        this.fillwaters = [];
        this.isChange = false;
        this.initTime = new Date().getTime()/1000;
        this.pattern = options.pattern ? options.pattern : "fillwater";         //原本设计了多种填充多个着色器，这里已经废弃
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 添加水填充特效
     * */
    addFillWater(fillwater){
        if(!(fillwater instanceof hmap.geosolution.FillWater)){
            throw "parameter must be a hmap.geosolution.FillWater!"
        }
        this.fillwaters.push(fillwater);
        this.isChange = true;
    };

    /**
     * 根据id移除水填充特效
     * @param {Number} id 水填充特效的id
     */
    removeFillWaterById(id){
        let fillwater = this.getFillWaterById(id);
        if(fillwater){
            this.remove(fillwater);
        }
    }

    /**
     * 移除一个水填充特效
     * @param {hmap.geosolution.FillWater} fillwater 水填充特效
     * @throws 当参数fillwater不是水填充类型时，抛出异常。
     */
    remove(fillwater){
        if(!(fillwater instanceof hmap.geosolution.FillWater)){
            throw TypeError("parameter must be a hmap.geosolution.FillWater!");
        }
        if(fillwater){
            this.fillwaters.splice(this.fillwaters.findIndex(v => v.getId() === fillwater.getId()), 1);      //从数组中移除
        }
    }

    /**
     * 根据id获取水填充要素
     * @param {Number} id 水填充要素id
     * @returns {hmap.geosolution.FillWater} 返回获取的水填充要素；若没有则返回null
     */
    getFillWaterById(id){
        let result = null;
        for(let fillwater of this.fillwaters){
            if(id && fillwater.getId()==id){
                result = fillwater;
            }
        }
        return result;
    }

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
		super.setMap(_map);
        //初始化render
        this.vpMatrix=this._map.getVPMatrix();
        this.render=new hmap.FillWaterOldRender(this.gl,this.pattern);
    }

    /**
     * 设置上下文
     * @private
     */
    _configContext(){
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    }

    /**
     * 重新绘制
     * @private
     */
    redraw(){
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;
        if(!this._isMGL){                                           //不和map共用gl的情况,共用的话不清除
            this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        }
        this._drawFillWaters();

        if(!this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){
                this._tick();
            }.bind(this));
        }
    }

    /**
     * 绘制水填充特效
     * @private
     */
    _drawFillWaters(){
        const positions = [], indices = [];
        for(let i=0;i<this.fillwaters.length;i++){
            let dataItem = this.fillwaters[i].dataToDraw;
            positions.push(...dataItem.a_position);
            indices.push(...dataItem.index)
        }
        const dataMap = {
            positions:positions,
            indices:indices
        }
        const uniforms = {
            u_mvMatrix: this._map.getViewMatrix(),
            u_projMatrix: this._map.getProjMatrix(),
            u_time:new Date().getTime()/1000 - this.initTime
        };
        this.render.draw(dataMap,uniforms,this.isChange);
        this.isChange = false;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 粒子组成点，点主要移动组成规律的图形
 * @type {hmap.geosolution.ParticleMover}
 * @private
 */
hmap.geosolution.ParticleMover=class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {Array} options.coordArr 坐标点数组
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.ParticleMover";
        this.position = options.coordArr;
        this.velocity = this.position;
        this.acceleration = [0, 0, 0];
        this.speed = 0;                             //粒子运动速度，默认为0
        this.inertiaForce = [0, 0, 0];              //物体惯性运动
        this.isActive = false;
    }

    /**
     * 回到初始化状态
     * */
    init(position){
        this.velocity = this.position = position;
        this.acceleration = [0, 0, 0];
    }

    /**
     * 更新位置点
     * */
    updatePosition() {
        let prevVelocity = this.velocity, prevAcceleration = this.acceleration;
        this.velocity = [prevVelocity[0]+prevAcceleration[0], prevVelocity[1]+prevAcceleration[1], prevVelocity[2]+prevAcceleration[2]];
        this.position = this.velocity;
    }


    /**
     * 叠加一个增量以驱动
     * */
    applyForce(position){
        let prev = this.acceleration;
        this.acceleration = [prev[0]+position[0], prev[1]+position[1], prev[2]+position[2]];
    }

    /**
     * 叠加一个增量以驱动
     * */
    applyInertia(){
        let prev = this.velocity, inertiaForce = this.inertiaForce;
        this.velocity = [prev[0]+inertiaForce[0], prev[1]+inertiaForce[1], prev[2]+inertiaForce[2]];
    }

    /**
     *
     * */
    inactivate(){
        this.isActive = false;
    }

    /**
     * 激活粒子
     * */
    activate(){
        this.isActive = true;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 粒子的通用类，自身具有惯性，受重力(或升力)影响，暂时忽略空气阻力，用来构建烟、火、喷泉、消防喷水等效果
 * @type {hmap.geosolution.Particle}
 * @private
 */
hmap.geosolution.Particle = class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.coordinate  粒子起点
     * @param {hmap.basetype.Coordinate} options.destination 粒子终点，火、烟等没有粒子终点
     * @param {Array} options.inertia 粒子每帧在xyz方向上的惯性，默认为[0,0,0]，烟、火等自身没有惯性；如果粒子有destination，则此项自动计算
     * @param {Array} options.gravity 粒子每帧在xyz方向上所受的外力加速度，默认为[0,0,0]，gravity[2]为负表示粒子受重力影响，为正则表示粒子受上升力影响
     * @param {hmap.style.Color} options.color 粒子颜色，粒子和粒子之间颜色使用加法混合
     * @param {Number} options.pointRadius 粒子半径，单位米
     * @param {Number} options.maxHeight 粒子显示的最大高度，单位米，超过此高度粒子不显示，暂未使用
     * @param {Number} options.minHeight 粒子显示的最小高度，单位米，低于此高度粒子不显示，暂未使用
     * @param {Number} options.pointNum 粒子总的数量，粒子过多的话会影响性能
     * @param {Number} options.controlNum 粒子一次发射的数量，用来控制粒子流动的速度
     * @param {Array} options.forceScale 粒子每帧运动在xyz方向上的偏移比例，默认[1,1,1]
     * @param {Number} options.scale 和预设的比例，默认为1
     */
    constructor(options={}){
        this.CLASS_NAME="hmap.geosolution.Particle";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.coordinate = options.coordinate;
        this.destination = options.destination;
        this.inertia = options.inertia ? options.inertia:[0,0,0];
        this.gravity = options.gravity ? options.gravity:[0,0,0];
        this.color = options.color;
        this.pointRadius = options.pointRadius;
        this.maxHeight = options.maxHeight;
        this.minHeight = options.minHeight;
        this.pointNum = options.pointNum;
        this.controlNum = options.controlNum;
        this.forceScale = options.forceScale ? options.forceScale:[1,1,1];
        this.scale = options.hasOwnProperty("scale") ? options["scale"]:1;

        this.offsetTimes = 0;                        //偏移次数
        this.movers = [];                            //保存全部粒子
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this._initParticleParam();
        this._initMover();
        this._initDataMap();
    }

    /**
     * 计算需要绘制的数据
     * */
    _initDataMap(){
        const positions = [], originForce=[], offsetIndex=[];
        let movers = this.movers;
        for(let mover of movers){
            positions.push(...mover.position);
            originForce.push(...mover.initForce);
            offsetIndex.push(mover.offsetIndex);
        }
        this.dataMap = {
            positions:positions,
            originForce:originForce,
            offsetIndex:offsetIndex
        }
    }

    /**
     * 初始化粒子的参数，包括惯性力、地球引力等
     * @private
     * */
    _initParticleParam(){
        const unitPerMeter = 1/110000, scale=this.scale;
        this.pointRadius *= unitPerMeter;this.maxHeight *= unitPerMeter;this.minHeight *= unitPerMeter;
        this.gravity[0] *= unitPerMeter;this.gravity[1] *= unitPerMeter;this.gravity[2] *= unitPerMeter;
        const coordinate = this.coordinate,desCoordinate = this.destination;
        if(!desCoordinate){
            this.gravity[0] *= scale;this.gravity[1] *= scale;this.gravity[2] *= scale;
            this.inertia[0] *= scale*unitPerMeter;this.inertia[1] *= scale*unitPerMeter;this.inertia[2] *= scale*unitPerMeter;
        }else{
            let length_x = desCoordinate.getOrdinate("X") - coordinate.getOrdinate("X"),
                length_y = desCoordinate.getOrdinate("Y") - coordinate.getOrdinate("Y");
            const pointNum = this.pointNum, controlNum = this.controlNum;
            let times = Math.floor(pointNum/controlNum),sourceZ = coordinate.getOrdinate("Z"),
                destinationZ = desCoordinate.getOrdinate("Z"), minusZ = destinationZ - sourceZ;
            const gravityZ = this.gravity[2];
            let v = (minusZ - gravityZ*times*times/2)/times;            //重力方向的惯性速度
            this.inertia = [length_x/times, length_y/times, v];         //计算惯性作用
        }
        this.coordArr = [coordinate.getOrdinate("X"), coordinate.getOrdinate("Y"), coordinate.getOrdinate("Z")];
        const colorArr = this.color.toArray();
        this.normalColorArr = [colorArr[0]/255, colorArr[1]/255, colorArr[2]/255, colorArr[3]];         //归一化颜色数组
    }

    /**
     * 初始化所有的粒子移动点，和随机的偏移速度
     * @private
     * */
    _initMover(){
        let scale=this.scale, forceScale = this.forceScale;
        if(this.destination) scale=1;
        for (let i = 0; i < this.pointNum; i++) {
            var mover = new hmap.geosolution.ParticleMover({
                coordArr:this.coordArr
            });
            this.movers.push(mover);

            var rad1 = this._getRadian(Math.log(this._getRandomInt(200, 256)) / Math.log(256) * 270);
            var rad2 = this._getRadian(this._getRandomInt(0, 360));
            var force = this._getSpherical(rad1, rad2, 0.000015);           //在单位球的一片区域获取随机的点，作为初始偏移量
            mover.initForce = [force[0]*forceScale[0]*scale, force[1]*forceScale[1]*scale, (force[0]+force[1])*0.5*forceScale[2]*scale];
            mover.offsetIndex = Math.floor(i/this.controlNum);
        }
    }

    /**
     * 在min和max之间 生成随机值
     * */
    _getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    /**
     * 弧度转为度数
     * */
    _getDegree(radian) {
        return radian / Math.PI * 180;
    }

    /**
     * 度数转化为弧度
     * */
    _getRadian(degrees) {
        return degrees * Math.PI / 180;
    }

    /**
     * 在球面上随机的一片区域获取坐标，作为初始的偏移量
     * */
    _getSpherical(rad1, rad2, r) {
        var x = Math.cos(rad1) * Math.cos(rad2) * r;
        var y = Math.cos(rad1) * Math.sin(rad2) * r;
        var z = Math.sin(rad1) * r;
        return [x, y, z];
    }

    /**
     * 获取火情对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 设置火情的id
     * @param {String} id id值
     */
    setId(id){
        this._id = id;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 粒子图层，以大量粒子的运动来表达烟、火、喷泉、消防喷水等效果
 * ！！！兼容性实现，将于下个版本舍弃。建议使用Cell-MathModel-Layer模式进行开发。替换类为hmap.geosolution.cell.Particle、hmap.geosolution.math.ParticleModel、hmap.geosolution.GeosolutionLayer，使用方式详见对应类的API说明。
 * @type {hmap.geosolution.ParticleLayer}
 * @extends hmap.layer.Layer
 * @private
 */
hmap.geosolution.ParticleLayer=class extends hmap.layer.Layer{
    /**
     * 构造函数
     * @param {Object} options 构造选项
     * @param {Boolean} options.UseMapGL 图层需要一直刷新来表达粒子的运动，因此需要将图层的UseMapGL设置为false
     */
    constructor(name="粒子图层",options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.ParticleLayer";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //初始化一些参数
        this.container=null;    //图层容器
        this._map=null;         //地图对象
        this.gl=null;           //webgl的绘图环境

        this.dataMap = {};                  //所有的数据
        this.particles = [];                //所有的粒子群
    }

    /**
     * 获取该图层的类名
     * @returns {String} 图层类名
     */
    getClassType(){
        return this.CLASS_NAME;
    }

    /**
     * 添加一个粒子特效
     * */
    addParticle(particle){
        if(!(particle instanceof hmap.geosolution.Particle)){
            throw "parameter must be a hmap.geosolution.Particle!"
        }
        this.particles.push(particle);
    };

    /**
     * 根据粒子要素的id移除粒子
     * @param {Number} id 粒子要素的id
     */
    removeParticleById(id){
        let particle = this.getParticleById(id);
        if(particle){
            this.remove(particle);
        }
    }

    /**
     * 移除一个粒子要素
     * @param {hmap.geosolution.Particle} particle 粒子要素
     * @throws 当参数particle不是粒子要素类型时，抛出异常。
     */
    remove(particle){
        if(!(particle instanceof hmap.geosolution.Particle)){
            throw TypeError("parameter must be a hmap.geosolution.Particle!");
        }
        if(particle){
            this.particles.splice(this.particles.findIndex(v => v.getId() === particle.getId()), 1);      //从数组中移除
        }
    }

    /**
     * 根据id获取粒子要素
     * @param {Number} id 粒子要素id
     * @returns {hmap.geosolution.Particle} 返回获取的粒子要素；若没有则返回null
     */
    getParticleById(id){
        let result = null;
        for(let particle of this.particles){
            if(id && particle.getId()==id){
                result = particle;
            }
        }
        return result;
    }

    /**
     * 设置地图
     * @private
     * @param {hmap.Map} _map 地图对象
     */
    setMap(_map){
		super.setMap(_map);
        //初始化render
        this.vpMatrix=this._map.getVPMatrix();
        this.render=new hmap.ParticleOldRender(this.gl);
    }

    /**
     * 设置上下文
     * @private
     */
    _configContext(){
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    }

    /**
     * 重新绘制
     * @private
     */
    draw(){
        super.draw();
        if(this.animateId){
            cancelAnimationFrame(this.animateId);
        }
        this._tick();
    }

    _tick(){
        this.vpMatrix=this._map.getVPMatrix();
        this.render._vpMatrix=this.vpMatrix;
        if(this._visibility){    //可见的情况
            this._drawParticles();
        }

        if(!this.gl.isContextLost()){
            this.animateId=requestAnimationFrame(function(){
                this.redraw();
            }.bind(this));
        }
    }

    /**
     * 绘制粒子
     * @private
     */
    _drawParticles(){
        const viewMatrix = this._map.getViewMatrix(), projMatrix = this._map.getProjMatrix();
        const resolution = this._map.getResolution();

        const blend = this.getBlendStatus();
        /*blend.setFunc({
            rgbSrcFactor:hmap.status.BlendFactor.SRC_,
            rgbDstFactor: hmap.status.BlendFactor.DST_COLOR,
            rgbMode: hmap.status.BlendFunc.FUNC_ADD
        })
        blend.active(this.gl);*/
        blend.setFunc({
            rgbSrcFactor:hmap.status.BlendFactor.SRC_ALPHA,
            rgbDstFactor: hmap.status.BlendFactor.ONE,
            rgbMode: hmap.status.BlendFunc.FUNC_ADD
        })
        blend.active(this.gl);

        const depth = this.getDepthStatus();
        depth.setEnable(false);
        depth.active(this.gl);

        /*this.gl.enable(this.gl.BLEND);            //允许混合
        this.gl.blendEquation( this.gl.FUNC_ADD );
        this.gl.blendFunc( this.gl.SRC_ALPHA, this.gl.ONE );                //加法混合
        this.gl.disable(this.gl.DEPTH_TEST);    */

        for(let particle of this.particles){
            const dataMap = particle.dataMap, color = particle.normalColorArr, scale = particle.scale,
                pointSize = [particle.pointRadius/resolution]*scale,offsetCount = Math.floor(particle.pointNum/particle.controlNum);
            particle.offsetTimes++
            const ctrlOffset = particle.offsetTimes, gravity = particle.gravity,
                inertia = particle.inertia,originPosition = particle.coordArr;
            const uniforms = {
                u_mvMatrix: viewMatrix,
                u_projMatrix: projMatrix,
                u_color: color,
                u_size: [pointSize],
                u_offsetCount:[offsetCount],
                u_ctrlOffset:[ctrlOffset],
                u_originPosition:originPosition,
                u_gravity:gravity,
                u_inertia:inertia
            };
            this.render.draw(dataMap,uniforms);
        }
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案图层。
 * @type {hmap.geosolution.GeosolutionLayer}
 * @extends hmap.layer.Layer
 */
hmap.geosolution.GeosolutionLayer=class extends hmap.layer.Layer{
    /**
     * GeosolutionLayer的构造函数。
     * @param options
     * @param {Boolean} options.static 图层的动静属性，建议将动画效果和非动画效果分canvas放置，并分别设置图层的对应动静属性。true时用于绘制非动画。默认值true。
     */
    constructor(options){
        super(options);
        this._modelData=new Map();
        options=options||{};
        this._static=options.static===false?options.static:true;//图层的动静属性，建议将动画效果和非动画效果分canvas放置，并分别设置图层的对应动静属性
        this.enableHashCode=options.enableHashCode?options.enableHashCode:false;//是否拾取
    }

    /**
     * 图层类型（拾取使用）
     * @return {string}
     * @private
     */
    getLayerType(){
        return "hmap.layer.GeosolutionLayer";
    }

    /**
     * 与图层挂接
     * @param _map
     * @private
     */
    setMap(_map){
        super.setMap(_map);
        //添加container（即GL的设置）。因重绘和基类存在差异，无调用resize接口，故初始化时进行设置。如果不设置，hmap初始化代码中canvas.height和canvas.width为300*500（即无canvas高度和宽度设置的默认值）
        this.container.height=this.container.clientHeight;
        this.container.width=this.container.clientWidth;
        this.gl.viewport(0,0,this.container.width,this.container.height);
        this._checkLost();
        this._mapUnit=this._map.getCrs().getUnit();//指米还是度
        this._srid=this._map.getCrs().getSrid();//指坐标系标识，是900913还是4326
    }

    /**
     * 添加MathModel到layer
     * @param {hmap.geosolution.math.MathModel} mathModel 数学模型对象
     */
    addMathModel(mathModel){
        if(!this.gl){
            throw Error("Please add this layer to map first!");
        }
        if(!(mathModel instanceof hmap.geosolution.math.MathModel)){
            throw TypeError("Parameter must be a type of hmap.geosolution.math.MathModel!");
        }
        if(!mathModel.isRenderable()){
            mathModel._initRenderOpts(this.gl,{isRTE:this._isRTE,mapUnit:this._mapUnit,srid:this._srid});
        }
        this._modelData.set(mathModel._id,mathModel);
        mathModel._setMap(this._map);
    }

    /**
     * 根据MathModel的唯一标识符获取MathModel对象
     * @param {String} id 添加到layer上MathModel对象的唯一标识符
     * @returns {hmap.geosolution.math.MathModel} 具体的MathModel对象
     */
    getMathModelById(id){
        return this._modelData.get(id);
    }

    /**
     * 根据MathModel的ClassName属性获取MathModel
     * @param {String} className MathModel的类名
     * @returns {Array} MathModel数组
     */
    getModelsByClassName(className){
        let models=[];
        for(const mod of this._modelData.values()){
            if(mod.CLASS_NAME===className){
                models.push(mod);
            }
        }
        return models;
    }

    /**
     * 获取layer上的所有MathModel
     * @returns {Array} MathModel数组
     */
    getAllMathModels(){
        return [...this._modelData.values()];
    }

    /**
     * 根据MathModel的唯一标识符移除layer上的MathModel对象
     * @param {String} id 添加到layer上的MathModel对象的唯一标识符
     */
    removeMathModelById(id){
        this._modelData.delete(id);
    }

    /**
     * 移除layer上的所有MathModel对象
     */
    removeAllMathModels(){
        this._modelData.clear();
    }

    redraw(){
        super.redraw();
        this._staticDraw();
        this._map.af.active();
    }
    /**
     * 图层绘制方法
     * @private
     */
    draw(){
        //单帧绘制
        this._tick();
    }

    /**
     * 静态处理
     * @private
     */
    //该方法调用mathmodel的绘制方法，会进行更新判断，如果buffer数据已更新，则需进行缓冲区数据替换
    _staticDraw(){
        const uniforms={
            u_vpMatrix:this._map.getVPMatrix(),
            u_ifRTE:this._isRTE,
            u_mvMatrix:this._map.getViewMatrix(),
            u_projMatrix:this._map.getProjMatrix(),
            u_camera:this._splitCameraPrecision(this._mapUnit),
            u_res:this._isRTE?hmap.util.Correction.float32FromDouble64(this._map.getResolution(),this._mapUint):[this._map.getResolution(),0],
            u_fogColor:this._map.getFogColor(),
            u_fogDist:this._map.getFogDist(),
            u_unit:this._mapUnit==="m"//精度修正的单位，如果是m则为1，度为0
        };
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
        //设置数据和非静态变量，然后针对存在动画的图层进行绘制
        for(const value of this._modelData.values()){
            this.activeStatusManager(this.gl);
            this.gl.flush();
            value._drawFrame(uniforms);
            this.activeStatusManager(this.gl);
            this.gl.flush();
            value._draw(uniforms);
        }
    }

    /**
     * 自调用刷新函数，存在动画时调用，为减少判断与数据刷新
     * @private
     */
    _tick(){
        window.cancelAnimationFrame(this.animateId);

        const uniforms={
            u_vpMatrix:this._map.getVPMatrix(),
            u_ifRTE:this._isRTE,
            u_mvMatrix:this._map.getViewMatrix(),
            u_projMatrix:this._map.getProjMatrix(),
            u_camera:this._splitCameraPrecision(this._mapUnit),
            u_res:this._isRTE?this._float32FromDouble64(this._map.getResolution()):[this._map.getResolution(),0],
            u_fogColor:this._map.getFogColor(),
            u_fogDist:this._map.getFogDist(),
            u_unit:this._mapUnit==="m"//精度修正的单位，如果是m则为1，度为0
        };
        for(const value of this._modelData.values()){
            this.activeStatusManager(this.gl);
            this.gl.flush();
            value._tickFrame(uniforms);
            this.activeStatusManager(this.gl);
            this.gl.flush();
            value._tick(uniforms);
        }
        if((!this.gl.isContextLost())&&(!this._static)){
            this.animateId=window.requestAnimationFrame(()=>this._layerContainer.redraw(1,true));
        }
    }

    /**
     * 处理上下文丢失事件
     * @param ev
     * @private
     */
    _handleContextLost(ev) {
        ev.preventDefault();
        cancelAnimationFrame(this.animateId);
        throw new Error("上下文丢失，请释放浏览器资源后重试！");
    }

    /**
     * 处理恢复上下文事件
     * 注：当资源有余时才会触发恢复，恢复后需要重新设置相关绘制项。注释代码是以filledCircle举例
     * @private
     */
    _handleContextRestored() {
        this._configContext();
        for(let value of this._modelData.values()){
            value._initRenderOpts(gl,{isRTE:this._isRTE,mapUnit:this._mapUnit,srid:this._srid});
        }
        this.redraw();
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 柱状图模型的组成元素。
 * @type {hmap.geosolution.cell.Bar}
 */
hmap.geosolution.cell.Bar=class{
    /**
     * Bar的构造函数。
     * @param {hmap.basetype.Coordinate} center 该Bar放置的中心点坐标，必需
     * @param {Number} value Bar代表的统计值，大于0时有效，若不提供或小于等于0，则按0处理。
     * @param {Object} options 其他设置项，可选
     * @param {hmap.style.Color} options.colorB bar底部使用的颜色，默认值为hmap.style.color(255,0,0,1)
     * @param {hmap.style.Color} options.colorT bar顶部使用的颜色，默认值为options.colorB的颜色
     * @throws 当参数类型不正确时，方法内部报错
     * @example
     * //创建barCell
     * const center=new hmap.basetype.Coordinate(120.235078, 30.19345, 0);
     * const value=100;
     * const barCell=new hmap.geosolution.cell.Bar(center,value,{
     *      colorB:new hmap.style.Color(255,200,10,1),
     *      colorT:new hmap.style.Color(0,255,20,1)
     * });
     *
     */
    constructor(center,value,options){
        this.CLASS_NAME="hmap.geosolution.cell.Bar";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._center=[center.getOrdinate("X"),center.getOrdinate("Y"),center.getOrdinate("Z")];
        this._value=value>=0?value:0;
        options=options||{};
        const color0=options.colorB?options.colorB:new hmap.style.Color(255,0,0,1);
        this._color0=color0.toNormalizeArray();//高度为0的顶点颜色
        const color1=options.colorT?options.colorT:color0;
        this._color1=color1.toNormalizeArray();//高度为1的顶点颜色
    }

    /**
     * 获取该cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 设置颜色
     * @param {hmap.style.Color} color 颜色。
     * @param {Boolean} isTop 是否是bar的顶端颜色，默认为false
     * @example
     * //设置顶部颜色
     * barCell.setColor(new hmap.style.Color(0,20,240,1),true);
     */
    setColor(color,isTop=false){
        if(isTop){
            this._color1=color.toNormalizeArray();
        }else{
            this._color0=color.toNormalizeArray();
        }
    }

    /**
     * 销毁该cell
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 电子墙模型的组成元素。
 * @type {hmap.geosolution.cell.EleWall}
 */
hmap.geosolution.cell.EleWall=class{
    /**
     * EleWall，电子墙的构造函数。
     * @param {Object}options
     * @param {hmap.basetype.CoordSeq} options.coordSeq 构建电子墙使用的坐标序列，要求构建的序列符合线的数学定义，行进正方向为逆时针。必需。
     * @param {Number} options.height 电子墙的高度，地理单位。参数大于0时有效，不提供或小于等于0时，默认使用0.01。由于精度原因，建议高度设置大于0.001。
     * @param {Number} options.cycleLength 动画周期长度，单位为米，参数大于0时有效，不提供或小于等于0时，默认使用11100。另该参数为动画使用参数，为保证效果，请重新设置！
     * @param {Number} options.amplitude 动画振幅，即正弦波的幅值。地理单位。参数大于0时有效，不提供或小于等于0时，默认使用options.height的四分之一。另该参数为动画使用参数！
     * @param {Number} options.freq 动画频率，即多少时间一个周期。毫秒。参数大于0时有效，不提供或小于等于0时，默认使用3000
     * @param {hmap.style.Color} options.colorB 底部颜色。默认值hmap.style.Color(255,0,0,1)
     * @param {hmap.style.Color} options.colorT 顶部颜色。默认值colorB
     * @param {Boolean} options.useTexture 是否使用纹理。使用纹理时，则颜色不起作用。默认值false
     * @param {Number} options.repeatNum 纹理重复次数。参数大于0时有效，不提供或小于等于0时，使用默认值1。不使用纹理时该参数不起作用！
     * @param {Image} options.image 纹理图片，Image类型。onload后传入。否则会报错。不使用纹理时，不需要设置。
     * @param {Boolean} options.isAnimation 是否开启动画，默认false。
     * @param {Number} options.density 周期插值密度。参数大于0时有效，不提供或小于等于0时，默认使用0，即不插值。建议设计动画时使用。采用周期插值的方式，密度越大，绘制动画线条的流畅性越好，但相应的内存显存占用越大，每帧耗时越长。！！显存占用超量会导致浏览器崩溃。
     * @throws 当坐标序列类型非hmap.basetype.CoordSeq或者构成坐标序列的坐标点小于2时，不进行处理
     * @example
     * let binjiangWkt = "POLYGON ((120.21646746080478  30.240118684529705, 120.23065425528966  30.188494778811048, 120.21338199298464  30.139155061157226,   120.20748257256275  30.135702441514525,  120.14282988798902  30.137828151048382, 120.12286157869892  30.158495329795699,  120.12205637610089  30.185304932077031,  120.12505495232426  30.189324343143994,  120.20871278216919  30.233002548828608,  120.21646746080478  30.240118684529705))";
     * let wkt = new hmap.format.WKT();
     * let geometry = wkt.readGeometry(binjiangWkt);
     * let coordSeq = geometry.getCoordSeqs()[0];
     * let texture=new Image();
     * texture.src="imgs/2016112000.png";
     *
     * //纹理eleWall
     * texture.onload=function(){
     *     const eleWall=new hmap.geosolution.cell.EleWall({
     *          coordSeq:coordSeq,
     *          useTexture:true,
     *          image:texture,
     *          height:0.01,
     *          repeatNum:20
     *      });
     * }
     *
     * //颜色eleWall
     * const eleWall=new hmap.geosolution.cell.EleWall({
     *      coordSeq:coordSeq,
     *      colorB:new hmap.style.Color(Math.random()*255,Math.random()*255,Math.random()*255,1),
     *      colorT:new hmap.style.Color(Math.random()*255,Math.random()*255,Math.random()*255,1),
     *      height:0.01,
     *     });
     *
     * //动画eleWall
     * const eleWall=new hmap.geosolution.cell.EleWall({
     *      coordSeq:coordSeq,
     *      colorB:new hmap.style.Color(Math.random()*255,Math.random()*255,Math.random()*255,1),,
     *      colorT:new hmap.style.Color(Math.random()*255,Math.random()*255,Math.random()*255,1),,
     *      height:0.01,
     *      isAnimation:true,
     *      cycleLength:1000,//单位为米
     *      freq:60000,
     *      density:10
     * });
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.EleWall";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        options=options||{};
        // if(!(options.coordSeq instanceof hmap.basetype.CoordSeq)||(options.coordSeq.getCoordCount()<2)){
        //     throw new TypeError("options.coordSeq must be a type of hmap.basetype.CoordSeq and greater than 2!")
        // }
        this._coordSeq=options.coordSeq instanceof hmap.basetype.CoordSeq?options.coordSeq:new hmap.basetype.CoordSeq();
        // if(this._coordSeq.getCoordCount()<2)throw new Error("coordSeq count must greater than 2!");
        this._height=options.height>0?options.height:0.01;//电子墙高度，地理单位，默认0.001
        this._cycleLength=options.cycleLength>0?options.cycleLength:11100;//动画周期长度，距离，单位为米，默认值11100
        this._amplitude=options.amplitude>0?options.amplitude:0.25*this._height;//振幅，动画参数，正弦波的幅值，地理单位
        this._freq=options.freq>0?options.freq:3000;//动画频率，即多少时间一个周期。毫秒。
        const color0=options.colorB?options.colorB:new hmap.style.Color(255,0,0,1);
        this._color0=color0.toNormalizeArray();
        const color1=options.colorT?options.colorT:color0;
        this._color1=color1.toNormalizeArray();
        this._ifTex=options.useTexture===true?options.useTexture:false;
        this._repeatNum=options.repeatNum>0?options.repeatNum:1;
        this._texture=options.image?options.image:null;
        this._isAnimation=options.isAnimation===true?1:0;//是否开启动画
        this._density=options.density>=0?options.density:0;//周期插值密度。默认为0，不进行插值。采用周期插值的方式，密度越大，绘制动画线条的流畅性越好，但相应的内存显存占用越大，每帧耗时越长
    }

    /**
     * 获取cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 根据动画周期插入坐标点,同时获取各个顶点对应的长度、使用的坐标数组
     * @param {Boolean} isRTE 是否使用精度补偿数组，默认为false，精度补偿待填入状态
     * @param {String} unit map单位
     * @param {String} srid map坐标系
     * @returns {{distances: Array<Number>, positions: Array<Number>}}
     * @private
     */
    _insertCoords(isRTE=false,unit="degrees",srid="4326"){
        const coordArr=this._coordSeq.extractCoords();
        if(coordArr.length<2)return;
        const x0=coordArr[0].getOrdinate("X"),y0=coordArr[0].getOrdinate("Y"),z0=coordArr[0].getOrdinate("Z");
        let distances=[0,0], coords=[x0,y0,z0,x0,y0,z0],distance=0;
        if (isRTE) {
            const xx = hmap.util.Correction.float32FromDouble64(x0, unit);
            const yy = hmap.util.Correction.float32FromDouble64(y0, unit);
            const zz = hmap.util.Correction.float32FromDouble64(z0, unit);
            coords = [xx[0], yy[0], zz[0], xx[1], yy[1], zz[1],xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
        }
        if(this._density===0){
            //遍历计算插值
            for(let i=1,count=coordArr.length;i<count;i++){
                const coord=coordArr[i],pre=coordArr[i-1];
                const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
                //处理当前端点
                distance+=coord.get2Dist(pre,srid);//返回单位为米
                distances.push(distance,distance);
                if(isRTE){
                    const xx = hmap.util.Correction.float32FromDouble64(x, unit);
                    const yy = hmap.util.Correction.float32FromDouble64(y, unit);
                    const zz = hmap.util.Correction.float32FromDouble64(z, unit);
                    coords.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1],xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                }else{
                    coords.push(x,y,z,x,y,z);
                }
            }
        }else{
            //计算插值长度
            const len=this._cycleLength/this._density;
            let posDist=0;
            //遍历计算插值
            for(let i=1,count=coordArr.length;i<count;i++){
                const coord=coordArr[i],pre=coordArr[i-1];
                const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
                const xP=pre.getOrdinate("X"),yP=pre.getOrdinate("Y"),zP=pre.getOrdinate("Z");
                const currentDist=coord.get2Dist(pre,srid);//返回单位为米
                const pointCount=Math.floor(currentDist/len);//计算中间的插值点数
                const xLen=x-xP,yLen=y-yP, zLen=z-zP;
                const vectorNormal=[xLen/currentDist,yLen/currentDist,zLen/currentDist];//当前坐标序列的均值向量，即当前坐标序列每个分量地理单位与米的比值关系
                if(pointCount>0){
                    //处理中间点
                    for(let j=1;j<pointCount;j++){
                        const x=xP+vectorNormal[0]*len*j,//转换为地理分量进行叠加处理
                            y=yP+vectorNormal[1]*len*j,
                            z=zP+vectorNormal[2]*len*j;
                        if(isRTE){
                            const xx = hmap.util.Correction.float32FromDouble64(x, unit);
                            const yy = hmap.util.Correction.float32FromDouble64(y, unit);
                            const zz = hmap.util.Correction.float32FromDouble64(z, unit);
                            coords.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1],xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                        }else{
                            coords.push(x,y,z,x,y,z);
                        }
                        distance+=len;
                        distances.push(distance,distance);
                    }
                }
                //处理当前端点
                distance=currentDist+posDist;
                distances.push(distance,distance);
                if (isRTE) {
                    const xx = hmap.util.Correction.float32FromDouble64(x, unit);
                    const yy = hmap.util.Correction.float32FromDouble64(y, unit);
                    const zz = hmap.util.Correction.float32FromDouble64(z, unit);
                    coords.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1],xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                } else {
                    coords.push(x,y,z,x,y,z);
                }
                posDist=distance;
            }
        }

        this.dataReady = true;      //动画基础数据准备好
        return{
            distances:distances,//长度数组
            positions:coords,
            distLast:distance//最终长度
        };
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 填充动态圆模型的组成元素。
 * @type {hmap.geosolution.cell.FilledCircle}
 */
hmap.geosolution.cell.FilledCircle=class{
    /**
     * FilledCircle 构造函数。
     * @param options
     * @param {hmap.basetype.Coordinate} options.center cell中心点坐标。默认值hmap.basetype.Coordinate(0,0,0)
     * @param {hmap.style.Color} options.color 显示颜色。默认值hmap.style.Color(255,0,0,1)
     * @param {Number} options.minSize 动画圆最小半径，像素单位。大于等于0时有效，不提供或小于0时使用默认值，默认值为1。
     * @param {Number} options.maxSize 动画圆最大半径，像素单位。大于0等于0时有效，不提供或小于0时使用默认值options.minSize
     * @param {Number} options.freq 频率。周期时间。毫秒。大于0时有效，不提供或小于等于0时使用默认值3000
     * @param {Array} options.threshold 每层圆的半径阈值。四维数组。默认值[0.20,0.40,0.60,0.80]。即以当前帧的圆半径为1，最内层圆半径比例为0.2，次外层为0.4-0.2，再次外层为0.6-0.4等
     * @example
     * let filledCricle=new hmap.geosolution.cell.FilledCircle({
     *      center:new hmap.basetype.Coordinate(120.235078,30.19345,0),
     *      color:new hmap.style.Color(255,0,0,1),
     *      minSize:0,
     *      maxSize:85,
     *      freq:3000,
     *      threshold:[0.20,0.40,0.60,0.80],//示例效果1
     *      //threshold:[0.2,0.5,0.7,1.0],//示例效果2
     * });
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.FilledCircle";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);

        const coord=options.center?options.center:new hmap.basetype.Coordinate();
        this._center=[coord.getOrdinate("X"),coord.getOrdinate("Y"),coord.getOrdinate("Z")];
        const color=options.color?options.color:new hmap.style.Color(255,0,0,1);
        this._color=color.toNormalizeArray();
        this._size=options.minSize>=0?options.minSize:1.0;//当前为半径大小
        this._maxSize=options.maxSize>0?options.maxSize:this._size;
        this._freq=options.freq>0?options.freq:3000;
        this._threshold=options.threshold?options.threshold:[0.20,0.40,0.60,0.80];
        this._startTime=null;
    }

    /**
     * 获取cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 热力图模型的组成元素。
 * @type {hmap.geosolution.cell.Heatpoint}
 */
hmap.geosolution.cell.Heatpoint=class{
    /**
     * Heatpoint，热力点的构造函数。
     * @param {hmap.basetype.Coordinate} coordinate 坐标值。必需。
     * @param {Number} value 热力点热力值。必需。
     * @throws coordinate类型不是hmap.basetype.Coordinate时，方法内部报错。
     * @throws value非数字类型或小于等于0报错
     */
    constructor(coordinate,value){
        this.CLASS_NAME="hmap.geosolution.cell.Heatpoint";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._center=[coordinate.getOrdinate("X"),coordinate.getOrdinate("Y"),coordinate.getOrdinate("Z")];
        if(!Number.isFinite(value)||value<=0){
            throw value+" must be a number that larger than 0!";
        }
        this._value=value;
    }

    /**
     * 获取cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁cell对象
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 散点图模型的组成元素。
 * @type {hmap.geosolution.cell.ScatterPoint}
 */
hmap.geosolution.cell.ScatterPoint=class{
    /**
     * ScatterPoint，散点构造函数。
     * @param options
     * @param {String} options.type 散点的类型。枚举值，包括"BubblePoint"、"BreathPoint"、"BubbleCircle"、"BreathCircle"。默认值为"BubblePoint"。
     * @param {hmap.basetype.Coordinate} options.center 散点的中心点坐标。默认值为hmap.basetype.Coordinate(0,0,0)
     * @param {Number} options.minSize 散点的直径，像素。大于等于0时有效，不提供或小于0使用默认值10.0。
     * @param {Number} options.maxSize 散点动画的最大直径，像素单位。大于等于0时有效，不提供或小于0时使用默认值options.minSize
     * @param {Number} options.freq 散点的动画更新频率，即周期时间，毫秒。大于0时有效，不提供或小于等于0时使用默认值3000。
     * @param {hmap.style.Color} options.color 散点的颜色。默认值为hmap.style.Color(255,0,0,1)。
     * @param {hmap.style.Color} options.colorChange "BubblePoint"类型散点的变化颜色，默认值等于options.color。
     * @param {Array} options.colorRange 二维向量。"BubblePoint"、"BubbleCircle"、"BreathCircle"类型散点的颜色变化区间。区间第一个值对应最小，第二值对应最大。计算方式为颜色分量与该区间值相乘。默认[1.0,0.0]。不提供或超出范围使用默认。
     * @throws 参数类型不对，对应方法运行报错
     * @example
     * let scatter=new hmap.geosolution.cell.ScatterPoint({
     *      center:new hmap.basetype.Coordinate(120.235078,30.19345,0),
     *      type:"BubblePoint",//枚举值，"BubblePoint"、"BreathPoint"、"BubbleCircle"、"BreathCircle"
     *      size:2,
     *      maxSize:20,
     *      color:new hmap.style.Color(255,0,0,1),
     *      colorChange:new hmap.style.Color(255,255,0,1),//"BubblePoint"专用
     *      colorRange:[1.0,0.0]//"BubblePoint"、"BubbleCircle"、"BreathCircle"使用
     * });
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.ScatterPoint";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);

        options=options||{};
        this._type=options.type?options.type:"BubblePoint";
        const coord=options.center?options.center:new hmap.basetype.Coordinate();
        this._center=[coord.getOrdinate("X"),coord.getOrdinate("Y"),coord.getOrdinate("Z")];
        this._size=options.minSize>=0?options.minSize:10.0;//当前直径大小（即最小的直径大小）
        this._maxSize=options.maxSize>=0?options.maxSize:this._size;
        this._freq=options.freq>0?options.freq:3000;
        const color=options.color?options.color:new hmap.style.Color(255,0,0,1);
        this._color=color.toNormalizeArray();
        const colorC=options.colorChange?options.colorChange:color;//BubblePoint专用
        this._colorC=colorC.toNormalizeArray();
        const alpha=options.colorRange?options.colorRange:[1.0,0.0];//BubblePoint、BubbleCircle、BreathCircle使用。颜色变化范围，计算方式为颜色与该参数的相乘
        this._alpha=[Math.min(alpha[0],1.0),Math.max(alpha[1],0.0)];
    }

    /**
     * 获取cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 获取内部类型
     * @param type
     * @returns {*|String}
     * @private
     */
    _getType(type){
        const typeMap={
            "BubblePoint":["bubble",0],
            "BreathPoint":["breath",0],
            "BubbleCircle":["circle",1],
            "BreathCircle":["circle",2]
        };
        return typeMap[type]||"";
    }

    /**
     * 销毁对象
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 饼状图模型的构成元素。扇形。
 * @type {hmap.geosolution.cell.Sector}
 */
hmap.geosolution.cell.Sector=class{
    /**
     * Sector，扇形的构造函数。
     * @param options
     * @param {hmap.style.Color} options.color 扇形的颜色。默认值hmap.style.Color(255,0,0,1)。
     * @param {Number} options.value 扇形代表的统计值，必需。
     * @throws options.color无参数校验，参数类型错误，方法内部报错。options.value非Number或小于等于0。
     * @example
     * let sector=new hmap.geosolution.cell.Sector({
     *      color:new hmap.style.Color(200,0,0,1),
     *      value:500,
     * });
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.Sector";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        options=options||{};
        const color=options.color?options.color:new hmap.style.Color(255,0,0,1);
        this._color=color.toNormalizeArray();
        if(!Number.isFinite(options.value)||options.value<=0){
            throw "options.value must be a number that larger than 0!";
        }
        this._value=options.value;
    //     this._valueChange=true;
    }

    /**
     * 获取唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 获取该Sector代表的统计值
     * @returns {Number} 该Sector代表的统计值
     */
    getValue(){
        return this._value;
    }

    /**
     * 设置该Sector的颜色值
     * @param {hmap.style.Color} color 颜色值
     */
    setColor(color){
        this._color=color.toNormalizeArray();
    }

    /**
     * 销毁对象
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.cell = hmap.geosolution.cell || {};
/**
 * 蝌蚪图模型的组成元素。
 * @type {hmap.geosolution.cell.Tadpole}
 */
hmap.geosolution.cell.Tadpole = class {
    /**
     * Tadpole 构造函数。
     * ！！！注：如果使用插值，插值过密，会导致浏览器崩溃。options.length、options.frameCount的关系为：每length的地理单位，插值frameCount个点。
     * @param options
     * @param {hmap.basetype.CoordSeq} options.coordSeq 坐标序列，tadpole的运行轨迹构成。必填！填错或坐标序列长度小于2报错！
     * @param {Number} options.length tadpole的长度，单位为米。大于0时有效，不提供或者小于等于0时使用默认值365。
     * @param {Number} options.frameCount 运行一个tadpole所需要的帧数。正整数，非正整数采用Math.floor处理。大于等于2时有效，小于2或不提供时采用默认值，默认值为20。
     * @param {Number} options.maxSize tadpole的起始端点直径，像素大小。大于0时有效，小于等于0或不提供时采用默认值10。
     * @param {Number} options.minSize tadpole的末尾端点直径，像素大小。大于0时有效，小于等于0或不提供时采用默认值1。
     * @param {hmap.style.Color} options.color tadpole的主体颜色。默认值hmap.style.Color(255,0,0,1)。
     * @param callBack 行至原坐标序列点的回调函数
     *
     * @example
     * let coord1 = new hmap.basetype.Coordinate(120.23,30.19,0);
     * let coord2 = new hmap.basetype.Coordinate(120.20,31.23,0);
     * let coordSeq = new hmap.basetype.CoordSeq([coord1,coord2]);
     * let tadpole=new hmap.geosolution.cell.Tadpole({
     *      coordSeq:coordSeq,
     *      length:360,//单位为米
     *      frameCount:20,
     *      maxSize:10,
     * });
     */
    constructor(options, callBack) {
        this.CLASS_NAME = "hmap.geosolution.cell.Tadpole";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        options = options || {};
        this._coordSeq = options.coordSeq instanceof hmap.basetype.CoordSeq ? options.coordSeq : new hmap.basetype.CoordSeq();
        if(this._coordSeq.getCoordCount()<2){throw "options.coordSeq was not a hmap.basetype.CoordSeq or with a count that less than 2!";}
        this._length = options.length>0 ? options.length : 365;
        this._frameCount = Math.floor(options.frameCount) >= 2? Math.floor(options.frameCount) : 20;
        // this._pointCount = options.pointCount >= 1 ? options.pointCount : 1;//因为callBack函数的问题暂时去掉。callBack函数设置为到原坐标序列点返回，但如果每帧偏移的点数不为1，多个点有可能存在偏移多个选坐标序列点的状况，不好处理。
        this._pointCount=1;
        this._maxSize = options.maxSize>0 ? options.maxSize : 10;
        this._minSize = options.minSize >0? options.minSize : 1;
        const color=options.color instanceof hmap.style.Color?options.color:new hmap.style.Color(255,0,0,1);
        this._color=color.toNormalizeArray();
        this._isActive=true;//内部使用变量，用来标识蝌蚪图的运行状态
        this._callBack = callBack;
    }

    /**
     * 获取cell的唯一标识符
     * @returns {String} 该cell的唯一标识符
     */
    getId() {
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 根据动画周期插入坐标点,同时获取各个顶点对应的长度、使用的坐标数组
     * @returns {{distances: Array<Number>, positions: Array<Number>}}
     * @private
     */
    _insertCoords(isRTE = false, unit = "degrees",srid="4326") {
        const coordArr = this._coordSeq.extractCoords();
        const x0 = coordArr[0].getOrdinate("X"), y0 = coordArr[0].getOrdinate("Y"), z0 = coordArr[0].getOrdinate("Z");
        let coords = [x0, y0, z0],
            indexMap = new Map(),//索引回调存储，键为插入序列中的索引值，value为原坐标序列中对应的索引值
            insertIndex = 0;//插入值在整个顶点数组中的索引
        if (isRTE) {
            const xx = hmap.util.Correction.float32FromDouble64(x0, unit);
            const yy = hmap.util.Correction.float32FromDouble64(y0, unit);
            const zz = hmap.util.Correction.float32FromDouble64(z0, unit);
            coords = [xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
        }
        //处理第一个顶点
        indexMap.set(insertIndex, 0);

        //计算插值长度
        const len = this._length / (this._frameCount * this._pointCount);
        //遍历计算插值
        for (let i = 1, count = coordArr.length; i < count; i++) {
            const coord = coordArr[i], pre = coordArr[i - 1];
            const x = coord.getOrdinate("X"), y = coord.getOrdinate("Y"), z = coord.getOrdinate("Z");
            const xP = pre.getOrdinate("X"), yP = pre.getOrdinate("Y"), zP = pre.getOrdinate("Z");
            const currentDist = coord.get2Dist(pre,srid);//返回地理单位为米
            const pointCount = Math.floor(currentDist / len);//计算中间的插值点数
            const xLen = x - xP, yLen = y - yP, zLen = z - zP;
            const vectorNormal = [xLen / currentDist, yLen / currentDist, zLen / currentDist];//当前坐标序列的均值向量，即当前坐标序列每个分量地理单位与米的比值关系
            if (pointCount > 0) {
                //处理中间点
                for (let j = 1; j < pointCount; j++) {
                    const x = xP + vectorNormal[0] * len * j,//转换为地理单位进行叠加处理
                        y = yP + vectorNormal[1] * len * j,
                        z = zP + vectorNormal[2] * len * j;
                    if (isRTE) {
                        const xx = hmap.util.Correction.float32FromDouble64(x, unit);
                        const yy = hmap.util.Correction.float32FromDouble64(y, unit);
                        const zz = hmap.util.Correction.float32FromDouble64(z, unit);
                        coords.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                    } else {
                        coords.push(x, y, z);
                    }
                    insertIndex+=1;
                }
            }
            //处理当前端点
            if (isRTE) {
                const xx = hmap.util.Correction.float32FromDouble64(x, unit);
                const yy = hmap.util.Correction.float32FromDouble64(y, unit);
                const zz = hmap.util.Correction.float32FromDouble64(z, unit);
                coords.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
            } else {
                coords.push(x, y, z);
            }
            insertIndex+=1;
            indexMap.set(insertIndex,i);
        }
        this.dataReady = true;      //动画基础数据准备好
        return {
            positions: coords,
            returnIndexMap:indexMap,
            count:insertIndex+1
        };
    }


    /**
     * 到达节点时运行的回调函数
     * @param data
     * @private
     */
    returnPoint(data) {
        if (typeof(this._callBack) === "function") {
            this._callBack(data);
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 可视域模型的组成元素。
 * @type {hmap.geosolution.cell.Viewshed}
 */
hmap.geosolution.cell.Viewshed=class{
    /**
     * 构造函数。
     * @param {hmap.basetype.Coordinate} position 可视域的地理坐标。
     * @param {Number} vertAngle 可视域的垂直可视角。即垂直地面方向，可视域的张角，范围为大于0度小于180度。
     * @param {Number} horiAngle 可视域的水平可视角。即平行地面方向，可视域的张角，范围为大于0度小于180度。
     * @param {Number} radius 可视域的半径。即类似四棱锥的边长。与地理单位一致。大于0。
     * @param {Array} orien 朝向。由坐标系x,y,z定义的三维向量，内部处理成单位向量使用[x,y,z]。x的正方向是向东，y的正方向是向北，z的正方向是球心指向表面的法线方向。
     * @param {hmap.style.Color} color 可视域的颜色。
     * @example
     * const location=new hmap.basetype.Coordinate(120.235078, 30.19345, 0.05);
     * const color=new hmap.style.Color(255,255,0,0.6);
     * const viewshed=new hmap.geosolution.cell.Viewshed(
     *          location,//可视域的地理坐标
     *          30,//垂直可视角
     *          50,//水平可视角
     *          0.03,//可视域半径
     *          [1,0,0],//朝向
     *          color,//颜色
     *      );
     */
    constructor(position,vertAngle,horiAngle,radius,orien,color){
        this.CLASS_NAME="hmap.geosolution.cell.Viewshed";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        if(!(position instanceof hmap.basetype.Coordinate)){
            throw "position must be the type of hmap.basetype.Coordinate!"
        }
        this._position=position;
        if(!Number.isFinite(vertAngle)||vertAngle<=0||vertAngle>=180){
            throw "vertAngle must be a number that between 0 and 180!";
        }
        this._vertAngle=vertAngle;
        if(!Number.isFinite(horiAngle)||horiAngle<=0||horiAngle>=180){
            throw "horiAngle must be a number that between 0 and 180!";
        }
        this._horiAngle=horiAngle;
        if((!Number.isFinite(radius))||radius<=0){
            throw "radius must be number and greater than 0!"
        }
        this._radius=radius;
        if(!(orien instanceof Array)||orien.length!==3){
            throw "orien must be an object of Array with 3 number!";
        }
        this._orien=orien;
        // if(!(color instanceof hmap.style.Color)){
        //     throw color+" must be a hmap.style.Color!"
        // }
        this._color=color;
        this._sidesNormal=this._calcSideLengthNomal();
        this._colorArrayNormal=this._color.toNormalizeArray();

        // if(!(sideColor instanceof hmap.style.Color)){
        //     throw sideColor+" must be a hmap.style.Color!"
        // }
        this._colorSide=this._color;
        this._colorArrayNormalS=this._colorSide.toNormalizeArray();
    }
    /**
     * 根据夹角计算可视半径为1的状态下底面矩形边长和椎体高度
     * 改变可视半径,则直接根据三角形相似计算.真实可视域模型为得到的单位数据*可视域半径
     * @private
     */
    _calcSideLengthNomal(){
        //将垂直角度转换为弧度,计算出的边长应该对应y轴的变换
        const radiaV=this._vertAngle*(Math.PI/180);

        //将水平角度转换为弧度,计算出的边长应该对应x轴的变换
        const radiaH=this._horiAngle*(Math.PI/180);
        const tanV=Math.tan(radiaV/2);
        const tanH=Math.tan(radiaH/2);
        const sq=Math.sqrt(1+tanH*tanH+tanV*tanV);
        const sideV=2*tanV/sq;
        const sideH=2*tanH/sq;
        const h=1/sq;
        //默认方向向下
        return{sideV:sideV,sideH:sideH,h:h};
    }

    /**
     * 获取可视域的唯一标识符
     * @returns {String} 标识符
     */
    getId(){
        return this._id;
    }

    /**
     * 设置可视域所在的地理坐标
     * @param {hmap.basetype.Coordinate} position 地理坐标
     * @throws 当参数position类型不对时，抛出异常
     */
    setPosition(position){
        if(!(position instanceof hmap.basetype.Coordinate)){
            throw position +" must be the type of hmap.basetype.Coordinate!"
        }
        this._position=position;
    }

    /**
     * 获取可视域所在的地理坐标
     * @returns {hmap.basetype.Coordinate} 地理坐标
     */
    getPosition(){
        return this._position;
    }

    /**
     * 设置可视域的颜色
     * @param {hmap.style.Color} color 可视域颜色值
     * @throws 当参数color的类型不对时，抛出异常。
     */
    setColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw "parameter must be a hmap.style.Color!"
        }
        this._color=color;
        this._colorArrayNormal=this._color.toNormalizeArray();
    }

    /**
     * 获取可视域的颜色
     * @returns {hmap.style.Color} 可视域的颜色
     */
    getColor(){
        return this._color;
    }

    /**
     * 设置可视域边框的颜色
     * @param {hmap.style.Color} color 可视域边框的颜色
     * @throws 当参数color的类型不对时，抛出异常。
     */
    setSideColor(color){
        if(!(color instanceof hmap.style.Color)){
            throw "parameter must be a hmap.style.Color!"
        }
        this._colorSide=color;
        this._colorArrayNormalS=this._colorSide.toNormalizeArray();
    }

    /**
     * 获取边框颜色
     * @returns {hmap.style.Color} 边框颜色
     */
    getSideColor(){
        return this._colorSide;
    }

    /**
     * 设置可视半径
     * @param {Number} radius 可视半径
     * @throws 当参数类型不对时，抛出异常
     */
    setRadius(radius){
        if(!Number.isFinite(radius)){
            throw "parameter must be number!"
        }
        this._radius=radius;
    }

    /**
     * 获取可视半径
     * @returns {Number} 返回可视半径
     */
    getRadius(){
        return this._radius;
    }

    /**
     * 设置朝向
     * @param {Array} orien 朝向
     */
    setOrien(orien){
        this._orien=orien;
    }

    /**
     * 获取朝向
     * @returns {Array} 返回朝向
     */
    getOrien(){
        return this._orien;
    }

    /**
     * 设置垂直可视角
     * @param {Number} angle 垂直可视角，范围是（0,180），不包括0和180
     * @throws 当参数值超出范围时，抛出异常
     */
    setVertAngle(angle){
        if(!Number.isFinite(angle)||angle<=0||angle>=180){
            throw angle+" must be a number that between 0 and 180!";
        }
        this._vertAngle=angle;
        this._sidesNormal=this._calcSideLengthNomal();
    }

    /**
     * 获取垂直可视角
     * @returns {Number} 垂直可视角
     */
    getVertAngle(){
        return this._vertAngle;
    }

    /**
     * 设置水平可视角
     * @param {Number} angle 水平可视角，范围是（0,180），不包括0和180
     * @throws 当参数值超出范围时，抛出异常
     */
    setHoriAngle(angle){
        if(!Number.isFinite(angle)||angle<=0||angle>=180){
            throw angle+" must be a number that between 0 and 180!";
        }
        this._horiAngle=angle;
        this._sidesNormal=this._calcSideLengthNomal();
    }

    /**
     * 获取水平可视角
     * @returns {Number} 水平可视角
     */
    getHoriAngle(){
        return this._horiAngle;
    }

    /**
     * @private
     */
    _getPositionArray(){
        return [this._position.getOrdinate("X"),this._position.getOrdinate("Y"),this._position.getOrdinate("Z")];
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell = hmap.geosolution.cell||{};
/**
 * 数学模型FillWaterModel的组成元素
 * @type {hmap.geosolution.cell.FillWater}
 */
hmap.geosolution.cell.FillWater=class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {Array<hmap.basetype.CoordSeq>} options.coordSeqs 坐标序列数组，必填项，可直接传入多边形几何的coordSeq，也可以使用坐标数组构造一个coordSeq,注意使用坐标数组构造时，需要首尾坐标相同
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.FillWater";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.coordSeqs = options.coordSeqs;                       //归一化的颜色数组
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this.data = this._triangulate(this.coordSeqs);
    }

    /**
     * 获取水填充对象的id值
     * @returns {String} 水填充对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 将坐标序列进行三角化
     * @param coordSeqs
     * @returns {Object} like:{{a_position: *, index: *, positionCount: *[], indexCount: *[]}}
     * @private
     */
    _triangulate(coordSeqs) {
        let fill_xyzs, triIndices;
        const coordData = hmap.strategy.EarCut.getCoordDataFromCoordSeq(coordSeqs);
        //因为面构造为闭合，默认最后一个点和第一个点相同，故三点一面其实为四点
        if (coordData.coordData.length === 12) {
            fill_xyzs = coordData.coordData.slice(0, 9);
            triIndices = [0, 1, 2];
        } else {
            fill_xyzs = coordData.coordData;
            triIndices = hmap.strategy.EarCut.earcut(coordData.coordData, coordData.holeIndices, 3);
        }
        return {
            a_position: fill_xyzs,
            index: triIndices,
            positionCount: [fill_xyzs.length / 3],
            indexCount: [triIndices.length]
        };
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell = hmap.geosolution.cell||{}
/**
 * 流线要素
 * @type {hmap.geosolution.cell.Flow}
 */
hmap.geosolution.cell.Flow=class{
    /**
     * 构造函数
     * @param {object} options
     * @param {hmap.basetype.CoordSeq} options.coordSeq 线动画的坐标序列，必填项
     * @param {Number} options.speed 飞行速度，单位为米/秒，默认20，取值为大于0
     * @param {Number} options.fps 每秒帧数，用于计算每帧的速度，默认30，取值为大于0
     * @param {Number} options.length 流线长度，单位为米，取值为大于0，默认50
     * @param {hmap.style.Color} options.color 流线颜色值，默认值为new hmap.style.Color(240.0, 141.0, 65.0, 1.0)
     * @param {Number} options.delay 动画延迟播放的时间，单位毫秒，取值为不小于0，默认为0，流线的时间维参数，延迟为负表示动画提前播放
     */
    constructor(options,callback){
        this.CLASS_NAME="hmap.geosolution.cell.Flow";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        /****添加需要的属性*****/
        this.coordSeq = options.coordSeq;

        this._speed = (options.speed && options.speed > 0) ? options.speed:20;

        this.fps = (options.fps && options.fps > 0) ? options.fps:30;

        this._length = (options.length && options.length > 0) ? options.length : 50;

        this._color = options.color ? options.color : new hmap.style.Color(240.0, 141.0, 65.0, 1.0);

        this.delay = options.hasOwnProperty("delay") ? options.delay : 0;

        this.dataReady = false;

        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this._initFlow();
    }

    /**
     * 计算流线的绘制数据
     * @private
     */
    processData(srid){
        const coordsArray = this.coordsArray,
            frameSpeed = this._speed/this.fps, length = this._length, color = this.normalColors;
        const selfFrameSum = Math.ceil(length/frameSpeed);              //一根流线总的长度
        let positions=[], colors=[], prevFrameNums=[], currFrameNums=[], nextFrameNums=[],
            offsetPerFrames=[], frameSum = 0, drawPointNum=0;
        for(let i=1;i<coordsArray.length;i++){
            let curCoords = coordsArray[i], prevCoords=coordsArray[i-1];
            positions.push([prevCoords.getOrdinate("X"),prevCoords.getOrdinate("Y"),prevCoords.getOrdinate("Z")]);
            positions.push([curCoords.getOrdinate("X"),curCoords.getOrdinate("Y"),curCoords.getOrdinate("Z")]);
            colors.push(...color);colors.push(...color);
            let frameNum = Math.ceil(curCoords.get3Dist(prevCoords,srid)/frameSpeed);
            prevFrameNums.push(frameSum);prevFrameNums.push(frameSum);
            currFrameNums.push(frameSum);
            frameSum += frameNum;
            currFrameNums.push(frameSum);
            nextFrameNums.push(frameSum);nextFrameNums.push(frameSum);
            const offsetArray = [(curCoords.getOrdinate("X") - prevCoords.getOrdinate("X"))/frameNum,
                (curCoords.getOrdinate("Y") - prevCoords.getOrdinate("Y"))/frameNum,
                (curCoords.getOrdinate("Z") - prevCoords.getOrdinate("Z"))/frameNum];
            offsetPerFrames.push(...offsetArray);offsetPerFrames.push(...offsetArray);
            drawPointNum+=2;
        }
        let selfFrameSums = new Array(drawPointNum).fill(selfFrameSum),
            routeFrameSums = new Array(drawPointNum).fill(frameSum);
        this.drawPointNum = drawPointNum;
        this.data = {
            positions:positions,
            colors:colors,
            prevFrameNums:prevFrameNums,
            currFrameNums:currFrameNums,
            nextFrameNums:nextFrameNums,
            routeFrameSums:routeFrameSums,
            selfFrameSums:selfFrameSums,
            offsetPerFrames:offsetPerFrames,
        }
        this.dataReady = true;
    }

    /**
     * 初始化流线要素的属性
     * @private
     */
    _initFlow(){
        if(!(this.coordSeq instanceof hmap.basetype.CoordSeq)){
            throw TypeError("coordSeq format must be hmap.basetype.CoordSeq!");
        }
        if(this.coordSeq.getCoordCount() < 2){
            throw "coordinates count after simplify must more than 1";
        }
        this.coordsArray = this.coordSeq.extractCoords();

        if(!(this._color instanceof hmap.style.Color)){
            throw TypeError("format of parameter 'color' must be hmap.style.Color!");
        }
        const colorArr = this._color.toArray();
        this.normalColors = [colorArr[0]/255, colorArr[1]/255, colorArr[2]/255, colorArr[3]];

        this.frameDelay = this.delay * this.fps/1000;
    }

    /**
     * 获取id
     * @returns {Number} 一个流线的id
     * @example
     * let plId = flow.getId();
     */
    getId(){
        return this._id;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell = hmap.geosolution.cell||{};
/**
 * 粒子组成点，点主要移动组成规律的图形
 * @type {hmap.geosolution.cell.ParticleMover}
 * @private
 */
hmap.geosolution.cell.ParticleMover=class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {Array} options.coordArr 坐标点数组
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.ParticleMover";
        this.position = options.coordArr;
        this.velocity = this.position;
        this.acceleration = [0, 0, 0];
        this.speed = 0;                             //粒子运动速度，默认为0
        this.inertiaForce = [0, 0, 0];              //物体惯性运动
        this.isActive = false;
    }

    /**
     * 回到初始化状态
     * @private
     * */
    init(position){
        this.velocity = this.position = position;
        this.acceleration = [0, 0, 0];
    }

    /**
     * 更新位置点
     * @private
     * */
    updatePosition() {
        let prevVelocity = this.velocity, prevAcceleration = this.acceleration;
        this.velocity = [prevVelocity[0]+prevAcceleration[0], prevVelocity[1]+prevAcceleration[1], prevVelocity[2]+prevAcceleration[2]];
        this.position = this.velocity;
    }


    /**
     * 叠加一个增量以驱动
     * @private
     * */
    applyForce(position){
        let prev = this.acceleration;
        this.acceleration = [prev[0]+position[0], prev[1]+position[1], prev[2]+position[2]];
    }

    /**
     * 叠加一个增量以驱动
     * @private
     * */
    applyInertia(){
        let prev = this.velocity, inertiaForce = this.inertiaForce;
        this.velocity = [prev[0]+inertiaForce[0], prev[1]+inertiaForce[1], prev[2]+inertiaForce[2]];
    }

    /**
     *  禁用粒子
     *  @private
     * */
    inactivate(){
        this.isActive = false;
    }

    /**
     * 激活粒子
     * @private
     * */
    activate(){
        this.isActive = true;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell=hmap.geosolution.cell||{};
/**
 * 数学模型ParticleModel的组成元素-通用类，自身具有惯性，受重力(或升力)影响，暂时忽略空气阻力，用来构建烟、火、喷水等效果
 * @type {hmap.geosolution.cell.Particle}
 */
hmap.geosolution.cell.Particle = class{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.coordinate  粒子起点
     * @param {hmap.basetype.Coordinate} options.destination 粒子终点，火、烟等没有粒子终点
     * @param {Array} options.inertia 粒子每帧在xyz方向上的惯性，默认为[0,0,0]，烟、火等自身没有惯性；设置时参照火焰惯性[0.0, 0.0, 0.06]左右，如果粒子有destination，则此项自动计算
     * @param {Array} options.gravity 粒子每帧在xyz方向上所受的外力加速度，默认为[0,0,0]，gravity[2]为负表示粒子受重力影响，为正则表示粒子受上升力影响，设置时参照重力为[0.0, 0.0, -0.005]左右
     * @param {hmap.style.Color} options.color 粒子颜色，粒子和粒子之间颜色使用加法混合
     * @param {Number} options.pointRadius 粒子半径，取值为大于0，默认值为1，参数设置不在预设范围自动取默认值，单位米
     * @param {Number} options.maxHeight 粒子显示的最大高度，单位米，超过此高度粒子不显示，暂未使用
     * @param {Number} options.minHeight 粒子显示的最小高度，单位米，低于此高度粒子不显示，暂未使用
     * @param {Number} options.pointNum 粒子总的数量，取值为大于0的整数，默认值为100，参数设置不在预设范围自动取默认值
     * @param {Number} options.controlNum 粒子一次发射的数量，取值为大于0的整数，默认值为2，参数设置不在预设范围自动取默认值，用来控制粒子流动的速度
     * @param {Array} options.forceScale 粒子每帧运动在xyz方向上的偏移比例，默认[1,1,1]，参数表示xyz方向上的偏移分量
     * @param {Number} options.scale 和预设的比例，默认为1，取值为大于0，参数设置不在预设范围自动取默认值
     */
    constructor(options={}){
        this.CLASS_NAME="hmap.geosolution.cell.Particle";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.coordinate = options.coordinate;
        this.destination = options.destination;
        this.inertia = options.inertia ? options.inertia:[0,0,0];
        this.gravity = options.gravity ? options.gravity:[0,0,0];
        this.color = options.color;
        this.pointRadius = (options.pointRadius && options.pointRadius > 0) ? options.pointRadius : 1;
        this.maxHeight = options.maxHeight;
        this.minHeight = options.minHeight;
        this.pointNum = (options.pointNum && options.pointNum > 0) ? options.pointNum : 100;
        this.controlNum = (options.controlNum && options.controlNum > 0)? options.controlNum : 2;
        this.forceScale = options.forceScale ? options.forceScale:[1,1,1];
        this.scale = (options.hasOwnProperty("scale") && options.scale > 0) ? options.scale:1;

        this.offsetTimes = 0;                        //偏移次数
        this.movers = [];                            //保存全部粒子
        this.resetByUnit = false;
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        this._initParticleParam();
        this._initMover();
        this._initDataMap();
    }

    /**
     * 计算需要绘制的数据
     * @private
     * */
    _initDataMap(){
        const positions = [], originForce=[], offsetIndex=[];
        let movers = this.movers;
        for(let mover of movers){
            positions.push(...mover.position);
            originForce.push(...mover.initForce);
            offsetIndex.push(mover.offsetIndex);
        }
        this.dataMap = {
            positions:positions,
            originForce:originForce,
            offsetIndex:offsetIndex
        }
    }


    /**
     * 根据地图单位重新调整参数
     * */
    resetByMapUnit(mapUnit){
        let unitPerMeter = 1;
        if(mapUnit == "degrees"){
            unitPerMeter = 1/((Math.PI*6378137*2)/360);
        }else{
            let meterPerUnit = ((Math.PI*6378137*2)/360);
            let originForces = this.dataMap.originForce;        //计算的结果为米
            for(let i=0;i<originForces.length/3;i++){
                originForces[3*i] *= meterPerUnit;
                originForces[3*i+1] *= meterPerUnit;
                originForces[3*i+2] *= meterPerUnit;
            }
        }
        this.pointRadius *= unitPerMeter;this.maxHeight *= unitPerMeter;this.minHeight *= unitPerMeter;
        this.gravity[0] *= unitPerMeter;this.gravity[1] *= unitPerMeter;this.gravity[2] *= unitPerMeter;
        if(!this.destination){
            this.inertia[0] *= unitPerMeter;this.inertia[1] *= unitPerMeter;this.inertia[2] *= unitPerMeter;
        }else{
            const coordinate = this.coordinate,desCoordinate = this.destination;
            let length_x = desCoordinate.getOrdinate("X") - coordinate.getOrdinate("X"),
                length_y = desCoordinate.getOrdinate("Y") - coordinate.getOrdinate("Y");
            const pointNum = this.pointNum, controlNum = this.controlNum;
            let times = Math.floor(pointNum/controlNum),sourceZ = coordinate.getOrdinate("Z"),
                destinationZ = desCoordinate.getOrdinate("Z"), minusZ = destinationZ - sourceZ;
            const gravityZ = this.gravity[2];
            let v = (minusZ*unitPerMeter - gravityZ*times*times/2)/times;            //重力方向的惯性速度
            this.inertia = [length_x/times, length_y/times, v];         //计算惯性作用
        }
        this.resetByUnit = true;        //根据单位设置
    }

    /**
     * 初始化粒子的参数，包括惯性力、地球引力等
     * @private
     * */
    _initParticleParam(){
        const scale = this.scale;
        // this.pointRadius *= unitPerMeter;this.maxHeight *= unitPerMeter;this.minHeight *= unitPerMeter;
        // this.gravity[0] *= unitPerMeter;this.gravity[1] *= unitPerMeter;this.gravity[2] *= unitPerMeter;
        const coordinate = this.coordinate,desCoordinate = this.destination;
        if(!desCoordinate){
            this.gravity[0] *= scale;this.gravity[1] *= scale;this.gravity[2] *= scale;
            this.inertia[0] *= scale;this.inertia[1] *= scale;this.inertia[2] *= scale;
        }else{
            let length_x = desCoordinate.getOrdinate("X") - coordinate.getOrdinate("X"),
                length_y = desCoordinate.getOrdinate("Y") - coordinate.getOrdinate("Y");
            const pointNum = this.pointNum, controlNum = this.controlNum;
            let times = Math.floor(pointNum/controlNum),sourceZ = coordinate.getOrdinate("Z"),
                destinationZ = desCoordinate.getOrdinate("Z"), minusZ = destinationZ - sourceZ;
            const gravityZ = this.gravity[2];
            let v = (minusZ - gravityZ*times*times/2)/times;            //重力方向的惯性速度
            this.inertia = [length_x/times, length_y/times, v];         //计算惯性作用
        }
        this.coordArr = [coordinate.getOrdinate("X"), coordinate.getOrdinate("Y"), coordinate.getOrdinate("Z")];
        const colorArr = this.color.toArray();
        this.normalColorArr = [colorArr[0]/255, colorArr[1]/255, colorArr[2]/255, colorArr[3]];         //归一化颜色数组
    }

    /**
     * 初始化所有的粒子移动点，和随机的偏移速度
     * @private
     * */
    _initMover(){
        let scale=this.scale, forceScale = this.forceScale;
        if(this.destination) scale=1;
        for (let i = 0; i < this.pointNum; i++) {
            const mover = new hmap.geosolution.cell.ParticleMover({
                coordArr:this.coordArr
            });
            this.movers.push(mover);

            const rad1 = this._getRadian(Math.log(this._getRandomInt(200, 256)) / Math.log(256) * 270);
            const rad2 = this._getRadian(this._getRandomInt(0, 360));
            const force = this._getSpherical(rad1, rad2, 0.000015);           //在单位球的一片区域获取随机的点，作为初始偏移量
            mover.initForce = [force[0]*forceScale[0]*scale, force[1]*forceScale[1]*scale, (force[0]+force[1])*0.5*forceScale[2]*scale];
            mover.offsetIndex = Math.floor(i/this.controlNum);
        }
    }

    /**
     * 在min和max之间 生成随机值
     * @returns {Number} min和max之间的随机值
     * @private
     * */
    _getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }

    /**
     * 弧度转为度数
     * @returns {Number} 弧度对应的度数值
     * @private
     * */
    _getDegree(radian) {
        return radian / Math.PI * 180;
    }

    /**
     * 度数转化为弧度
     * @returns {Number} 度数对应的弧度
     * @private
     * */
    _getRadian(degrees) {
        return degrees * Math.PI / 180;
    }

    /**
     * 在球面上随机的一片区域获取坐标，作为初始的偏移量
     * @returns {Array} 偏移量在x、y、z方向上的分量
     * @private
     * */
    _getSpherical(rad1, rad2, r) {
        const x = Math.cos(rad1) * Math.cos(rad2) * r;
        const y = Math.cos(rad1) * Math.sin(rad2) * r;
        const z = Math.sin(rad1) * r;
        return [x, y, z];
    }

    /**
     * 获取粒子对象的id值
     * @returns {String} id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell = hmap.geosolution.cell||{};
/**
 * 数学模型ParticleModel的组成元素-火焰
 * @type {hmap.geosolution.cell.Fire}
 * @extends hmap.geosolution.cell.Particle
 */
hmap.geosolution.cell.Fire = class extends hmap.geosolution.cell.Particle{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.coordinate  粒子点坐标
     * @param {Number} options.scale 和预设的比例，取值为大于0，默认为1，参数设置不在预设范围自动取默认值
     * @param {Number} options.maxHeight 粒子显示的最大高度，单位米，超过此高度粒子不显示，暂未启用
     * @param {Number} options.minHeight 粒子显示的最小高度，单位米，低于此高度粒子不显示，暂未启用
     */
    constructor(options={}){
        const particleOpts = {
            coordinate: options.coordinate,
            destination: null,
            inertia: [0,0,0],
            gravity: [0.0, 0.0, 0.02],
            color: new hmap.style.Color(255,102,51,1.0),
            pointRadius: 10,
            maxHeight: options.maxHeight,
            minHeight: options.minHeight,
            pointNum: 100,
            controlNum: 2,
            forceScale: [0.6,0.6,0],
            scale: (options.hasOwnProperty("scale") && options.scale > 0) ? options.scale:1
        };
        super(particleOpts);
        this.CLASS_NAME="hmap.geosolution.cell.Fire";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        
        this.offsetTimes = 0;                        //偏移次数
        this.movers = [];                            //保存全部粒子
    }

    /**
     * 获取'粒子火焰'对象的id值
     * @returns {String} '粒子火焰'对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 数学模型ParticleModel的组成元素-烟
 * @type {hmap.geosolution.cell.Smoke}
 * @extends hmap.geosolution.cell.Particle
 */
hmap.geosolution.cell.Smoke = class extends hmap.geosolution.cell.Particle{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.coordinate  粒子起点
     * @param {Number} options.scale 和预设的比例，取值为大于0，默认为1，参数设置不在预设范围自动取默认值
     * @param {Number} options.maxHeight 粒子显示的最大高度，单位米，超过此高度粒子不显示，暂未使用
     * @param {Number} options.minHeight 粒子显示的最小高度，单位米，低于此高度粒子不显示，暂未使用
     */
    constructor(options={}){
        const particleOpts = {
            coordinate: options.coordinate,
            destination: null,
            inertia: [0,0,0],
            gravity: [0.0, 0.0, 0.06],
            color: new hmap.style.Color(40,40,40,1.0),
            pointRadius:40,
            maxHeight: options.maxHeight,
            minHeight: options.minHeight,
            pointNum: 180,
            controlNum: 2,
            forceScale: [2.0,2.0,0],
            scale:(options.hasOwnProperty("scale") && options.scale > 0) ? options.scale:1
        };
        super(particleOpts);
        this.CLASS_NAME="hmap.geosolution.cell.Smoke";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        this.offsetTimes = 0;                           //偏移次数
        this.movers = [];                              //保存全部粒子
    }

    /**
     * 获取'粒子烟'对象的id值
     * @returns {String} '粒子烟'对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 数学模型ParticleModel的组成元素-喷水
 * @type {hmap.geosolution.cell.OutFire}
 * @extends hmap.geosolution.cell.Particle
 */
hmap.geosolution.cell.OutFire = class extends hmap.geosolution.cell.Particle{
    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.Coordinate} options.coordinate  粒子起点
     * @param {hmap.basetype.Coordinate} options.destination 粒子终点，火、烟等没有粒子终点
     * @param {Number} options.scale 粒子和预设的比例，取值为大于0，默认为2，参数设置不在预设范围自动取默认值
     * @param {Number} options.maxHeight 粒子显示的最大高度，单位米，超过此高度粒子不显示，暂未启用
     * @param {Number} options.minHeight 粒子显示的最小高度，单位米，低于此高度粒子不显示，暂未启用
     */
    constructor(options={}){
        const particleOpts = {
            coordinate: options.coordinate,
            destination: options.destination,
            inertia: [0,0,0],
            gravity: [0.0, 0.0, -0.005],
            color: new hmap.style.Color(174,220,226,1.0),
            pointRadius: 2,
            maxHeight: options.maxHeight,
            minHeight: options.minHeight,
            pointNum: 1000,
            controlNum: 5,
            forceScale: [0.2,0.2,0.2],
            scale:(options.hasOwnProperty("scale") && options.scale > 0) ? options.scale:2
        };
        super(particleOpts);
        this.CLASS_NAME="hmap.geosolution.cell.OutFire";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        this.offsetTimes = 0;                        //偏移次数
        this.movers = [];                            //保存全部粒子
    }

    /**
     * 获取灭火对象的id值
     * @returns {String} 灭火对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.cell = hmap.geosolution.cell||{};
/**
 * 数学模型TrailModel的组成元素
 * @type {hmap.geosolution.cell.Trail}
 */
hmap.geosolution.cell.Trail=class{

    /**
     * 构造函数
     * @param {Object} options
     * @param {hmap.basetype.CoordSeq} options.coordSeq 坐标序列，必需项，支持坐标中的高度值，但是暂不支持完全垂直的线
     * @param {String} options.symbolSrc 线纹理图标的路径，必需项
     * @param {Number} options.lineWidth 线宽，单位像素，默认为10，取值范围为大于0，否则按默认值处理
     * @param {hmap.style.Color} options.lineColor 线颜色，默认为new hmap.style.Color(255,0,0,1)
     * @param {Boolean} options.useAlpha 是否只使用纹理的透明度值，而不使用纹理的rgb值，默认为false
     * @param {Boolean} options.repeat 线纹理是否重复放置，默认为true，若为false，placeSpace设置值无效，暂未启用
     * @param {Number} options.placeLength 图标放置的长度，单位像素，默认为20，取值范围为大于0，否则按默认值处理
     * @param {Number} options.placeSpace 图标放置的间隔长度，单位像素，默认为20，取值范围为不小于0，否则按默认值处理
     * @param {Boolean} options.showLine 是否显示基础路线，默认为true
     * @param {Boolean} options.isAnimate 是否需要纹理偏移动画，默认为true
     * @param {Number} options.speed 纹理偏移速度，默认为5；速度值为0时，纹理不会偏移，速度值为100时，当前纹理会偏移到下个纹理，完整覆盖下个纹理，在视觉上表现为纹理静止；100为一个轮回，速度值101的视觉效果与1相同
     */
    constructor(options){
        this.CLASS_NAME="hmap.geosolution.cell.Trail";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);            //自动生成
        /****添加需要的属性*****/
        this.coordSeq = options.coordSeq;                                //坐标序列
        this.lineWidth = (options.lineWidth && options.lineWidth > 0) ? options.lineWidth : 10;              //线宽，默认为10px
        this.lineColor = options.lineColor ? options.lineColor : new hmap.style.Color(255,0,0,1);              //线宽，默认为10px
        this.symbolSrc = options.symbolSrc;                                       //符号图标路径
        this.useAlpha = options.hasOwnProperty("useAlpha") ? options.useAlpha : false;
        this.repeat = options.hasOwnProperty("repeat") ? options.repeat:true;     //默认重复放置
        this.placeLength = (options.hasOwnProperty("placeLength") && options.placeLength > 0) ? options.placeLength:20;          //放置的长度，单位像素
        this.placeSpace = (options.hasOwnProperty("placeSpace") && options.placeSpace >= 0) ? options.placeSpace:20;             //放置间隔，单位像素
        this.showLine = options.hasOwnProperty("showLine") ? options.showLine : true;                       //是否显示基础线
        this.isAnimate = options.hasOwnProperty("isAnimate") ? options.isAnimate : true;                    //是否偏移动画，默认true
        this.speed = options.hasOwnProperty("speed") ? options.speed : 5;                     //偏移速度
        this.uvOffset = 0.0;                //纹理偏移
        this.dataReady = false;
        this._init();
    }

    /**
     * 初始化
     * @private
     */
    _init(){
        if(!(this.symbolSrc)){
            throw TypeError("parameter 'symbolSrc' must be given!");
        }
        if(!(this.coordSeq instanceof hmap.basetype.CoordSeq)){
            throw TypeError("parameter 'coordSeq' format must be hmap.basetype.CoordSeq!");
        }
        if(this.coordSeq.getCoordCount() < 2){
            throw RangeError("coordinates count of coordSeq must more than 1");
        }
        let coords = this.coordSeq.extractCoords();
        if(coords.length > 2){
            coords = this._getSmoothCoords(coords);     //原始的坐标需要平滑处理
        }
        this.positions = this._coordsToXYZs(coords);

        if(!(this.lineColor instanceof hmap.style.Color)){
            throw TypeError("format of parameter 'lineColor' must be hmap.style.Color!");
        }
        const colorArr = this.lineColor.toArray();
        this.colorArr = [colorArr[0]/255, colorArr[1]/255, colorArr[2]/255, colorArr[3]];
    }

    /**
     * 将坐标数组转化为绘制所需要的顶点数据，两份顶点
     * @param {Array<hmap.basetype.Coordinate>} coords 坐标数组
     * @returns {Array} xyzs
     * @private
     */
    _coordsToXYZs(coords) {
        let xyzs = [];
        for(let i=0;i<coords.length;i++){
            const coord = coords[i];
            const x = coord.getOrdinate("X"), y =  coord.getOrdinate("Y"), z = coord.getOrdinate("Z");
            xyzs.push(x, y, z);
            xyzs.push(x, y, z);
        }
        return xyzs;
    }

    /**
     * 对坐标进行平滑处理，并对z值进行处理
     * @private
     */
    _getSmoothCoords(coordArr){
        const output = [];
        output.push(coordArr[0]);
        for(let i=1;i<coordArr.length-1;i++){
            let prevCoord = coordArr[i-1],currCoord = coordArr[i],nextCoord=coordArr[i+1];
            const prevZ = prevCoord.getOrdinate("Z"), curZ = currCoord.getOrdinate("Z"), nextZ = nextCoord.getOrdinate("Z");
            if(!(hmap.strategy.Topology.checkCollinear(prevCoord, nextCoord, currCoord) === 0)){            //三点不共线
                let point1 = new hmap.geom.Point(new hmap.basetype.Coordinate(currCoord.getOrdinate("X")-(currCoord.getOrdinate("X")-prevCoord.getOrdinate("X"))*0.1,currCoord.getOrdinate("Y")-(currCoord.getOrdinate("Y")-prevCoord.getOrdinate("Y"))*0.1,currCoord.getOrdinate("Z")-(currCoord.getOrdinate("Z")-prevCoord.getOrdinate("Z"))*0.1));
                let point2 = new hmap.geom.Point(currCoord);
                let point3 = new hmap.geom.Point(new hmap.basetype.Coordinate(currCoord.getOrdinate("X")+(nextCoord.getOrdinate("X")-currCoord.getOrdinate("X"))*0.1,currCoord.getOrdinate("Y")+(nextCoord.getOrdinate("Y")-currCoord.getOrdinate("Y"))*0.1,currCoord.getOrdinate("Z")+(nextCoord.getOrdinate("Z")-currCoord.getOrdinate("Z"))*0.1));
                let bezier = new hmap.geomext.BezierCurve2([point1,point2,point3],10);
                let coords = bezier.getCoordSeq().extractCoords();
                for(let j=0;j<6;j++){
                    let coord = coords[j];
                    coord.setOrdinate("Z",prevZ + 0.9*(curZ-prevZ) + 0.1*(curZ-prevZ)*(j+1)/6)
                }
                for(let j=0;j<6;j++){
                    let coord = coords[j+6];
                    coord.setOrdinate("Z",curZ + 0.1*(nextZ-curZ)*j/6)
                }
                output.push(...coords);
            }else{
                output.push(currCoord);
            }
        }
        output.push(coordArr[coordArr.length-1]);
        return output;
    }

    /**
     * 获取线纹理动画对象的id值
     * @returns {String} 线纹理动画对象的id值
     */
    getId(){
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 比较a位置和b位置的position是否相等
     * @private
     */
    compareV3( a, b ) {
        let aa = a * 6, ab = b * 6;
        return ( this.positions[ aa ] === this.positions[ ab ] ) && ( this.positions[ aa + 1 ] === this.positions[ ab + 1 ] ) && ( this.positions[ aa + 2 ] === this.positions[ ab + 2 ] );
    }

    /**
     * 获取指定位置的position的x、y、z
     * @private
     */
    copyV3( a ) {
        let aa = a * 6;
        return [ this.positions[ aa ], this.positions[ aa + 1 ], this.positions[ aa + 2 ] ];
    }

    // if (this._isRTE) {
    //     const xx = hmap.util.Correction.float32FromDouble64(xyzPosition[0], this._mapUnit);
    //     const yy = hmap.util.Correction.float32FromDouble64(xyzPosition[1], this._mapUnit);
    //     const zz = hmap.util.Correction.float32FromDouble64(xyzPosition[2], this._mapUnit);
    //     positions.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
    // } else {
    //     positions.push(xyzPosition[0], xyzPosition[1], xyzPosition[2]);
    // }
    /**
     * 处理宽线绘制数据
     * @private
     */
    processData(isRTE, mapUnit) {
        let l = this.positions.length / 6;

        this.previous = [], this.next = [], this.side = [], this.width = [],
            this.indices = [], this.uvs = [];         //前个点

        for( let j = 0; j < l; j++ ) {
            this.side.push( 1 );
            this.side.push( -1 );
        }

        let w = 1;
        for( let j = 0; j < l; j++ ) {
            this.width.push( w );
            this.width.push( w );
        }

        let v;
        if( this.compareV3( 0, l - 1 ) ){
            v = this.copyV3( l - 2 );
        } else {
            v = this.copyV3( 0 );
        }
        this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
        this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
        for( let j = 0; j < l - 1; j++ ) {
            v = this.copyV3( j );
            this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
            this.previous.push( v[ 0 ], v[ 1 ], v[ 2 ] );
        }

        for( let j = 1; j < l; j++ ) {
            v = this.copyV3( j );
            this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
            this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
        }

        if( this.compareV3( l - 1, 0 ) ){
            v = this.copyV3( 1 );
        } else {
            v = this.copyV3( l - 1 );
        }
        this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );
        this.next.push( v[ 0 ], v[ 1 ], v[ 2 ] );

        for( let j = 0; j < l - 1; j++ ) {
            let n = j * 2;
            this.indices.push( n, n + 1, n + 2 );
            this.indices.push( n + 2, n + 1, n + 3 );
        }

        let distance = 0;
        for( let j = 0; j < l; j++ ) {
            let preX = this.previous[j*6], prevY = this.previous[j*6+1], prevZ = this.previous[j*6+2];
            let currX = this.positions[j*6], currY = this.positions[j*6+1], currZ = this.positions[j*6+2];
            distance += Math.sqrt((preX-currX)*(preX-currX) + (prevY-currY)*(prevY-currY) + (prevZ-currZ)*(prevZ-currZ));
            this.uvs.push( distance, 0 );
            this.uvs.push( distance, 1 );
        }
        if(isRTE){
            this.positions = this._translateTo64(this.positions, mapUnit);
            this.previous = this._translateTo64(this.previous, mapUnit);
            this.next = this._translateTo64(this.next, mapUnit);
        }
        this.dataMap = {
            positions: this.positions,
            previous: this.previous,
            next: this.next,
            side: this.side,
            width: this.width,
            uvs: this.uvs,
            indices: this.indices,
            symbolSrc:this.symbolSrc
        }
        this.dataReady = true;
    }

    _translateTo64(positions,mapUnit){
        const positionCount = positions.length/3;
        const output=[];
        for(let i=0;i<positionCount;i++){
            const xx = hmap.util.Correction.float32FromDouble64(positions[3*i], mapUnit);
            const yy = hmap.util.Correction.float32FromDouble64(positions[3*i+1], mapUnit);
            const zz = hmap.util.Correction.float32FromDouble64(positions[3*i+2], mapUnit);
            output.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
        }
        return output;
    }
};
;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.cell = hmap.geosolution.cell || {};
/**
 * 数学模型RainModel的组成元素
 * @type {hmap.geosolution.cell.Rain}
 */
hmap.geosolution.cell.Rain = class {
    /**
     * 构造函数
     * @param {hmap.geom.Polygon} area 下雨的地理区域，面装几何体，必填项
     * @param {Object} options
     * @param {Number} options.rainLevel 雨量级别（1-6） 1、小雨 2、中雨 3、大雨 4、暴雨 5、大暴雨 6、特大暴雨,默认值为1
     * @param {Number} options.height 云层高度,正数，单位为米，默认10000米

     * @param {hmap.style.Color} options.color 雨滴颜色，默认为new hmap.style.Color(153,153,153,1)
     */
    constructor(area, options={}) {
        this.CLASS_NAME = "hmap.geosolution.cell.Rain";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        if (!(area && area instanceof hmap.geom.Polygon)) {
            throw new Error('area must be a hmap.geom.Polygon!');
        }
        this._area = area;
        /****添加需要的属性*****/
        switch (options.rainLevel) {
            case 1:
                this._divide = 40;
                this._rainSize = 2;
                break;
            case 2:
                this._divide = 50;
                this._rainSize = 2;
                break;
            case 3:
                this._divide = 60;
                this._rainSize = 2;
                break;
            case 4:
                this._divide = 70;
                this._rainSize = 3;
                break;
            case 5:
                this._divide = 80;
                this._rainSize = 3;
                break;
            case 6:
                this._divide = 100;
                this._rainSize = 3;
                break;
            default:
                this._divide = 40;
                this._rainSize = 2;
                break;
        }
        if (options.height!==undefined &&(!Number.isFinite(options.height)||options.height<=0)) {
            throw new Error('options.height must be a positive number!');
        }
        this._height = (options.height!==undefined ? options.height : 10000) / 110000;
        
        if (options.color && !(options.color instanceof hmap.style.Color)) {
            throw new Error('options.color must be type of hmap.style.Color!');
        }
        this._factor = 1;   //
        this._color = options.color ? options.color : new hmap.style.Color(153, 153, 153, 1);
    }


    /**
     * 获取对象的id值
     * @returns {String} 对象的id值
     */
    getId() {
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 根据下雨地理范围获取着色器需要的数据
     * @private
     */
    _initVertex() {
        const area = this._area;
        let fill_xyzs = [],
            arrIndex = [],
            timeDelayArr = [],
            rainSizes=[],
            speeds=[],
            colors=[],
            index = 0;
        const areaExtent = area.getExtent();
        const left = areaExtent.getLeft();
        const bottom = areaExtent.getBottom();
        const right = areaExtent.getRight();
        const top = areaExtent.getTop();
        const divideX = (right - left) / this._divide;
        const divideY = (top - bottom) / this._divide;
        for (let i = 0; i < this._divide; i++) {
            for (let j = 0; j < this._divide; j++) {
                //打乱雨点
                const random = Math.random();
                let tempX, tempY;
                if (random > 0.5) {
                    tempX = -1 * Math.random();
                    tempY = Math.random();
                } else {
                    tempX = Math.random();
                    tempY = -1 * Math.random();
                }
                const x = (0.5 * (1 + tempX) + i) * divideX + left;
                const y = (0.5 * (1 + tempY) + j) * divideY + bottom;
                const coord = new hmap.basetype.Coordinate(x, y, 0);
                if (this._area.intersectsCoordinate(coord)) {
                    fill_xyzs.push(x, y, this._height*this._factor);
                    colors.push(...this._color.toNormalizeArray());
                    
                    arrIndex.push(Math.floor((i + 1) * (j + 1) * Math.random())); //保证地图缩放的时候筛选出来的点比较均匀
                    const rainSize = Math.round((Math.random() + 1) * this._rainSize);
                    const speed = ((rainSize - 1) * 0.8 + 1) / 110000*this._factor;
                    rainSizes.push(rainSize); //保证雨点大小的随机性
                    speeds.push(speed);
                    timeDelayArr.push(10 * Math.random()); //给每个雨点一个延时，使雨点不是同时下落
                }
            }
        }
        Object.assign(this, {
            a_position: fill_xyzs,
            a_number: arrIndex,
            a_timeDelay: timeDelayArr,
            a_size: rainSizes,
            a_speed:speeds,
            a_color: colors,
            positionCount: [fill_xyzs.length / 3],
            u_initRes: this._initRes,
        })
    }

    /**
     * 设置承载特效的map对象
     * @param {hmap.Map} map map对象
     * @private
     */
    _setMap(map) {
        this._map = map;
        this._initRes = map.getResolution();
        if (this._map && this._map.getCrs().getSrid() === "3857") {
            this._factor = 110000;
        } else {

        }
    }
};
;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.cell = hmap.geosolution.cell || {};
/**
 * 数学模型SnowModel的组成元素
 * @type {hmap.geosolution.cell.Snow}
 */
hmap.geosolution.cell.Snow = class {
    /**
     * 构造函数
     * @param {hmap.geom.Polygon} area 下雪的地理区域，面状几何体，必填项
     * @param {Object} options
     * @param {Number} options.snowLevel 降雪级别（1-6） 1、小雪 2、中雪 3、大雪 4、暴雪 5、大暴雪 6、特大暴雪,默认为1
     * @param {Number} options.height 云层高度,正数，单位为米,默认10000米
     * @param {String} options.imageSrc 纹理图片路径 
     * @example
         snow = new hmap.geosolution.cell.Snow(area);
         snowModel.addMathCell(snow);
         snowModel.updateDrawData();
         geoLayer.redraw();
     */
    constructor(area, options = {}) {
        this.CLASS_NAME = "hmap.geosolution.cell.Snow";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        if (!(area && area instanceof hmap.geom.Polygon)) {
            throw new Error('area must be a hmap.geom.Polygon!');
        }
        this._area = area;
        if (options.snowLevel!=undefined && (!/^\d+$/.test(options.snowLevel) || options.snowLevel < 1 || options.snowLevel > 6)) {
            throw new Error('options.snowLevel must be integer between 1 and 6!');
        }
        switch (options.snowLevel) {
            case 1:
                this._snowSize = 0.8;
                this._bestSnowDis = 0.005;
                break;
            case 2:
                this._snowSize = 0.8;
                this._bestSnowDis = 0.004;
                break;
            case 3:
                this._snowSize = 1;
                this._bestSnowDis = 0.004;
                break;
            case 4:
                this._snowSize = 1.2;
                this._bestSnowDis = 0.004;
                break;
            case 5:
                this._snowSize = 1.3;
                this._bestSnowDis = 0.004;
                break;
            case 6:
                this._snowSize = 1.5;
                this._bestSnowDis = 0.004;
                break;
            default:
                this._snowSize = 0.8;
                this._bestSnowDis = 0.005;
                break;
        }

        if (options.height != undefined && (!Number.isFinite(options.height) || options.height <= 0)) {
            throw new Error('options.height must be a positive number!');
        }
        this._height = (options.height !== undefined ? options.height : 10000) / 110000;
        this._speed = 2 - this._snowSize; //雪片越小速度越大

        //默认的纹理
        const imgSrc = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTUtMDctMDNUMTg6NTk6MjIrMDI6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTAxLTEyVDE1OjE0OjQwKzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTAxLTEyVDE1OjE0OjQwKzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmIzMzBlMWI0LTk5ZDctNGU2NS05MGQ2LTNmYjFiYmE2ZTE0MCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjAyNThjNzMxLTQ4ZjQtYTA0MS1hNGFkLTQ4MTA2MTVjY2FlYSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjJjY2VkMTUyLTRjNzAtNDFlZC1hMzcyLWRlOWY4NjgyZTcwMSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MmNjZWQxNTItNGM3MC00MWVkLWEzNzItZGU5Zjg2ODJlNzAxIiBzdEV2dDp3aGVuPSIyMDE1LTA3LTAzVDE4OjU5OjIyKzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjMzMGUxYjQtOTlkNy00ZTY1LTkwZDYtM2ZiMWJiYTZlMTQwIiBzdEV2dDp3aGVuPSIyMDE5LTAxLTEyVDE1OjE0OjQwKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz50mbqsAAAToElEQVR4nOVbW49dR5X+VlXtc2v3Ne52N6bTTnAc0u02GRJQwEhYQkJ5QhmhPPOUl0iBB/4AP4JfMA95IEIaJEYiQhlesCZMEE1iGxJHIjK21XbSwX1xd5+zd9Va87BrVdfefWwI4xEaUVJpn7PPPnVqfbUu31pVh0QE/8zN/KMn8I9uTl+8+uqrAAARgYgghIBer4dnnnkGAPDFL34RANDr9eiJJ55AVVUgIhhjwMwYDAbY3Nyk8+fPP/DHdnd3ZWtrS6y1ICICACLCtWvXxDmH2dlZXL9+HR988AF6vR5mZmawvb2Nw8NDeO+xt7eHpaUlDAYDTE5O4vvf/z7OnTuH1157DR9++CGICNvb2zh58iTubG7iwrP/gvmz61iZG2B5aQG/+e93MDExgW9/+9vHAcgbEWFvbw+Tk5O0uLiIEydOyPnz52lychL9fj89BgD7+/s0MTGh4KT749rU1JRMTU3p22R7y8vL2N3dTWPs7e3JnTt3sLW1BWvtAwF9FK0BQFwUfPLJJ5ibm8Mrr7yiGqCmkgtHZVni4OCAJiYmCAAiEA0AmBlEpGPnDoez1wqMrK2tydraGr333nu4evUqfv/730tZluh2u405PqqWABgOhwCAnZ0dLCws4Ec/+hGdOnUqf5ZEhA4ODtDr9chaS51OB/Pz84QjoRsA6bjOOel0OknY7HMBgL/85S8yGo1kYWEB1loCIBcuXMCFCxdkfX2dNjY25J133sH9+/chIo8UhATA5z//eRweHmJxcRHf+973iIioqioURaGTNQBQlqWJq2GYGWVZUq/XGwcCAVCTkUxg7UDUgtnZWd7e3hZmhrVWkGnH+vo61tfX8eUvfxlvvPGG3Lx5E8vLy8hM6dEA0Ov1MBwO8eKLL+Lpp5/GRx99hLm5ORXGACAiotnZWROFIQDGGJNee+8hIlQURVqibLUku2pnAEJEZnZ2VoXmDKwExPnz57G8vIxf/epXuHXrlnz88ccoyxLe+/+VRiQA7t+/j+npaaytrREAeuKJJ/SjXGACQCEEIyLGOWc6nQ6h1gZTVZWJqv6g8MoAwMwiImyt5UxQ7TlIlIMwPT2Nl156SXZ3d+nKlSuoqkq2t7f/buEbADjncOnSJXrssceAphorABARC8CIiBERKyI2hGCcc0REptPpGGttDhhCCClc5gKKSC50qKqKrbVsjMnvqzbw7u6uMDPNzMzw1NSUXLx4ET/5yU/o5s2b8t5772E0GmFycvIz+4gEwNmzZ/H0008DqD33cDikfr9vNFwDMGVZWmutcc5ZAE5EbDQBS0QqvEF0mAAoCq5NALAxRlqCBmstExEDCLHrZwIgFEUhckRbBQBefvllAYC3334bV65ckY2NDezv738mEBIA3nuMRiOgVmfa39+nbrdL0SsbAKbT6Zi46tZaa4nIEpGN49j4nI2AkYiYLAQmAFQoACwiLCKBiAIRBQA+jqNgMADq9/v63mZjAABeeOEFvPDCC3Tt2jV5/fXX5U9/+hMI+Js4RFoe51yK1c45zM/P58ITAENExtRL6mIvAHS0i0iXmbsAekTUN8b0AfRFpA+gD2AQez+79gD0RETH6cZrkf1GfjUP6FhbW6Mf/OAHeOmll6jb7WBrawvAw7lD0oAzZ86gFfeBzNtrZ2Zna2gLEXFRAwpmLuJnyT+ISMQr+ZTc+wcAuvIetUlV8bVFUxNyZxiy9/l4BAALCwvmu9/9rpxZWaH/evs3Mqw8HpbvJQDW19d1xfPeBsEyswVQeO+dtdZZa9NqWWsLAI6IHOoQaVpjHQMgdi8iPgJQReHzbgFU2ULo9/JQmfMLPPf881j/0pfk3376H9gyI6ycXnw4ALOzs+lmCIEODg7oxIkThohoOBxSp9MxRGSdczZGA0tEBWpNKIwxHX0dx3XRB+QAAE0foDbviaiKwBVRWO3Wex9ql0MBzbAcsnFzcAFAOkVBFy88hW63J1UIGJf6JwCuXLmC9fV1AIAxBv1+H0QEESEiMsxs1NMTke10OiqkE5GO2rAxJtksERkRMaj9R1sLfJysB1CFEEpjjGqA+hiDWrPK+H3ViFxLc2eZTEHbM6trAIB3331XNOEaC8DCwoK+JCKCc47ia1Lq2+oWtboXRFREALpxzA4Ruegj9FnDzDDGCABmZjbGqPqXOFr5Ml5HqE2uin6mxFGk0V4B4LIsiYh8pO05yBxCECLC4uIiXbp0SbJstgnA3t5e7gTbbrNBf9sgKBCoTSBFBUSugMgTAGiMlizmewClMcYDGMXvlxHUMgpeZgInrhEB9Vm48/GawuSNGzdodnYWp06dEu89QsitJgMgQ08R1FhOIQTKihgkIoaZrTEm8QARSUCISBf1ihbRri1iGG0BwKjtvxOFdHoVERdC0N8wkVjlpqTFG2nFe5/P//Tp0+JcLeb169dxeHiI55577jgAjz/+OFqt7TFyDSBmJiIyquIRgEJVH7UZFDiK3xoZdPICgDOvn6/2iIg03ObEikSEtAoVgcznKXF+6V6321VtoNXVVezs7DTkSkRoc3OzDUAtde0PGmSCiKgoCiIiik6uZkiRJEWG6IhInWNXRHpE1ENNfnJSNJFdJwBMiMgEgAkiGhCRPt8D0DPGdBVcZi7UxHDcR7XDOLz3+POf/9yQb5wT1C8pomNbCAHMTDE85TTYoqUJiOaAOpHK9VWjQRE5gM3GyHMKAIAxRqQOS0xE4pxrpMwA2HtvALA68Vwea60sLy+PB+Djjz/G5z73OZ1UTiqkqiohImFmFEUhRCTGmLzUlTcTBVWTKBBXTBki1U1/i1E7N/UVyi5T0RS1xQgza/1gXBrNcXyOmsg4YpLQsbz3qRLVAGB+fr4tCLz3IiKKtMQQJnEwtb8crBQ6lT/ESSQHSURKpAT1CodoLho2rSZRugAikjLFzHmGOG6izhlXaZOvJPTJkyePrRYAIBYWGiqvzEmFNcao0ByLGg1NyX8w8w+5eeRa0RWRDhF1Ee0bNY9QX6G9LyI9EenGZ/NESbsFoKm6EREzGo00cjR8wc7OTgOApAFxdRt1u6IokpqJCHvvWfN2XRGuwwFnK5OnqkkTMmflEHlBZgYBRyGONFTGz5jqBCnPFRwAx8zqcBt+AwBFx50zRgFAw+FQpqenjwNw9+5ddLtdnDhxQifV6MwsRMTGGGHmRkEjqjFHVU3fia9T+IwTUpMw2cRyz60rlhMl1ZqCmQuKeUO09UTTs/HbJqBNBoNB40YygY2NDezt7Y35Tj0Zay0751hEQqSwqefvY4Ejd1LqM6B5QeyaMjsR0SQq74lRRqKkxKqgZhGmHQa1RjkWhHY+kDTga1/7mjrCdtUWcSD23jMRBWttyuSIqBIRVVEPwBtjqgyMoGGrsRS1o1M75YzhtWlyyjjj1ajKM7OlukjTSOOJKGe2DSBipEstacCPf/xjvPnmm405olV0cM6FWMkNAEIIIYhIEJHAzIGIfLRXBScvdXE0k6QRes1UN88xbKYx6mWrm8Nr1jEbb399vvE8a8Morr2Bubi53hNpUCwxqLQjW2hALGAFHK14BqJi5QqYZCkh8VkFgHK16Hu/y0Jm/TnZtjEkFV2amGgP6mwuhmhdoSxrQ6XRw69YtfPjhh+3vNKo41tpUxnLOqVfOe+L0+WfRcWnxI2lF5i8Sr49JzrjKlIKUkyS9Nljj39oSHLdu3UJZlpiammonFzqohiolJKmaE4X0AKpcG3CU4alj03Q2D1mIgqUQqpEk4yH6TEPAfMVzkhaf1Wca9733yFsC4Jvf/Ga6eePGDSwuLkq3202/EEKQw8ND7vV6wTmXfIBGgBBCZa11RKQakKe4eVZIOMrwEAE1aDo/NRENs6nFvcNxPckOQEII4r3XLfvU2u+PbWHdvXsXP/vZz2R3d7fxAzEfYOeclrG8McZHx1dZa0sAlYhUrUKG9rFmgjHmgiONUocaiEjB5pgWJFDGACHOOXQ6nXYyJwcHB40bSQM0PpZlia9//esgInz66acYDAbS7/el1+vl5WldIR9XXusBlYJgrS2ZeRR5foFY4oo/Rzji+GoOwBG3aFSGc0eqYTUDpr2VxiIiVVVJBKABTntXOQGwsbEBoK4MTUxM4Nq1a7DWyurqKvr9fu4LGltaWtcjokRViaiUowqRFk+1LKarwkQUYgKUp98hRo9cEyoc+Z1kJpnwDUGJSLfZj7XLv/41Ln7jG8cBmJycTDe99xgMBlhZWUG/34fm4DiqtugkTFTHYK2toqClMSavE+bbZg0AolAujoM6fxI1sWQ6GSBKuJR7sDGGiYhDCJwla+N8BUQERcssEgBxXzA1IsL169fhvcezzz6LmZkZnTRQU01NjnRlQlx93cRQB5gXRY8BEEHLa4XJDESkAlBGv6J8Q/1OCHWFs60NHBM0oeaxHGEAZ7/61YacCYCvfOUrjQ9iLAZQcwS9rVctkuS0GEf5uZawx5WqdEWUHCnLUwKWA1ACGBljSmYu0XSMPv42I+4469hVVYlzTjIzEABg7/Hrt97Cd1588TgA4zYNFIiDgwM5efJkftyFu92u7tLoVpWPk05cHc0ymTo6TaN1T1ALIMeywBhSRwoCjkeJPClLGhALoTrXpPLGGLlw7lxDvgRAe8Mgb4PBIP88IT0cDrkoimCt1ZS0kqPydc7rc9Kjds5RrS0zK/UFjtih0ulSREaoQ+UIx0NqDkR7w7ThBzY2NrC7u4szTz752QBotYRop9PRukBgZmOtJWOMCSFUmqigWZBIDjSuvgPgjDGavipzy80qlcrRigo4rgFt4dN8RQR5IeQYABcvXnygxLdv38Zrr72GH/7wh3myxNnWNzvngvfeOOd8FttV7TXuCx1thzf2CzIfoOww3x3OQVBfkK9+mws0vP/W1pZcv35dTp48ibm5ufEA6GnPdhMRTExMYHJyMs4/edbGigKgeERGdz8aiUx0qoIsj4j5fHKCUu9Cae0x8QvUkaCt+rkW5IXSvEwuADA3N4fnn38eRVEc2yEmvfHHP/5xLAAKAhHh3LlzjTMEIQQ3Go3MYDAwAFw8M2BjbE9VHIm7x3HnuMg+y2uFjb2ILBwGHGmAR51yj1DvJ+q9HBzVCjUlvnfvnty4cUO0SLK2tpZkSxqwsrIyVngiSsddx5y5YWOMbjhyzA2AOlevgNrzxqKHZAXUEFmj8oMcAAUhX1HPzJUxplK2GULwqJmor6qKY54iQE3kdnd3OdY35He/+51cvnwZExMTMMY0AEga0CZCbRC89/DeY2pqKs/TDQA6PDw0uolpjLHOOcfMzntvnXPOGFOISBFCKGLG6Jg5rw6bPM9HdogiRgT1GxUze135yBBLLcyo1ohIqKqKO51OKMtS3n//fckLJhcuXDiuAXfu3HkgAABweHiYb5/lbI76/T6JCO/s7ICIMD09jbhzlJe2OdJXZ611xpik+sxsRUTNqyYtzcqzRoQQt9FTPTKEkMryMV1nItJECKPRCH/4wx/SHmcbgKQB77777kMBUAR7vR594QtfQLb3ljRBRCiGQ43tNhNU9wotxd0hZrbWWqrLCibXAM0/NGNMSVCoz+h5730wxngR8cwcnHNp1XHkA0RE+ODgoOH5coefNODnP//5QwGg+GeElZUVefLJJ8fVDYmISP0EM0sIAd1ut6EFEQwTQtBTZCYSKZWfdOs7jpMSHsSSnF5jPpCKJ51Oh9vz8t5ja2urUTMcC4Cex39Y63Q6WFlZQVEUcu/ePep2uxgMBnmWqBrBzjndUzQAJO7aSqwm6Va60mATQtATH3k0yLM6RvQJ6khRO0dmZv2cEfnGaDSSbreLoihQVRVCCGMPTuZbY38VAGstiqLAaDTC66+/Lt/61rf0rzQPqiKnvQU9GxTvKwB65s9E+0x1/QwEHVMTHXbOcfQFbK1VX5GYX1mWuH37NpaXl2l3d5eXl5cfeGp07F9mHtaICGVZYjAYYGZmRgDQaDSSoijywmQuHEUA8tp/ewsrnUkOIehefg5AIl5RzVPPs8DsGTlz5oxYa+XevXu4c+dOntHiXJYQfWYA1Jacc7r7Im+++SZWV1fp7NmzOlktn7XBUHJCIQRDddxUUqUHq5MGVFUFAIibtOrUhJnVNDi7z3fv3hURkaWlpWQ6Tz311EPl+cwAjGvRxnS1xjrI1n0ajUbinCNdGf2vQQyFABqHnZMmhBAkaiADkMPDQ4n/cJPhcIj5+Xl1nvj3n/4UB/v7ODEx0ZjQv7788qMFoNPppBj76aefyi9+8QssLS3JpUuXKNt2b+QGg8EgrzNSr9djzQi1jTlqj+hcARz9+cJ7D+ecnDlzJiVABwcH0GNxh/H/UOPaIwEgb/fv38fVq1fbyVVuy5RdtVGkrzQzM/Mwhyzta/Y7aZE/+ugj/Odbb8n0zAzmTp1CfbJmfHvkADjnMDMzg8ceewzGGNnf38fly5fp9OnTknNwNEEQay2mpqbaf7Bot3alV8a9/u1vfytXr13D6uoqyrJ86Hz/euz7O5uivr29jV/+8peyubmZx/Njh5xiMjMutz/WfVXxzs4O7+zsyL1792R/f78RBRYWFjA5OYm4OXKs5+2Ra0C7OeewsLCA+F+kvKUVGw6H2Nzc1Pxh7DiBGT0iWXr8cbp5+zY+eP99mZ6exsHBAZaWlrC6upqefZjKt1vKBf5Z2/+ZCfx/af8DTo8DJZHbJ6cAAAAASUVORK5CYII=';
        this._imageSrc = options.imageSrc || imgSrc;
        this._texturePromise = this._loadImg();
    }

    /**
     * 纹理加载promise
     * @private
     */
    _loadImg() {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = function () {
                this._textureImage = img;
                resolve(this);
            }.bind(this);
            img.src = this._imageSrc;
        })
    }

    

    /**
     * 获取对象的id值
     * @returns {String} 对象的id值
     */
    getId() {
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 根据下雪的地理范围和地图分辨率获取着色器需要的顶点数据
     * @private
     */
    _calculateVertex() {
        const area = this._area;
        let positions = [],
            timeDelayArr = [],
            rotation = [], //每朵雪花在xyz方向上的旋转
            speed = [], //每朵雪花在xyz方向上的速度
            size = []; //每朵雪花的大小
        const areaExtent = area.getExtent();
        const left = areaExtent.getLeft();
        const bottom = areaExtent.getBottom();
        const right = areaExtent.getRight();
        const top = areaExtent.getTop();
        const snowDis = this._bestSnowDis;
        const divideX = (right - left) / snowDis;
        const divideY = (top - bottom) / snowDis;

        for (let i = 0; i < divideX; i++) {
            for (let j = 0; j < divideY; j++) {
                //打乱顶点，弱化网格效果
                const random = Math.random();
                let tempX, tempY;
                if (random > 0.5) {
                    tempX = -1 * Math.random();
                    tempY = Math.random();
                } else {
                    tempX = Math.random();
                    tempY = -1 * Math.random();
                }
                const x = (0.5 * (1 + tempX) + i) * snowDis + left;
                const y = (0.5 * (1 + tempY) + j) * snowDis + bottom;
                const coord = new hmap.basetype.Coordinate(x, y, 0);
                if (area.intersectsCoordinate(coord)) {
                    positions.push(x, y, this._height);
                    size.push(Math.round((Math.random() + 1) * this._snowSize)); //保证雪点大小的随机性
                    timeDelayArr.push(10 * Math.random()); //给每个雪点一个延时，使雪点不是同时下落,
                    rotation.push(
                        Math.random() * 2 * Math.PI,
                        Math.random() * 2,
                        Math.random() * 2
                    );
                    speed.push(
                        (1 + Math.random()),
                        (1 + Math.random()),
                        (Math.random() + 1) * this._speed
                    );
                }
            }
        }
        Object.assign(this, {
            a_position: positions,
            a_timeDelay: timeDelayArr,
            a_size: size,
            a_speed: speed,
            a_rotation: rotation,
        })
    }

    /**
     * 设置承载特效的map对象
     * @param {hmap.Map} map map对象
     * @private
     */
    _setMap(map) {
        this._map = map;
        if (this._map && this._map.getCrs().getSrid() === "3857") {
            this._bestSnowDis *= 110000;
            this._height *= 110000;
            this._speed *= 110000;
            this._snowSize*=110000;
        }
    }
};
/**
 * 风向在东西向和南北向的分量
 */
hmap.geosolution.cell.Wind = {
    EAST: {
        ewWind: -1,
        nsWind: 0
    },
    SOUTH: {
        ewWind: 0,
        nsWind: 1
    },
    WEST: {
        ewWind: 1,
        nsWind: 0
    },
    NORTH: {
        ewWind: 0,
        nsWind: -1
    },
    EAST_SOUTH: {
        ewWind: -1,
        nsWind: 1
    },
    WEST_SOUTH: {
        ewWind: 1,
        nsWind: 1
    },
    EAST_NORTH: {
        ewWind: -1,
        nsWind: -1
    },
    WEST_NORTH: {
        ewWind: 1,
        nsWind: -1
    }
};
/**
 * 风向枚举值
 */
hmap.geosolution.cell.WindDirect = {
    EAST: "EAST",
    SOUTH: "SOUTH",
    WEST: "WEST",
    NORTH: "NORTH",
    EAST_SOUTH: "EAST_SOUTH",
    WEST_SOUTH: "WEST_SOUTH",
    EAST_NORTH: "EAST_NORTH",
    WEST_NORTH: "WEST_NORTH"
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.cell = hmap.geosolution.cell || {};
/**
 * 数学模型GridHeatModel的组成元素
 * @type {hmap.geosolution.cell.GridHeat}
 */
hmap.geosolution.cell.GridHeat = class {
    /**
     * 构造函数
     * @param {hmap.basetype.CoordSeq} coordSeq 热力图的数据源，其中坐标序列中的坐标必须带有count属性,构造坐标实例的时候直接将count挂在对象上
     * @param {Number} gridSize 网格大小，单位为地图单位，必须为正数
     * @param {Array<hmap.style.Color>} colorArr 颜色段
     * @param {Object} options
     * @param {Number} options.gridSpace 选填项，网格间隔跟网格大小的比例，取值必须在0-1之间,间隔越大，网格越小，默认0.2
     * @param {String} options.unit 地图单位，只有两个取值degrees或者mi，默认是degrees
     * @param {Number} options.miniHeight 最小高度，默认0.00001,如果柱体在地图旋转的时候出现闪烁，适当的调大该属性
     * @param {Number} options.maxHeight 最大高度，默认0.001
     */
    constructor(coordSeq, gridSize, colorArr, options) {
        this.CLASS_NAME = "hmap.geosolution.cell.GridHeat";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        if (!(coordSeq instanceof hmap.basetype.CoordSeq)) {
            throw new Error("coordSeq must be type of hmap.basetype.CoordSeq!");
        }
        this._coordseq = coordSeq;
        if (!(gridSize && Number.isFinite(gridSize) && gridSize >= 0)) {
            throw new Error("options.gridSize must be a positive number");
        }
        this._gridSize = gridSize;
        if (!(colorArr instanceof Array)) {
            throw new Error("colorArr must be a type of Array");
        } else {
            colorArr.forEach(item => {
                if (!item instanceof hmap.style.Color) {
                    throw new Error("colorArr must be a array of hmap.style.Color!");
                }
            })
        }
        this._colorArr = colorArr;
        if (options.gridSpace && (!Number.isFinite(options.gridSpace) || options.gridSpace < 0 || options.gridSpace > 1)) {
            throw new Error("options.gridSpace must be a number between 0 and 1!");
        }
        this._gridSpace = options.gridSpace !== undefined ? options.gridSpace : 0.2; //默认0.2
        this.a_position = [];
        this.a_positionH = [];
        this.a_positionL = [];
        this.a_color = [];
        this.a_indices = [];
        if (options.unit && ['mi', 'degrees'].indexOf(options.unit) === -1) {
            throw new Error('options.unit must be "mi" or "degrees"');
        }
        this._unit = options.unit || 'degrees';
        if (options.miniHeight && (!Number.isFinite(options.miniHeight) || options.miniHeight <= 0)) {
            throw new Error("options.miniHeight must be a positive number!");
        }
        this._miniHeight = options.miniHeight !== undefined ? options.miniHeight : 0.00001;

        if (options.maxHeight && (!Number.isFinite(options.maxHeight) || options.maxHeight <= 0 || options.maxHeight <= this._miniHeight)) {
            throw new Error("options.maxHeight must be a positive number greater than options.miniHeight!");
        }
        this._maxHeight = options.maxHeight !== undefined ? options.maxHeight : 0.001;

        this._gap = this._maxHeight - this._miniHeight;
    }

    /**
     * 获取对象的id值
     * @returns {String} 对象的id值
     */
    getId() {
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 顶点计算
     * @param {Number} dimension 维度
     * @param {Number} current  索引标识
     * @private
     */
    _calculateVertex(dimension,current) {
        const coordSeq = this._coordseq, gridSize = this._gridSize, unit = this._unit||"degrees";
        //采用聚合原理，只不过不是屏幕范围的聚合，而是这个coordseq的聚合
        let areaExtent = coordSeq.getExtent();
        const left = areaExtent.getLeft();
        const bottom = areaExtent.getBottom();
        let coordsIn = {};
        const len = coordSeq.getCoordCount();
        let miniCount = 0;
        let maxCount = 0;
        for (let i = 0; i < len; i++) {
            let coordCol = Math.ceil((coordSeq.getCoordinate(i)._x - left) / gridSize);
            let coordRow = Math.ceil((coordSeq.getCoordinate(i)._y - bottom) / gridSize);
            let ranks = coordRow + "-" + coordCol;
            if (!coordsIn[ranks]) {
                coordsIn[ranks] = [];
            }
            const countTemp = coordSeq.getCoordinate(i).count;
            if (i == 0) {
                miniCount = countTemp;
                maxCount = countTemp;
            }
            if (miniCount > countTemp) {
                miniCount = countTemp;
            } else if (maxCount < countTemp) {
                maxCount = countTemp;
            }
            coordsIn[ranks].push(countTemp); //统计行列号相同的点，构成数组
        }
        let lengthArr = [];
        for (let ranks in coordsIn) {
            lengthArr.push(coordsIn[ranks].reduce((a, b) => a + b));
        }
        lengthArr = Array.from(new Set(lengthArr));
        lengthArr = lengthArr.sort(function (a, b) {
            return a - b
        })
        this._segmentArr = this._getColorSegment(this._colorArr, lengthArr);
        const factor = this._gap / (maxCount - miniCount)
        //遍历所有网格
        for (let ranks in coordsIn) {
            const coorCount = coordsIn[ranks].reduce((a, b) => a + b);
            //************根据行列号相同的点数组中的元素长度，计算步长，确定热度颜色值******
            const propotionColor = this._getColor(coorCount);
            //***************根据行列号计算顶点坐标*********************
            // 一个网格对应两个三角形，六个顶点（左下，左上、右上   左上、右上、右下），一种颜色，但是为了同步三角形，也要传入两个颜色，
            const r = Number(ranks.split('-')[0]);
            const c = Number(ranks.split('-')[1]);
            let gridLeft = (c - 1) * gridSize + left - 0.5 * this._gridSpace * gridSize;
            let gridRight = gridLeft + gridSize * (1 - 0.5 * this._gridSpace);
            let gridBottom = (r - 1) * gridSize + bottom + 0.5 * this._gridSpace * gridSize;
            let gridTop = gridBottom + gridSize * (1 - 0.5 * this._gridSpace);
            let gridLeftH, gridLeftL, gridRightH, gridRightL, gridBottomH, gridBottomL, gridTopH, gridTopL;
            gridLeftH = hmap.util.Correction.float32FromDouble64(gridLeft, unit)[0];
            gridLeftL = hmap.util.Correction.float32FromDouble64(gridLeft, unit)[1];
            gridRightH = hmap.util.Correction.float32FromDouble64(gridRight, unit)[0];
            gridRightL = hmap.util.Correction.float32FromDouble64(gridRight, unit)[1];
            gridBottomH = hmap.util.Correction.float32FromDouble64(gridBottom, unit)[0];
            gridBottomL = hmap.util.Correction.float32FromDouble64(gridBottom, unit)[1];
            gridTopH = hmap.util.Correction.float32FromDouble64(gridTop, unit)[0];
            gridTopL = hmap.util.Correction.float32FromDouble64(gridTop, unit)[1];

            let num = 8; //顶点数
            if (dimension === 3) {
                const height = this._miniHeight + factor * coorCount;
                const heightH = hmap.util.Correction.float32FromDouble64(height, unit)[0];
                const heightL = hmap.util.Correction.float32FromDouble64(height, unit)[1];
                this.a_positionH.push(
                    gridRightH, gridBottomH, heightH,
                    gridLeftH, gridBottomH, heightH,
                    gridLeftH, gridBottomH, 0,
                    gridRightH, gridBottomH, 0,
                    gridRightH, gridTopH, 0,
                    gridRightH, gridTopH, heightH,
                    gridLeftH, gridTopH, heightH,
                    gridLeftH, gridTopH, 0); //8个顶点的xyz

                this.a_positionL.push(
                    gridRightL, gridBottomL, heightL,
                    gridLeftL, gridBottomL, heightL,
                    gridLeftL, gridBottomL, 0,
                    gridRightL, gridBottomL, 0,
                    gridRightL, gridTopL, 0,
                    gridRightL, gridTopL, heightL,
                    gridLeftL, gridTopL, heightL,
                    gridLeftL, gridTopL, 0); //8个顶点的xyz


                const cursor = num * current;
                this.a_indices.push(
                    cursor + 0, cursor + 1, cursor + 2, cursor + 0, cursor + 2, cursor + 3,
                    cursor + 0, cursor + 3, cursor + 4, cursor + 0, cursor + 4, cursor + 5,
                    cursor + 0, cursor + 5, cursor + 6, cursor + 0, cursor + 6, cursor + 1,
                    cursor + 7, cursor + 6, cursor + 1, cursor + 7, cursor + 1, cursor + 2,
                    cursor + 7, cursor + 2, cursor + 3, cursor + 7, cursor + 3, cursor + 4,
                    cursor + 7, cursor + 4, cursor + 5, cursor + 7, cursor + 5, cursor + 6,
                    65535);
                for (let i = 0; i < 8; i++) {
                    this.a_color.push(...propotionColor);
                }
                current++;
            } else {
                //遍历所有网格
                this.a_positionH.push(
                    gridLeftH, gridBottomH, 0,
                    gridLeftH, gridTopH, 0,
                    gridRightH, gridTopH, 0,
                    gridLeftH, gridBottomH, 0,
                    gridRightH, gridTopH, 0,
                    gridRightH, gridBottomH, 0)
                this.a_positionL.push(
                    gridLeftL, gridBottomL, 0,
                    gridLeftL, gridTopL, 0,
                    gridRightL, gridTopL, 0,
                    gridLeftL, gridBottomL, 0,
                    gridRightL, gridTopL, 0,
                    gridRightL, gridBottomL, 0)
                //2个三角形的颜色,对应6个顶点的颜色
                for (let i = 0; i < 6; i++) {
                    this.a_color.push(...propotionColor);
                }

            }
        }
        this._current = current;
    }

    /**
     * 根据颜色域、值域计算颜色分段
     * @param {Array<hmap.basetype.Color>} colorArr  颜色范围
     * @param {Array} valueArr   值范围
     * @private
     */
    _getColorSegment(colorArr, valueArr) {
        //数据分段
        const colorLen = colorArr.length;
        const valueLen = valueArr.length;
        const divideValueLen = valueLen / (colorLen - 1);
        let segmentArr = [];
        for (let i = 0; i < colorLen - 1; i++) {
            segmentArr.push({
                startColor: colorArr[i],
                endColor: colorArr[i + 1],
                valueArr: i == colorLen - 2 ? valueArr : valueArr.splice(0, divideValueLen) //最后一个段承载剩下所有的数据，因为有小数的问题
            })
        }
        return segmentArr;
    }

    /**
     * 根据当前值获取颜色形成渐变的效果
     * @param {Number} value
     * @private
     */
    _getColor(value) {
        const colorLen = this._segmentArr.length;
        for (let i = 0; i < colorLen; i++) {
            const tempSegment = this._segmentArr[i];
            const valueArr = tempSegment.valueArr;
            if (valueArr.indexOf(value) !== -1) {
                const colorMinNor = tempSegment.startColor.toNormalizeArray();
                const colorMaxNor = tempSegment.endColor.toNormalizeArray();
                const colorR = colorMaxNor[0] - colorMinNor[0];
                const colorG = colorMaxNor[1] - colorMinNor[1];
                const colorB = colorMaxNor[2] - colorMinNor[2];
                const colorA = colorMaxNor[3] - colorMinNor[3];

                const maxCount = Math.max(...valueArr),
                    minCount = Math.min(...valueArr);
                const divideR = maxCount - minCount !== 0 ? colorR / (maxCount - minCount) : 0;
                const divideG = maxCount - minCount !== 0 ? colorG / (maxCount - minCount) : 0;
                const divideB = maxCount - minCount !== 0 ? colorB / (maxCount - minCount) : 0;
                const divideA = maxCount - minCount !== 0 ? colorA / (maxCount - minCount) : 0;
                const minColorR = colorMinNor[0],
                    minColorG = colorMinNor[1],
                    minColorB = colorMinNor[2],
                    minColorA = colorMinNor[3];
                return [
                    minColorR + divideR * (value - minCount),
                    minColorG + divideG * (value - minCount),
                    minColorB + divideB * (value - minCount),
                    minColorA + divideA * (value - minCount)
                ];
            }
        }
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.cell = hmap.geosolution.cell || {};
/**
 * 数学模型蜂窝热力图的组成元素
 * @type {hmap.geosolution.cell.HexGridHeat}
 */
hmap.geosolution.cell.HexGridHeat = class {
    /**
     * 构造函数
     * @param {hmap.basetype.CoordSeq} coordSeq 热力图的数据源，其中坐标序列中的坐标必须带有count属性,构造坐标实例的时候直接将count挂在对象上
     * @param {Number} gridSize 网格大小，包括间隔，单位为地图单位，必须为正数
     * @param {Array<hmap.style.Color>} colorArr 颜色段
     * @param {Object} options 选填项
     * @param {Number} options.gridSpace 选填项，网格间隔跟网格大小的比例，取值必须在0-1之间,间隔越大，网格越小，默认0.2
     * @param {String} options.unit 地图单位，只有两个取值degrees或者mi，默认是degrees
     * @param {Number} options.miniHeight 最小高度，默认0.00001,如果柱体在地图旋转的时候出现闪烁，适当的调大该属性
     * @param {Number} options.maxHeight 最大高度，默认0.001
     */
    constructor(coordSeq, gridSize, colorArr, options) {
        this.CLASS_NAME = "hmap.geosolution.cell.HexGridHeat";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        if (!(coordSeq instanceof hmap.basetype.CoordSeq)) {
            throw new Error("coordSeq must be type of hmap.basetype.CoordSeq!");
        }
        this._coordseq = coordSeq;
        if (gridSize < 0) {
            throw new Error("options.gridSize must be a positive number!");
        }
        this._gridSize = gridSize;
        if (!(colorArr instanceof Array)) {
            throw new Error("colorArr must be a type of Array");
        } else {
            colorArr.forEach(item => {
                if (!item instanceof hmap.style.Color) {
                    throw new Error("colorArr must be a array of hmap.style.Color!");
                }
            })
        }
        this._colorArr = colorArr;
        if (options.gridSpace && (!Number.isFinite(options.gridSpace) || options.gridSpace < 0 || options.gridSpace > 1)) {
            throw new Error("options.gridSpace must be a number between 0 and 1!");
        }
        this._gridSpace = options.gridSpace !== undefined ? options.gridSpace : 0.2; //默认0.2
        

        this.a_position = [];
        this.a_positionH = [];
        this.a_positionL = [];
        this.a_color = [];
        this.a_indices = [];
        if (options.unit && ['mi', 'degrees'].indexOf(options.unit) === -1) {
            throw new Error('options.unit must be "mi" or "degrees"');
        }
        this._unit = options.unit || 'degrees';
        if (options.miniHeight && (!Number.isFinite(options.miniHeight) || options.miniHeight <= 0)) {
            throw new Error("options.miniHeight must be a positive number!");
        }
        this._miniHeight = options.miniHeight !== undefined ? options.miniHeight : 0.00001;

        if (options.maxHeight && (!Number.isFinite(options.maxHeight) || options.maxHeight <= 0 || options.maxHeight <= this._miniHeight)) {
            throw new Error("options.maxHeight must be a positive number greater than options.miniHeight!");
        }
        this._maxHeight = options.maxHeight !== undefined ? options.maxHeight : 0.001;

        this._gap = this._maxHeight - this._miniHeight;
    }

    /**
     * 获取对象的id值
     * @returns {String} 对象的id值
     */
    getId() {
        return this._id;
    }

    /**
     * 销毁对象
     */
    destroy() {
        let names = Object.getOwnPropertyNames(this);
        for (let i = 0, len = names.length; i < len; i++) {
            const name = names[i];
            this[name] = null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 顶点计算
     * @param {Number} dimension 维度
     * @param {Number} current  索引标识
     * @private
     */
    _calculateVertex(dimension,current) {
        console.log(current);
        const coordSeq = this._coordseq, gridSize = this._gridSize, unit = this._unit||"degrees";
        //采用聚合原理，只不过不是屏幕范围的聚合，而是这个coordseq的聚合
        const areaExtent = coordSeq.getExtent();
        const left = areaExtent.getLeft();
        const bottom = areaExtent.getBottom();
        const coordsIn = {};
        const _2SIN60 = Math.pow(3, 0.5);
        const len = coordSeq.getCoordCount();
        let miniCount = 0;
        let maxCount = 0;
        for (let i = 0; i < len; i++) {
            const coordCol = Math.ceil((coordSeq.getCoordinate(i)._x - left) / (gridSize * _2SIN60));
            const coordRow = Math.ceil((coordSeq.getCoordinate(i)._y - bottom) / (gridSize * 1.5));
            const ranks = coordRow + "-" + coordCol;
            if (!coordsIn[ranks]) {
                coordsIn[ranks] = [];
            }
            const countTemp = coordSeq.getCoordinate(i).count;
            if (i == 0) {
                miniCount = countTemp;
                maxCount = countTemp;
            }
            if (miniCount > countTemp) {
                miniCount = countTemp;
            } else if (maxCount < countTemp) {
                maxCount = countTemp;
            }
            coordsIn[ranks].push(countTemp); //统计行列号相同的点，构成数组
        }

        let lengthArr = [];
        for (let ranks in coordsIn) {
            lengthArr.push(coordsIn[ranks].reduce((a, b) => a + b));
        }
        lengthArr = Array.from(new Set(lengthArr));
        lengthArr = lengthArr.sort(function (a, b) {
            return a - b
        })
        this._segmentArr = this._getColorSegment(this._colorArr, lengthArr)
        const times = 1 - 0.5 * this._gridSpace;
        /**计算顶点 */
        const factor = this._gap/ (maxCount - miniCount)
        for (let ranks in coordsIn) {
            const coorCount = coordsIn[ranks].reduce((a, b) => a + b);
            const height = this._miniHeight + factor * coorCount;
            //************根据行列号相同的点数组中的元素长度，计算步长，确定热度颜色值******
            const propotionColor = this._getColor(coorCount);

            //***************根据行列号计算顶点坐标*********************
            // 一个网格对应两个三角形，六个顶点（左下，左上、右上   左上、右上、右下），一种颜色，但是为了同步三角形，也要传入两个颜色，
            const r = Number(ranks.split('-')[0]);
            const c = Number(ranks.split('-')[1]);

            //行号为偶数的，整体右移0.5*_2SIN60*gridSize
            let gridLeft, verticalCenter, gridRight, gridBottom, horizontal1, horizontalCenter, horizontal2,
                gridTop;
            let gridLeftH, verticalCenterH, gridRightH, gridBottomH, horizontal1H, horizontal2H,
                gridTopH;
            let gridLeftL, verticalCenterL, gridRightL, gridBottomL, horizontal1L, horizontal2L,
                gridTopL;
            if (r % 2 == 1) {
                gridLeft = (c - 1) * gridSize * _2SIN60 + left - 0.5 * this._gridSpace * gridSize;
                verticalCenter = gridLeft + 0.5 * gridSize * times * _2SIN60;
                gridRight = verticalCenter + 0.5 * gridSize * times * _2SIN60;
            } else {
                gridLeft = (c - 1) * gridSize * _2SIN60 + left + 0.5 * gridSize * _2SIN60 - 0.5 * this._gridSpace * gridSize;
                verticalCenter = gridLeft + 0.5 * gridSize * _2SIN60 * times;
                gridRight = verticalCenter + 0.5 * gridSize * _2SIN60 * times;
            }
            gridBottom = (r - 1) * gridSize * 1.5 + bottom + -0.5 * this._gridSpace * gridSize;
            horizontal1 = gridBottom + 0.5 * gridSize * times;
            horizontalCenter = horizontal1 + 0.5 * gridSize * times;
            horizontal2 = horizontalCenter + 0.5 * gridSize * times;
            gridTop = horizontal2 + 0.5 * gridSize * times;

            gridLeftH = hmap.util.Correction.float32FromDouble64(gridLeft, unit)[0];
            gridLeftL = hmap.util.Correction.float32FromDouble64(gridLeft, unit)[1];

            verticalCenterH = hmap.util.Correction.float32FromDouble64(verticalCenter, unit)[0];
            verticalCenterL = hmap.util.Correction.float32FromDouble64(verticalCenter, unit)[1];

            gridRightH = hmap.util.Correction.float32FromDouble64(gridRight, unit)[0];
            gridRightL = hmap.util.Correction.float32FromDouble64(gridRight, unit)[1];

            gridBottomH = hmap.util.Correction.float32FromDouble64(gridBottom, unit)[0];
            gridBottomL = hmap.util.Correction.float32FromDouble64(gridBottom, unit)[1];

            horizontal1H = hmap.util.Correction.float32FromDouble64(horizontal1, unit)[0];
            horizontal1L = hmap.util.Correction.float32FromDouble64(horizontal1, unit)[1];

            horizontal2H = hmap.util.Correction.float32FromDouble64(horizontal2, unit)[0];
            horizontal2L = hmap.util.Correction.float32FromDouble64(horizontal2, unit)[1];

            gridTopH = hmap.util.Correction.float32FromDouble64(gridTop, unit)[0];
            gridTopL = hmap.util.Correction.float32FromDouble64(gridTop, unit)[1];

            if (dimension === 3) {
                const num = 12;
                const heightH = hmap.util.Correction.float32FromDouble64(height, unit)[0];
                const heightL = hmap.util.Correction.float32FromDouble64(height, unit)[1];

                //遍历所有网格
                this.a_positionH.push(
                    gridLeftH, horizontal2H, 0,
                    verticalCenterH, gridTopH, 0,
                    gridRightH, horizontal2H, 0,
                    gridRightH, horizontal1H, 0,
                    verticalCenterH, gridBottomH, 0,
                    gridLeftH, horizontal1H, 0,
                    gridLeftH, horizontal2H, heightH,
                    verticalCenterH, gridTopH, heightH,
                    gridRightH, horizontal2H, heightH,
                    gridRightH, horizontal1H, heightH,
                    verticalCenterH, gridBottomH, heightH,
                    gridLeftH, horizontal1H, heightH,
                ); //12个顶点的xy

                this.a_positionL.push(
                    gridLeftL, horizontal2L, 0,
                    verticalCenterL, gridTopL, 0,
                    gridRightL, horizontal2L, 0,
                    gridRightL, horizontal1L, 0,
                    verticalCenterL, gridBottomL, 0,
                    gridLeftL, horizontal1L, 0,
                    gridLeftL, horizontal2L, heightL,
                    verticalCenterL, gridTopL, heightL,
                    gridRightL, horizontal2L, heightL,
                    gridRightL, horizontal1L, heightL,
                    verticalCenterL, gridBottomL, heightL,
                    gridLeftL, horizontal1L, heightL,
                );

                const cursor = num * current;
                this.a_indices.push(
                    cursor + 0, cursor + 1, cursor + 2, cursor + 2, cursor + 3, cursor + 4, cursor + 4, cursor + 5, cursor + 0, cursor + 0, cursor + 2, cursor + 4, //底面
                    cursor + 6, cursor + 7, cursor + 8, cursor + 8, cursor + 9, cursor + 10, cursor + 10, cursor + 11, cursor + 6, cursor + 6, cursor + 8, cursor + 10, //顶面
                    cursor + 0, cursor + 1, cursor + 7, cursor + 0, cursor + 7, cursor + 6,
                    cursor + 1, cursor + 2, cursor + 8, cursor + 1, cursor + 8, cursor + 7,
                    cursor + 2, cursor + 3, cursor + 9, cursor + 2, cursor + 9, cursor + 8,
                    cursor + 3, cursor + 4, cursor + 10, cursor + 3, cursor + 10, cursor + 9,
                    cursor + 4, cursor + 5, cursor + 11, cursor + 4, cursor + 11, cursor + 10,
                    cursor + 5, cursor + 0, cursor + 6, cursor + 5, cursor + 6, cursor + 11, 65535 //片元重启标记
                )
                for (let i = 0; i < 12; i++) {
                    this.a_color.push(...propotionColor);
                }
                current++;

            } else {
                this.a_positionH.push(
                    gridLeftH, horizontal2H, 0, verticalCenterH, gridTopH, 0, gridRightH, horizontal2H, 0,
                    gridRightH, horizontal2H, 0, gridRightH, horizontal1H, 0, verticalCenterH, gridBottomH, 0,
                    verticalCenterH, gridBottomH, 0, gridLeftH, horizontal1H, 0, gridLeftH, horizontal2H, 0,
                    gridLeftH, horizontal2H, 0, gridRightH, horizontal2H, 0, verticalCenterH, gridBottomH, 0,
                ); //12个顶点的xy

                this.a_positionL.push(
                    gridLeftL, horizontal2L, 0, verticalCenterL, gridTopL, 0, gridRightL, horizontal2L, 0,
                    gridRightL, horizontal2L, 0, gridRightL, horizontal1L, 0, verticalCenterL, gridBottomL, 0,
                    verticalCenterL, gridBottomL, 0, gridLeftL, horizontal1L, 0, gridLeftL, horizontal2L, 0,
                    gridLeftL, horizontal2L, 0, gridRightL, horizontal2L, 0, verticalCenterL, gridBottomL, 0,
                ); //12个顶点的xy

                //6个三角形的颜色,对应18个顶点的颜色
                for (let i = 0; i < 12; i++) {
                    this.a_color.push(...propotionColor);
                }
            }


        }
        this._current = current;
    }

    /**
     * 根据颜色域、值域计算颜色分段
     * @param {Array<hmap.basetype.Color>} colorArr  颜色范围
     * @param {Array} valueArr   值范围
     * @private
     */
    _getColorSegment(colorArr, valueArr) {
        //数据分段
        const colorLen = colorArr.length;
        const valueLen = valueArr.length;
        const divideValueLen = valueLen / (colorLen - 1);
        let segmentArr = [];
        for (let i = 0; i < colorLen - 1; i++) {
            segmentArr.push({
                startColor: colorArr[i],
                endColor: colorArr[i + 1],
                valueArr: i === colorLen - 2 ? valueArr : valueArr.splice(0, divideValueLen) //最后一个段承载剩下所有的数据，因为有小数的问题
            })
        }
        return segmentArr;
    }

    /**
     * 根据当前值获取颜色形成渐变的效果
     * @param {Number} value
     * @private
     */
    _getColor(value) {
        const colorLen = this._segmentArr.length;
        for (let i = 0; i < colorLen; i++) {
            const tempSegment = this._segmentArr[i];
            const valueArr = tempSegment.valueArr;
            if (valueArr.indexOf(value) !== -1) {
                const colorMinNor = tempSegment.startColor.toNormalizeArray();
                const colorMaxNor = tempSegment.endColor.toNormalizeArray();
                const colorR = colorMaxNor[0] - colorMinNor[0];
                const colorG = colorMaxNor[1] - colorMinNor[1];
                const colorB = colorMaxNor[2] - colorMinNor[2];
                const colorA = colorMaxNor[3] - colorMinNor[3];

                const maxCount = Math.max(...valueArr),
                    minCount = Math.min(...valueArr);
                const divideR = maxCount - minCount !== 0 ? colorR / (maxCount - minCount) : 0;
                const divideG = maxCount - minCount !== 0 ? colorG / (maxCount - minCount) : 0;
                const divideB = maxCount - minCount !== 0 ? colorB / (maxCount - minCount) : 0;
                const divideA = maxCount - minCount !== 0 ? colorA / (maxCount - minCount) : 0;
                const minColorR = colorMinNor[0],
                    minColorG = colorMinNor[1],
                    minColorB = colorMinNor[2],
                    minColorA = colorMinNor[3];
                return [
                    minColorR + divideR * (value - minCount),
                    minColorG + divideG * (value - minCount),
                    minColorB + divideB * (value - minCount),
                    minColorA + divideA * (value - minCount)
                ];
            }
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型基类，无法被实例化。
 * @abstract
 * @type {hmap.geosolution.math.MathModel}
 */
hmap.geosolution.math.MathModel=class{
    constructor(options){
        if (new.target === hmap.geosolution.math.MathModel) {
            throw new TypeError("The MathModel is an abstract class,and can not be instanced!");
        }
        this.CLASS_NAME = "hmap.geosolution.math.MathModel";
        this._objMap=new Map();
        this._drawData=null;
        this._render=null;
        this._gl=null;
        this._isRTE=false;
        this._renderable=false;
        this._mapUnit=null;
        this._upFlag = {
            index: null,
            isChange: false,
            update: null
        };
        this._glStatus={};
        //"A":add,"R":change,"D":delete,"O":全刷数据.
        // 根据更新数据的模式判断更新Buffer数据的模式，
        //if(isChange==true){
        //     update=="R",根据index替换数据
        //     else:全部更新数据
        // }
    }

    /**
     * 初始化render
     * @param gl
     * @param opts
     * @private
     */
    _initRenderOpts(gl,opts){
        this._gl=gl;
        this._mapUnit=opts.mapUnit?opts.mapUnit:"degrees";
        this._srid=opts.srid?opts.srid:"4326";
    }

    /**
     * 设置承载model的map
     * @param {hmap.Map} map  map对象
     * @private
     */
    _setMap(map){
        this._map = map;
    }

    /**
     * 添加对应的cell到数学模型
     * @param mathCell 与MathModel对应的cell对象
     */
    addMathCell(mathCell){
        // this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 根据唯一标识符获取组成该数学模型的cell
     * @param {String} id cell对象的唯一标识符
     * @returns {Object|null} 该id对应的cell对象或null
     */
    getMathCellById(id){
        return this._objMap.get(id);
    }

    /**
     * 获取组成该数学模型的所有cell
     * @returns {Array} 组成该数学模型的cell构成的数组
     */
    getAllMathCells(){
        return [...this._objMap.values()];
    }

    /**
     * 根据cell的唯一标识符，将对应的cell对象从数学模型中移除
     * @param {String} id cell的唯一标识符
     */
    removeMathCellById(id){
        this._objMap.delete(id);
    }

    /**
     * 清空该数学模型中的组成cell
     */
    removeAll(){
        this._objMap.clear();
    }

    /**
     * 该数学模型是否处于可绘制状态，只用MathModel处于可绘制状态才可绘制到图层
     * @returns {Boolean} true或者false，true为可绘制状态
     * @private
     */
    isRenderable(){
        return this._renderable;
    }

    /**
     * 当cell数据变化时，重新组织绘制数据方法
     */
    updateDrawData(){}

    /**
     * 销毁对象
     */
    destroy(){
        let names=Object.getOwnPropertyNames(this);
        for(let i=0,len=names.length;i<len;i++){
            const name=names[i];
            this[name]=null;
            delete this[name];
        }
        delete this;
    }

    /**
     * 组织更新绘制数据
     * @private
     */
    _draw(){}

    /**
     * 无顶点数据更新，仅进行屏幕帧绘制
     * @private
     */
    _tick(){}

    /**
     * 仅针对使用帧的model有用
     * @private
     */
    _tickFrame(){}

    /**
     * 仅针对使用帧的model有用
     * @private
     */
    _drawFrame(){}
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.math = hmap.geosolution.math || {};
/**
 * 地理解决方案数学模型，柱状图模型。
 * @type {hmap.geosolution.math.BarModel}
 * @extends hmap.geosolution.math.MathModel
 */

hmap.geosolution.math.BarModel = class extends hmap.geosolution.math.MathModel {
    /**
     * BarModel的构造函数。
     * @param options
     * @param {Number} options.sideNum 该模型的组成Bar的边数，整数，大于2时有效，小于等于2或不提供时采用默认值4。
     * @param {Boolean} options.isLiner 该模型是否使用线性颜色渐变。true则根据Bar对象的colorB和colorT径向渐变颜色，false则使用Bar的colorB颜色。默认false。
     * @param {Number} options.size 该模型的组成Bar的半径，地理单位。大于0时有效，小于等于0或不提供时，采用默认值0.01。
     * @param {Number} options.height 该数学模型的最大高度，Bar最大值对应的高度，地理单位，大于0时有效，小于等于0或不提供时采用默认值。默认值0.03。
     * @throws 无参数检查，类型错误时，方法内部报错。
     * @example
     * const mathModel=new hmap.geosolution.math.BarModel({
     *          size:0.0001,
     *          height:0.009,
     *          isLiner:false,
     *          sideNum:6,
     * });
     */
    constructor(options) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.BarModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        options = options || {};
        this._isRTE = false;
        this._sideNum = options.sideNum > 2 ? options.sideNum : 4;
        this._isLiner = options.isLiner ? options.isLiner : false;
        this._size = options.size > 0 ? options.size : 0.01;//地理单位，半径
        this._height = options.height > 0 ? options.height : 0.03;
        this._maxValue = null;//最大值，默认最大值对应设置的高度
        this._initDrawData();//初始化绘制使用数据形式
        this._pick = options.pick ? options.pick : false;//是否支持拾取
    }

    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        this._posSize = 3;
        this._render = new hmap.render.BarRender(this._gl, this._posSize, this._sideNum);
        this._renderable = true;
    }

    /**
     * 添加Bar元素
     * @param {hmap.geosolution.cell.Bar} mathCell Bar元素
     */
    addMathCell(mathCell) {
        if (!(mathCell instanceof hmap.geosolution.cell.Bar)) {
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id, mathCell);
    }

    /**
     * 获取BarModel中Bar的半径大小
     * @returns {Number} BarModel的半径值
     */
    getSize() {
        return this._size;
    }

    /**
     * 设置BarModel中Bar的半径大小，地理单位。
     * @param {Number} size BarModel的半径值
     */
    setSize(size) {
        this._size = size;
    }

    /**
     * 获取BarModel中Bar的颜色渐变状态
     * @returns {Boolean} true或者false。true表示渐变，false表示不渐变。
     */
    getIsLiner() {
        return this._isLiner;
    }

    /**
     * 设置BarModel中Bar的颜色渐变状态
     * @param {Boolean} isLiner 是否渐变
     */
    setIsLiner(isLiner) {
        this._isLiner = isLiner;
    }

    /**
     * 获取BarModel的最大高度
     * @returns {Number} BarModel的最大高度
     */
    getHeight() {
        return this._height;
    }

    /**
     * 设置BarModel的最大高度
     * @param {Number} height 高度值
     */
    setHeight(height) {
        this._height = height;
    }

    /**
     * 更新绘制数据接口。当组成BarModel的Bar更新时调用。
     * 注：
     * 添加、删除、修改单个Bar建议调用updateDrawData(barCell.getId())；
     * 多个时建议调用updateDrawData()。前者为按标识符更新，后者为全量更新。
     * @param {String} id 需要更新的Bar的唯一标识符。
     * example
     * //更新单个BarCell
     * bar.setColor(new hmap.style.Color(255,0,0,1),false);
     * BarModel.updateDrawData(bar.getId());
     * //更新多个BarCell
     * BarModel.updateDrawData();
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    this._drawData.centers.splice(this._posSize * ind, this._posSize, ...value._center);
                    this._drawData.values.splice(ind, 1, value._value);
                    this._drawData.colors0.splice(4 * ind, 4, ...value._color0);
                    this._drawData.colors1.splice(4 * ind, 4, ...value._color1);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.splice(ind, 1);
                    this._drawData.centers.splice(this._posSize * ind, this._posSize);
                    this._drawData.values.splice(ind, 1);
                    this._drawData.colors0.splice(4 * ind, 4);
                    this._drawData.colors1.splice(4 * ind, 4);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
        this._maxValue = Math.max(...this._drawData.values);
        if (this._pick) {
            this._buildBarBBox();
        }
    }

    _draw(uniforms) {
        if (this._drawData.idArray.length <= 0) return;
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms) {
        if (this._drawData.idArray.length <= 0||this._render._upBuffer===false) return;
        uniforms.u_height = this._height;
        uniforms.u_maxValue = this._maxValue;
        uniforms.u_size = this._size;
        uniforms.u_ifLiner = this._isLiner;
        this._render.draw(this._drawData, uniforms, "");
    }

    /**
     * 组装数据
     * @param value
     * @private
     */
    _assemble(value) {
        this._drawData.idArray.push(value._id);
        this._drawData.centers.push(...value._center);
        this._drawData.values.push(value._value);
        this._drawData.colors0.push(...value._color0);
        this._drawData.colors1.push(...value._color1);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            centers: [],//Bar的center
            values: [],//Bar的统计值
            colors0: [],//Bar的colorBottom
            colors1: [],//Bar的colorTop
            idArray: []
        };
    }
    /**
     * 创建柱状图的BBox对象
     * @private
     */
    _buildBarBBox() {
        const height = this._height;
        const maxValue = this._maxValue;
        const size = this._size;
        for (let value of this._objMap.values()) {
            const minX = value._center[0] - size;
            const maxX = value._center[0] + size;

            const minY = value._center[1] - size;
            const maxY = value._center[1] + size;

            const minZ = value._center[2];
            const maxZ = value._center[2] + height * value._value / maxValue;
            value._box = new hmap.basetype.BBox(minX, minY, minZ, maxX, maxY, maxZ);
        }
    }

    /**
     * 拾取
     * @param ray 射线
     * @return {Array}
     * @private
     */
    intersectRay(ray) {
        if(!this._pick) return [];
        const arr = [];
        for (let value of this._objMap.values()) {
            let res = value._box.intersectRay(ray);
            if (res) {
                value.mid= this._id;
                res.feature = value;
                arr.push(res);
            }
        }
        return arr;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型，电子墙模型。
 * @type {hmap.geosolution.math.EleWallModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.EleWallModel=class extends hmap.geosolution.math.MathModel{
    /**
     * EleWallModel的构造函数。
     * @example
     * const eleWallModel=new hmap.geosolution.math.EleWallModel();
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.EleWallModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._initDrawData();
        this._glStatus={
            "CULL_FACE":false
        };
    }

    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        this._posSize=opts.isRTE?6:3;
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._render=new hmap.render.EleWallRender(this._gl,this._posSize);
        this._renderable=true;
    }

    /**
     * 添加EleWall元素
     * @param {hmap.geosolution.cell.EleWall} mathCell EleWall元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.EleWall)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 更新绘制数据接口。
     * 添加单个数据建议调用updateDrawData(eleWallCell.getId());
     * 删除更新调用updateDrawData()刷新全部数据
     * @param {String} id cell对象的唯一标识符
     * @example
     * //在已绘制的EleWallModel中添加或删除一个cell（建议用法）
     * eleWallModel.updateDrawData(eleWallCell.getId());
     * //删除或添加多个eleWallCell后更新绘制数据
     * eleWallModel.updateDrawData();
     */
    updateDrawData(id){
        if(id){
            //判断图层中是否存在数据
            if(this._objMap.get(id)){
                const value=this._objMap.get(id);
                let ind=this._drawData.idArray.indexOf(id);
                //add or change
                if(ind===-1){
                    this._assemble(value);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    //更新数据，更新除顶点相关和纹理相关的属性变量。纹理更新方法完备，但考虑效率暂时注释
                    this._drawData.heights.splice(ind,1,value._height);
                    this._drawData.animParams.splice(ind,1,[value._amplitude,value._cycleLength,value._freq,value._isAnimation]);
                    this._drawData.colors0.splice(ind,1,value._color0);
                    this._drawData.colors1.splice(ind,1,value._color1);
                    this._drawData.ifTexs.splice(ind,1,value._ifTex);
                    this._drawData.repeats.splice(ind,1,value._repeatNum);
                    // const tex=this._drawData.textures[ind];
                    // if(value._ifTex) {
                    //     this._drawData.textures.splice(ind, 1, this._getGLTexture(value._texture));
                    // }else{
                    //     this._drawData.textures.splice(ind,1,"");
                    // }
                    // if(tex!=="")this._gl.deleteTexture(tex);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                let ind=this._drawData.idArray.indexOf(id);
                if(ind!==-1){
                    this._drawData.idArray.splice(ind,1);
                    this._drawData.heights.splice(ind,1);
                    this._drawData.animParams.splice(ind,1);
                    this._drawData.colors0.splice(ind,1);
                    this._drawData.colors1.splice(ind,1);
                    this._drawData.ifTexs.splice(ind,1);
                    this._drawData.repeats.splice(ind,1);
                    const tex=this._drawData.textures[ind];
                    this._drawData.textures.splice(ind, 1);
                    if(tex!=="")this._gl.deleteTexture(tex);
                    //删除顶点和顶点距离
                    let nums=this._drawData.numArray.slice(0,ind);
                    nums=nums.length===0?0:nums.reduce((x,y)=>x+y);
                    this._drawData.positions.splice(nums*this._posSize,this._drawData.numArray[ind]*this._posSize);
                    this._drawData.distances.splice(nums,this._drawData.numArray[ind]);
                    this._drawData.numArray.splice(ind,1);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="D";
                }
            }

        }else{
            //update all
            this._initDrawData();
            for(let value of this._objMap.values()){
                this._assemble(value);
            }
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }

    _draw(uniforms){
        if(this._drawData.idArray.length===0)return;
        this._startTime=this._startTime||window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms){
        if(this._drawData.idArray.length<=0||this._render._upBuffer===false)return;
        this._gl.disable(this._gl.CULL_FACE);
        uniforms.u_time=this._startTime?window.Date.now()-this._startTime:0;
        this._render.draw(this._drawData,uniforms,"TRIANGLE_FAN");
    }

    /**
     * 绑定纹理，并返回webGLTexture
     * @param img
     * @returns {*}
     * @private
     */
    _getGLTexture(img){
        return this._render._createTexture(img).texture;
    }

    /**
     * 组装数据
     * @param value
     * @private
     */
    _assemble(value){
        const posAndDist=value._insertCoords(this._isRTE,this._mapUnit,this._srid);
        this._drawData.idArray.push(value._id);
        this._drawData.numArray.push(posAndDist.distances.length);
        this._drawData.distances.push(...posAndDist.distances);
        this._drawData.positions.push(...posAndDist.positions);
        this._drawData.distLasts.push(posAndDist.distLast);
        this._drawData.heights.push(value._height);
        this._drawData.animParams.push([value._amplitude,value._cycleLength,value._freq,value._isAnimation]);
        this._drawData.colors0.push(value._color0);
        this._drawData.colors1.push(value._color1);
        this._drawData.ifTexs.push(value._ifTex);
        this._drawData.repeats.push(value._repeatNum);
        if(value._ifTex){
            this._drawData.textures.push(this._getGLTexture(value._texture));
        }else{
            this._drawData.textures.push("");
        }
    }
    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData(){
        this._drawData={
            idArray:[],
            numArray:[],//存储插值后的顶点数量
            positions:[],//顶点attribute
            distances:[],//顶点距离，attribute
            distLasts:[],//wall总长度，uniform
            heights:[],//高度数组，uniform
            animParams:[],//动画参数，分别为幅值、周期长度、周期时间
            colors0:[],//底部颜色
            colors1:[],//顶部颜色
            textures:[],//存储glTexture
            ifTexs:[],//是否使用纹理
            repeats:[]//纹理重复次数
        };
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.math = hmap.geosolution.math || {};
/**
 * 地理解决方案数学模型，填充圆模型。平面效果，显示不使用深度（或高程）信息，叠加层次与添加或绘制顺序有关。
 * @type {hmap.geosolution.math.FilledCircleModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.FilledCircleModel = class extends hmap.geosolution.math.MathModel {
    /**
     * FilledCircleModel的构造函数。
     * @example
     * let filledCircleModel=new hmap.geosolution.math.FilledCircleModel();
     */
    constructor(options) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.FilledCircleModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._initDrawData();
        this._glStatus={
            "DEPTH_TEST":false
        }
    }

    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._posSize = opts.isRTE ? 6 : 3;
        this._render = new hmap.render.FilledCircleRender(this._gl, this._posSize);
        this._renderable = true;
    }

    /**
     * 添加FilledCircle元素
     * @param {hmap.geosolution.cell.FilledCircle} mathCell FilledCircle元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.FilledCircle)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 更新绘制数据接口。当组成FilledCircleModel的FilledCircle更新时调用。。
     * 注：
     * 添加、删除、修改单个FilledCircle建议调用updateDrawData(filledCircleCell.getId())；
     * 多个时建议调用updateDrawData()。前者为按标识符更新，后者为全量更新。
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                let center = value._center;
                if (this._isRTE) {
                    const xx = hmap.util.Correction.float32FromDouble64(center[0],this._mapUnit);
                    const yy = hmap.util.Correction.float32FromDouble64(center[1],this._mapUnit);
                    const zz = hmap.util.Correction.float32FromDouble64(center[2],this._mapUnit);
                    center = [xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
                }
                //add or change
                if (ind === -1) {
                    this._assemble(value, center);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    this._drawData.centers.splice(this._posSize * ind, this._posSize, ...center);
                    this._drawData.colors.splice(4 * ind, 4, ...value._color);
                    this._drawData.sizes.splice(ind, 1, value._size);
                    this._drawData.maxSizes.splice(ind, 1, value._maxSize);
                    this._drawData.freqs.splice(ind, 1, value._freq);
                    this._drawData.thresholds.splice(4 * ind, 4, ...value._threshold);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.splice(ind, 1);
                    this._drawData.centers.splice(this._posSize * ind, this._posSize);
                    this._drawData.colors.splice(4 * ind, 4);
                    this._drawData.sizes.splice(ind, 1);
                    this._drawData.maxSizes.splice(ind, 1);
                    this._drawData.freqs.splice(ind, 1);
                    this._drawData.thresholds.splice(4 * ind, 4);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                let center = value._center;
                if (this._isRTE) {
                    const xx = hmap.util.Correction.float32FromDouble64(value._center[0],this._mapUnit);
                    const yy = hmap.util.Correction.float32FromDouble64(value._center[1],this._mapUnit);
                    const zz = hmap.util.Correction.float32FromDouble64(value._center[2],this._mapUnit);
                    center = [xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
                }
                this._assemble(value, center);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }

    _draw(uniforms) {
        if (this._drawData.idArray.length <= 0)return;
        this._startTime = this._startTime ? this._startTime : Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms) {
        if(this._drawData.idArray.length<=0||this._render._upBuffer===false)return;
        this._gl.disable(this._gl.DEPTH_TEST);
        uniforms.u_time =this._startTime ? window.Date.now() - this._startTime : 0;
        this._render.draw(this._drawData, uniforms, "TRIANGLE_FAN");
    }

    /**
     * 组装数据
     * @param value
     * @param isRTECenter
     * @private
     */
    _assemble(value, isRTECenter) {
        this._drawData.idArray.push(value._id);
        this._drawData.centers.push(...isRTECenter);
        this._drawData.colors.push(...value._color);
        this._drawData.sizes.push(value._size);
        this._drawData.maxSizes.push(value._maxSize);
        this._drawData.freqs.push(value._freq);
        this._drawData.thresholds.push(...value._threshold);
    }

    /**
     * 初始化绘制数据存储
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],
            colors: [],//主要颜色数组
            sizes: [],//初始化半径数组
            maxSizes: [],//动画最大半径数组
            freqs: [],//频率数组
            centers: [],//中心点坐标数组
            thresholds: []//圈层阈值数组
        };
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型，热力图模型。热力图无高度（或深度）信息，显示层次和添加或绘制顺序有关。
 * @type {hmap.geosolution.math.HeatmapModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.HeatmapModel=class extends hmap.geosolution.math.MathModel{
    /**
     * 热力图模型构建函数
     * @param options 可选参数。
     * @param {Number} options.size 单个热力点所覆盖的半径，像素单位。大于0时有效，小于等于0或者不提供时采用默认值，默认值为40。
     * @param {Array} options.colors 四维数组，hmap.style.Color类型，分别对应阈值0.25，0.50，0.75，1.0的颜色（比如某处热力与最大热力的比值为0.30，则该处显示数组的第一个颜色和第二个颜色的过渡色）。默认值[new hmap.style.Color(0,0,255,1),new hmap.style.Color(0,255,0,1),new hmap.style.Color(255,255,0,1),new hmap.style.Color(255,0,0,1)];
     * @throws 无参数校验，参数类型错误时，方法内部报错。
     * @example
     * let heatmap=new geosolution.math.HeatmapModel({
     *      size:40,
     *      colors:[new hmap.style.Color(0,0,255,1),new hmap.style.Color(0,255,0,1),new hmap.style.Color(255,255,0.0,1),new hmap.style.Color(255,0,0,1)]
     * });
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.HeatmapModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        options=options||{};
        this._size=options.size>0?options.size:40.0;//单个热力点所覆盖的半径，像素单位
        this._opacities=[1.0,1.0,1.0,1.0];//各个热力区间的颜色透明度值
        //各个热力区间阈值的颜色值，默认按照Value由小及大的顺序
        const colors=[new hmap.style.Color(0,0,255,this._opacities[0]),
            new hmap.style.Color(0,255,0,this._opacities[1]),
            new hmap.style.Color(255,255,0.0,this._opacities[2]),
            new hmap.style.Color(255,0,0,this._opacities[3])];
        this._colorArray=options.colors?options.colors:colors;
        const colorNA=this._colorArray.map(x=>{return x.toNormalizeArray();});
        this._tColors=[colorNA[0][0]*0.5,colorNA[0][1]*0.5,colorNA[0][2]*0.5,colorNA[0][3]*0.5].concat(colorNA.reduce(function (a, b) { return a.concat(b)} ));
        this._maxValFlag=true;//默认使用热力最大值
        this._maxValue=0;//该数学模型的最大热力值
        this._minValFlag=true;//默认使用热力最小值
        this._minValue=0;//该数学模型的最小热力值
        this._initDrawData();
        this._glStatus={
            "BLEND":true,
            "blendEquation":"FUNC_ADD",
            "blendFuncSeparate":["SRC_ALPHA", "ONE_MINUS_SRC_ALPHA", "ONE", "ONE"],
            "DEPTH_TEST":false
        };
    }

    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._posSize=opts.isRTE?6:3;
        this._render=new hmap.render.HeatmapRender(this._gl,this._posSize);
        this._renderable=true;
    }

    /**
     * 添加Heatpoint元素
     * @param {hmap.geosolution.cell.Heatpoint} mathCell Heatpoint元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.Heatpoint)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
        if(this._maxValFlag){
            this._maxValue=Math.max(this._maxValue,mathCell._value);
        }
    }

    /**
     * 设置最大热力值，该方法不调用则默认使用组成HeatmapModel的所有Heatpoint的最大值。
     * @param {Number} value 大于0的热力最大值
     */
    setMaxHeatValue(value){
        if(value>this._minValue){
            this._maxValue=value;
            this._maxValFlag=false;
        }else{
            throw new Error("MaxValue must be greater than minValue!");
        }
    }

    /**
     * 获取该HeatmapModel使用的最大热力值
     * @returns {Number} 热力值
     */
    getMaxHeatValue(){
        return this._maxValue;
    }

    /**
     * 设置最小热力值，该方法不调用则默认使用0作为最小值。
     * @param {Number} value 大于0的热力最小值
     */
    setMinHeatValue(value){
        if(value>0&&value<this._maxValue){
            this._minValue=value;
        }else{
            throw new Error("MinValue must be less than maxValue!");
        }
    }

    /**
     * 获取HeatmapModel使用的最小热力值。
     * @returns {number} 热力值
     */
    getMinHeatValue(){
        return this._minValue;
    }

    /**
     * 设置对应热度层级的颜色
     * @param {hmap.style.Color} color 颜色值
     * @param {Number} lev 热度层级，大于等于0小于4的整数值
     * @example
     * heatmap.setColorByLevel(new hmap.style.Color(255,200,0,1),1);
     */
    setColorByLevel(color,lev){
        this._colorArray.splice(lev,1,color);
        const colorNA=color.toNormalizeArray();
        this._tColors.splice(lev*4+4,...colorNA);
        this._drawData.colors=this._tColors;
    }

    /**
     * 获取当前热力图的等级颜色配置
     * @returns {Array} 返回各等级的RGBA颜色数组,颜色数组索引增大,表示热力图的等级也增大
     * @example
     * let colors = Heatmap.getColorArray();
     */
    getColorArray(){
        return this._colorArray;
    }

    /**
     * 获取Heatpoint的value为0时对应的颜色。
     * @returns {hmap.style.Color} Heatpoint的value为0时对应的颜色
     */
    getBaseColor(){
        return new hmap.style.Color(this._tColors[0]*255,
            this._tColors[1]*255,this._tColors[2]*255,this._tColors[3]);
    }

    /**
     * 设置Heatpoint的value为0时对应的颜色。该颜色涉及到等级配置色的渐变。
     * @param {hmap.style.Color} color 颜色值对象
     */
    setBaseColor(color){
        const colorNA=color.toNormalizeArray();
        this._tColors.splice(0,4,...colorNA);
        this._drawData.colors=this._tColors;
    }

    /**
     * 设置HeatmapModel中单个Heatpoint的半径值。
     * @param {Number} size 半径值。像素单位。
     */
    setSize(size){
        this._size=size;
    }

    /**
     * 获取HeatmapModel中单个Heatpoint的半径值。
     * @returns {Number} 半径值。像素单位。
     */
    getSize(){
        return this._size;
    }

    /**
     * 更新绘制数据接口。当组成HeatmapModel的Heatpoint更新时调用。
     * 注：
     * 添加、删除、修改单个Heatpoint建议调用updateDrawData(Heatpoint.getId())；
     * 多个时建议调用updateDrawData()。前者为按标识符更新，后者为全量更新。
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id){
        if(id){
            //判断图层中是否存在数据
            if(this._objMap.get(id)){
                const value=this._objMap.get(id);
                let ind=this._drawData.idArray.indexOf(id);
                let center=value._center;
                if(this._isRTE){
                    const xx = hmap.util.Correction.float32FromDouble64(center[0],this._mapUnit);
                    const yy = hmap.util.Correction.float32FromDouble64(center[1],this._mapUnit);
                    const zz = hmap.util.Correction.float32FromDouble64(center[2],this._mapUnit);
                    center=[xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
                }
                //add or change
                if(ind===-1){
                    this._assemble(value,center);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    this._drawData.centers.splice(this._posSize*ind,this._posSize,...center);
                    this._drawData.values.splice(ind,1,value._value);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                let ind=this._drawData.idArray.indexOf(id);
                if(ind!==-1){
                    this._drawData.idArray.splice(ind,1);
                    this._drawData.centers.splice(this._posSize*ind,this._posSize);
                    this._drawData.values.splice(ind,1);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="D";
                }
            }

        }else{
            //update all
            this._initDrawData();
            for(let value of this._objMap.values()){
                let center=value._center;
                if(this._isRTE){
                    const xx = hmap.util.Correction.float32FromDouble64(value._center[0],this._mapUnit);
                    const yy = hmap.util.Correction.float32FromDouble64(value._center[1],this._mapUnit);
                    const zz = hmap.util.Correction.float32FromDouble64(value._center[2],this._mapUnit);
                    center=[xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]];
                }
                this._assemble(value,center);
            }
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
        // if(this._maxValFlag){
        //     this._maxValue=Math.max(...this._drawData.values);
        // }
        // if(this._minValFlag){
        //     this._minValue=Math.min(...this._drawData.values);
        // }
    }

    _draw(uniforms){
        // this._tick(uniforms);
    }

    _drawFrame(uniforms){
        if((this._drawData.idArray.length<=0)||(this._maxValue<=this._minValue))return;
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tickFrame(uniforms);
    }

    _tick(uniforms){
        if((this._drawData.idArray.length<=0)||(this._maxValue<=this._minValue)||this._render._upBuffer===false)return;
        this._gl.enable(this._gl.BLEND);
        this._gl.blendEquation(this._gl.FUNC_ADD);
        // this._gl.blendFuncSeparate( this._gl.ONE, this._gl.ZERO, this._gl.ONE, this._gl.ZERO);
        this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
        this._gl.disable(this._gl.DEPTH_TEST);
        this._render.draw(this._drawData,uniforms,"TRIANGLE_FAN");
    }

    _tickFrame(uniforms){
        if((this._drawData.idArray.length<=0)||(this._maxValue<=this._minValue)||this._render._upBuffer===false)return;
        uniforms.u_size=this._size;
        uniforms.u_maxValue=this._maxValue;
        uniforms.u_minValue=this._minValue;
        this._render.drawFrame(this._drawData,uniforms)
    }
    /**
     * 组装数据
     * @param value
     * @param isRTECenter
     * @private
     */
    _assemble(value,isRTECenter){
        this._drawData.idArray.push(value._id);
        this._drawData.centers.push(...isRTECenter);
        this._drawData.values.push(value._value);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData(){
        this._drawData={
            idArray:[],
            centers:[],//热力点的中心坐标
            values:[],//热力值
            colors:this._tColors,
        }
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型，饼状图模型。平面效果，显示不使用深度（或高程）信息，叠加层次与添加或者绘制顺序有关。
 * @type {hmap.geosolution.math.PieModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.PieModel=class extends hmap.geosolution.math.MathModel{
    /**
     * PieModel的构造函数。
     * @param options
     * @param {hmap.basetype.Coordinate} options.center PieModel的中心点坐标。默认值hmap.basetype.Coordinate(0,0,0)
     * @param {Number} options.sideNum PieModel模型构建的边数，整数。内部按设置值生成最终饼状图形状。原则上参数仅要求大于2，但实际使用中建议构建边数为近似圆的多边形。当options.sideNum小于等于2或不提供时采用默认值，默认值360。
     * ！注：该方法内部按Sector的value权重分配所占用PieModel的边数，当权重过小以致权重乘以options.sideNum时会出现误差；设置边数过多会导致浏览器内存和显存占用同比例增加。建议按需设置。
     * @param {Number} options.size PieModel的半径，地理单位。大于0时有效，小于等于0或不提供时采用默认值，默认值0.01。
     * @param {Number} options.innerPercent 内侧挖空半径占比，0到1。小于0时使用0，大于1时使用1，不提供使用0。
     * @param {Boolean} options.autoRadius 是否按Sector的Value值分配半径。为true时，最大value的Sector对应options.size，其余按比例赋值。默认值false。
     * @param {Boolean} options.autoColor 是否按Sector的Value值分配颜色。为true时，最大value的Sector使用options.pieColor，其余按比例赋值。默认值false。
     * @param {hmap.style.Color} options.pieColor PieModel的颜色，默认值hmap.style.Color(255,0,0,1)。当options.autoColor为true时使用，options,autoColor为false时使用Sector的颜色。
     * @throws 无参数校验，类型错误，方法报错。
     * @example
     * let pieModel=new hmap.geosolution.math.PieModel({
     *      center:new hmap.basetype.Coordinate(120.20,30.19,0),
     *      sideNum:60,
     *      size:0.01,
     *      innerPercent:0.3,//中空的半径占比
     *      autoRadius:true,//true为南丁格尔玫瑰图，false为正常饼状图
     *      autoColor:false,//true以饼状图的颜色为基调，每个扇形的颜色与权重相关，不受其自身设定颜色影响；false为使用扇形自身颜色
     *      pieColor:new hmap.style.Color(255,200,20)
     * });
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.PieModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        options=options||{};
        this._sideNum=options.sideNum>2?options.sideNum:360;
        this._size=options.size>0?options.size:0.01;//半径，地理单位
        let innerPercent=options.innerPercent?options.innerPercent:0;
        innerPercent=Math.max(0,innerPercent);
        innerPercent=Math.min(1,innerPercent);
        this._innerPercent=innerPercent;
        const center=options.center?options.center:new hmap.basetype.Coordinate();
        this._center=[center._x,center._y,center._z];
        this._autoRadius=options.autoRadius===true?1:0;
        this._autoColor=options.autoColor===true?1:0;//为true时使用pieColor依据面积权重渲染
        const pieColor=options.pieColor?options.pieColor:new hmap.style.Color(255,0,0,1);
        this._pieColor=pieColor.toNormalizeArray();
        this._initDrawData();
        this._glStatus={
            "DEPTH_TEST":false
        };
        this._pick = options.pick ? options.pick : false;//是否支持拾取
    }

    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        this._posSize=opts.isRTE?6:3;
        this._render=new hmap.render.PieRender(this._gl,this._posSize,this._sideNum);
        this._drawData.positions=hmap.render.PieRender._createFilledCircle(this._sideNum).positions;
        this._renderable=true;
    }

    /**
     * 添加Sector元素
     * @param {hmap.geosolution.cell.Sector} mathCell Sector元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.Sector)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 获取扇形在整个饼状图中的占比
     * @returns {Map} map对象，key值为Sector的Id，value为占比。
     * @example
     * peiModel.getWeights();
     */
    getWeights(){
        let returnMap=new Map(),values=[],idArray=[],valueSum=0,wSum=0;
        if(this._objMap.size===0)return returnMap;
        if(this._objMap.size===1){
            returnMap.set([...this._objMap.keys()][0],1);
            return returnMap;
        }
        for(let obj of this._objMap.values()){
            idArray.push(obj._id);
            values.push(obj._value);
            valueSum+=obj._value;
        }
        for(let i=0,len=idArray.length;i<len-1;i++){
            const weight=values[i]/valueSum;
            returnMap.set(idArray[i],weight);
            wSum+=weight;
        }
        returnMap.set(idArray[idArray.length-1],1-wSum);
        return returnMap;
    }

    /**
     * 更新绘制数据接口。
     * 注：1.当更新Model中的某sector的颜色后，建议调用传入该sector的id进行更新，比全量更新减少计算量。
     *      调用方法为pieModel.updateDrawData(sectorId);
     *     2.当添加、移除Model中的sector或更新Model中sector的value值时，必须调用全量更新
     *      调用方法为pieModel.updateDrawData();
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id){
        if(id){
            //判断图层中是否存在数据
            if(this._objMap.get(id)){
                const obj=this._objMap.get(id);
                const ind=this._drawData.idArray.indexOf(id);
                if(ind===-1){//不存在该数据
                    this._getDrawDataByObjMap();
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    //更新，只更新颜色
                    const color=obj._color;
                    const num=this._drawData.numArray[ind]+2;
                    let colorArray=new Array(num).fill(color).flat();
                    let nums=this._drawData.numArray.slice(0,ind);
                    nums=nums.length===0?0:nums.reduce((x,y)=>x+y)+2*ind;
                    this._drawData.colors.splice(nums*4,num*4,...colorArray);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                this._getDrawDataByObjMap();
                this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
            }

        }else{
            this._getDrawDataByObjMap();
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }

    /**
     * 从当前的模型数据中计算权重，并依据权重组织顶点数据和索引
     * 注：权重划分的数量代表三角形的数量，所以顶点要补充圆心和第一个点
     * @private
     */
    _getDrawDataByObjMap(){
        //sector的索引数组，值数组，颜色数组，根据面积权重计算出的三角形数量，值求和，最大值
        let idArray=[],values=[],colorArr=[],numArray=[],valueSum=0,valueMax=0;
        for(let obj of this._objMap.values()){
            idArray.push(obj._id);
            values.push(obj._value);
            colorArr.push(obj._color);
            valueSum+=obj._value;
            valueMax=Math.max(valueMax,obj._value);
        }
        const weightArr=values.map(x=>x/valueSum);
        this._maxWeight=valueMax/valueSum;
        let colors=[],weights=[];
        const len=this._objMap.size;
        let lastNum=this._sideNum,indices=[], positions=this._drawData.positions,posAfter=[],start=0;
        //组织顶点数据
        if(len>1){
            for(let i=0;i<len-1;i++){
                start+=numArray[i-1]||0;
                const num=Math.round(values[i]/valueSum*this._sideNum);
                const end=start+num+1;//绘制num的三角形需要num+1个边缘顶点
                let pos=positions.slice(start*3,end*3);//取出需要的顶点
                pos.unshift(0,0,0);//补充圆心
                posAfter.push(...pos);
                colors.push(...new Array(num+2).fill(colorArr[i]));
                weights.push(...new Array(num+2).fill(weightArr[i]));
                const indexArray=new Array(num+2).fill(0).map((n,x)=>x+indices.length-i);//组织绘制索引
                indices.push(...indexArray);
                indices.push(65535);
                numArray.push(num);
                this._buildPolygon(idArray[i], this._center, pos, weightArr[i], this._maxWeight);
                lastNum-=num;
            }
        }
        start+=numArray[len-2]||0;
        let pos=positions.slice(start*3,((start+lastNum+1)*3));
        pos.unshift(0,0,0);
        posAfter.push(...pos);
        colors.push(...new Array(lastNum+2).fill(colorArr[len-1]));
        weights.push(...new Array(lastNum+2).fill(weightArr[len-1]));
        const indexArray=new Array(lastNum+2).fill(0).map((n,x)=>x+indices.length-len+1);
        indices.push(...indexArray);
        numArray.push(lastNum);
        colors=colors.flat();
        this._buildPolygon(idArray[len - 1], this._center, pos, weightArr[len - 1], this._maxWeight);
        this._drawData={
            idArray:idArray,
            indices:indices,
            numArray:numArray,
            colors:colors,
            weights:weights,
            positions:posAfter
        };
    }

    _draw(uniforms){
        if(this._drawData.idArray.length<=0)return;
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms){
        if(this._drawData.idArray.length<=0||this._render._upBuffer===false)return;
        uniforms.u_center=this._center;
        uniforms.u_color=this._pieColor;
        uniforms.u_maxWeight=this._maxWeight;
        uniforms.u_radius=[this._innerPercent,this._size];
        uniforms.u_ifAuto=[this._autoColor,this._autoRadius];
        this._gl.disable(this._gl.DEPTH_TEST);
        this._render.draw(this._drawData,uniforms);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData(){
        this._drawData={
            idArray:[],//id数组
            indices:[],//索引值（数据更新，需要重新计算）
            numArray:[],//每个扇形所包含的顶点数（数据更改，需要重新计算）
            colors:[],
            weights:[],//每个扇形顶点的面积权重（数据更改，需要重新计算）
            positions:[]//扇形顶点（初始化时一次生成，不再进行更新）
        };
    }
    /**
     * 创建饼图对应几何体
     * @param id
     * @param center
     * @param positions
     * @param weight
     * @param maxWeight
     * @private
     */
    _buildPolygon(id, center, positions, weight, maxWeight) {
        if (!this._pick) return;
        // console.log(id, center, weight, maxWeight)
        const innerPercent = this._innerPercent;
        const size = this._size;
        const autoRadiu = this._autoRadius;
        const percent = weight / maxWeight;
        //计算过程同shader
        const radius2 = (percent * size * (1.0 - innerPercent) + size * innerPercent) * autoRadiu + (1 - autoRadiu) * size;
        const arrCoords = [];
        for (let i = 0, len = positions.length; i < len; i += 3) {
            const coordArr = [positions[i] * radius2 + center[0], positions[i + 1] * radius2 + center[1], positions[i + 2] * radius2 + center[2]];
            const coord = new hmap.basetype.Coordinate(coordArr[0], coordArr[1], coordArr[2]);
            arrCoords.push(coord)
        }
        if (innerPercent !== 0) { //说明有中空的部分，此时应删除第一个点(圆心)，并计算内圆片段倒序
            arrCoords.splice(0, 1);
            const innerCoords = [];
            const innerSize = this._size * this._innerPercent;
            const radius2 = (percent * innerSize * (1.0 - innerPercent) + innerSize * innerPercent) * autoRadiu + (1 - autoRadiu) * innerSize;
            for (let i = 3, len = positions.length; i < len; i += 3) {
                const coordArr = [positions[i] * radius2 + center[0], positions[i + 1] * radius2 + center[1], positions[i + 2] * radius2 + center[2]];
                const coord = new hmap.basetype.Coordinate(coordArr[0], coordArr[1], coordArr[2]);
                innerCoords.push(coord)
            }
            arrCoords.push(...innerCoords.reverse());
        }
        // console.log(arrCoords)
        if (arrCoords.length > 2) {
            this._objMap.get(id)._geometry = new hmap.geom.Polygon([hmap.geom.LinearRing.fromCoordSeq(new hmap.basetype.CoordSeq(arrCoords))]);
        }
    }


    /**
     * 拾取
     * @param ray 射线
     * @return {Array}
     * @private
     */
    intersectRay(ray) {
        if (!this._pick) return;
        const arr = [];
        for (let value of this._objMap.values()) {
            if (!value._geometry) continue;
            let distance = value._geometry.intersectRay(ray);
            if (distance) {
                value.mid=this._id;
                arr.push({
                    distance: distance,
                    feature: value,
                });
            }
        }
        return arr;
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型，散点图模型。点效果，具备旋转不变性。显示不使用深度（或高程）信息，叠加层次与添加或者绘制顺序有关。
 * @type {hmap.geosolution.math.ScatterModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.ScatterModel=class extends hmap.geosolution.math.MathModel{
    /**
     * ScatterModel的构造函数。
     * @param options
     * @param {Number} options.sideNum 组成ScatterModel的"BubbleCircle"和"BreathCircle"对应的边数。大于2时有效，小于等于2或不提供时使用默认值，默认值4。
     * @example
     * let scatterModel=new hmap.geosolution.math.ScatterModel({
     *      sideNum:10
     * });
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.ScatterModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        options=options||{};
        this._sideNum=options.sideNum>2?options.sideNum:4;//仅针对circle
        this._initDrawData();
        this._startTime=null;
        this._glStatus={
            "DEPTH_TEST":false
        };
    }


    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        this._posSize=opts.isRTE?6:3;
        this._render=new hmap.render.ScatterRender(this._gl,this._posSize,this._sideNum);
        this._renderable=true;
    }

    /**
     * 添加ScatterPoint元素
     * @param {hmap.geosolution.cell.ScatterPoint} mathCell ScatterPoint元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.ScatterPoint)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 更新绘制数据接口。当组成ScatterModel的ScatterPoint更新时调用。
     * 注：
     * 添加、删除、修改单个ScatterPoint建议调用updateDrawData(ScatterPoint.getId())；
     * 多个时建议调用updateDrawData()。前者为按标识符更新，后者为全量更新。
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id){
        if(id){
            //判断图层中是否存在数据
            if(this._objMap.get(id)){
                const value=this._objMap.get(id);
                const type=value._getType(value._type)[0];
                const ind=this._drawData[type].idArray.indexOf(id);
                //需要判断绘制数据中是否存在该数据
                if(ind===-1){//该类型中不存在该数据
                    for(const [name,dataObj] of Object.entries(this._drawData)){
                        const ind=dataObj.idArray.indexOf(id);
                        if(ind!==-1){ //发生过类型更换，将原始类型的绘制数据清理
                            this._deleteDrawData(name,ind);
                            break;
                        }
                    }
                    this._addDrawData(type,value);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    this._replaceDrawData(type,ind,value);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                for(const [name,dataObj] of Object.entries(this._drawData)){
                    const ind=dataObj.idArray.indexOf(id);
                    if(ind!==-1){ //数据中存在该id，需要删除
                        this._deleteDrawData(name,ind);
                        break;
                    }
                }
                this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="D";
            }

        }else{
            //updateAll
            this._initDrawData();
            for(let value of this._objMap.values()){
                const type=value._getType(value._type)[0];
                this._addDrawData(type,value);
            }
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }
    _addDrawData(type,val){
        const dataObj=this._drawData[type];
        switch(type){
            case "bubble":
                dataObj.idArray.push(val._id);
                dataObj.centers.push(...val._center);
                dataObj.sizes.push(val._size);
                dataObj.maxSizes.push(val._maxSize);
                dataObj.freqs.push(val._freq);
                dataObj.colors.push(...val._color);
                dataObj.colorCs.push(...val._colorC);
                dataObj.alphas.push(...val._alpha);
                break;
            case "breath":
                dataObj.idArray.push(val._id);
                dataObj.centers.push(...val._center);
                dataObj.sizes.push(val._size);
                dataObj.maxSizes.push(val._maxSize);
                dataObj.freqs.push(val._freq);
                dataObj.colors.push(...val._color);
                break;
            case "circle":
                const cycle=val._getType(val._type)[1]||0;
                dataObj.idArray.push(val._id);
                dataObj.centers.push(...val._center);
                dataObj.sizes.push(val._size);
                dataObj.maxSizes.push(val._maxSize);
                dataObj.freqs.push(val._freq);
                dataObj.colors.push(...val._color);
                dataObj.alphas.push(...val._alpha);
                dataObj.cycles.push(cycle);
                break;
            default:break;
        }
    }
    _deleteDrawData(type,index){
        const dataObj=this._drawData[type];
        switch (type){
            case "bubble":
                dataObj.idArray.splice(index,1);
                dataObj.centers.splice(3*index,3);
                dataObj.sizes.splice(index,1);
                dataObj.maxSizes.splice(index,1);
                dataObj.freqs.splice(index,1);
                dataObj.colors.splice(4*index,4);
                dataObj.colorCs.splice(4*index,4);
                dataObj.alphas.splice(2*index,2);
                break;
            case "breath":
                dataObj.idArray.splice(index,1);
                dataObj.centers.splice(3*index,3);
                dataObj.sizes.splice(index,1);
                dataObj.maxSizes.splice(index,1);
                dataObj.freqs.splice(index,1);
                dataObj.colors.splice(4*index,4);
                break;
            case "circle":
                dataObj.idArray.splice(index,1);
                dataObj.centers.splice(3*index,3);
                dataObj.sizes.splice(index,1);
                dataObj.maxSizes.splice(index,1);
                dataObj.freqs.splice(index,1);
                dataObj.colors.splice(4*index,4);
                dataObj.alphas.splice(2*index,2);
                dataObj.cycles.splice(index,1);
                break;
            default:break;
        }
    }
    _replaceDrawData(type,index,val){
        const dataObj=this._drawData[type];
        switch (type){
            case "bubble":
                dataObj.centers.splice(3*index,3,...val._center);
                dataObj.sizes.splice(index,1,val._size);
                dataObj.maxSizes.splice(index,1,val._maxSize);
                dataObj.freqs.splice(index,1,val._freq);
                dataObj.colors.splice(4*index,4,...val._color);
                dataObj.colorCs.splice(4*index,4,...val._colorC);
                dataObj.alphas.splice(2*index,2,...val._alpha);
                break;
            case "breath":
                dataObj.centers.splice(3*index,3,...val._center);
                dataObj.sizes.splice(index,1,val._size);
                dataObj.maxSizes.splice(index,1,val._maxSize);
                dataObj.freqs.splice(index,1,val._freq);
                dataObj.colors.splice(4*index,4,...val._color);
                break;
            case "circle":
                dataObj.centers.splice(3*index,3,...val._center);
                dataObj.sizes.splice(index,1,val._size);
                dataObj.maxSizes.splice(index,1,val._maxSize);
                dataObj.freqs.splice(index,1,val._freq);
                dataObj.colors.splice(4*index,4,...val._color);
                dataObj.alphas.splice(2*index,2,...val._alpha);
                dataObj.types.splice(index,1,cycle);
                break;
            default:break;
        }
    }
    _draw(uniforms){
        if(this._drawData.bubble.idArray.length===0&&this._drawData.breath.idArray.length===0&&this._drawData.circle.idArray.length===0){
            return;
        }
        this._startTime=this._startTime||window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms){
        if(this._drawData.bubble.idArray.length===0&&this._drawData.breath.idArray.length===0&&this._drawData.circle.idArray.length===0){
            return;
        }
        if(this._render._upBuffer===false)return;
        uniforms.u_time=this._startTime?window.Date.now()-this._startTime:0;
        this._gl.disable(this._gl.DEPTH_TEST);
        this._render.draw(this._drawData,uniforms);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData(){
        this._drawData={
            bubble:{
                idArray:[],
                centers:[],
                sizes:[],
                maxSizes:[],
                freqs:[],
                colors:[],
                colorCs:[],
                alphas:[]
            },
            breath:{
                idArray:[],
                centers:[],
                sizes:[],
                maxSizes:[],
                freqs:[],
                colors:[]
            },
            circle:{
                idArray:[],
                centers:[],
                sizes:[],
                maxSizes:[],
                freqs:[],
                colors:[],
                alphas:[],
                cycles:[]
            }
        };
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
hmap.geosolution.math = hmap.geosolution.math || {};
/**
 * 地理解决方案数学模型，蝌蚪图模型。
 * @type {hmap.geosolution.math.TadpoleModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.TadpoleModel = class extends hmap.geosolution.math.MathModel {
    /**
     * TadpoleModel的构造函数。
     * @param options
     * @param {Boolean} options.needLoop 是否需要循环。默认值false。
     * @example
     * let tadpoleModel=new hmap.geosolution.math.TadpoleModel({
     *      needLoop:false
     * });
     */
    constructor(options) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.TadpoleModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        options = options || {};
        this._needLoop = options.needLoop === true ? options.needLoop : false;
        this._initDrawData();
        this._isStart = true;
    }

    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        this._posSize = opts.isRTE ? 6 : 3;
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._render = new hmap.render.TadpoleRender(this._gl, this._posSize);
        this._renderable = true;
    }

    /**
     * 添加Tadpole元素
     * @param {hmap.geosolution.cell.Tadpole} mathCell Tadpole元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.Tadpole)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 开启动画
     */
    setStart() {
        this._isStart = true;
    }

    /**
     * 暂停动画
     */
    setPause() {
        this._isStart = false;
    }

    /**
     * 更新绘制数据。
     * 注：非全量刷新请传入id。已绘制到图层上的数据id更新仅支持颜色和大小。更新顶点建议全部刷新。
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    //更新数据，更新颜色和大小
                    this._drawData.colors.splice(ind, 1, value._color);
                    this._drawData.sizes.splice(ind, 1, [value._maxSize, value._minSize]);
                    this._drawData.activeArray.splice(ind, 1, true);
                    this._drawData.offsets.splice(ind, 1, -value._frameCount * value._pointCount);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.splice(ind, 1);
                    this._drawData.tadpoleNums.splice(ind, 1);
                    this._drawData.indexMaps.splice(ind, 1);
                    this._drawData.colors.splice(ind, 1);
                    this._drawData.sizes.splice(ind, 1);
                    this._drawData.activeArray.splice(ind, 1);
                    this._drawData.offsets.splice(ind, 1);
                    //删除顶点和插值数量
                    let nums = this._drawData.numArray.slice(0, ind);
                    nums = nums.length === 0 ? 0 : nums.reduce((x, y) => x + y);
                    this._drawData.positions.splice(nums * this._posSize, this._drawData.numArray[ind] * this._posSize);
                    this._drawData.numArray.splice(ind, 1);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }

    _draw(uniforms) {
        if (this._drawData.idArray.length === 0) {
            return;
        }
        if ((!this._render._upBuffer) || (this._upFlag.isChange && (this._upFlag.update !== "R"))) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms) {
        if(this._drawData.idArray.length<=0||this._render._upBuffer===false)return;
        this._iteration(uniforms);
    }

    /**
     * 随绘制迭代数组偏移
     * @private
     */
    _iteration(uniforms) {

        let totalPointSum = 0, groupPointsSum = 0;         //蝌蚪当前开始位置的索引
        const cellCount = this._objMap.size;
        for (let i = 0; i < cellCount; i++) {
            const color = this._drawData.colors[i];//当前tadpole颜色
            const size = this._drawData.sizes[i];//当前大小范围
            const insertNum = this._drawData.numArray[i];//当前轨迹插入点总数
            const tadpoleNum = this._drawData.tadpoleNums[i];//当前tadpole组成点总数
            const indexMap = this._drawData.indexMaps[i];
            const id = this._drawData.idArray[i];
            if (!this._drawData.activeArray[i]) {
                totalPointSum += insertNum;
                groupPointsSum += tadpoleNum;
                continue;
            }
            let pointOffset = this._drawData.offsets[i];//tadpole组内点偏移量，初始为每个tadpole的组成点数的负值
            const offset = totalPointSum + (pointOffset < 0 ? 0 : pointOffset);
            const offsetOther = groupPointsSum;
            let drawCount = 0;
            if (pointOffset < 0) {
                drawCount = pointOffset + tadpoleNum;
            } else if (pointOffset > insertNum - tadpoleNum) {
                drawCount = insertNum - pointOffset;
            } else {
                drawCount = tadpoleNum;
            }

            if (drawCount > 0) {
                const dataParam = {
                    offsetPos: offset,
                    offsetOther: offsetOther,
                    count: drawCount
                };
                uniforms.color = color;
                uniforms.size = size;
                this._render.draw(uniforms, dataParam);
            }
            const currentIndex = pointOffset + tadpoleNum;//当前tadpole第一个点运行到的索引
            if (indexMap.has(currentIndex)) {
                this._objMap.get(id).returnPoint(indexMap.get(currentIndex));
            }
            totalPointSum += insertNum;
            groupPointsSum += tadpoleNum;
            if (this._isStart) {
                this._drawData.offsets[i]++;
            }
            if (this._drawData.offsets[i] > insertNum) { //终点判断
                if (this._needLoop) {      //循环状态
                    this._drawData.offsets[i] = -tadpoleNum;
                } else {
                    this._drawData.activeArray[i] = false;
                }
            }
        }
    }

    /**
     * 组装数据
     * @param value
     * @private
     */
    _assemble(value) {
        const inserts = value._insertCoords(this._isRTE, this._mapUnit,this._srid);
        this._drawData.idArray.push(value._id);
        this._drawData.numArray.push(inserts.count);
        this._drawData.tadpoleNums.push(value._frameCount * value._pointCount);
        this._drawData.indexMaps.push(inserts.returnIndexMap);
        this._drawData.positions.push(...inserts.positions);
        this._drawData.colors.push(value._color);
        this._drawData.sizes.push([value._maxSize, value._minSize]);
        this._drawData.activeArray.push(value._isActive);
        this._drawData.offsets.push(-value._frameCount * value._pointCount);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],//索引数组
            numArray: [],//tadpole运行轨迹插值后的数量
            tadpoleNums: [],//每个tadpole组成的数量
            indexMaps: [],//用于回调的索引Map。键为插值后索引，值为原数组索引
            positions: [],//插值后顶点数组
            colors: [],//颜色设置
            sizes: [],//大小设置
            activeArray: [],//活跃状态数组
            offsets: [],//当前蝌蚪行进到的点的偏移
        };
    }

};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型，可视域模型。
 * @type {hmap.geosolution.math.ViewshedModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.ViewshedModel=class extends hmap.geosolution.math.MathModel{
    /**
     * ViewshedModel的构造函数。
     * let viewshedModel=new hmap.geosolution.math.ViewshedModel();
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.ViewshedModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this._initDrawData();
        this._upFlag={
            index:null,
            isChange:false,
            update:null//"A":add,"R":change,"D":delete,"O"
        };
        this._glStatus={
            "CULL_FACE":false,
            "depthFunc":"LEQUAL"
        };
    }

    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        this._render=new hmap.render.ViewshedRender(this._gl);
        this._renderable=true;
    }

    /**
     * 添加Viewshed元素
     * @param {hmap.geosolution.cell.Viewshed} mathCell Viewshed元素
     */
    addMathCell(mathCell){
        if(!(mathCell instanceof hmap.geosolution.cell.Viewshed)){
            throw "MathCell and MathModel must match up!"
        }
        this._objMap.set(mathCell._id,mathCell);
    }

    /**
     * 更新绘制数据接口。当组成ViewshedModel的Viewshed更新时调用。
     * 注：
     * 添加、删除、修改单个Viewshed建议调用updateDrawData(viewshedCell.getId())；
     * 多个时建议调用updateDrawData()。前者为按标识符更新，后者为全量更新。
     * @param {String} id cell对象的唯一标识符
     */
    updateDrawData(id){
        if(id){
            //判断图层中是否存在数据
            if(this._objMap.get(id)){
                const value=this._objMap.get(id);
                let ind=this._drawData.idArray.indexOf(id);
                //add or change
                if(ind===-1){
                    this._assemble(value);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="A";
                }else{
                    this._drawData.a_orien.splice(3*ind,3,...value.getOrien());
                    this._drawData.a_radius.splice(ind,1,value.getRadius());
                    this._drawData.a_color.splice(ind*4,4,...value._colorArrayNormal);
                    this._drawData.a_scale.splice(3*ind,3,value._sidesNormal.sideH,value._sidesNormal.sideV,value._sidesNormal.h);
                    this._drawData.a_location.splice(3*ind,3,...value._getPositionArray());
                    this._drawData.a_colorSide.splice(ind*4,4,...value._colorArrayNormalS);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="R";
                }
            }else{
                //delete or null
                let ind=this._drawData.idArray.indexOf(id);
                if(ind!==-1){
                    this._drawData.idArray.splice(ind,1);
                    this._drawData.a_orien.splice(3*ind,3);
                    this._drawData.a_radius.splice(ind,1);
                    this._drawData.a_color.splice(ind*4,4);
                    this._drawData.a_scale.splice(3*ind,3);
                    this._drawData.a_location.splice(3*ind,3);
                    this._drawData.a_colorSide.splice(ind*4,4);
                    this._upFlag.index=ind;this._upFlag.isChange=true;this._upFlag.update="D";
                }
            }

        }else{
            //update all
            this._initDrawData();
            for(let value of this._objMap.values()){
                this._assemble(value);
            }
            this._upFlag.index=null;this._upFlag.isChange=true;this._upFlag.update="O";
        }
    }

    _draw(uniforms){
        if(this._drawData.idArray.length<=0)return;
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
        // this._tick(uniforms);
    }

    _tick(uniforms){
        if(this._drawData.idArray.length<=0||this._render._upBuffer===false)return;
        this._gl.disable(this._gl.CULL_FACE);
        this._gl.depthFunc(this._gl.LEQUAL);
        this._render._vpMatrix=uniforms.u_vpMatrix;//需要由layer更新
        this._render.draw(this._drawData,"TRIANGLES");
    }

    /**
     * 组装数据
     * @param value
     * @private
     */
    _assemble(value){
        this._drawData.idArray.push(value.getId());
        this._drawData.a_orien.push(...value.getOrien());
        this._drawData.a_radius.push(value.getRadius());
        this._drawData.a_color.push(...value._colorArrayNormal);
        this._drawData.a_scale.push(value._sidesNormal.sideH,value._sidesNormal.sideV,value._sidesNormal.h);
        this._drawData.a_location.push(...value._getPositionArray());
        this._drawData.a_colorSide.push(...value._colorArrayNormalS);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData(){
        this._drawData={
            idArray:[],//索引数组
            a_orien:[],//朝向向量
            a_radius:[],//可视半径
            a_scale:[],//模型缩放值
            a_color:[],//可视域模型颜色
            a_location:[],//可视域模型位置
            a_colorSide:[]//可视域模型描边颜色
        };
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案数学模型-水填充模型
 * @type {hmap.geosolution.math.FillWaterModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.FillWaterModel=class extends hmap.geosolution.math.MathModel{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.FillWaterModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._isChange = false;
        this.initTime = new Date().getTime()/1000;
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        const posSize=opts.isRTE?6:3;
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._render=new hmap.render.FillWaterRender(this._gl,posSize);
        this._renderable=true;
    }

    /**
     * 添加水填充特效
     * @param {hmap.geosolution.cell.FillWater} fillwater 水填充要素
     * @example
     * fillWaterModel.addMathCell(fillwater);
     */
    addMathCell(fillwater){
        if (!(fillwater instanceof hmap.geosolution.cell.FillWater)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.FillWater!");
        }
        if(!this._objMap.get(fillwater._id)){
            this._objMap.set(fillwater._id,fillwater);
            this._isChange = true;
        }
    }

    // /**
    //  * 根据id获取水填充要素
    //  * @param {Number} id 水填充要素id
    //  * @returns {hmap.geosolution.cell.FillWater} fillWater 水填充要素
    //  * @example
    //  * let fillWaterCell = fillWaterModel.getMathCellById(id);
    //  */
    // getMathCellById(id){
    //     return super.getMathCellById(id);
    // }
    //
    // /**
    //  * 获取全部的水填充要素
    //  * @returns {Array<hmap.geosolution.cell.FillWater>} 水填充要素数组
    //  * @example
    //  * let flowArray = fillWaterModel.getAllMathCells();
    //  * */
    // getAllMathCells(){
    //     return super.getAllMathCells();
    // }

    /**
     * 根据id从水填充特效model中移除水填充要素
     * @param {String} id 水填充要素id
     * @example
     * fillWaterModel.removeMathCellById(idStr);
     */
    removeMathCellById(id){
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空水填充特效model中的水填充要素
     * @example
     * fillWaterModel.removeAll()
     */
    removeAll(){
        super.removeAll();
        this._isChange = true;
    }

    /**
     * 将水填充数据添加到render的buffer中，每次数据变动都需要执行此方法
     * @private
     */
    _addDataToRender(){
        const positions = [], indices = [];
        const fillwaters = this.getAllMathCells();
        for(let i=0;i<fillwaters.length;i++){
            let dataItem = fillwaters[i].data;
            let positionCount = positions.length/3, dataIndices = dataItem.index;
            if(positionCount != 0){             //重新计算索引
                for(let j=0;j<dataIndices.length;j++){
                    dataItem.index[j] += positionCount;
                }
            }
            positions.push(...dataItem.a_position);
            indices.push(...dataItem.index);
        }
        this.count = indices.length;
        const dataMap = {
            positions:positions,
            indices:indices
        }
        this._render._addStaticBufferD(dataMap);               //向render中的buffer填充数据
        this._isChange = false;
    }

    _draw(uniforms){
        if(this._isChange){
            this._addDataToRender();
            this._isChange = false;
        }
        const gl = this._gl;                //状态应该放到tick
        gl.enable(gl.BLEND);                                //允许混合
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );                //加法混合
        gl.disable(gl.DEPTH_TEST);
        this._tick(uniforms)
    }

    _tick(uniforms={}){
        if(uniforms){
            uniforms.u_time = new Date().getTime()/1000 - this.initTime;
        }
        const drawOpt = {
            count:this.count
        };
        this._render.draw(uniforms,drawOpt);
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math=hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型-流线模型，大约可以支持150万条由2个坐标点组成的线段
 * @type {hmap.geosolution.math.FlowModel}
 * @extends {hmap.geosolution.math.MathModel}
 */
hmap.geosolution.math.FlowModel=class extends hmap.geosolution.math.MathModel{
    /**
     * 流线动画图层，与蝌蚪图类似，缺点是不能设置线宽
     * @param {object} options
     * @param {Boolean} options.needLoop 流线动画是否循环播放，默认为true，注意如果未设置循环播放，播放结束后流线对象虽然不再显示，但是并没有被删除，需要手动去移除和删除
     * @param {Boolean} options.colorAddition 颜色是否叠加显示，默认为true，红、绿、蓝三种颜色的线相交部分为白色，若为false，则显示为具有遮挡关系的三根线
     */
    constructor(options={}){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.FlowModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.framesParam = 0;                   //动画帧参数
        this._isChange = false;
        this._isStart = false;
        this.needLoop = options.hasOwnProperty("needLoop") ? options.needLoop : true;                      //是否循环播放
        this.colorAddition = options.hasOwnProperty("colorAddition") ? options.colorAddition:true;
    }

    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        const posSize=opts.isRTE?6:3;
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._render=new hmap.render.FlowRender(this._gl,posSize);
        this._renderable=true;
    }

    /**
     * 添加一个流线要素
     * @param {hmap.geosolution.cell.Flow} flow 流线要素
     * @throws 当参数flow的类型不对时，抛出异常。
     * @example
     * let coordSeq = [new hmap.basetype.Coordinate(120.13,30.19,0.0),new hmap.basetype.Coordinate(120.43,30.19,0.0)];
     * let flow = new hmap.geosolution.cell.Flow({coordSeq:coordSeq});
     * flowModel.addMathCell(flow);
     */
    addMathCell(flow){
        if (!(flow instanceof hmap.geosolution.cell.Flow)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.Flow!");
        }
        if(!this._objMap.get(flow._id)){
            this._objMap.set(flow._id,flow);
            this._isChange = true;
        }
    }

    // /**
    //  * 根据id获取流线要素
    //  * @param {Number} id 流线id
    //  * @returns {hmap.geosolution.cell.Flow} flow 流线要素
    //  * @example
    //  * let flow = flowModel.getMathCellById(id);
    //  */
    // getMathCellById(id){
    //     return super.getMathCellById(id);
    // }
    //
    // /**
    //  * 获取全部的流线要素
    //  * @returns {Array<hmap.geosolution.cell.Flow>} 流线要素数组
    //  * @example
    //  * let flowArray = flowModel.getAllMathCells();
    //  */
    // getAllMathCells(){
    //     return super.getAllMathCells();
    // }

    /**
     * 根据id从流线model中移除流线要素
     * @param {String} id 流线要素id
     */
    removeMathCellById(id){
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空流线model中的流线要素
     * @example
     * flowModel.removeAll()
     */
    removeAll(){
        super.removeAll();
        this._isChange = true;
    }

    _draw(uniforms){
        if(this._isChange){
            this._addDataToRender();
            this._isChange = false;
        }

        /*const gl = this._gl;
        gl.enable(gl.BLEND);            //允许混合
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );                //加法混合
        gl.disable(gl.DEPTH_TEST);*/

        /*const blend = this.getBlendStatus();
        blend.setFunc({
            rgbSrcFactor:hmap.status.BlendFactor.SRC_ALPHA,         //颜色叠加混合
            rgbDstFactor: hmap.status.BlendFactor.ONE,
            rgbMode: hmap.status.BlendFunc.FUNC_ADD
        })
        blend.active(this.gl);

        if(!this._isStart){
            if(uniforms){
                uniforms.u_framesParam = this.framesParam;
                uniforms.u_needLoop = this.needLoop;
            }
            const drawOpt = {
                count:this.count
            };
            this._render.draw(uniforms,drawOpt);
        }*/
        this._tick(uniforms);
    }

    _tick(uniforms={}){
        if(!this._isStart) return;

        const gl = this._gl;
        if(!this.colorAddition){
            gl.enable(gl.BLEND);
            gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
        }else{
            gl.enable(gl.BLEND);            //允许混合
            gl.blendEquation( gl.FUNC_ADD );
            gl.blendFunc( gl.SRC_ALPHA, gl.ONE );                //加法混合
            gl.disable(gl.DEPTH_TEST);
        }
        if(uniforms){
            uniforms.u_framesParam = this.framesParam;
            uniforms.u_needLoop = this.needLoop;
        }
        const drawOpt = {
            count:this.count
        };
        this._render.draw(uniforms,drawOpt);
        this.framesParam++;
    }

    /**
     * 动画开启
     */
    start() {
        this._isStart = true;
    }

    /**
     * 动画暂停
     */
    pause() {
        this._isStart = false;
    }

    /**
     * 将流线数据添加到render的buffer中，每次删除或者更新操作都需要执行此方法
     * @private
     */
    _addDataToRender(){
        const positions = [], colors=[], prevFrameNums = [], currFrameNums = [], nextFrameNums = [],
            routeFrameSums=[], selfFrameSums=[], startFrameNums=[],offsetPerFrames=[];
        let count = 0;
        const flows = this.getAllMathCells();
        for(let i=0;i<flows.length;i++){
            const flow = flows[i];
            if(!flow.dataReady){
                flow.processData(this._srid);
            }
            let flowData = flow.data;
            const xyzPositions = flowData.positions, flowColors=flowData.colors, flowPrevFrameNums = flowData.prevFrameNums,
                flowCurrFrameNums = flowData.currFrameNums, flowNextFrameNums=flowData.nextFrameNums,flowRouteFrameSums=flowData.routeFrameSums,
                flowSelfFrameSums=flowData.selfFrameSums, flowOffsetPerFrames=flowData.offsetPerFrames;
            for(let j=0;j<xyzPositions.length;j++){
                const xyzPosition = xyzPositions[j];
                if (this._isRTE) {
                    const xx = hmap.util.Correction.float32FromDouble64(xyzPosition[0], this._mapUnit);
                    const yy = hmap.util.Correction.float32FromDouble64(xyzPosition[1], this._mapUnit);
                    const zz = hmap.util.Correction.float32FromDouble64(xyzPosition[2], this._mapUnit);
                    positions.push(xx[0], yy[0], zz[0], xx[1], yy[1], zz[1]);
                } else {
                    positions.push(xyzPosition[0], xyzPosition[1], xyzPosition[2]);
                }
            }
            colors.push(...flowColors);
            prevFrameNums.push(...flowPrevFrameNums);
            currFrameNums.push(...flowCurrFrameNums);
            nextFrameNums.push(...flowNextFrameNums);
            routeFrameSums.push(...flowRouteFrameSums);
            selfFrameSums.push(...flowSelfFrameSums);
            offsetPerFrames.push(...flowOffsetPerFrames);

            const flowPointNum = flow.drawPointNum;
            if(!flow.startFrameNums){
                flow.startFrameNums = new Array(flowPointNum).fill(this.framesParam + flow.frameDelay);
            }
            startFrameNums.push(...flow.startFrameNums);
            count += flowPointNum;
        }
        this.count = count;
        const dataMap = {
            positions:positions,                //顶点
            colors:colors,                      //顶点颜色
            prevFrameNums:prevFrameNums,        //上一个顶点帧号
            currFrameNums:currFrameNums,        //当前顶点帧号
            nextFrameNums:nextFrameNums,        //下一个顶点帧号
            routeFrameSums:routeFrameSums,      //整个路径的帧总数
            selfFrameSums:selfFrameSums,        //流线自身的帧总数
            startFrameNums:startFrameNums,      //开始的帧数
            offsetPerFrames:offsetPerFrames     //位置偏移量vec3
        }
        this._render._addStaticBufferD(dataMap);               //向render中的buffer填充数据
        this.start();
    }
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
hmap.geosolution.math = hmap.geosolution.math||{};
/**
 * 地理解决方案数学模型-粒子模型，以大量粒子的运动来表达烟、火、喷泉、消防喷水等效果
 * @type {hmap.geosolution.math.ParticleModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.ParticleModel=class extends hmap.geosolution.math.MathModel{
    /**
     * 构造函数
     */
    constructor(name="粒子图层",options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.ParticleModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
    }

    /**
     * 初始化render
     * @private
     * */
    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        const posSize=opts.isRTE?6:3;
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._render=new hmap.render.ParticleRender(this._gl,posSize);
        this._renderable=true;
    }

    /**
     * 添加粒子对象
     * @param {hmap.geosolution.cell.Particle} particle 粒子对象
     * @example
     * particleModel.addMathCell(particle);
     * */
    addMathCell(particle){
        if (!(particle instanceof hmap.geosolution.cell.Particle)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.Particle!");
        }
        if(!this._objMap.get(particle._id)){
            this._objMap.set(particle._id,particle);
        }
    }

    // /**
    //  * 根据id获取粒子对象
    //  * @param {Number} id 粒子对象id
    //  * @returns {hmap.geosolution.cell.Particle} particle 粒子对象
    //  * @example
    //  * let particle = particleModel.getMathCellById(id);
    //  */
    // getMathCellById(id){
    //     return super.getMathCellById(id);
    // }
    //
    // /**
    //  * 获取全部的粒子对象
    //  * @returns {Array<hmap.geosolution.cell.particle>} 粒子对象数组
    //  * @example
    //  * let particleArray = particleModel.getAllMathCells();
    //  * */
    // getAllMathCells(){
    //     return super.getAllMathCells();
    // }
    //
    // /**
    //  * 根据id从粒子model中移除粒子对象
    //  * @param {String} id 粒子对象id
    //  * @example
    //  * particleModel.removeMathCellById(id);
    //  * */
    // removeMathCellById(id){
    //     super.removeMathCellById(id);
    // }
    //
    // /**
    //  * 清空粒子model中的粒子对象
    //  * @example
    //  * particleModel.removeAll()
    //  * */
    // removeAll(){
    //     super.removeAll();
    // }

    /**
     * 绘制粒子
     * @private
     * */
    _draw(uniforms){
        this._tick(uniforms);           //状态放到tick里面，也应该放到tick
    }

    /**
     * 动画
     * @private
     * */
    _tick(uniforms={}){
        const gl = this._gl;
        gl.enable(gl.BLEND);            //允许混合
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );                //加法混合
        gl.disable(gl.DEPTH_TEST);

        const particles = this.getAllMathCells();
        for(let particle of particles){
            if(!particle.resetByUnit){
                particle.resetByMapUnit(this._mapUnit, this._isRTE);
            }
            const dataMap = particle.dataMap, color = particle.normalColorArr, scale = particle.scale,
                pointSize = [particle.pointRadius]*scale,offsetCount = Math.floor(particle.pointNum/particle.controlNum);
            particle.offsetTimes++
            const ctrlOffset = particle.offsetTimes, gravity = particle.gravity,
                inertia = particle.inertia,originPosition = particle.coordArr;
            const privateUniforms = {
                u_vpMatrix:uniforms.u_vpMatrix,
                u_color: color,
                u_size: [pointSize],
                u_offsetCount:[offsetCount],
                u_ctrlOffset:[ctrlOffset],
                u_originPosition:originPosition,
                u_gravity:gravity,
                u_inertia:inertia,
                u_ifRTE:uniforms.u_ifRTE,
                u_unit:uniforms.u_unit,
                u_camera:uniforms.u_camera,
                u_res:uniforms.u_res
            };
            this._render.draw(dataMap,privateUniforms);
        }
    }
};
;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 地理解决方案数学模型-线纹理模型
 * @type {hmap.geosolution.math.TrailModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.TrailModel=class extends hmap.geosolution.math.MathModel{
    /**
     * 构造函数
     */
    constructor(options){
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.TrailModel";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._isChange = false;
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl,opts){
        super._initRenderOpts(gl,opts);
        const posSize=opts.isRTE?6:3;
        this._isRTE=opts.isRTE===true?opts.isRTE:false;
        this._render=new hmap.render.TrailRender(this._gl,posSize);
        this._renderable=true;
    }

    /**
     * 添加线纹理动画
     * @param {hmap.geosolution.cell.Trail} trail 线纹理动画
     * @example
     * TrailModel.addMathCell(trail);
     */
    addMathCell(trail){
        if (!(trail instanceof hmap.geosolution.cell.Trail)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.Trail!");
        }
        if(!this._objMap.get(trail._id)){
            this._objMap.set(trail._id,trail);
            let symbolSrc = trail.symbolSrc;
            this._render.addSymbolToTexture(symbolSrc);
        }
    }

    // /**
    //  * 根据id获取线纹理动画
    //  * @param {Number} id 线纹理动画id
    //  * @returns {hmap.geosolution.cell.Trail} trail 线纹理动画
    //  * @example
    //  * let trail = TrailModel.getMathCellById(id);
    //  */
    // getMathCellById(id){
    //     return super.getMathCellById(id);
    // }
    //
    // /**
    //  * 获取全部的线纹理动画
    //  * @returns {Array<hmap.geosolution.cell.Trail>} 线纹理动画数组
    //  * @example
    //  * let trailArray = TrailModel.getAllMathCells();
    //  * */
    // getAllMathCells(){
    //     return super.getAllMathCells();
    // }
    //
    // /**
    //  * 根据id从线纹理动画model中移除线纹理动画要素
    //  * @param {String} id 线纹理动画id
    //  * @example
    //  * TrailModel.removeMathCellById(idStr);
    //  */
    // removeMathCellById(id){
    //     super.removeMathCellById(id);
    // }
    //
    // /**
    //  * 清空线纹理动画model中的线纹理动画
    //  * @example
    //  * trailModel.removeAll()
    //  */
    // removeAll(){
    //     super.removeAll();
    // }

    /**
     * 绘制线纹理动画
     * @private
     */
    _drawTrails(uniforms={}){
        const gl = this._gl;                        //状态应该放到tick
        gl.enable(gl.BLEND);                                //允许混合
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );                //加法混合
        gl.disable(gl.DEPTH_TEST);

        const trails = this.getAllMathCells();
        for(let i=0;i<trails.length;i++){
            let trail= trails[i];
            if(!trail.dataReady){
                trail.processData(this._isRTE, this._mapUnit);
            }
            let dataItem = trail.dataMap;
            uniforms.u_uvOffset = trail.uvOffset;
            uniforms.u_lineWidth = trail.lineWidth;
            uniforms.u_placeLength = trail.placeLength;
            uniforms.u_placeSpace = trail.placeSpace;
            uniforms.u_showLine = trail.showLine;
            uniforms.u_lineColor = trail.colorArr;
            uniforms.u_useAlpha = trail.useAlpha;
            const positions = dataItem.positions, previous = dataItem.previous,
                next = dataItem.next, side = dataItem.side, uvs = dataItem.uvs, indices = dataItem.indices, symbolSrc=dataItem.symbolSrc;
            const dataMap = {
                positions:positions,
                previous:previous,
                next:next,
                side:side,
                uvs:uvs,
                indices:indices,
                symbolSrc:symbolSrc
            }
            this._render.draw(dataMap, uniforms);
            if(trail.isAnimate){
                trail.uvOffset += 0.01 * trail.speed;
                if(trail.uvOffset > 1.0){
                    trail.uvOffset = trail.uvOffset - 1.0;
                }
            }
        }
    }

    _draw(uniforms){
        this._drawTrails(uniforms);
    }

    _tick(uniforms={}){
        this._drawTrails(uniforms);
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 地理解决方案数学模型-雨模型
 * @type {hmap.geosolution.math.RainModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.RainModel = class extends hmap.geosolution.math.MathModel {
    /**
     * 构造函数
     * @param {Object} options 选项
    * @param {Number|String} options.windDirect 枚举值，表示风向，取值为
       东风: "EAST"||hmap.geosolution.cell.WindDirect.EAST,
       南风: "SOUTH"||hmap.geosolution.cell.WindDirect.SOUTH,
       西风: "WEST"||hmap.geosolution.cell.WindDirect.WEST,
       北风: "NORTH"||hmap.geosolution.cell.WindDirect.NORTH,
       东南风:"EAST_SOUTH"||hmap.geosolution.cell.WindDirect.EAST_SOUTH,
       西南风:"WEST_SOUTH"||hmap.geosolution.cell.WindDirect.WEST_SOUTH,
       东北风:"EAST_NORTH"||hmap.geosolution.cell.WindDirect.EAST_NORTH,
       西北风:"WEST_NORTH"||hmap.geosolution.cell.WindDirect.WEST_NORTH,默认无风
     * @param {Number} options.windLevel  正整数，取值范围为（0-12）分别对应：（0无风、1软风、2轻风、3微风、4和风、5劲风、6强风、7疾风、8大风、9烈风、10狂风、11暴风、12飓风）,默认无风
     */
    constructor(options = {}) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.RainModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._isChange = false;
        this._startTime = new Date().getTime();
        if (options.windLevel && (!/^\d+$/.test(options.windLevel) || options.windLevel < 0 || options.windLevel > 12)) {
            throw new Error('options.windLevel must be a integer between 0 and 12!');
        }
        const windDirectList = [
            "EAST",
            "SOUTH",
            "WEST",
            "NORTH",
            "EAST_SOUTH",
            "WEST_SOUTH",
            "EAST_NORTH",
            "WEST_NORTH",
        ]
        if (options.windLevel && (!/^\d+$/.test(options.windLevel) || options.windLevel < 0 || options.windLevel > 12)) {
            throw new Error('options.windLevel must be a integer between 0 and 12!');
        }
        if (options.windDirect && windDirectList.indexOf(options.windDirect) !== -1) {
            this.u_ewWind = hmap.geosolution.cell.Wind[options.windDirect].ewWind;
            this.u_nsWind = hmap.geosolution.cell.Wind[options.windDirect].nsWind;
            const windLevelTemp = options.windLevel != undefined ? options.windLevel : 0;
            this.u_windForce = windLevelTemp * 0.6 / 12;
        } else {
            this.u_ewWind = 0;
            this.u_nsWind = 0;
            this.u_windForce = 0;
        }
        this._initDrawData();
    }

    /**
     * 设置风向
     * @param {String} windDirect 枚举值，表示风向，取值为
     东风: "EAST"||hmap.geosolution.cell.WindDirect.EAST,
     南风: "SOUTH"||hmap.geosolution.cell.WindDirect.SOUTH,
     西风: "WEST"||hmap.geosolution.cell.WindDirect.WEST,
     北风: "NORTH"||hmap.geosolution.cell.WindDirect.NORTH,
     东南风:"EAST_SOUTH"||hmap.geosolution.cell.WindDirect.EAST_SOUTH,
     西南风:"WEST_SOUTH"||hmap.geosolution.cell.WindDirect.WEST_SOUTH,
     东北风:"EAST_NORTH"||hmap.geosolution.cell.WindDirect.EAST_NORTH,
     西北风:"WEST_NORTH"||hmap.geosolution.cell.WindDirect.WEST_NORTH
     */
    setWindDir(windDirect) {
        if (windDirect) {
            this.u_ewWind = hmap.geosolution.cell.Wind[windDirect].ewWind;
            this.u_nsWind = hmap.geosolution.cell.Wind[windDirect].nsWind;
        } else {
            this.u_ewWind = 0;
            this.u_nsWind = 0;
            this.u_windForce = 0;
        }
    }

    /**
     * 设置风力
     * @param {Number} windLevel  风力，正整数，取值范围为（0-12）分别对应：（0无风、1软风、2轻风、3微风、4和风、5劲风、6强风、7疾风、8大风、9烈风、10狂风、11暴风、12飓风）
     */
    setWindLevel(windLevel) {
        this.u_windForce = 0.6 / 12 * (windLevel ? windLevel : 0);
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        const posSize = opts.isRTE ? 6 : 3;
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._render = new hmap.render.RainRender(this._gl, posSize);
        this._renderable = true;
    }

    /**
     * 添加雨特效
     * @param {hmap.geosolution.cell.Rain} rain 雨要素
     * @example
     * rainModel.addMathCell(rain);
     */
    addMathCell(rain) {
        if (!(rain instanceof hmap.geosolution.cell.Rain)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.Rain!");
        }
        if (!this._objMap.get(rain._id)) {
            this._objMap.set(rain._id, rain);
            this._isChange = true;
            rain._setMap(this._map);
        }
    }

    /**
     * 根据id从雨特效model中移除雨要素
     * @param {String} id 雨要素id
     * @example
     * rainModel.removeMathCellById(idStr);
     */
    removeMathCellById(id) {
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空雨特效model中的雨要素
     * @example
     * fillWaterModel.removeAll()
     */
    removeAll() {
        super.removeAll();
        this._isChange = true;
    }

    /**
     * 更新绘制数据接口。
     * 添加单个数据建议调用updateDrawData(rainCell.getId());
     * 删除更新调用updateDrawData()刷新全部数据
     * @param {String} id cell对象的唯一标识符
     * @example
     * //在已绘制的RainModel中添加或删除一个cell（建议用法）
     * rainModel.updateDrawData(rainCell.getId());
     * //删除或添加多个rainCell后更新绘制数据
     * rainModel.updateDrawData();
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    //更新和顶点无关的信息
                    // const tex=this._drawData.textures[ind];
                    // if(value._ifTex) {
                    //     this._drawData.textures.splice(ind, 1, this._getGLTexture(value._texture));
                    // }else{
                    //     this._drawData.textures.splice(ind,1,"");
                    // }
                    // if(tex!=="")this._gl.deleteTexture(tex);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.length = 0;
                    this._drawData.a_position.length = 0;
                    this._drawData.a_timeDelay.length = 0;
                    this._drawData.a_number.length = 0;
                    this._drawData.a_size.length = 0;
                    this._drawData.a_speed.length = 0;
                    this._drawData.a_color.length = 0;
                    this._drawData.u_initRes = null;
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }


    _draw(uniforms) {
        if (this._drawData.idArray.length === 0) return;
        this._startTime = this._startTime || window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
    }

    _tick(uniforms = {}) {

        if (this._drawData.idArray.length === 0) return;
        this._gl.disable(this._gl.CULL_FACE);
        const u_time = (this._startTime ? window.Date.now() - this._startTime : 0) / 1000;
        const {
            u_ewWind,
            u_nsWind,
            u_windForce,
        } = this;
        const {
            u_initRes
        } = this._drawData;
        Object.assign(uniforms, {
            u_ewWind,
            u_nsWind,
            u_windForce,
            u_time,
            u_initRes
        });
        this._render.draw(this._drawData, uniforms);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],
            a_position: [],
            a_timeDelay: [],
            a_number: [],
            a_size: [],
            a_speed: [],
            a_color: [],
            u_initRes: null,
        };
    }

    /**
     * 组装数据
     * @param {hmap.geosolution.cell.Rain} rainCell  rain单元
     * @private
     */
    _assemble(rainCell) {
        rainCell._initVertex();
        this._drawData.idArray.push(rainCell._id);
        this._drawData.a_position.push(...rainCell.a_position);
        this._drawData.a_timeDelay.push(...rainCell.a_timeDelay);
        this._drawData.a_number.push(...rainCell.a_number);
        this._drawData.a_size.push(...rainCell.a_size);
        this._drawData.a_speed.push(...rainCell.a_speed);
        this._drawData.a_color.push(...rainCell.a_color);
        this._drawData.u_initRes = rainCell.u_initRes;
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 地理解决方案数学模型-雪模型
 * @type {hmap.geosolution.math.SnowModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.SnowModel = class extends hmap.geosolution.math.MathModel {
    /**
     * 构造函数
     * @param {Object} options 选项
     * @param {String} options.windDirect  枚举值，表示风向，取值为
     东风: "EAST"||hmap.geosolution.cell.WindDirect.EAST,
     南风: "SOUTH"||hmap.geosolution.cell.WindDirect.SOUTH,
     西风: "WEST"||hmap.geosolution.cell.WindDirect.WEST,
     北风: "NORTH"||hmap.geosolution.cell.WindDirect.NORTH,
     东南风:"EAST_SOUTH"||hmap.geosolution.cell.WindDirect.EAST_SOUTH,
     西南风:"WEST_SOUTH"||hmap.geosolution.cell.WindDirect.WEST_SOUTH,
     东北风:"EAST_NORTH"||hmap.geosolution.cell.WindDirect.EAST_NORTH,
     西北风:"WEST_NORTH"||hmap.geosolution.cell.WindDirect.WEST_NORTH,其他取值都视为无效值
     * @param {Number} options.windLevel  整数，取值范围为（0-12）分别对应：（0无风、1软风、2轻风、3微风、4和风、5劲风、6强风、7疾风、8大风、9烈风、10狂风、11暴风、12飓风）
     */
    constructor(options = {}) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.SnowModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._isChange = false;
        this._startTime = new Date().getTime();
        if (options.windLevel && (!/^\d+$/.test(options.windLevel) || options.windLevel < 0 || options.windLevel > 12)) {
            throw new Error('options.windLevel must be a integer between 0 and 12!');
        }
        const windDirectList = [
            "EAST",
            "SOUTH",
            "WEST",
            "NORTH",
            "EAST_SOUTH",
            "WEST_SOUTH",
            "EAST_NORTH",
            "WEST_NORTH",
        ]
        if (options.windDirect && windDirectList.indexOf(options.windDirect) !== -1) {
            this.u_ewWind = hmap.geosolution.cell.Wind[options.windDirect].ewWind;
            this.u_nsWind = hmap.geosolution.cell.Wind[options.windDirect].nsWind;
            this.u_windForce = 0.8 / 12 * (options.windLevel ? options.windLevel : 0);
        } else {
            this.u_ewWind = 0;
            this.u_nsWind = 0;
            this.u_windForce = 0;
        }
        
        
        this._initDrawData();
    }

    /**
     * 设置风向
     * @param {String} windDirect 枚举值，表示风向，取值为
     东风: "EAST"||hmap.geosolution.cell.WindDirect.EAST,
     南风: "SOUTH"||hmap.geosolution.cell.WindDirect.SOUTH,
     西风: "WEST"||hmap.geosolution.cell.WindDirect.WEST,
     北风: "NORTH"||hmap.geosolution.cell.WindDirect.NORTH,
     东南风:"EAST_SOUTH"||hmap.geosolution.cell.WindDirect.EAST_SOUTH,
     西南风:"WEST_SOUTH"||hmap.geosolution.cell.WindDirect.WEST_SOUTH,
     东北风:"EAST_NORTH"||hmap.geosolution.cell.WindDirect.EAST_NORTH,
     西北风:"WEST_NORTH"||hmap.geosolution.cell.WindDirect.WEST_NORTH
     */
    setWindDir(windDirect) {
        if (windDirect) {
            this.u_ewWind = hmap.geosolution.cell.Wind[windDirect].ewWind;
            this.u_nsWind = hmap.geosolution.cell.Wind[windDirect].nsWind;
        } else {
            this.u_ewWind = 0;
            this.u_nsWind = 0;
            this.u_windForce = 0;
        }
    }

    /**
     * 设置风力
     * @param {Number} windLevel  风力，正整数，取值范围为（1-12）分别对应：（0无风、1软风、2轻风、3微风、4和风、5劲风、6强风、7疾风、8大风、9烈风、10狂风、11暴风、12飓风）
     */
    setWindLevel(windLevel) {
        this.u_windForce = 0.8 / 12 * (windLevel ? windLevel : 0);
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        const posSize = opts.isRTE ? 6 : 3;
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._render = new hmap.render.SnowRender(this._gl, posSize);
        this._renderable = true;
    }

    /**
     * 添加雪特效
     * @param {hmap.geosolution.cell.Snow} snow 雪要素
     * @example
     * rainModel.addMathCell(snow);
     */
    addMathCell(snow) {
        if (!(snow instanceof hmap.geosolution.cell.Snow)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.Snow!");
        }
        if (!this._objMap.get(snow._id)) {
            this._objMap.set(snow._id, snow);
            this._isChange = true;
            snow._setMap(this._map);
        }
    }

    /**
     * 根据id从雪特效model中移除雪要素
     * @param {String} id 雪要素id
     * @example
     * rainModel.removeMathCellById(idStr);
     */
    removeMathCellById(id) {
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空雪特效model中的雪要素
     * @example
     * fillWaterModel.removeAll()
     */
    removeAll() {
        super.removeAll();
        this._isChange = true;
    }

    /**
     * 更新绘制数据接口。
     * 添加单个数据建议调用updateDrawData(snowCell.getId());
     * 删除更新调用updateDrawData()刷新全部数据
     * @param {String} id cell对象的唯一标识符
     * @example
     * //在已绘制的SnowModel中添加或删除一个cell（建议用法）
     * snowModel.updateDrawData(snowCell.getId());
     * //删除或添加多个snowCell后更新绘制数据
     * snowModel.updateDrawData();
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    //更新和顶点无关的信息
                    // const tex=this._drawData.textures[ind];
                    // if(value._ifTex) {
                    //     this._drawData.textures.splice(ind, 1, this._getGLTexture(value._texture));
                    // }else{
                    //     this._drawData.textures.splice(ind,1,"");
                    // }
                    // if(tex!=="")this._gl.deleteTexture(tex);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.length = 0;
                    this._drawData.a_position.length = 0;
                    this._drawData.a_timeDelay.length = 0;
                    this._drawData.a_size.length = 0;
                    this._drawData.a_speed.length = 0;
                    this._drawData.a_rotation.length = 0;
                    this._drawData.u_initRes.length = 0;
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }


    _draw(uniforms) {
        if (this._drawData.idArray.length === 0) return;
        this._startTime = this._startTime || window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addChangeBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
    }

    _tick(uniforms = {}) {

        if (this._drawData.idArray.length === 0) return;
        this._gl.disable(this._gl.CULL_FACE);
        const u_time = (this._startTime ? window.Date.now() - this._startTime : 0) / 1000;

        const {
            u_ewWind,
            u_nsWind,
            u_windForce,
        } = this;
        Object.assign(uniforms, {
            u_ewWind,
            u_nsWind,
            u_windForce,
            u_time
        });
        this._render.draw(this._drawData, uniforms);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],
            a_position: [],
            a_timeDelay: [],
            a_size: [],
            a_speed: [],
            a_rotation: [],
            u_initRes: [],
            textures: []
        };
    }

    /**
     * 组装数据
     * @param {hmap.geosolution.cell.Snow} snowCell  snow单元
     * @private
     */
    _assemble(snowCell) {
        snowCell._calculateVertex();
        this._drawData.idArray.push(snowCell._id);
        this._drawData.a_position.push(...snowCell.a_position);
        this._drawData.a_timeDelay.push(...snowCell.a_timeDelay);
        this._drawData.a_size.push(...snowCell.a_size);
        this._drawData.a_speed.push(...snowCell.a_speed);
        this._drawData.a_rotation.push(...snowCell.a_rotation);
        snowCell._texturePromise.then(snowCell => {
            this._drawData.textures.push(this._getGLTexture(snowCell._textureImage));
        })
    }

    /**
     * 绑定纹理，并返回webGLTexture
     * @param img
     * @returns {*}
     * @private
     */
    _getGLTexture(img) {
        return this._render._createTexture(img).texture;
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 地理解决方案数学模型-网格热力图模型
 * @type {hmap.geosolution.math.GridHeatModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.GridHeatModel = class extends hmap.geosolution.math.MathModel {
    /**
     * 构造函数
     * @param {Object} options 选填项
     * @param {Number} options.dimension 选填项[2,3]，二维网格还是三维网格热力图,默认为2 
     */
    constructor(options = {
        dimension: 2
    }) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.GridHeatModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        this._isChange = false;
        if (options.dimension && !Number.isFinite(options.dimension)) {
            throw new Error("options.dimension must be number!");
        }
        if (options.dimension && [2, 3].indexOf(options.dimension) === -1) {
            throw new Error("options.dimension must be 2 or 3!");
        }
        this._dimension = options.dimension;
        this._current = 0;
        this._startTime = new Date().getTime();
        this._initDrawData();
    }

    /**
     * 设置model维度
     * @param {Number} dimension model维度
     */
    setDimension(dimension=2){
        if (dimension && !Number.isFinite(dimension)) {
            throw new Error("dimension must be number!");
        }
        if (dimension && [2, 3].indexOf(dimension) === -1) {
            throw new Error("dimension must be 2 or 3!");
        }
        this._dimension = dimension;
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        const posSize = opts.isRTE ? 6 : 3;
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._render = new hmap.render.GridHeatRender(this._gl, posSize);
        this._renderable = true;
    }

    /**
     * 添加网格热力图
     * @param {hmap.geosolution.cell.GridHeat} gridHeat 网格热力图要素
     * @example
     * gridHeatModel.addMathCell(gridHeat);
     */
    addMathCell(gridHeat) {
        if (!(gridHeat instanceof hmap.geosolution.cell.GridHeat)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.GridHeat!");
        }
        if (!this._objMap.get(gridHeat._id)) {
            this._objMap.set(gridHeat._id, gridHeat);
            this._isChange = true;
            gridHeat._map = this._map;
        }
    }

    /**
     * 根据id从网格热力图model中移除网格热力图要素
     * @param {String} id 网格热力图要素id
     * @example
     * gridHeatModel.removeMathCellById(idStr);
     */
    removeMathCellById(id) {
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空网格热力图model中的网格热力图要素
     * @example
     * gridHeatModel.removeAll()
     */
    removeAll() {
        super.removeAll();
        this._isChange = true;
    }

    /**
     * 更新绘制数据接口。
     * 添加单个数据建议调用updateDrawData(gridHeatCell.getId());
     * 删除更新调用updateDrawData()刷新全部数据
     * @param {String} id cell对象的唯一标识符
     * @example
     * //在已绘制的GridHeatModel中添加或删除一个cell（建议用法）
     * gridHeatModel.updateDrawData(gridHeatCell.getId());
     * //删除或添加多个gridHeatCell后更新绘制数据
     * gridHeatModel.updateDrawData();
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    value._calculateVertex(this._dimension,this._current);
                    this._current = value._current;
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.length = 0;
                    this._drawData.a_positionH.length = 0;
                    this._drawData.a_positionL.length = 0;
                    this._drawData.a_color.length = 0;
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                value._calculateVertex(this._dimension,this._current);
                this._current = value._current;
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }


    /**
     * @private
     */
    _draw() {
        this._current=0;
        if (this._drawData.idArray.length === 0) return;
        this._startTime = this._startTime || window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addStaticBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
    }

    /**
     * @private
     * @param {Object} uniforms 
     */
    _tick(uniforms = {}) {

        if (this._drawData.idArray.length === 0 || this._render._upBuffer === false) return;
        this._gl.disable(this._gl.CULL_FACE);
        this._render._draw(this._drawData, uniforms, this._dimension);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],
            a_positionH: [],
            a_positionL: [],
            a_color: [],
            a_indices: []
        };
    }

    /**
     * 组装数据
     * @param {hmap.geosolution.cell.GridHeat} gridHeat  gridHeat单元
     * @private
     */
    _assemble(gridHeat) {
        this._drawData.idArray.push(gridHeat._id);
        this._drawData.a_positionH.push(...gridHeat.a_positionH);
        this._drawData.a_positionL.push(...gridHeat.a_positionL);
        this._drawData.a_color.push(...gridHeat.a_color);
        this._drawData.a_indices.push(...gridHeat.a_indices);
    }
};;"use strict";
hmap.geosolution = hmap.geosolution || {};
/**
 * 地理解决方案数学模型-网格热力图模型
 * @type {hmap.geosolution.math.HexGridHeatModel}
 * @extends hmap.geosolution.math.MathModel
 */
hmap.geosolution.math.HexGridHeatModel = class extends hmap.geosolution.math.MathModel {
    /**
     * 构造函数
     * @param {Object} options 选填项
     * @param {Number} options.dimension 选填项[2,3]，二维蜂窝还是三维蜂窝热力图,默认为2 
     */
    constructor(options = {
        dimension: 2
    }) {
        super(options);
        this.CLASS_NAME = "hmap.geosolution.math.HexGridHeatModel";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME); //自动生成
        if (options.dimension && !Number.isFinite(options.dimension)) {
            throw new Error("options.dimension must be number!");
        }
        if (options.dimension && [2, 3].indexOf(options.dimension) === -1) {
            throw new Error("options.dimension must be 2 or 3!");
        }
        this._dimension = options.dimension;
        this._current = 0;
        this._isChange = false;
        this._startTime = new Date().getTime();
        this._initDrawData();
    }

    /**
     * 设置model维度
     * @param {Number} dimension model维度
     */
    setDimension(dimension=2) {
        if (dimension && !Number.isFinite(dimension)) {
            throw new Error("dimension must be number!");
        }
        if (dimension && [2, 3].indexOf(dimension) === -1) {
            throw new Error("dimension must be 2 or 3!");
        }
        this._dimension = dimension;
    }

    /**
     * 初始化render
     * @private
     */
    _initRenderOpts(gl, opts) {
        super._initRenderOpts(gl, opts);
        const posSize = opts.isRTE ? 6 : 3;
        this._isRTE = opts.isRTE === true ? opts.isRTE : false;
        this._render = new hmap.render.HexGridHeatRender(this._gl, posSize);
        this._renderable = true;
    }

    /**
     * 添加网格热力图
     * @param {hmap.geosolution.cell.HexGridHeat} hexGridHeat 网格热力图要素
     * @example
     * hexGridHeatModel.addMathCell(hexGridHeat);
     */
    addMathCell(hexGridHeat) {
        if (!(hexGridHeat instanceof hmap.geosolution.cell.HexGridHeat)) {
            throw TypeError("parameter must be a hmap.geosolution.cell.HexGridHeat!");
        }
        if (!this._objMap.get(hexGridHeat._id)) {
            this._objMap.set(hexGridHeat._id, hexGridHeat);
            this._isChange = true;
            hexGridHeat._map = this._map;
        }
    }

    /**
     * 根据id从网格热力图model中移除网格热力图要素
     * @param {String} id 网格热力图要素id
     * @example
     * hexGridHeatModel.removeMathCellById(idStr);
     */
    removeMathCellById(id) {
        super.removeMathCellById(id);
        this._isChange = true;
    }

    /**
     * 清空网格热力图model中的网格热力图要素
     * @example
     * hexGridHeatModel.removeAll()
     */
    removeAll() {
        super.removeAll();
        this._isChange = true;
    }

    /**
     * 更新绘制数据接口。
     * 添加单个数据建议调用updateDrawData(hexGridHeatCell.getId());
     * 删除更新调用updateDrawData()刷新全部数据
     * @param {String} id cell对象的唯一标识符
     * @example
     * //在已绘制的HexGridHeatModel中添加或删除一个cell（建议用法）
     * hexGridHeatModel.updateDrawData(hexGridHeatCell.getId());
     * //删除或添加多个hexGridHeatCell后更新绘制数据
     * hexGridHeatModel.updateDrawData();
     */
    updateDrawData(id) {
        if (id) {
            //判断图层中是否存在数据
            if (this._objMap.get(id)) {
                const value = this._objMap.get(id);
                let ind = this._drawData.idArray.indexOf(id);
                //add or change
                if (ind === -1) {
                    value._calculateVertex(this._dimension, this._current);
                    this._current = value._current;
                    this._assemble(value);
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "A";
                } else {
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "R";
                }
            } else {
                //delete or null
                let ind = this._drawData.idArray.indexOf(id);
                if (ind !== -1) {
                    this._drawData.idArray.length = 0;
                    this._drawData.a_positionH.length = 0;
                    this._drawData.a_positionL.length = 0;
                    this._drawData.a_color.length = 0;
                    this._drawData.a_indices.length = 0;
                    this._drawData.dimension.length = 0;
                    this._upFlag.index = ind;
                    this._upFlag.isChange = true;
                    this._upFlag.update = "D";
                }
            }

        } else {
            //update all
            this._initDrawData();
            for (let value of this._objMap.values()) {
                value._calculateVertex(this._dimension, this._current);
                this._current = value._current;
                this._assemble(value);
            }
            this._upFlag.index = null;
            this._upFlag.isChange = true;
            this._upFlag.update = "O";
        }
    }


    _draw() {
        this._current=0;
        if (this._drawData.idArray.length === 0) return;
        this._startTime = this._startTime || window.Date.now();
        if ((!this._render._upBuffer) || this._upFlag.isChange) {
            this._render._addStaticBufferD(this._drawData);
            this._upFlag.isChange = false;
        }
    }

    _tick(uniforms = {}) {

        if (this._drawData.idArray.length === 0 || this._render._upBuffer === false) return;
        this._gl.disable(this._gl.CULL_FACE);
        this._render._draw(this._drawData, uniforms, this._dimension);
    }

    /**
     * 初始化绘制数据格式
     * @private
     */
    _initDrawData() {
        this._drawData = {
            idArray: [],
            a_positionH: [],
            a_positionL: [],
            a_color: [],
            a_indices: [],
            dimension: []
        };
    }

    /**
     * 组装数据
     * @param {hmap.geosolution.cell.GridHeat} gridHeat  gridHeat单元
     * @private
     */
    _assemble(gridHeat) {
        this._drawData.idArray.push(gridHeat._id);
        this._drawData.a_positionH.push(...gridHeat.a_positionH);
        this._drawData.a_positionL.push(...gridHeat.a_positionL);
        this._drawData.a_color.push(...gridHeat.a_color);
        this._drawData.a_indices.push(...gridHeat.a_indices);
    }
};;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.BarShader={};
hmap.shader.BarShader.vsShader= `#version 300 es
in vec3 a_position;
in vec4 a_color0;
in vec4 a_color1;
in vec3 a_center;
in float a_value;//值

uniform bool u_ifLiner;
uniform float u_size;
uniform float u_height;
uniform float u_maxValue;
uniform mat4 u_mvpMatrix;

out vec4 v_color;
flat out float v_distFog;

float getHeight(){
    return a_value/u_maxValue*u_height;
}

void main(){
    float height=getHeight();
    gl_Position=u_mvpMatrix*vec4(vec3(u_size*a_position.xy,a_position.z*height)+a_center,1.0);
    v_color=a_color0;
    if(u_ifLiner){
     if(a_position.z>0.5){
        v_color=a_color1;
     }
    }
    v_distFog=gl_Position.w;
}
`;
hmap.shader.BarShader.fsShader=`#version 300 es
precision mediump float;
in vec4 v_color;
flat in float v_distFog;
uniform vec4 u_fogColor;
uniform vec2 u_fogDist;
out vec4 outColor;
void main(){
    // vec4 color=v_color;
    // /*雾化*/
    // float fogFactor=clamp((u_fogDist.y-v_distFog)/(u_fogDist.y-u_fogDist.x),0.5,1.0); 
    // outColor=mix(u_fogColor.rgba,color.rgba,fogFactor); 
    outColor=v_color;
}
`;;"use strict";
/**
 * 地理解决方案中的电子墙着色器。暂未处理RTE，添加纹理进行操作
 * @type {*|{}}
 * @private
 */
hmap.shader=hmap.shader||{};
hmap.shader.EleWallShader={};
hmap.shader.EleWallShader.vsShader=`#version 300 es
#define PI 3.1415926
in vec4 a_position;
in float a_distance;
uniform float u_height;
uniform float u_distLast;//整条线的长度
uniform mat4 u_vpMatrix;
uniform float u_time;
uniform vec4 u_animParam;//正弦函数动画参数（幅值，周期长度，周期时间,是否开启动画）
uniform float u_repeat;
out vec2 v_texCoord;

float getCurrentH(){
    float angle=mod(a_distance,u_animParam.y)/u_animParam.y*2.0*PI;
    angle+=u_animParam.y/u_animParam.z*u_time;
    float h=u_animParam.x*sin(angle)+u_height-u_animParam.x*0.5;
    return h;
}
void main(){
    float h=mod(float(gl_VertexID),2.0)*(getCurrentH()*u_animParam.w+u_height*(1.0-u_animParam.w));
    gl_Position=u_vpMatrix*vec4(a_position.xy,a_position.z+h,a_position.w);
    v_texCoord=vec2((a_distance/u_distLast*u_repeat),mod(float(gl_VertexID),2.0));
    gl_PointSize=30.0;
}
`;
hmap.shader.EleWallShader.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precison mediump float;
#endif 
uniform sampler2D u_tex;
uniform vec4 u_color0;
uniform vec4 u_color1;
uniform bool u_ifTex;
in vec2 v_texCoord;
out vec4 outColor;
void main(){
    outColor=mix(u_color0,u_color1,vec4(v_texCoord.y));
    if(u_ifTex){
        outColor=texture(u_tex,v_texCoord);
    }
}
`;
hmap.shader.EleWallShader.vsShaderRTE=`#version 300 es
#define PI 3.1415926
in float a_distance;

in vec3 a_positionH;
in vec3 a_positionL;
uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform bool u_ifRTE;

uniform float u_height;
uniform float u_distLast;//整条线的长度
uniform mat4 u_vpMatrix;
uniform float u_time;
uniform vec4 u_animParam;//正弦函数动画参数（幅值，周期长度，周期时间,是否开启动画）
uniform float u_repeat;
uniform float u_unit;
out vec2 v_texCoord;

float getCurrentH(){
    float angle=mod(a_distance,u_animParam.y)/u_animParam.y*2.0*PI;
    angle+=u_animParam.y/u_animParam.z*u_time;
    float h=u_animParam.x*sin(angle)+u_height-u_animParam.x;
    return h;
}

vec4 corrections(){
    vec3 highD=a_positionH-u_cameraH;
    vec3 diff=a_positionL-u_cameraL;
    vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
    return vec4(highD+lowD,1.0);
}
void main(){
    float h=mod(float(gl_VertexID),2.0)*(getCurrentH()*u_animParam.w+u_height*(1.0-u_animParam.w));
    vec4 position=vec4(a_positionH,1.0);
    mat4 mvMatrix=u_mvMatrix;
    if(u_ifRTE){
         mat4 mvR2Eye=u_mvMatrix;
         mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
         mvMatrix=mvR2Eye;
         position=corrections();
    }
    gl_Position=u_projMatrix*mvMatrix*vec4(position.xy,position.z+h,position.w);
    // gl_Position=u_vpMatrix*vec4(a_position.xy,a_position.z+h,a_position.w);
    v_texCoord=vec2((a_distance/u_distLast*u_repeat),1.0-mod(float(gl_VertexID),2.0));
    gl_PointSize=30.0;
}
`;;hmap.shader=hmap.shader||{};
hmap.shader.FilledCircleShader={};
hmap.shader.FilledCircleShader.vsShader=`#version 300 es
in vec4 a_position;

in vec3 a_center;
in vec3 a_centerL;
in vec4 a_color;
in vec4 a_threshold;//由内圈到外圈的最大阈值
in float a_size;//初始大小
in float a_freq;//由初始大小到最终大小间隔毫秒数
in float a_maxSize;//最终大小

uniform float u_time;//动画开始经过的时间（毫秒）
uniform float u_res;//分辨率
uniform float u_resL;//低级分辨率

uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform bool u_ifRTE;
uniform float u_unit;

out float v_dist;
out vec4 v_color;
out vec4 v_threshold;

float getCurrentSize(){
    float size=a_size;
    size+=mod(u_time,a_freq)*(a_maxSize-a_size)/a_freq;
    return size;
}

vec4 corrections(){
     float res=u_res+u_resL/10000000.0*(1.0-u_unit)+u_resL*u_unit;
     vec3 highD=a_center-u_cameraH;
     vec3 diff=a_centerL-u_cameraL;
     vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
     return vec4(highD+lowD,res);
}

void main(){
    float size=getCurrentSize();
    vec4 pos=a_position;
    float res=u_res;
    mat4 mvMatrix=u_mvMatrix;
    vec3 center=a_center;
    if(u_ifRTE){
        mat4 mvR2Eye=u_mvMatrix;
        mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
        mvMatrix=mvR2Eye;
        vec4 corr=corrections();
        center=corr.xyz;
        res=corr.w;
    }
    pos.xy=pos.xy*size*res;
    pos.xyz=pos.xyz+center;
    gl_Position=u_projMatrix*mvMatrix*pos;
    // gl_Position.z=float(gl_InstanceID)*gl_Position.w*0.000001;
    v_dist=length(a_position.xy);
    v_color=a_color;
    v_threshold=a_threshold;
}

`;
hmap.shader.FilledCircleShader.fsShader=`#version 300 es
precision mediump float;
in float v_dist;
in vec4 v_color;
in vec4 v_threshold;
out vec4 outColor;
void main(){
    outColor=v_color;
    if(v_dist<v_threshold.x){
       outColor.a=v_color.a; 
    }else if(v_dist<v_threshold.y){
        outColor.a*=0.75;
    }else if(v_dist<v_threshold.z){
        outColor.a*=0.50;
    }else if(v_dist<v_threshold.w){
        outColor.a*=0.25;
    }else{
        outColor.a*=0.15;
    }  
}
`;;"use strict";
hmap.shader = hmap.shader || {};
hmap.shader.HeatmapShader = {};

/**--颜色---**/
hmap.shader.HeatmapShader.colorVsShader=`#version 300 es
in vec4 a_position;
in vec4 a_color;
out vec4 v_color;
void main(){
    gl_Position=a_position;
    v_color=a_color;
}`;
hmap.shader.HeatmapShader.colorFsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;
}
`;

hmap.shader.HeatmapShader.frameVsShader=`#version 300 es
in vec4 a_position;

in vec3 a_center;
in vec3 a_centerL;
in float a_value;

uniform float u_size;
uniform float u_maxValue;
uniform float u_minValue;

uniform float u_res;
uniform float u_resL;

uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform bool u_ifRTE;
uniform float u_unit;

out float v_dist;
out float v_ratio;
out float v_distFog;

vec4 corrections(){
     float res=u_res+u_resL/10000000.0*(1.0-u_unit)+u_resL*u_unit;
     vec3 highD=a_center-u_cameraH;
     vec3 diff=a_centerL-u_cameraL;
     vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
     return vec4(highD+lowD,res);
}
void main(){
    float res=u_res;
    vec4 pos=a_position;
    vec3 center=a_center;
    mat4 mvMatrix=u_mvMatrix;
    if(u_ifRTE){
        mat4 mvR2Eye=u_mvMatrix;
        mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
        mvMatrix=mvR2Eye;
        vec4 corr=corrections();
        center=corr.xyz;
        res=corr.w;
    }
    pos.xy=pos.xy*u_size*res;
    pos.xyz=pos.xyz+center;
    gl_Position=u_projMatrix*mvMatrix*pos;
    
    v_dist=length(a_position.xy);
    v_ratio=max(0.0,(a_value-u_minValue))/(u_maxValue-u_minValue);
    v_distFog=gl_Position.w;
}
`;
hmap.shader.HeatmapShader.frameFsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in float v_dist;
in float v_ratio;
in float v_distFog;
out vec4 outColor;
void main(){
    outColor=vec4(0.0,0.0,0.0,v_ratio)*smoothstep(1.0,0.0,v_dist);
    outColor.r=v_distFog;
}
`;

hmap.shader.HeatmapShader.vsShader=`#version 300 es
in vec4 a_position;
in vec2 a_texCoord;
uniform mat4 u_projMatrix;
out vec2 v_texCoord;
void main(){
    gl_Position=a_position;
    v_texCoord=a_texCoord;
}`;
hmap.shader.HeatmapShader.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D u_texture;
uniform sampler2D u_colorTexture;
uniform vec4 u_fogColor;
uniform vec2 u_fogDist;
in vec2 v_texCoord;
out vec4 outColor;
/*根据纹理来分配颜色*/
vec4 tex2color(float tex){
   return texture(u_colorTexture,vec2(tex,0.50));
}
void main(){
    outColor=texture(u_texture,v_texCoord);
    float tex=outColor.a;
    if(tex==0.0)discard;
    float distFog=outColor.r;
    vec4 color=tex2color(tex);

     /*雾化*/
    float fogFactor=clamp((u_fogDist.y-distFog)/(u_fogDist.y-u_fogDist.x),0.0,1.0); 
    outColor=mix(u_fogColor.rgba,color.rgba,fogFactor);
}`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.PieShader={};
hmap.shader.PieShader.vsShader=`#version 300 es
in vec3 a_position;
in vec4 a_color;
in float a_weight;

uniform vec3 u_center;
uniform vec4 u_color;
uniform float u_maxWeight;
uniform vec2 u_radius;//x=innerPercent,y=maxRadius
uniform vec2 u_ifAuto;//x=autoColor,y=autoRadius,{Boolean}
uniform mat4 u_vpMatrix;

out float v_innerPercent;
out float v_dist;
out vec4 v_color;

void main(){
    float percent=a_weight/u_maxWeight;
    // float radius=percent*u_radius.y*u_ifAuto.y+(-u_ifAuto.y+1.0)*u_radius.y;//原始代码
    float radius=(percent*u_radius.y*(1.0-u_radius.x)+u_radius.y*u_radius.x)*u_ifAuto.y+(-u_ifAuto.y+1.0)*u_radius.y;
    
    gl_Position=u_vpMatrix*vec4(vec3(a_position*radius+u_center),1.0);
    v_color=u_ifAuto.x*percent*u_color+(1.0-u_ifAuto.x)*a_color;
    // v_innerPercent=u_radius.x/percent*u_ifAuto.y+(-u_ifAuto.y+1.0)*u_radius.x;//原始代码
    v_innerPercent=u_radius.x/(percent*(1.0-u_radius.x)+u_radius.x)*u_ifAuto.y+(-u_ifAuto.y+1.0)*u_radius.x;//fix value差距过大的innerPercent切掉bug
    v_dist=length(a_position.xy);
}
`;
hmap.shader.PieShader.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

in vec4 v_color;
in float v_dist;
in float v_innerPercent;
out vec4 outColor;
void main(){
    outColor=v_color;
    if(v_dist<v_innerPercent)discard;
}
`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.ScatterShader={};
hmap.shader.ScatterShader.breathPointVs=`#version 300 es
in vec4 a_center;
in float a_size;
in float a_maxSize;
in float a_freq;
in vec4 a_color;

uniform float u_time;
uniform mat4 u_mvpMatrix;
out float v_ratio;
out vec4 v_color;

//计算双周期变化
float getSizeAdd(){
    float size=a_maxSize-a_size;
    float percent=mod(u_time,a_freq)/a_freq;
    percent=step(0.5,percent)*(1.-percent)+step(percent,0.5)*percent;
    return size*2.0*percent;
}

void main(){
    float size=a_size+getSizeAdd();
    gl_PointSize=size;
    gl_Position=u_mvpMatrix*a_center;
    v_ratio=a_size/size; 
    v_color=a_color; 
}
`;
hmap.shader.ScatterShader.breathPointFs=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
in float v_ratio;
out vec4 outColor;
void main(){
    float dist=distance(gl_PointCoord,vec2(.5,.5));
    if(dist-0.5>=0.000001){
        discard;
    }
    outColor=v_color*smoothstep(.5,.0,(dist-0.5*v_ratio));
}`;

hmap.shader.ScatterShader.bubblePointVs=`#version 300 es
in vec4 a_center;
in float a_size;
in float a_maxSize;
in float a_freq;
in vec4 a_color;
in vec4 a_colorC;
in vec2 a_alpha;

uniform float u_time;
uniform mat4 u_mvpMatrix;
out float v_ratio;
out vec4 v_color;
out vec4 v_colorC;

//单纯计算单周期变化
vec2 getStatus(){
    float size=a_size;
    float alpha=a_alpha.x;
    float percent=mod(u_time,a_freq)/a_freq;
    size+=percent*(a_maxSize-a_size);
    alpha+=percent*(a_alpha.y-a_alpha.x);
    return vec2(size,alpha);
}

void main(){
    vec2 status=getStatus();
    gl_PointSize=status.x;
    gl_Position=u_mvpMatrix*a_center;
    v_ratio=a_size/status.x;
    v_color=a_color;
    v_colorC=a_colorC*status.y;  
}
`;
hmap.shader.ScatterShader.bubblePointFs=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
in vec4 v_colorC;
in float v_ratio;
out vec4 outColor;
void main(){
    vec4 color=v_color;
    float dist=distance(gl_PointCoord,vec2(.5,.5));
    if(dist-0.5>=0.000001){
        discard;
    }
    float ratio=v_ratio*0.5;
    outColor=v_color*step(dist,ratio)+v_colorC*step(ratio,dist);
}`;

hmap.shader.ScatterShader.circleVs=`#version 300 es
in vec3 a_position;
in vec3 a_center;
in vec4 a_color;
in float a_size;
in float a_maxSize;
in float a_freq;
in vec2 a_alpha;
in float a_cycle;//1 or 2

uniform float u_time;
uniform mat4 u_mvpMatrix;
uniform vec2 u_viewport;

out vec4 v_color;

//单周期
vec3 getCurrentStatus(){
    float size=a_size;
    float alpha=a_alpha.x;
    float percent=mod(u_time,a_freq)/a_freq;
    alpha+=percent*(a_alpha.y-a_alpha.x);
    size+=percent*(a_maxSize-a_size);
    return vec3(size/u_viewport.x,size/u_viewport.y,alpha);
}
//双周期
vec3 getCurrentStatus2(){
    float size=a_size;
    float alpha=a_alpha.x;
    float percent=mod(u_time,a_freq)/a_freq;
    percent=step(0.5,percent)*(1.-percent)+step(percent,0.5)*percent;
    size+=percent*(a_maxSize-a_size)*2.0;
    alpha+=percent*(a_alpha.y-a_alpha.x)*2.0;
    return vec3(size/u_viewport.x,size/u_viewport.y,alpha);
}
void main(){
    vec3 status=(2.0-a_cycle)*getCurrentStatus()+(a_cycle-1.0)*getCurrentStatus2();
    vec4 position=vec4(status.xy*a_position.xy,a_position.z,0.0);
    vec4 webPosition=u_mvpMatrix*vec4(a_center,1.0);
    gl_Position=webPosition+position*webPosition.w;
    
    v_color=a_color*status.z;
}`;

hmap.shader.ScatterShader.circleFs=`#version 300 es
precision mediump float;
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;
    if(outColor.a==0.)discard;
}`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.TadpoleShader={};
/**
 * 地理解决方案蝌蚪图使用着色器，使用RTE
 * @type {string}
 * @private
 */
hmap.shader.TadpoleShader.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  vec2 a_size;
    in  float a_count;
    in  vec4  a_color;
    out vec4  v_color;
    
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    uniform float u_unit;
    
    float getParam(){
        return float(gl_VertexID)/a_count;
    }
    
    vec4 corrections(){
        vec3 highD=a_positionH-u_cameraH;
        vec3 diff=a_positionL-u_cameraL;
        vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
        return vec4(highD+lowD,1.0);
    }
    void main(){
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=corrections();
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        gl_PointSize=a_size.y+(a_size.x-a_size.y)*getParam();
        v_color=a_color*getParam();
    }  
`;
hmap.shader.TadpoleShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
        discard;
    }else{
        outColor=v_color;     
    }
}
`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.ViewsedShader={};
/**
 * 地理解决方案，可视域使用着色器
 * @type {string}
 * @private
 */
hmap.shader.ViewsedShader.vsShader=`#version 300 es
in vec3  a_position;
in float a_radius;
in vec3  a_scale;
in vec4  a_color;
in vec3  a_orien;//朝向向量
in vec3  a_location;
uniform mat4 u_mvpMatrix;
out vec4 v_color;

//有朝向向量的原始朝向向量计算夹角和旋转轴,旋转夹角为第四个参数
vec4 calcRotate(vec3 orien){
    float angle=0.0;
    //vec3 normal=vec3(0,0,-1);默认朝向z负半轴
    vec3 normal=vec3(1,0,0);//默认朝向
    angle=acos(dot(normal,normalize(orien)));
    vec3 rotateAxis=cross(normal,normalize(orien));
    return vec4(rotateAxis,angle);
}
//根据旋转向量和旋转角度计算旋转矩阵
mat3 calcRotateM(vec4 rotate){
    float c=cos(rotate.w);
    float s=sin(rotate.w);
    float x=rotate.x;
    float y=rotate.y;
    float z=rotate.z;
    
    vec3 l1=vec3(c+(1.-c)*x*x,(1.-c)*x*y+s*z,(1.-c)*x*z-s*y);
    vec3 l2=vec3((1.-c)*x*y-s*z,c+(1.-c)*y*y,(1.-c)*y*z+s*x);
    vec3 l3=vec3((1.-c)*x*z+s*y,(1.-c)*y*z-s*x,c+(1.-c)*z*z);
    return mat3(l1,l2,l3);
}
//初始化模型顶点的边长
const float Length=length(vec3(0.5,0.5,1.0));
void main(){
    //变换模型为设定模式
    // vec3 position=a_position*a_scale*a_radius/Length;默认朝向z负半轴
    vec3 position=a_position*vec3(a_scale.z,a_scale.y,a_scale.x)*a_radius/Length;//默认朝向x正半轴
    //旋转模型到正确朝向,并进行平移
    vec4 rotate=calcRotate(a_orien);
    mat3 rotateMatrix=calcRotateM(rotate);
    
    vec3 positionRT=rotateMatrix*position+a_location;
    gl_Position=u_mvpMatrix*vec4(positionRT,1.0);
    v_color=a_color;
    gl_PointSize=5.0;
}`;
hmap.shader.ViewsedShader.fsShader=`#version 300 es
precision mediump float;
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;
}
`;;hmap.shader=hmap.shader||{};
/**
 * 地理解决方案-水填充特效着色器
 * @private
 * */
hmap.shader.FillWaterShader={};
hmap.shader.FillWaterShader.vsShader=`#version 300 es
in vec4 a_position;
uniform mat4 u_vpMatrix;
void main() {
  gl_Position = u_vpMatrix*a_position;
}
`;
hmap.shader.FillWaterShader.fsShader=`#version 300 es
precision highp float;
#define TAU 6.28318530718
#define MAX_ITER 5
#define INTENSITY 0.004
#define SCALE 500.0
uniform float u_time;
out vec4 outColor;
void main() {
    vec2 uv = gl_FragCoord.xy/SCALE;
    vec2 p = mod(uv * TAU, TAU) - 250.0;
    vec2 i = vec2(p);
    float c = 0.9;
    for (int n = 0; n < MAX_ITER; n++) {
        float t = 0.5 * u_time*2.0 * (1.0 - (3.5 / (float(n)+1.0)));
        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / INTENSITY), p.y / (cos(i.y + t) / INTENSITY)));
    }
    c = 1.17 - pow(c / float(MAX_ITER), 1.4);
    outColor=vec4(clamp(vec3(pow(abs(c), 8.0)) + vec3(0.0, 0.1, 0.6), 0.0, 1.0), 1.0);
}
`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.FlowShader={};
/**
 * 地理解决方案中流线动画使用的着色器，使用RTE
 * @type {string}
 * @private
 */
hmap.shader.FlowShader.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  vec4  a_color;
    out vec4  v_color;
    
    in float a_prevFrameNum;            //上个节点的帧数
    in float a_currFrameNum;            //当前节点的帧数
    in float a_nextFrameNum;            //下个节点的帧数
    in float a_routeFrameSum;           //流线路线的帧数
    in float a_selfFrameSum;            //流线本身帧数
    in float a_startFrameNum;           //开始的帧数，用于延迟开始动画
    in vec3 a_offsetPerFrame;           //节点位置的偏移
    uniform float u_framesParam;        //动画帧参数
    uniform bool u_needLoop;            //是否需要循环播放

    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    uniform float u_unit;
    
    vec4 corrections(){
        vec3 highD=a_positionH-u_cameraH;
        vec3 diff=a_positionL-u_cameraL;
        vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
        return vec4(highD+lowD,1.0);
    }
    
    void main(){
        float param = (u_framesParam - a_startFrameNum);
        float flowFrameSum = a_routeFrameSum + a_selfFrameSum;
        if(u_needLoop){
            while(param > flowFrameSum){
                param = param - flowFrameSum;
            }
        }
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            mat4 mvR2Eye=u_mvMatrix;            
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=corrections();
        }
        float lineParam = 0.0;
        float opacity = 0.0;
        bool pointDiscard = true;
        if(param > a_nextFrameNum + a_selfFrameSum || param < a_prevFrameNum){
            pointDiscard = true;
            opacity = 0.0;
        }else if( param >= a_currFrameNum && param <= a_currFrameNum + a_selfFrameSum ){
            pointDiscard = false;
            if(param - a_selfFrameSum < 0.0){
                opacity = a_currFrameNum/param;
            }else{
                opacity = sin((a_currFrameNum - (param - a_selfFrameSum))*1.570796327/a_selfFrameSum);    
            }
        }else{
            if(param - a_selfFrameSum > a_currFrameNum){
                lineParam = param - a_selfFrameSum - a_currFrameNum;
            }else{
                lineParam = param - a_currFrameNum;
            }
            pointDiscard = false;
            if(param - a_selfFrameSum < 0.0){
                opacity = (a_currFrameNum + lineParam)/param;
            }else{
                opacity = sin((a_currFrameNum + lineParam - (param - a_selfFrameSum))*1.570796327/a_selfFrameSum);    
            }
        }
        position = position + vec4(a_offsetPerFrame*lineParam, 0.0);
        if(!pointDiscard){
            gl_Position=u_projMatrix*mvMatrix*position;
            v_color=vec4(a_color.xyz, a_color.w*opacity);
        }
    }  
`;
hmap.shader.FlowShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
        outColor=v_color;
    }
`;;hmap.shader=hmap.shader||{};
hmap.shader.ParticleShader={};
/**
 * 粒子系统着色器
 * @private
 * */
hmap.shader.ParticleShader.vsShader=`#version 300 es
in vec3 a_positionH;
in vec3 a_positionL;
uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_vpMatrix;
uniform float u_size;

in vec3 a_originForce;          //初始的力,逐顶点
in float a_offsetIndex;         //偏移索引
uniform float u_offsetCount;    //点的数量
uniform float u_ctrlOffset;     //偏移，控制粒子流动的速度，递增
uniform vec4 u_originPosition;  //开始点
uniform vec3 u_gravity;         //地球引力
uniform vec3 u_inertia;         //惯性
uniform bool u_ifRTE;

uniform float u_unit;
uniform float u_res;
uniform float u_resL;
    
vec4 corrections(){
    vec3 highD = a_positionH-u_cameraH;
    vec3 diff = a_positionL-u_cameraL;
    vec3 lowD=diff/10000000.0*(1.0-u_unit) + diff*u_unit;
    return vec4(highD+lowD,1.0);
}
    
void main() {
    float offset = u_ctrlOffset;
    if(offset - a_offsetIndex > 0.0){
        vec4 position=vec4(a_positionH,1.0);
        float res=u_res;
        if(u_ifRTE){
            //position=corrections();
            res=res+u_resL/10000000.0*(1.0-u_unit)+u_resL*u_unit;
        }
        float a_offset = offset - a_offsetIndex;
        a_offset = fract(a_offset/u_offsetCount)*u_offsetCount;
        vec3 gravityDis = vec3(0.0,0.0,0.0);
        for(int i=0;i<int(a_offset);i++){
			 gravityDis =gravityDis+float(i) *u_gravity;
		} 
        vec3 totalForce =  u_inertia*a_offset + a_originForce*a_offset + gravityDis;
        position.xyz += totalForce;
        gl_Position = u_vpMatrix * position;
        gl_PointSize = u_size/res;
    }
}
`;

hmap.shader.ParticleShader.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform vec4 u_color;
out vec4 outColor;

void main() {
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
        discard;
    }else{
        vec4 color = u_color;
        color.a *= cos(3.14159*dist);
        outColor = color;               //以cos规律渐变的圆
    }      
}
`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.TrailShader={};
/**
 * 地理解决方案中线纹理动画使用的着色器，每个要素单独绘制
 * @type {string}
 * @private
 */
hmap.shader.TrailShader.vsShader=`#version 300 es
    in vec3 a_positionH;
    in vec3 a_positionL;
    in vec3 a_previousH;
    in vec3 a_previousL;
    in vec3 a_nextH;
    in vec3 a_nextL;
    
    in float a_side;
    in vec2 a_uv;

    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    uniform float u_unit;
    
    uniform float u_res;
    uniform float u_resL;
    uniform float u_lineWidth;
  
    out vec2 v_uv;
    
    vec4 corrections(vec3 positionH, vec3 positionL){
        vec3 highD=positionH-u_cameraH;
        vec3 diff=positionL-u_cameraL;
        vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
        return vec4(highD+lowD,1.0);
    }
    
    void main() {
         vec4 position=vec4(a_positionH,1.0);
         vec4 previous=vec4(a_previousH,1.0);
         vec4 next=vec4(a_nextH,1.0);
         mat4 mvMatrix=u_mvMatrix; 
         float res=u_res;
         if(u_ifRTE){
            position=corrections(a_positionH, a_positionL);
            previous=corrections(a_previousH, a_previousL);
            next=corrections(a_nextH, a_nextL);
            res=res+u_resL/10000000.0*(1.0-u_unit)+u_resL*u_unit;

            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;           
         }
         vec2 currentP = position.xy;
         vec2 prevP = previous.xy;
         vec2 nextP = next.xy;
         float width = res * u_lineWidth/2.0;
         
         float scale = 1.0; vec2 dir;
         if( nextP == currentP ) dir = normalize( currentP - prevP );
         else if( prevP == currentP ) dir = normalize( nextP - currentP );
         else {
             vec2 dir1 = normalize( currentP - prevP );
             vec2 dir2 = normalize( nextP - currentP );
             dir = normalize( dir1 + dir2 );
             float cc = abs(atan(-dir.x/dir.y) - atan(dir1.y/dir1.x));
			 scale = 1.0/sin(cc);
         }
         vec2 normal = vec2( -dir.y, dir.x);
         vec4 offset = vec4( normal * (width*scale) * a_side, 0.0, 1.0 );
         position.xy += offset.xy;
         gl_Position = u_projMatrix * mvMatrix * position;
         v_uv = vec2(a_uv.x/res,a_uv.y);
    }
`;

hmap.shader.TrailShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    uniform bool u_showLine;
    uniform bool u_useAlpha;            //仅使用纹理的透明度
    uniform vec4 u_lineColor;
    uniform float u_uvOffset;
    uniform float u_placeLength;
    uniform float u_placeSpace;
    
    uniform sampler2D u_pattern;        //纹理
     
    in vec2 v_uv;
    out vec4 outColor;

    void main() {
        vec4 color = u_lineColor;
        vec2 outUv = v_uv;
        outUv.x = fract(outUv.x/(u_placeLength + u_placeSpace) - u_uvOffset)*(u_placeLength + u_placeSpace)/u_placeLength;
        vec4 textureColor = texture( u_pattern, outUv);
        if(u_showLine){
            if(u_useAlpha){
                color.a *= textureColor.a;
                outColor = color;
            }else{
                outColor = color*(1.0-textureColor.a) + textureColor*textureColor.a;
            }
        }else{
            outColor = textureColor;
        }
    }
`;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.RainShader={};
/**
 * 地理解决方案--雨着色器
 * @type {string}
 * @private
 */
hmap.shader.RainShader.vsShader=`#version 300 es
in vec3 a_position;
in vec4 a_color;
in float a_number;
in float a_timeDelay;      //每一个点有一个延时，保证不会同时下落                  

in float a_size;                    //点大小,统一点大小
in float a_speed;                    //速度变量，单位米/秒
uniform float u_time;                     //时间变量，单位秒
uniform float u_ewWind;                   //东西方向风向因子
uniform float u_nsWind;                   //南北方向风向因子
uniform float u_windForce;                 //风力因子
uniform float u_initRes;                      //初始地图分辨率
uniform mat4 u_mvpMatrix;
uniform float u_resolution;         //当前地图的分辨率  

out vec4 v_color;
  
void main() {
    
         if(u_resolution/u_initRes >= 1.0 && fract(a_number/floor(u_resolution/u_initRes))==0.0 ||u_resolution/u_initRes <1.0){
            vec4 position=vec4(a_position,1.0);
            float height = position.z;
            float fallDis = fract((a_speed *2000.0* (u_time-a_timeDelay))/height)*height;
            position.z -= fallDis;
            position.x += u_ewWind*u_windForce*fallDis;
            position.y += u_nsWind*u_windForce*fallDis;
            gl_Position = u_mvpMatrix * position;
            gl_PointSize = a_size;
            v_color=a_color;
         }  
         
}`;

hmap.shader.RainShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main() {
        float dist = distance(gl_PointCoord,vec2(0.5,0.5));
        if(dist<0.5){
            outColor = v_color;
        }else{
            discard;
        }
    }
`;;"use strict";
hmap.shader = hmap.shader || {};
hmap.shader.SnowShader = {};
/**
 * 地理解决方案中雪着色器
 * @type {string}
 * @private
 */
hmap.shader.SnowShader.vsShader = `#version 300 es
    in vec3 a_position;
    in vec3 a_rotation;
    in vec3 a_speed;
    in float a_size;
    in float a_timeDelay;

    uniform float u_time;
    uniform mat4 u_mvpMatrix;
    uniform float u_ewWind;                   //东西方向风向因子
    uniform float u_nsWind;                   //南北方向风向因子
    uniform float u_windForce;                 //风力因子

    out float v_rotation;
    void main() {
      v_rotation = a_rotation.x + u_time * a_rotation.z;
      vec4 position=vec4(a_position,1.0);
      position.x += sin(u_time * a_speed.x*0.3) * 0.01;
      position.y += cos(u_time * a_speed.y*0.3) * 0.01;
      float height = position.z;
      float fallDis = fract((a_speed.z/100.0* (u_time-a_timeDelay))/height)*height;
      position.z -= fallDis;
      position.x += u_ewWind*u_windForce*fallDis;
      position.y += u_nsWind*u_windForce*fallDis;
      gl_Position = u_mvpMatrix * position;
      //gl_PointSize = 25.0*a_size / (gl_Position.w*25.0);
      if( 25.0*a_size / (gl_Position.w*3.0)>a_size*10.0){
        gl_PointSize=a_size*10.0;
      }else{
        gl_PointSize=25.0*a_size / (gl_Position.w*3.0);
      }
    }`;
hmap.shader.SnowShader.fsShader = `#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    uniform sampler2D u_texture;
    in float v_rotation;
    out vec4 outputColor;
    void main() {
      vec2 rotated = vec2(
        cos(v_rotation) * (gl_PointCoord.x - 0.5) + sin(v_rotation) * (gl_PointCoord.y - 0.5)+0.5,
        cos(v_rotation) * (gl_PointCoord.y - 0.5) - sin(v_rotation) * (gl_PointCoord.x - 0.5)+0.5
      );
      outputColor = texture(u_texture, rotated);
      if(outputColor.a<0.4)discard;
    }`;;"use strict";
hmap.shader = hmap.shader || {};
hmap.shader.GridHeatShader = {};
/**
 * 地理解决方案中雪着色器
 * @type {string}
 * @private
 */
hmap.shader.GridHeatShader.vsShader = `#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in vec4 a_color;
    out vec4 v_color;
    
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    uniform float u_unit;
    
    vec4 corrections(){
        vec3 highD=a_positionH-u_cameraH;
        vec3 diff=a_positionL-u_cameraL;
        vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
        return vec4(highD+lowD,1.0);
    }
    
    void main() {
    vec4 position=vec4(a_positionH,1.0);
    mat4 mvR2Eye=u_mvMatrix;
        mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
        position=corrections();
    gl_Position=u_projMatrix*mvR2Eye*position;
      v_color = a_color;
    }`;

hmap.shader.GridHeatShader.fsShader = `#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outputColor;
    void main() {
      outputColor =v_color;
    }`;;"use strict";
hmap.shader = hmap.shader || {};
hmap.shader.HexGridHeatShader = {};
/**
 * 蜂窝热力图着色器
 * @type {string}
 * @private
 */
hmap.shader.HexGridHeatShader.vsShader = `#version 300 es
in  vec3  a_positionH;
in  vec3  a_positionL;
in vec4 a_color;
out vec4 v_color;

uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform bool u_ifRTE;
uniform float u_unit;

vec4 corrections(){
    vec3 highD=a_positionH-u_cameraH;
    vec3 diff=a_positionL-u_cameraL;
    vec3 lowD=diff/10000000.0*(1.0-u_unit)+diff*u_unit;
    return vec4(highD+lowD,1.0);
}

void main() {
vec4 position=vec4(a_positionH,1.0);
mat4 mvR2Eye=u_mvMatrix;
    mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
    position=corrections();
gl_Position=u_projMatrix*mvR2Eye*position;
  v_color = a_color;
}`;
hmap.shader.HexGridHeatShader.fsShader =  `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
out vec4 outputColor;
void main() {
  outputColor = v_color;
}`;;hmap.shader = hmap.shader || {};
hmap.shader.pointcloud = {};
hmap.shader.pointcloud.vs = `#version 300 es
    // precision mediump float;
        
    in vec3 a_position;
    in vec4 a_color;

    uniform mat4 u_vpMatrix;   
    uniform float u_size;
    
    out vec4 v_color;
    void main(){
        gl_Position = u_vpMatrix * vec4(a_position,1.0);   
        gl_PointSize = u_size;
        v_color = a_color;       
    }
    `;
hmap.shader.pointcloud.fs = `#version 300 es
    precision mediump float;
    
    in vec4 v_color;
    out vec4 outColor;
    void main(){
        outColor = vec4(0.0,1.0,0.0,1.0);
        outColor = v_color;
    }
    `;

hmap.shader.pointcloud.fs_circle = `#version 300 es
    precision mediump float;
    
    in vec4 v_color;
    out vec4 outColor;
    void main(){
       
       float d = distance(gl_PointCoord, vec2(0.5, 0.5));
       if(d < 0.5) {
         outColor = v_color;
       } else { discard; }
    }
    `;; 'use strict';
 hmap.shader=hmap.shader||{};
 hmap.shader.S3MShader=hmap.shader.S3Mshader||{};
 hmap.shader.S3MShader.fsShader= `
    #ifdef TexCoord
        uniform sampler2D uTexture;
        uniform float uTextureWidth;
        varying vec4 vTexCoord;
        varying vec4 vTexMatrix;
    #endif
    #ifdef TexCoord2
        uniform sampler2D uTexture2;
        uniform float uTexture2Width;
        varying vec4 vTexMatrix2;
    #endif
    #ifdef VertexNormal
        varying vec3 vNormalEC;
    #endif
        uniform vec4 uDiffuseColor;
        uniform vec4 uAmbientColor;
        varying vec4 vColor;
        uniform vec3 uSunDirectionEC;
    #ifdef TexCoord
        void calculateTexCoord(in vec2 inTexCoord, in float scale, in float XTran, in float YTran, in float fTile, in float mipLevel, inout vec2 outTexCoord)
        {
            vec2 fTexCoord = fract(inTexCoord);
            float offset = 1.0 * pow(2.0, mipLevel) / fTile;
            fTexCoord = clamp(fTexCoord, offset, 1.0 - offset);
            outTexCoord.x = (fTexCoord.x + XTran) * scale;
            outTexCoord.y = (fTexCoord.y + YTran) * scale;
        }
        vec4 sampleTexture(sampler2D curTexture, vec2 oriTexCoord, float texTileWidth, float fMaxMipLev, float fTexCoordScale, vec2 vecTexCoordTranslate)
        {
            vec2 realTexCoord;
            calculateTexCoord(oriTexCoord, fTexCoordScale, vecTexCoordTranslate.x, vecTexCoordTranslate.y, texTileWidth, 0.0, realTexCoord);
            vec4 color = texture2D(curTexture, realTexCoord.xy);
            return color;
        }
    #endif
    #ifdef TexCoord
        vec4 getTextureColor()
        {
            if(vTexMatrix.z < 0.0)
            {
                return vec4(1.0);
            }
            float texTileWidth = vTexMatrix.z * uTextureWidth;
            vec4 color = sampleTexture(uTexture, vTexCoord.xy, texTileWidth, vTexMatrix.w, vTexMatrix.z, vTexMatrix.xy);
            return color;
        }
    #endif
    #ifdef TexCoord2
        vec4 getTexture2Color()
        {
            if(vTexMatrix2.z < 0.0)
            {
                return vec4(1.0);
            }
            float texTileWidth = vTexMatrix2.z * uTexture2Width;
            vec4 color = sampleTexture(uTexture2, vTexCoord.zw, texTileWidth, vTexMatrix2.w, vTexMatrix2.z, vTexMatrix2.xy);
            color.r = clamp(color.r * 1.618, 0.0, 1.0);
            color.g = clamp(color.g * 1.618, 0.0, 1.0);
            color.b = clamp(color.b * 1.618, 0.0, 1.0);
            return color;
        }
    #endif
        void main()
        {
            vec4 color = vColor;
        #ifdef TexCoord
            color *= getTextureColor();
        #endif
        #ifdef TexCoord2
            color *= getTexture2Color();
        #endif
        #ifdef VertexNormal
            float diffuseIntensity = max(dot(uSunDirectionEC, normalize(vNormalEC)), 0.0);
            color = vec4(color.rgb * (vec3(0.8) * uDiffuseColor.rgb * diffuseIntensity + vec3(0.6) * uAmbientColor.rgb), color.a);
        #endif
            gl_FragColor = color;
           // float d = distance(gl_PointCoord, vec2(0.5, 0.5));
           // if(d < 0.5) {
           //   gl_FragColor = color;
           // } else { discard; }
        }
    `;;
'use strict';
hmap.shader=hmap.shader||{};
hmap.shader.S3MShader=hmap.shader.S3MShader||{};
hmap.shader.S3MShader.vsShader=`
      precision highp float;
      attribute vec4 aPosition;
    #ifdef VertexNormal
        attribute vec3 aNormal;
        varying vec3 vNormalEC;
    #endif
    #ifdef TexCoord
        attribute vec4 aTexCoord0;
        varying vec4 vTexCoord;
        varying vec4 vTexMatrix;
    #endif
    #ifdef TexCoord2
        attribute vec4 aTexCoord1;
        varying vec4 vTexMatrix2;
    #endif
        attribute vec4 aColor;
        varying vec4 vColor;
        uniform mat4 uNormal3D;
        uniform mat4 uModel;             
        uniform mat4 uProjMatrix;
        uniform mat4 uViewMatrix;
        
        const float SHIFT_LEFT8 = 256.0;
        const float SHIFT_RIGHT8 = 1.0 / 256.0;
        const float SHIFT_RIGHT4 = 1.0 / 16.0;
        const float SHIFT_LEFT4 = 16.0;
        void getTextureMatrix(in float nZ, inout float XTran, inout float YTran, inout float scale)
        {
            if(nZ <= 0.0)
            {
                return;
            }
            float nDel8 = floor(nZ * SHIFT_RIGHT8);
            float nDel16 = floor(nDel8 * SHIFT_RIGHT8);
            float nDel20 = floor(nDel16 * SHIFT_RIGHT4);
            YTran = nZ - nDel8 * SHIFT_LEFT8;
            XTran = nDel8 - nDel16 * SHIFT_LEFT8;
            float nLevel = nDel16 - nDel20 * SHIFT_LEFT4;
            scale = 1.0 / pow(2.0, nLevel);
        }
        void main()
        {
        #ifdef TexCoord
            vTexCoord.xy = aTexCoord0.xy;
            vTexMatrix = vec4(0.0,0.0,1.0,0.0);
            if(aTexCoord0.z < -999.0)
            {
                vTexMatrix.z = -1.0;
            }
            getTextureMatrix(floor(aTexCoord0.z), vTexMatrix.x, vTexMatrix.y, vTexMatrix.z);
        #endif
        #ifdef TexCoord2
            vTexCoord.zw = aTexCoord1.xy;
            vTexMatrix2 = vec4(0.0,0.0,1.0,0.0);
            if(aTexCoord1.z < -99.0)
            {
                vTexMatrix2.z = -1.0;
            }
            getTextureMatrix(floor(aTexCoord1.z), vTexMatrix2.x, vTexMatrix2.y, vTexMatrix2.z);
        #endif
        #ifdef VertexNormal
            vNormalEC = vec3(uNormal3D * vec4(aNormal,1.0));
        #endif
            vec4 positionMC = vec4(aPosition.xyz, 1.0);
            gl_Position=uProjMatrix*uViewMatrix*uModel*positionMC;
            gl_PointSize=2.0;
            vColor = aColor;
        }
    `;;hmap.util = hmap.util || {};
/**
 * @private
 */
hmap.util.AssembleShader = class {
    /**
     * 获取着色器的初始结构代码，包括着色器的源码和定义属性
     * @param vs
     * @param fs
     * @returns {{vsOpts: {source: *, defines: Array}, fsOpts: {source: string, defines: Array}}}
     */
    static getShaderOptions(vs,fs){
        let vsOpts={
            source:vs,
            defines:[],
            includeBuiltIns:false//不需要查询依赖关系
        };
        let fsOpts={
            source:fs,
            defines:[],
            includeBuiltIns:false//不需要去查询依赖关系
        };
        return{
            vsOpts:vsOpts,
            fsOpts:fsOpts
        }
    }

    /**
     * 根据定义属性组装最终的着色器代码
     * @param shaderOpts
     * @param isFragmentShader
     */
    static combineShaderOptions(shaderOpts,isFragmentShader){
        let combine=shaderOpts.source;
        //去掉着色器中的默认设置
        // combine=combine.replace(/precision\s(lowp|mediump|highp)\s(float|int);/, '');
        let result="";
        if(isFragmentShader){
            result+='\
            #ifdef GL_FRAGMENT_PRECISION_HIGH\n\
            precision highp float;\n\
            #else\n\
            precision mediump float;\n\
            #endif\n\n';
        }
        //为组装着色器预先定义宏
        const defines=shaderOpts.defines;
        if(defines!==null){
            for(let i=0,len=defines.length;i<len;++i){
                const define=defines[i];//字符串
                if(define.length!==0){
                    result+='#define '+define+'\n';
                }
            }
        }
        //增加依赖项
        if(shaderOpts.includeBuiltIns){
            result+=hmap.util.AssembleShader.getBuiltinsAndAutomaticUniforms(combine);
        }

        // //重新设置line number
        // result+='\n#line 0\n';

        //添加当前的source
        result+=combine;
        return result;
    }

    static getDependecyNode(name,glslSource,nodes){
        let dependencyNode="";
        //检查是否loaded
        for(let i=0,len=nodes.length;i<len;i++){
            if(nodes[i].name=name){
                dependencyNode=nodes[i];
            }
        }
        if(dependencyNode===""){
            dependencyNode={
                name:name,
                glslSource:glslSource,
                dependsOn:[],
                requireBy:[],
                evaluated:false
            };
            nodes.push(dependencyNode);
        }
        return dependencyNode;
    }

    static generateDependencies(currentNode,dependencyNodes){
        if(currentNode.evaluate)return;
        currentNode.evaluate=true;
        //标识glsl source使用的所有依赖项，执行czm的检索
        let czmMatches=currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
        if(czmMatches!==undefined && czmMathes!==null){
            //删除重复
            cmzMatches=czmMatches.filter((ele,pos)=>{
                return czmMatches.indexOf(ele)===pos;
            });

            cmzMatches.forEach(ele=>{
                if(ele!==currentMode.name && shaderSource._czmBuiltinsAndUniforms.hasOwnProperty(ele)){
                 let referenceNode=hmap.util.AssembleShader.getDependecyNode(ele,shaderSource._czmBuiltinsAndUniforms[ele],dependencyNodes);
                 referenceNode.requireBy.push(currentNode);

                 //递归调用，查找新节点的依赖
                    hmap.util.AssembleShader.generateDependencies(referenceNode,dependencyNodes);
                }
            });
        }
    }

    static getBuiltinsAndAutomaticUniforms(shaderSource){
        //为内置函数生成关系依赖图
        let dependencyNodes=[];
        const root=hmap.util.AssembleShader.getDependecyNode("main",shaderSource,dependencyNodes);
        hmap.util.AssembleShader.generateDependencies(root,dependencyNodes);
        hmap.util.AssembleShader.sortDependencies(dependencyNodes);

        //连接函数依赖项的源代码
        //反向迭代，以便在使用从属项之前声明它们
        let builtinSource='';
        for(let i=dependencyNodes.length-1;i>=0;i--){
            builtinSource=builtinSource=dependencyNodes[i].glslSource+'\n';
        }

        return builtinSource.replace(root.glslSource,'');
    }
};;let breathPointShader={};
breathPointShader.vs=`#version 300 es
in vec4 a_position;
in float a_size;
in vec4 a_color;
flat out vec4 v_color;
out float v_ratio;

uniform float u_sizeAdd;
uniform mat4 u_mvpMatrix;
void main(){
    gl_Position=u_mvpMatrix*a_position;
    float allSize=a_size+u_sizeAdd;
    gl_PointSize=allSize;
    
    v_ratio=a_size/allSize;
    v_color=a_color;
}
`;
breathPointShader.fs=`#version 300 es
precision mediump float;
flat in vec4 v_color;
in float v_ratio;
out vec4 outColor;
uniform float u_alpha;
void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
    discard;
    }
    outColor=v_color*smoothstep(0.5,0.0,(dist-0.5*v_ratio));
}
`;

breathPointShader.getLocations=function(gl,program){
    return{
        positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
        sizeAttributeLocation:gl.getAttribLocation(program,"a_size"),
        colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
        sizeAddLocation:gl.getUniformLocation(program,"u_sizeAdd"),
        mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
        alphaLocation:gl.getUniformLocation(program,"u_alpha")
    }
};;let bubbleShader={};
bubbleShader.vs=`#version 300 es
    in vec4 a_position;
    in float a_size;
    in vec4 a_color;
    flat out vec4 v_color;
    in vec4 a_changeColor;
    flat out vec4 v_changeColor;
    flat out float v_ratio;/*不变与变化的比值*/
    uniform float u_sizeAdd;
    uniform mat4 u_mvpMatrix;
    void main(){
        gl_Position=u_mvpMatrix*a_position;
        float size=a_size+u_sizeAdd;
        gl_PointSize=size;
        
        v_color=a_color;
        v_changeColor=a_changeColor;
        v_ratio=a_size/size; 
    }
`;
bubbleShader.fs=`#version 300 es
    precision mediump float;
    flat in vec4 v_color;
    flat in vec4 v_changeColor;
    flat in float v_ratio;
    out vec4 outColor;
    uniform float u_alpha;
    void main(){
       float dist=distance(gl_PointCoord,vec2(0.5,0.5));
       if(dist>0.5)discard;
       float ratio=v_ratio*0.5;
       outColor=v_color;
       if(dist>ratio){
        outColor=v_changeColor;
        outColor.a=u_alpha;
       }
    }
`;
bubbleShader.getLocations=function(gl,program){
    return{
        positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
        sizeAttributeLocation:gl.getAttribLocation(program,"a_size"),
        colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
        changeColorAttributeLocation:gl.getAttribLocation(program,"a_changeColor"),
        sizeAddLocation:gl.getUniformLocation(program,"u_sizeAdd"),
        mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
        alphaLocation:gl.getUniformLocation(program,"u_alpha")
    };
};;let circleShader={};
circleShader.vs=`#version 300 es
in vec4 a_circle;//默认按照模型坐标系生成
uniform vec3 u_center;
uniform float u_size;//像素大小,直径
uniform mat4 u_mvpMatrix;
uniform vec2 u_viewport;

vec2 toClipSize(float size){
    return vec2(size/u_viewport.x,size/u_viewport.y);
}
void main(){
    vec2 clipSize=toClipSize(u_size);
    vec4 clipCircle=vec4(clipSize*a_circle.xy,a_circle.z,0.0);
    vec4 webPosition=u_mvpMatrix*vec4(u_center,1.0);
    gl_Position=webPosition+clipCircle*webPosition.w;
    gl_PointSize=u_size;
}
`;
circleShader.fs=`#version 300 es
precision mediump float;
uniform vec4 u_color;
out vec4 outColor;
uniform float u_alpha;
void main(){
    outColor=u_color;
    outColor.a=u_alpha;
    if(outColor.a<=0.1){
        discard;
    }
}
`;

circleShader.getLocations=function(gl,program){
    return {
        positionAttributeLocation:gl.getAttribLocation(program,"a_circle"),
        centerLocation:gl.getUniformLocation(program,"u_center"),
        sizeLocation:gl.getUniformLocation(program,"u_size"),
        mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
        viewportLocation:gl.getUniformLocation(program,"u_viewport"),
        colorLocation:gl.getUniformLocation(program,"u_color"),
        alphaLocation:gl.getUniformLocation(program,"u_alpha")
    }
};
;"use strict";
/**
 * 地理解决方案中的电子墙着色器，普通着色器。添加RTE。
 * @type {*|{}}
 * @private
 */
hmap.shader=hmap.shader||{};
hmap.shader.EleWallShaderO={};
hmap.shader.EleWallShaderO.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  float a_size;
    in  vec4  a_color;
    out vec4  v_color;
    
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    void main(){
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        gl_PointSize=a_size;
        v_color=a_color;
    }
`;
hmap.shader.EleWallShaderO.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
        outColor=v_color;
    }
`;
hmap.shader.EleWallShaderO.getLocations=function(gl,program){
    return{
        a_positionH:gl.getAttribLocation(program,"a_positionH"),
        a_positionL:gl.getAttribLocation(program,"a_positionL"),
        u_cameraH:gl.getUniformLocation(program,"u_cameraH"),
        u_cameraL:gl.getUniformLocation(program,"u_cameraL"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_ifRTE:gl.getUniformLocation(program,"u_ifRTE"),
        a_color:gl.getAttribLocation(program,"a_color"),
        a_size:gl.getAttribLocation(program,"a_size")
    };
};;"use strict";
hmap.geosolution=hmap.geosolution||{};
/**
 * 热力图颜色帧缓冲使用的着色器
 * @type {string}
 * @private
 */
hmap.geosolution.Heatmap.prototype.colorVsShader=`#version 300 es
in vec4 a_position;
in vec4 a_color;
out vec4 v_color;
void main(){
    gl_Position=a_position;
    v_color=a_color;
}`;
hmap.geosolution.Heatmap.prototype.colorFsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;

}
`;
/**
 * 热力图计算帧缓冲使用的着色器
 * @type {string}
 * @private
 */
hmap.geosolution.Heatmap.prototype.frameVsShader=`#version 300 es
in vec4 a_position;
in float a_value;
uniform float u_size;
uniform float u_maxValue;
uniform mat4 u_matrix;
out float v_ratio;
out float v_distFog;
void main(){
    gl_Position=u_matrix*a_position;
    gl_PointSize=u_size;
    v_ratio=a_value/u_maxValue;
    v_distFog=gl_Position.w;
}
`;
hmap.geosolution.Heatmap.prototype.frameFsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in float v_ratio;
out vec4 outColor;
in float v_distFog;
void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
            discard;
    }
    // outColor=vec4(0.0,0.0,0.0,v_ratio)*2.0*smoothstep(0.5,0.0,dist);
    outColor=vec4(0.0,0.0,0.0,v_ratio)*smoothstep(0.5,0.0,dist);
    outColor.a=outColor.a;
    outColor.r=v_distFog;
}
`;
/**
 * 热力图渲染使用的着色器
 * @type {string}
 * @private
 */
hmap.geosolution.Heatmap.prototype.vsShader=`#version 300 es
in vec4 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;
void main(){
    gl_Position=a_position;
    v_texCoord=a_texCoord;
}`;
hmap.geosolution.Heatmap.prototype.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform sampler2D u_texture;
uniform sampler2D u_colorTexture;
uniform vec4 u_fogColor;
uniform vec2 u_fogDist;
in vec2 v_texCoord;
out vec4 outColor;
/*根据透明度来分配颜色*/
vec4 alpha2color(float alpha){
   return texture(u_colorTexture,vec2(alpha,0.50));
}
void main(){
    outColor=texture(u_texture,v_texCoord);
    float alpha=outColor.a;
    if(alpha==0.0)discard;
    float distFog=outColor.r;
    vec4 color=alpha2color(alpha);
    
     /*雾化*/
    float fogFactor=clamp((u_fogDist.y-distFog)/(u_fogDist.y-u_fogDist.x),0.0,1.0); 
    outColor=mix(u_fogColor.rgba,color.rgba,fogFactor);
}`;

hmap.geosolution.Heatmap.prototype.getLocations=function(gl,program,type){
    switch(type){
        case "frame":
            return{
                positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
                valueAttributeLocation:gl.getAttribLocation(program,"a_value"),
                sizeLocation:gl.getUniformLocation(program,"u_size"),
                maxValueLocation:gl.getUniformLocation(program,"u_maxValue"),
                mvpMatrixLocation:gl.getUniformLocation(program,"u_matrix")
            };
        case "render":
            return{
                positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
                texCoordAttributeLocation:gl.getAttribLocation(program,"a_texCoord"),
                textureLocation:gl.getUniformLocation(program,"u_texture"),
                colorTexture:gl.getUniformLocation(program,"u_colorTexture"),
                fogColorLocation:gl.getUniformLocation(program,"u_fogColor"),
                fogDistLocation:gl.getUniformLocation(program,"u_fogDist")
            };
        case "color":
            return{
                positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
                colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
            };

    }
};
;hmap.shader = hmap.shader || {};
hmap.shader.ObjShader = {};
/**
 * 绘制模型使用的着色器
 * @type {string}
 * @private
 */
hmap.shader.ObjShader.vsShader = `#version 300 es
    in vec3 aVertexPosition;
    in vec3 aVertexNormal;
    in vec2 aTextureCoord;
    in vec3 aDiffuse;
    in vec3 aSpecular;
    in vec3 aAmbient;
    in float aSpecularExponent;
    in float aDissolve;

    uniform mat4 uMMatrix;
    uniform mat4 uVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;
    uniform vec3 uCameraPosition;
    uniform vec3 uLightPosition;

    out vec2 vTextureCoord;
    out vec3 vTransformedNormal;
    out vec4 vPosition;
    out vec4 vCameraDirection;
    out vec4 vLightDirection;

    out vec3 vDiffuse;
    out vec3 vSpecular;
    out vec3 vAmbient;
    out float vSpecularExponent;
    out float vDissolve;
    out float v_dist;//雾化参数使用
    void main(void) {
        vDiffuse = aDiffuse;
        vSpecular = aSpecular;
        vAmbient = aAmbient;
        vSpecularExponent = aSpecularExponent;
        vDissolve = aDissolve;

        // vPosition = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        // gl_Position = uPMatrix * vPosition;
        vec4 worldPosition = uMMatrix * vec4(aVertexPosition,1.0);
        mat4 mvpMatrix = uPMatrix * uVMatrix * uMMatrix;
        gl_Position = mvpMatrix * vec4(aVertexPosition, 1.0);
        vCameraDirection = vec4(uCameraPosition, 1.0) - worldPosition;
        vLightDirection = vec4(uLightPosition, 1.0) - worldPosition;
        // vCameraDirection = mvpMatrix * uCameraDirection;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = mat3(uNMatrix) * aVertexNormal;
        v_dist=gl_Position.w;
    }
`;
hmap.shader.ObjShader.fsShader = `#version 300 es 
    #define M_PI 3.1415926535897932384626433832795
    precision mediump float;

    in vec2 vTextureCoord;
    in vec3 vTransformedNormal;
    in vec4 vPosition;
    in float vDissolve;
    in vec4 vCameraDirection;
    in vec4 vLightDirection;

    in vec3 vDiffuse;
    in vec3 vSpecular;
    in vec3 vAmbient;
    in float vSpecularExponent;
    uniform vec4 u_fogColor;
    uniform float alpha;
    uniform vec2 u_fogDist;
    out vec4 outColor;
    in float v_dist;
    uniform int uUseMapAmbient;
    uniform int uUseMapDiffuse;
    uniform int uUseMapSpecular;
    uniform sampler2D uMapAmbientSampler;
    uniform sampler2D uMapDiffuseSampler;
    uniform sampler2D uMapSpecularSampler;
    uniform float u_opacity;
    
    void main(void) {
        vec3 V = normalize(vCameraDirection.xyz);
        vec3 L = normalize(vLightDirection.xyz);
        vec3 H = normalize(L + V);
        vec3 N = normalize(vTransformedNormal);

        float diffuse = max(0.0,dot(N, L));
        float specular = max(0.0,dot(H, N));
        
        if(diffuse==0.0 || vSpecularExponent == 0.0)
            specular = 0.0;
        else
            specular = pow(specular, vSpecularExponent);
        vec3 ambientColor = vAmbient;
        if(uUseMapAmbient==1){
            vec4 mapAmbientColor=texture(uMapAmbientSampler,vTextureCoord);
            ambientColor = mapAmbientColor.rgb * vAmbient;
        }
        else {
            ambientColor = vAmbient;
        }

        vec3 diffuseColor = vDiffuse;
        if(uUseMapDiffuse==1){
            vec4 mapDiffuseColor=texture(uMapDiffuseSampler,vTextureCoord);
            diffuseColor = mapDiffuseColor.rgb * vDiffuse;
        }
        else {
            diffuseColor = ambientColor * vDiffuse * (dot(L, N));
        }

        vec3 specularColor = vSpecular;
        if(uUseMapSpecular==1){
            vec4 mapSpecularColor=texture(uMapSpecularSampler,vTextureCoord);
            specularColor = mapSpecularColor.rgb * vSpecular;
        }
        else {
            // specularColor = pow((2.0 * dot(N, L) * N - L) * vCameraDirection.xyz, vec3(vSpecularExponent));
            // specularColor = lightColor * vSpecular * pow(dot(normalize(reflect(L, N)), V), vSpecularExponent);
            specularColor = ambientColor * vSpecular * (dot(L, N));
        }

        vec3 color = ambientColor + diffuseColor * diffuse + specularColor * specular;
        // float fogFactor=clamp((u_fogDist.y-v_dist)/(u_fogDist.y-u_fogDist.x),0.0,1.0);  
        // vec3 color2=mix(u_fogColor.rgb,color.rgb,fogFactor);
        outColor = vec4(color, vDissolve*alpha*u_opacity);
    }
`;

hmap.shader.ObjShader.vsShaderRTELGD = `#version 300 es
    in vec3 aVertexPosition;
    in vec3 aVertexNormal;
    in vec2 aTextureCoord;
    in vec3 aDiffuse;
    in vec3 aSpecular;
    in vec3 aAmbient;
    in float aSpecularExponent;
    in float aDissolve;

    uniform mat4 uMMatrix;
    uniform mat4 uVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;
    uniform vec3 uCameraPosition;
    uniform vec3 uCameraPositionL;
    uniform vec3 uLightPosition;
    uniform vec3 uLightPositionLow;

    out vec2 vTextureCoord;
    out vec3 vTransformedNormal;
    out vec4 vPosition;
    out vec4 vCameraDirection;
    out vec4 vLightDirection;

    out vec3 vDiffuse;
    out vec3 vSpecular;
    out vec3 vAmbient;
    out float vSpecularExponent;
    out float vDissolve;
    out float v_dist;//雾化参数使用
    
    // RTE
    in vec3 aVertexPositionL;
    uniform bool uIfRTE;

    // LGD
    uniform float uFarPlaneD;
    uniform bool  uIfLGD;
    uniform float uLogConstant;
   
    vec4 logDepth(vec4 clipPos,bool ifLGD,float logC,float farPlaneD){
        vec4 clipD=clipPos;
        if(ifLGD){
            clipD.z=
            ((2.0*log(logC*clipPos.z+1.0)/log(logC*farPlaneD+1.0))-1.0)*clipPos.w;
        }
        return clipD;
    }
    
    void main(void) {
        vDiffuse = aDiffuse;
        vSpecular = aSpecular;
        vAmbient = aAmbient;
        vSpecularExponent = aSpecularExponent;
        vDissolve = aDissolve;
        
        //RTE
        vec4 vertexPosition=vec4(aVertexPosition,1.0);
        mat4 mvMatrix=uVMatrix*uMMatrix;
        if(uIfRTE){
            float numBitBias = -0.0;
            float lowerBitBias = -23.0;
            vec3 highD=aVertexPosition-uCameraPosition;
            vec3 lowD=(aVertexPositionL-uCameraPositionL)*exp2(lowerBitBias);
            mat4 mvR2Eye=mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            vertexPosition=vec4((highD+lowD)*exp2(numBitBias),1.0);
            vec3 cameraPosition = (uCameraPosition + uCameraPositionL*exp2(lowerBitBias))*exp2(numBitBias);
            vCameraDirection = vec4(cameraPosition, 1.0) - vertexPosition;
            vec3 lightPosition = (uLightPosition + uLightPositionLow*exp2(lowerBitBias))*exp2(numBitBias);
            vLightDirection = vec4(uLightPosition , 1.0) - vertexPosition;
            vTransformedNormal = aVertexNormal;
        }else{
            vCameraDirection = vec4(uCameraPosition, 1.0) - uMMatrix*vertexPosition;
            vLightDirection = vec4(uLightPosition , 1.0) - uMMatrix*vertexPosition;
            vTransformedNormal = mat3(uNMatrix) * aVertexNormal;
        }
        mat4 mvpMatrix = uPMatrix * mvMatrix;
        vec4 clip=mvpMatrix*vertexPosition;
        gl_Position=logDepth(clip,uIfLGD,uLogConstant,uFarPlaneD);
        vTextureCoord = aTextureCoord;
        v_dist=gl_Position.w;
    }
`;
hmap.shader.ObjShader.getLocation = function (gl, program) {
    return {
        positionAttributeLocation: gl.getAttribLocation(program, "aVertexPosition"),
        normalAttributeLocation: gl.getAttribLocation(program, "aVertexNormal"),
        mMatrixLocation: gl.getUniformLocation(program, "uMMatrix"),
        vMatrixLocation: gl.getUniformLocation(program, "uVMatrix"),
        pMatrixLocation: gl.getUniformLocation(program, "uPMatrix"),
        isRTE: gl.getUniformLocation(program, "uIfRTE"),
        cameraPositionLocation:gl.getUniformLocation(program, "uCameraPosition"),
        cameraPositionLocationLow:gl.getUniformLocation(program, "uCameraPositionL"),
        lightPosition:gl.getUniformLocation(program, "uLightPosition"),
        lightPositionLow:gl.getUniformLocation(program, "uLightPositionLow"),
        isLGD:gl.getUniformLocation(program,"uIfLGD"),
        uFarPlaneD:gl.getUniformLocation(program,"uFarPlaneD"),
        uLogConstant:gl.getUniformLocation(program,"uLogConstant"),
        fogColorLocation: gl.getUniformLocation(program, "fogColor"),
        fogDistLocation: gl.getUniformLocation(program, "fogDist"),
        alpha: gl.getUniformLocation(program, "alpha"),
        normalMatrixLocation: gl.getUniformLocation(program, "uNMatrix"),
        uOpacity: gl.getUniformLocation(program, "u_opacity"),
    };
};
;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.PieShaderO={};
/**
 * 地理解决方案中绘制饼状图使用的着色器
 * radius：半径
 * height：高度
 * trans：平移量
 * @type {string}
 */
hmap.shader.PieShaderO.vsShader=`#version 300 es
in vec4  a_position;
in float a_radius;
in float a_height;
in vec4  a_color;
uniform vec3 u_trans;
uniform mat4 u_mvpMatrix;
out vec4 v_color;

void main(){
    vec4 position=a_position*vec4(a_radius,a_radius,a_height,1.0);
    gl_Position=u_mvpMatrix*(position+vec4(u_trans,0.0));
    v_color=a_color;
    gl_PointSize=20.0;
}
`;
hmap.shader.PieShaderO.fsShader=`#version 300 es
precision mediump float;
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;
}
`;
hmap.shader.PieShaderO.getLocation=function(gl,program){
    return{
      positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
      radiusAttributeLocation:gl.getAttribLocation(program,"a_radius"),
      heightAttributeLocation:gl.getAttribLocation(program,"a_height"),
      colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
      transLocation:gl.getUniformLocation(program,"u_trans"),
      mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix")
    };
};
;hmap.shader=hmap.shader||{};
hmap.shader.modelShader=hmap.shader.modelShader||{};
hmap.shader.modelShader.vsShader=`#version 300 es
in vec4 a_position;/*模型坐标系生成*/
in vec2 a_texCoord;
out vec2 v_texCoord;
uniform mat4 u_mvpMatrix;
out float v_distFog;
void main(){
    gl_Position=u_mvpMatrix*a_position;
    v_distFog=gl_Position.z;
    gl_PointSize=10.0;
    v_texCoord=a_texCoord;
}`;
hmap.shader.modelShader.fsShader=`#version 300 es
precision mediump float;
// uniform sampler2D u_pattern;
in float v_distFog;
in vec2 v_texCoord;
uniform vec4 u_color;
uniform bool u_ifTex;
uniform vec4 u_fogColor;
uniform vec2 u_fogDist;
out vec4 outColor;
void main(){
    vec4 color;
    if(u_ifTex){
        // color=texture(u_pattern,v_texCoord);
    }else{
        color=u_color;
    }  
    
     /*雾化*/
    float fogFactor=clamp((u_fogDist.y-v_distFog)/(u_fogDist.y-u_fogDist.x),0.0,1.0); 
    outColor.rgb=mix(u_fogColor.rgb,color.rgb,fogFactor);
    outColor.a=color.a;  
}
`;
hmap.shader.modelShader.fsTexShader=`#version 300 es
precision mediump float;
uniform sampler2D u_pattern;
uniform vec4 u_fogColor;
uniform vec2 u_fogDist;
in vec2 v_texCoord;
out vec4 outColor;
void main(){
    outColor=texture(u_pattern,v_texCoord);
}
`;
hmap.modelShader={}||hmap.modelShader;
hmap.modelShader.getLocations=function(gl,program){
    // if(isTex){
    //     return{
    //         positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
    //         texCoordAttributeLocation:gl.getAttribLocation(program,"a_texCoord"),
    //         scaleAttributeLocation:gl.getAttribLocation(program,"u_scale"),
    //         colorLocation:gl.getUniformLocation(program,"u_color")
    //  };
    // }else{
    return{
        positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
        texCoordAttributeLocation:gl.getAttribLocation(program,"a_texCoord"),
        mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
        colorLocation:gl.getUniformLocation(program,"u_color"),
        ifTexLocation:gl.getUniformLocation(program,"u_ifTex"),
        patternLocation:gl.getUniformLocation(program,"u_pattern"),
        fogColorLocation:gl.getUniformLocation(program,"u_fogColor"),
        fogDistLocation:gl.getUniformLocation(program,"u_fogDist")
    };
    // }
};;"use strict";
/**
 * 绘制color多边形使用的着色器
 * @private
 */
hmap.shader=hmap.shader||{};
hmap.shader.polyColor={};
/*RTE*/
hmap.shader.polyColor.vs=`#version 300 es
    in vec3 a_position;
    in vec3 a_positionL;
    
    in vec4 a_color;
    in float a_checked;
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix; 
    uniform bool u_ifRTE;
    
    out vec4 v_color;
    out float v_checked;
    out float v_dist;
    void main(){
        vec4 position=vec4(a_position,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_position-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        v_color=a_color;
        v_checked=a_checked;
        v_dist=gl_Position.w;
    }
    `;

hmap.shader.polyColor.fs=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    
    in vec4 v_color;
    in float v_checked;
    in float v_dist;

    uniform vec4 u_fogColor;
    uniform vec2 u_fogDist;
    uniform float u_opacity;

    out vec4 outColor;
    void main(){
       vec4 color=v_color;
       if(v_checked==1.0){
           color=color*color.grba;
       }
      float fogFactor=clamp((u_fogDist.y-v_dist)/(u_fogDist.y-u_fogDist.x),0.0,1.0);  
      outColor.rgb=mix(u_fogColor.rgb,color.rgb,fogFactor);
      outColor.a=color.a*u_opacity;
      if(outColor.a<=0.0){
        discard;
      }
    }
    `;

/*RTE+LGD*/
hmap.shader.polyColor.vsD=`#version 300 es
    in vec3 a_position;
    in vec3 a_positionL;
    
    in vec4 a_color;
    in float a_checked;
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix; 
    uniform bool u_ifRTE;
    
    out vec4 v_color;
    out float v_checked;
    out float v_dist;
    
    //LGD
    uniform float u_farPlaneD;
    uniform bool  u_ifLGD;
    uniform float u_logConstant;
    
    vec4 logDepth(vec4 clipPos,bool ifLGD,float logC,float farPlaneD){
        vec4 clipD=clipPos;
        if(ifLGD){
            clipD.z=
            ((2.0*log(logC*clipPos.z+1.0)/log(logC*farPlaneD+1.0))-1.0)*clipPos.w;
        }
        return clipD;
    }
    
    void main(){
        vec4 position=vec4(a_position,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_position-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        vec4 clip=u_projMatrix*mvMatrix*position;
        gl_Position=logDepth(clip,u_ifLGD,u_logConstant,u_farPlaneD);
        v_color=a_color;
        v_checked=a_checked;
        v_dist=gl_Position.w;
    }
    `;;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.ShineShader={};
/**
 * 地理解决方案泛光使用着色器
 * @type {string}
 * @private
 */
hmap.shader.ShineShader.vsShader=`#version 300 es
in  vec3  a_prePositionH;
in  vec3  a_prePositionL;
in  vec3  a_positionH;
in  vec3  a_positionL;
in  vec3  a_nextPositionH;
in  vec3  a_nextPositionL;
in  float a_scale;
in  vec4  a_color;
in  float a_isOffset;

uniform vec3 u_cameraH;
uniform vec3 u_cameraL;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform bool u_ifRTE;
    
out vec4 v_color;
void main(){
    vec4 position=vec4(a_positionH,1.0);
    vec4 prePosition=vec4(a_prePositionH,1.0);
    vec4 nextPosition=vec4(a_nextPositionH,1.0);
    mat4 mvMatrix=u_mvMatrix;    
    if(abs(a_isOffset)>0.00001){
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            position=vec4(highD+lowD,1.0);
            
            vec3 preHighD=a_prePositionH-u_cameraH;
            vec3 preLowD=(a_prePositionL-u_cameraL)/10000000.0;
            prePosition=vec4(preHighD+preLowD,1.0);
            
            vec3 nextHighD=a_nextPositionH-u_cameraH;
            vec3 nextLowD=(a_nextPositionL-u_cameraL)/10000000.0;
            nextPosition=vec4(nextHighD+nextLowD,1.0);
            
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;           
        }        
        vec4 dir;vec4 dir1;vec4 dir2;vec4 normal;
		float a = 1.0;
		if( abs(nextPosition.x - position.x)<=0.000001 && abs(nextPosition.y - position.y)<=0.000001){
			dir = normalize( position - prePosition );
			normal = vec4(-dir.y,dir.x,dir.z,0);
		}
		else if( abs(prePosition.x - position.x)<=0.000001 && abs(prePosition.y - position.y) <=0.000001){
			dir = normalize( nextPosition - position );
			normal = vec4(-dir.y,dir.x,dir.z,0);
		}
		else {
			dir1 = normalize( position - prePosition );
			dir2 = normalize( nextPosition - position );
			dir = normalize( dir1 + dir2);
			normal = vec4(-dir.y,dir.x,dir.z,0);
			float cc = abs(atan(normal.y/normal.x) - atan(dir2.y/dir2.x));
			a = sin(cc);
		}
		gl_Position = u_projMatrix*mvMatrix*(position + normal*0.01*a_scale/a);
    }else{
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            position=vec4(highD+lowD,1.0);
            
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
        }
        gl_Position = u_projMatrix*mvMatrix*position;
    }
    gl_PointSize = 1.0;
    v_color = a_color;
    }
    `;//normal
hmap.shader.ShineShader.fsShader=`#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
in vec4 v_color;
out vec4 outColor;
void main() {
      outColor=v_color;
}
`;
hmap.shader.ShineShader.getLocation=function(gl,program){
    return{
        a_positionH:gl.getAttribLocation(program,"a_positionH"),
        a_positionL:gl.getAttribLocation(program,"a_positionL"),

        a_prePositionH:gl.getAttribLocation(program,"a_prePositionH"),
        a_prePositionL:gl.getAttribLocation(program,"a_prePositionL"),

        a_nextPositionH:gl.getAttribLocation(program,"a_nextPositionH"),
        a_nextPositionL:gl.getAttribLocation(program,"a_nextPositionL"),

        u_cameraH:gl.getUniformLocation(program,"u_cameraH"),
        u_cameraL:gl.getUniformLocation(program,"u_cameraL"),

        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_ifRTE:gl.getUniformLocation(program,"u_ifRTE"),

        isOffset:gl.getAttribLocation(program,"a_isOffset"),
        scale:gl.getAttribLocation(program,"a_scale"),
        color:gl.getAttribLocation(program,"a_color")
    }
};;let sparkPointShader={};
sparkPointShader.vs=`#version 300 es
    in vec4 a_position;
    in vec4 a_color;
    flat out vec4 v_color;
    in float a_size;
    uniform mat4 u_mvpMatrix;
    void main(){
        gl_Position=u_mvpMatrix*a_position;
        gl_PointSize=a_size;
        v_color=a_color;
    }
`;
sparkPointShader.fs=`#version 300 es
    precision mediump float;
    uniform sampler2D u_pattern;
    uniform bool u_texIf;
    uniform vec4 u_color;
    flat in vec4 v_color;
    out vec4 outColor;
    void main(){
     if(u_texIf){
        vec4 texColor=texture(u_pattern,gl_PointCoord);
        outColor=v_color*texColor;
     }else{
        outColor=u_color;
     }
     if(outColor.a==0.0)discard;
    }
`;
sparkPointShader.getLocations=function(gl,program){
    return{
        positionAttributeLocation:gl.getAttribLocation(program,"a_position"),
        colorAttributeLocation:gl.getAttribLocation(program,"a_color"),
        sizeAttributeLocation:gl.getAttribLocation(program,"a_size"),
        mvpMatrixLocation:gl.getUniformLocation(program,"u_mvpMatrix"),
        patternLocation:gl.getUniformLocation(program,"u_pattern"),
        textureIfLocation:gl.getUniformLocation(program,"u_texIf"),
        colorLocation:gl.getUniformLocation(program,"u_color")
    };
};;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.TadpoleShaderO={};
/**
 * 地理解决方案蝌蚪图使用着色器，使用RTE
 * @type {string}
 * @private
 */
hmap.shader.TadpoleShaderO.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  float a_size;
    in  vec4  a_color;
    out vec4  v_color;
    
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    void main(){
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        gl_PointSize=a_size;
        v_color=a_color;
    }  
`;
hmap.shader.TadpoleShaderO.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
        discard;
    }else{
        outColor=v_color;
        
    }
}
`;
hmap.shader.TadpoleShaderO.getLocation=function(gl,program){
    return{
        a_positionH:gl.getAttribLocation(program,"a_positionH"),
        a_positionL:gl.getAttribLocation(program,"a_positionL"),
        u_cameraH:gl.getUniformLocation(program,"u_cameraH"),
        u_cameraL:gl.getUniformLocation(program,"u_cameraL"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_ifRTE:gl.getUniformLocation(program,"u_ifRTE"),
        a_size:gl.getAttribLocation(program,"a_size"),
        a_color:gl.getAttribLocation(program,"a_color"),
    }
};;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.FlowsOldShader={};
/**
 * 地理解决方案中流线动画使用的着色器，使用RTE
 * @type {string}
 * @private
 */
hmap.shader.FlowsOldShader.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  vec4  a_color;
    out vec4  v_color;

    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    void main(){
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        v_color=a_color;
    }  
`;
hmap.shader.FlowsOldShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
        outColor=v_color;
    }
`;

hmap.shader.FlowsOldShader.getLocation=function(gl,program){
    return{
        a_positionH:gl.getAttribLocation(program,"a_positionH"),
        a_positionL:gl.getAttribLocation(program,"a_positionL"),
        u_cameraH:gl.getUniformLocation(program,"u_cameraH"),
        u_cameraL:gl.getUniformLocation(program,"u_cameraL"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_ifRTE:gl.getUniformLocation(program,"u_ifRTE"),
        a_color:gl.getAttribLocation(program,"a_color"),                //颜色
    }
};;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.tmsShader={};
/**
 * 渲染tms使用着色器
 * @type {string}
 * @private
 */
hmap.shader.tmsShader.vsShader=
    `#version 300 es
  layout(location=0) in vec4 a_Position;
  layout(location=1) in vec2 a_TexCoord;
  out vec2 v_TexCoord;
  uniform mat4 mvpMatrix;
  out float v_dist;
  void main(){
     gl_Position=mvpMatrix*a_Position;
     v_TexCoord=a_TexCoord;
     v_dist=gl_Position.w;
 }`;


hmap.shader.tmsShader.fsShader=
    `#version 300 es
  precision mediump float;
  uniform sampler2D u_Sampler;
  uniform vec4 u_color;
  uniform vec4 u_fogColor;
  uniform vec2 u_fogDist;
  uniform float u_opacity;
  in vec2 v_TexCoord;
  in float v_dist;
  out vec4 outColor;
  void main(){
       vec4 texColor=texture(u_Sampler,v_TexCoord);
       float fogFactor=clamp((u_fogDist.y-v_dist)/(u_fogDist.y-u_fogDist.x),0.0,1.0); 
       outColor.rgb=mix(u_fogColor.rgb,texColor.rgb,fogFactor);
       outColor.a=texColor.a * u_opacity;
  }`;
;"use strict";
hmap.shader=hmap.shader||{};
hmap.shader.ViewsedShaderO={};
/**
 * 地理解决方案，可视域使用着色器
 * @type {string}
 * @private
 */
hmap.shader.ViewsedShaderO.vsShader=`#version 300 es
in vec3  a_position;
in float a_radius;
in vec3  a_scale;
in vec4  a_color;
in vec3  a_orien;//朝向向量
in vec3  a_location;
uniform mat4 u_mvpMatrix;
out vec4 v_color;

//有朝向向量的原始朝向向量计算夹角和旋转轴,旋转夹角为第四个参数
vec4 calcRotate(vec3 orien){
    float angle=0.0;
    //vec3 normal=vec3(0,0,-1);默认朝向z负半轴
    vec3 normal=vec3(1,0,0);//默认朝向
    angle=acos(dot(normal,normalize(orien)));
    vec3 rotateAxis=cross(normal,normalize(orien));
    return vec4(rotateAxis,angle);
}
//根据旋转向量和旋转角度计算旋转矩阵
mat3 calcRotateM(vec4 rotate){
    float c=cos(rotate.w);
    float s=sin(rotate.w);
    float x=rotate.x;
    float y=rotate.y;
    float z=rotate.z;
    
    vec3 l1=vec3(c+(1.-c)*x*x,(1.-c)*x*y+s*z,(1.-c)*x*z-s*y);
    vec3 l2=vec3((1.-c)*x*y-s*z,c+(1.-c)*y*y,(1.-c)*y*z+s*x);
    vec3 l3=vec3((1.-c)*x*z+s*y,(1.-c)*y*z-s*x,c+(1.-c)*z*z);
    return mat3(l1,l2,l3);
}
//初始化模型顶点的边长
const float Length=length(vec3(0.5,0.5,1.0));
void main(){
    //变换模型为设定模式
    // vec3 position=a_position*a_scale*a_radius/Length;默认朝向z负半轴
    vec3 position=a_position*vec3(a_scale.z,a_scale.y,a_scale.x)*a_radius/Length;//默认朝向x正半轴
    //旋转模型到正确朝向,并进行平移
    vec4 rotate=calcRotate(a_orien);
    mat3 rotateMatrix=calcRotateM(rotate);
    
    vec3 positionRT=rotateMatrix*position+a_location;
    gl_Position=u_mvpMatrix*vec4(positionRT,1.0);
    v_color=a_color;
    gl_PointSize=5.0;
}`;
hmap.shader.ViewsedShaderO.fsShader=`#version 300 es
precision mediump float;
in vec4 v_color;
out vec4 outColor;
void main(){
    outColor=v_color;
}
`;
hmap.shader.ViewsedShaderO.getLocation=function(gl,program){
    return{
        a_position:gl.getAttribLocation(program,"a_position"),
        a_radius:gl.getAttribLocation(program,"a_radius"),
        a_scale:gl.getAttribLocation(program,"a_scale"),
        a_color:gl.getAttribLocation(program,"a_color"),
        a_orien:gl.getAttribLocation(program,"a_orien"),
        a_location:gl.getAttribLocation(program,"a_location"),
        u_mvpMatrix:gl.getUniformLocation(program,"u_mvpMatrix")
    };
};;hmap.shader = hmap.shader || {};
hmap.shader.FbxShader = {};
/**
 * 绘制FBX模型使用的着色器
 * @private
 */
hmap.shader.FbxShader.vs =`#version 300 es
		in vec3 a_position;
		in vec3 a_positionL;
		in vec4 a_normal;
		in vec3 a_color;

		out vec3 v_color;
		out vec3 v_light1;
		out vec3 v_light2;

		// 纹理
		in vec2 a_texCoord;
		out vec2 v_texCoord;

		uniform mat4 u_normalMatrix;//法向量矩阵
		uniform mat4 u_allMMatrix;//顶点变换矩阵

    	uniform vec3  emissive;//自发光色
    	uniform vec3  ambient;//环境光色

    	uniform vec3  diffuse;//漫反射光色
    	uniform vec3  specular;//镜面高光色
    	uniform float shininess;//高光光泽度

    	uniform float  useEmissive;
    	uniform float  useAmbient;
    	uniform float  usePointDiffuse;
    	uniform vec3  lightPosition;//点光源位置
    	uniform float  useDirectDiffuse;
    	uniform vec3  lightDirection;//平行光方向
    	uniform float  useSpecular;
    	uniform vec3  eyePosition;//视点位置（点光源的高光）
    	

		// 地理坐标精度
    	uniform mat4 u_mvMatrix;//视图矩阵
    	uniform mat4 u_projMatrix;//投影矩阵
		uniform vec3 u_cameraH;
    	uniform vec3 u_cameraL;
    	uniform float u_ifRTE;

    	// 深度的精度
	    uniform float u_farPlaneD;
	    uniform bool  u_ifLGD;
	    uniform float u_logConstant;
	    vec4 logDepth(vec4 clipPos,bool ifLGD,float logC,float farPlaneD){
			vec4 clipD = clipPos;
			// if(ifLGD){
			// 	clipD.z = 
			// 	((2.0*log(logC*clipPos.z+1.0)/log(logC*farPlaneD+1.0))-1.0)*clipPos.w;
			// }
			return clipD;
		}

		void main(){
			vec4 position=vec4(a_position,1.0);
			mat4 mvMatrix=u_mvMatrix*u_allMMatrix;
	        if(u_ifRTE==1.0){
	            vec4 wPosition=u_allMMatrix*vec4(a_position+a_positionL/10000000.0,1.0);
	            vec4 wCamera=vec4(u_cameraH+u_cameraL/10000000.0,0.0);
	            position=wPosition-wCamera;
	            mat4 mvR2Eye=u_mvMatrix;
	            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
	            mvMatrix=mvR2Eye;
	        }
	        vec4 clip = u_projMatrix*mvMatrix*position;
	        gl_Position=logDepth(clip,u_ifLGD,u_logConstant,u_farPlaneD);
	        vec4 vertexPosition = u_allMMatrix*position;

	        vec3 eValue = vec3(0.0);
	        if(useEmissive==1.0){
	        	eValue = emissive;
	        }
	        vec3 aValue = vec3(0.0);
	        if(useAmbient==1.0){
	        	aValue = ambient;
	        }

	        // 漫反射(高光与漫反射类型有关)
	        vec3 normal = normalize(vec3(u_normalMatrix * a_normal));
	        float nDotL;
	        vec3 dValue=vec3(0.0);
	        if(useDirectDiffuse==1.0){//平行光
	        	vec3 dlightDirection = normalize(lightDirection);
	        	nDotL=max(dot(dlightDirection,normal),0.0);
	        	dValue = dValue + diffuse*nDotL;
	        }
	        if(usePointDiffuse==1.0){//点光源
	        	vec3 dlightDirection = normalize(lightPosition-vec3(vertexPosition));
	        	nDotL=max(dot(dlightDirection,normal),0.0);
	        	dValue = dValue + diffuse*nDotL;
	        }

	        // 镜面高光 
	        vec3 specularDirection;
	        vec3 sValue=vec3(0.0);
	        if(useSpecular==1.0 && useDirectDiffuse==1.0){//平行光的高光
		        specularDirection=normalize(lightDirection);
	        	float specularDot = max(dot(specularDirection,normal),0.0);
		        if(nDotL==0.0){
		        	specularDot=0.0;
		        }else{
		        	specularDot=pow(specularDot,shininess);
		        }
	        	sValue = specular*specularDot;
	        }else if(useSpecular==1.0 && usePointDiffuse==1.0){//点光源的高光
	        	vec3 dlightDirection = normalize(lightPosition-vec3(vertexPosition));
	        	specularDirection=normalize(dlightDirection+eyePosition);
	        	float specularDot = max(dot(specularDirection,normal),0.0);
	        	if(nDotL==0.0){
		        	specularDot=0.0;
		        }else{
		        	specularDot=pow(specularDot,shininess);
		        }
	        	sValue = specular*specularDot;
	        }
	        
	        // 最终Color
	        v_light1 = eValue;
	        v_light2 = aValue + dValue + sValue;

	        v_color = a_color;
	        v_texCoord = a_texCoord;
		}
`;

hmap.shader.FbxShader.fs =`#version 300 es
		precision mediump float;
		uniform float opacity;//透明度
		uniform float u_opacityFactor;//模型的透明因子
		uniform float u_opacity;//图层透明因子

		in vec3 v_color;
		in vec3 v_light1;
		in vec3 v_light2;
		in vec2 v_texCoord;

		uniform sampler2D u_sampler;
		uniform float  u_useTexture;

		out vec4 outColor;
		void main(){
			vec4 color = vec4(v_color.rgb,1.0);

			if(u_useTexture==1.0){
		        color = texture(u_sampler, v_texCoord);
		    }

		    vec3 rgb;
		    if(v_light2.x==0.0 && v_light2.y==0.0 && v_light2.z==0.0){
		    	rgb = min((color.rgb + v_light1),vec3(1.0));
		    }else{
		    	rgb = min((color.rgb*v_light2 + v_light1),vec3(1.0));
		    	// rgb = min((color.rgb+v_light1)*v_light2,vec3(1.0));
		    }
	        outColor = vec4(rgb,opacity*u_opacityFactor*u_opacity);
		}
`;
;"use strict";
/**
 * 地理解决方案中的电子墙着色器，普通着色器。添加RTE。
 * @type {*|{}}
 * @private
 */
hmap.shader=hmap.shader||{};
hmap.shader.FlowLightShader={};
hmap.shader.FlowLightShader.vsShader=`#version 300 es
    in  vec3  a_positionH;
    in  vec3  a_positionL;
    in  vec4  a_color;
    out vec4  v_color;
    
    uniform vec3 u_cameraH;
    uniform vec3 u_cameraL;
    uniform mat4 u_mvMatrix;
    uniform mat4 u_projMatrix;
    uniform bool u_ifRTE;
    void main(){
        vec4 position=vec4(a_positionH,1.0);
        mat4 mvMatrix=u_mvMatrix;
        if(u_ifRTE){
            vec3 highD=a_positionH-u_cameraH;
            vec3 lowD=(a_positionL-u_cameraL)/10000000.0;
            mat4 mvR2Eye=u_mvMatrix;
            mvR2Eye[3]=vec4(0.0,0.0,0.0,mvR2Eye[3][3]);
            mvMatrix=mvR2Eye;
            position=vec4(highD+lowD,1.0);
        }
        gl_Position=u_projMatrix*mvMatrix*position;
        v_color=a_color;
    }
`;
hmap.shader.FlowLightShader.fsShader=`#version 300 es
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    in vec4 v_color;
    out vec4 outColor;
    void main(){
        outColor=v_color;
    }
`;
hmap.shader.FlowLightShader.getLocations=function(gl,program){
    return{
        a_positionH:gl.getAttribLocation(program,"a_positionH"),
        a_positionL:gl.getAttribLocation(program,"a_positionL"),
        u_cameraH:gl.getUniformLocation(program,"u_cameraH"),
        u_cameraL:gl.getUniformLocation(program,"u_cameraL"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_ifRTE:gl.getUniformLocation(program,"u_ifRTE"),
        a_color:gl.getAttribLocation(program,"a_color")
    };
};;"use strict";
hmap.shader = hmap.shader || {};
hmap.shader.GLTFShader = {};
hmap.shader.GLTFShader.vsShader=`#version 300 es
in vec4 a_position;
in vec2 a_texcoord_0;
in vec3 a_normal;
uniform mat4 u_vpMatrix;
uniform mat4 u_worldMatrix;
out vec4 v_position;
out vec2 v_texCoord;
out vec3 v_normal;
void main(){
    gl_Position=u_vpMatrix*u_worldMatrix*a_position;
    v_position=u_worldMatrix*a_position;
    v_texCoord=a_texcoord_0;
	v_normal=a_normal;
}`;
hmap.shader.GLTFShader.fsShader=`#version 300 es
precision mediump float;
in vec4 v_position;
in vec2 v_texCoord;
in vec3 v_normal;
uniform sampler2D u_tex;
uniform bool u_ifTex;
uniform vec4 u_color;
uniform vec3 u_lightDirection;
uniform float u_opacity;
out vec4 outColor;
void main(){
vec3 dx=dFdx(v_position.xyz);
vec3 dy=dFdy(v_position.xyz);
vec3 n=(normalize(cross(normalize(dx),normalize(dy))));
vec3 light=normalize(u_lightDirection);
//float diff=clamp(dot(n,light),0.5,1.0);
float diff=clamp(dot(v_normal,light),0.1,1.0);

//颜色处理
if(u_ifTex){
    outColor=texture(u_tex,v_texCoord);
   outColor=outColor*u_color+outColor*vec4(0.4,0.4,0.4,0.4);
}else{
    outColor=u_color;
    outColor=vec4(u_color.rgb*diff,1.0);
	outColor=outColor+u_color*vec4(0.4,0.4,0.4,0.4);
	//outColor.a=1.0;
}
outColor.a=outColor.a*u_opacity;
}`;
;hmap.shader=hmap.shader||{};
/**
 * 填充水的特效
 * @private
 * */
hmap.shader.FillWaterOldShader={};
hmap.shader.FillWaterOldShader.vsShader=`#version 300 es
in vec4 a_position;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
void main() {
  gl_Position = u_projMatrix*u_mvMatrix*a_position;
}
`;
hmap.shader.FillWaterOldShader.fsShader=`#version 300 es
precision highp float;
#define TAU 6.28318530718
#define MAX_ITER 5
#define INTENSITY 0.004
#define SCALE 500.0         //1000.0
uniform float u_time;
out vec4 outColor;
void main() {
    vec2 uv = gl_FragCoord.xy/SCALE;
    vec2 p = mod(uv * TAU, TAU) - 250.0;
    vec2 i = vec2(p);
    float c = 0.9;
    for (int n = 0; n < MAX_ITER; n++) {
        float t = 0.5 * u_time*2.0 * (1.0 - (3.5 / (float(n)+1.0)));
        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / INTENSITY), p.y / (cos(i.y + t) / INTENSITY)));
    }
    c = 1.17 - pow(c / float(MAX_ITER), 1.4);
    outColor=vec4(clamp(vec3(pow(abs(c), 8.0)) + vec3(0.0, 0.1, 0.6), 0.0, 1.0), 1.0);          //0.0, 0.35, 0.5
}
`;

hmap.shader.FillWaterOldShader.getLocations=function(gl,program){
    return{
        a_position:gl.getAttribLocation(program,"a_position"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_time:gl.getUniformLocation(program,"u_time")
    };
};;hmap.shader=hmap.shader||{};
hmap.shader.ParticleOldShader={};
/**
 * 粒子系统着色器
 * @private
 * */
hmap.shader.ParticleOldShader.vsShader=`#version 300 es
uniform highp float;
in vec4 a_position;
uniform mat4 u_mvMatrix;
uniform mat4 u_projMatrix;
uniform float u_size;

in vec3 a_originForce;          //初始的力,逐顶点
in float a_offsetIndex;         //偏移索引
uniform float u_offsetCount;    //点的数量
uniform float u_ctrlOffset;     //偏移，控制粒子流动的速度，递增
uniform vec4 u_originPosition;  //开始点
uniform vec3 u_gravity;         //地球引力
uniform vec3 u_inertia;         //惯性

void main() {
    float offset = u_ctrlOffset;
    if(offset - a_offsetIndex > 0.0){
        float a_offset = offset - a_offsetIndex;
        while(a_offset > u_offsetCount){
           a_offset -= u_offsetCount;
        }
        vec3 gravityDis = vec3(0.,0.,0.);
        for(float i=0.0;i<a_offset;i++){
            gravityDis += i*u_gravity;
        }
        vec3 totalForce =  u_inertia*a_offset + a_originForce*a_offset + gravityDis;       //合速度
        vec4 position = vec4(a_position.xyz + totalForce, a_position.w);
        gl_Position = u_projMatrix*u_mvMatrix*position;
        gl_PointSize = u_size;
    }
}
`;

hmap.shader.ParticleOldShader.fsShader=`#version 300 es
precision highp float;
uniform vec4 u_color;
out vec4 outColor;

void main() {
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist>0.5){
        discard;
    }else{
        vec4 color = u_color;
        outColor =vec4(color.rgb,cos(3.14159*dist));       //以cos规律渐变的圆
    }      
}
`;
hmap.shader.ParticleOldShader.getLocations=function(gl,program){
    return{
        a_position:gl.getAttribLocation(program,"a_position"),
        a_originForce:gl.getAttribLocation(program,"a_originForce"),
        a_offsetIndex:gl.getAttribLocation(program,"a_offsetIndex"),
        u_size:gl.getUniformLocation(program,"u_size"),
        u_color:gl.getUniformLocation(program,"u_color"),
        u_mvMatrix:gl.getUniformLocation(program,"u_mvMatrix"),
        u_projMatrix:gl.getUniformLocation(program,"u_projMatrix"),
        u_offsetCount:gl.getUniformLocation(program,"u_offsetCount"),
        u_ctrlOffset:gl.getUniformLocation(program,"u_ctrlOffset"),
        u_originPosition:gl.getUniformLocation(program,"u_originPosition"),
        u_gravity:gl.getUniformLocation(program,"u_gravity"),
        u_inertia:gl.getUniformLocation(program,"u_inertia")
    };
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.MathModelRender=class{
    constructor(){
    }

    setResolution(res){
        this.res=res;
    }

    _initToRender(){}

    draw(drawMap,uniforms,mode){}

    drawFrame(drawMap,uniforms){}

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){}

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){}

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {}

    /**
     * 重新创建一遍缓冲区，并填充数据。
     * 注：应对上下文丢失
     * @private
     */
    _reBuffers(){
        this._deleteBuffers();
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }

    /**
     * 删除绘制使用的缓冲区
     * @private
     */
    _deleteBuffers(){
        for(const [name,buffer] of Object.entries(this._buffers)){
            this.gl.deleteBuffer(buffer);
        }
    }
    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param offset,偏移量
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array,offset, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建顶点数组
     * @param location
     * @param dataType
     * @param size
     * @returns {AudioBuffer | WebGLBuffer}
     * @private
     */
    _createVerBuffer(location,dataType,size){
        let buffer=this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffer);
        this.gl.vertexAttribPointer(location, size,this.gl[dataType], false, 0, 0);
        this.gl.enableVertexAttribArray(location);
        return buffer;
    }

    _createTexture(image){
        return this._program.addGLTexture(image,0,"REPEAT","REPEAT");
    }

    /**
     * 创建帧缓冲
     * @private
     * @param {Number} textureWidth 纹理宽
     * @param {Number} textureHeight 纹理高
     * @param {Number} texUnit 纹理单元
     * @param {Object} texOpts 纹理参数
     * @returns {Object}
     */
    _createFrameBuffer(textureWidth,textureHeight,texUnit=0,texOpts={"internalFormat":"RGBA","format":"RGBA","type":"UNSIGNED_BYTE"}){
        let gl=this.gl;

        //创建帧缓冲
        const frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        //创建渲染缓冲,设置大小,设定为帧缓冲的深度关联对象,实现隐藏面消除等
        const depthRenderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureWidth, textureHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);

        //纹理设置(数据),绘制是将帧缓冲作为纹理
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        const fTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, fTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl[texOpts.internalFormat], textureWidth, textureHeight, 0, gl[texOpts.format], gl[texOpts.type], null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
        //设定帧缓冲的颜色关联对象,并指定纹理
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fTexture, 0);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        const e=gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if(e!==gl.FRAMEBUFFER_COMPLETE){
            throw "Framebuffer object is incomplete:"+e.toString();
        }

        return{frameBuffer:frameBuffer,
            depthRenderBuffer:depthRenderBuffer,
            texture:fTexture,unit:texUnit}
    }
};
;"use strict";
hmap.render=hmap.render||{};
hmap.render.BarRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize,sideNum){
        super();
        this.CLASS_NAME="hmap.render.BarRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._program=new hmap.program.BarProgram(this.gl,hmap.shader.BarShader.vsShader,hmap.shader.BarShader.fsShader);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
        this._drawCount=this._addStaticBufferD();
    }

    draw(drawMap,uniforms,mode){
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(drawMap);
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLES,this._drawCount,this.gl.UNSIGNED_SHORT,0,drawMap.idArray.length);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        let barData=hmap.render.BarRender._createBar(this._sideNum);
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_position,new Float32Array(barData.positions),false);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(barData.indices),this.gl.STATIC_DRAW);
        this.gl.bindVertexArray(null);
        return barData.count;
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_center,new Float32Array(drawMap.centers),false);
        this._addVerBuffer(this._buffers.a_color0,new Float32Array(drawMap.colors0),false);
        this._addVerBuffer(this._buffers.a_color1,new Float32Array(drawMap.colors1),false);
        this._addVerBuffer(this._buffers.a_value,new Float32Array(drawMap.values),false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        this.gl.bindVertexArray(this._vao);
        let b={},locations=this._program.getAttributeLocations();
        b.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        b.a_center=this._createVerBuffer(locations.a_center,"FLOAT",3);
        this.gl.vertexAttribDivisor(locations.a_center,1);
        b.a_value=this._createVerBuffer(locations.a_value,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_value,1);
        b.a_color0=this._createVerBuffer(locations.a_color0,"FLOAT",4);
        this.gl.vertexAttribDivisor(locations.a_color0,1);
        b.a_color1=this._createVerBuffer(locations.a_color1,"FLOAT",4);
        this.gl.vertexAttribDivisor(locations.a_color1,1);
        b.index=this.gl.createBuffer();
        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null);
        this.gl.bindVertexArray(null);
        this._upBuffer=false;
        return b;
    }

    /**
     * 创建柱状图模型数据
     * 注：组织两份索引值，包括顶面和侧面，然后合并索引值，使用trangles方式统一进行绘制。
     *     方便调用实例化接口
     * @private
     */
    static _createBar(div=4){
        let posArray=[0,0,1];//顶面中心点
        let eleArray1=[];//顶面中心点索引
        let eleArrayS=[];//侧面索引
        //处理第一个点
        const x=Math.cos(0),y=Math.sin(0);
        posArray.push(x,y,0.0,x,y,1.0);
        for(let i=1;i<=div;i++){
            const angle=2.0*Math.PI/div*i;
            const x=Math.cos(angle);
            const y=Math.sin(angle);
            posArray.push(x,y,0.0,x,y,1.0);
            eleArray1.push(2*i+2,0,2*i);
            eleArrayS.push(2*i-1,2*i+1,2*i,2*i,2*i+1,2*i+2);
        }
        const indices=[...eleArray1,...eleArrayS];
        return{
            positions:posArray,
            indices:indices,
            count:indices.length
        };
    }
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.EleWallRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize,sideNum){
        super();
        this.CLASS_NAME="hmap.render.EleWallRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._program=new hmap.program.EleWallProgram(this.gl,hmap.shader.EleWallShader.vsShaderRTE,hmap.shader.EleWallShader.fsShader);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
    }

    draw(drawMap,uniforms,mode){
        this._program.useProgram();
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(drawMap);
        let sum=0;
        for(let i=0,len=drawMap.idArray.length;i<len;i++){
            uniforms.u_height=drawMap.heights[i];
            uniforms.u_distLast=drawMap.distLasts[i];
            uniforms.u_animParam=drawMap.animParams[i];
            uniforms.u_color0=drawMap.colors0[i];
            uniforms.u_color1=drawMap.colors1[i];
            uniforms.u_ifTex=drawMap.ifTexs[i];
            uniforms.u_repeat=drawMap.repeats[i];
            this._program.setPrivateUniforms(uniforms);
            this.gl.bindTexture(this.gl.TEXTURE_2D,drawMap.textures[i]||null);
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP,sum,drawMap.numArray[i]);
            // this.gl.drawArrays(this.gl.POINTS,sum,drawMap.numArray[i]);
            sum+=drawMap.numArray[i];
        }

        this.gl.bindVertexArray(null);
    }


    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_position,new Float32Array(drawMap.positions),false);
        this._addVerBuffer(this._buffers.a_distance,new Float32Array(drawMap.distances),false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        this.gl.bindVertexArray(this._vao);
        let b={},locations=this._program.getAttributeLocations();
        // b.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        b.a_position = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,b.a_position);
        this.gl.vertexAttribPointer(locations.a_positionH, 3, this.gl.FLOAT, false, this._posSize*4, 0);
        this.gl.enableVertexAttribArray(locations.a_positionH);
        this.gl.vertexAttribPointer(locations.a_positionL, 3, this.gl.FLOAT, false, this._posSize*4, (this._posSize-3)*4);
        this.gl.enableVertexAttribArray(locations.a_positionL);
        b.a_distance=this._createVerBuffer(locations.a_distance,"FLOAT",1);
        this.gl.bindVertexArray(null);
        this._upBuffer=false;
        return b;
    }
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.FilledCircleRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize){
        super();
        this.CLASS_NAME="hmap.render.FilledCircleRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._program=new hmap.program.FilledCircleProgram(this.gl);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }

    draw(drawMap,uniforms,mode){
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(dataMap);
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLES,52,this.gl.UNSIGNED_BYTE,0,drawMap.idArray.length);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        let filledData=hmap.render.FilledCircleRender._createFilledCircle();
        this.gl.bindVertexArray(this._vao);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this._buffers.a_position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(filledData.positions),this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(filledData.indices),this.gl.STATIC_DRAW);

        this.gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_center,new Float32Array(drawMap.centers),false);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(drawMap.colors),false);
        this._addVerBuffer(this._buffers.a_threshold,new Float32Array(drawMap.thresholds),false);
        this._addVerBuffer(this._buffers.a_size,new Float32Array(drawMap.sizes),false);
        this._addVerBuffer(this._buffers.a_freq,new Float32Array(drawMap.freqs),false);
        this._addVerBuffer(this._buffers.a_maxSize,new Float32Array(drawMap.maxSizes),false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        let locations=this._program.getAttributeLocations();
        this.gl.bindVertexArray(this._vao);
        const FSIZE=4,posSize=this._posSize;
        let filled={};
        //填充面属性
        filled.a_position= this._createVerBuffer(locations.a_position,"FLOAT",3);
        filled.a_center=this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,filled.a_center);
        this.gl.vertexAttribPointer(locations.a_center, 3,this.gl.FLOAT, false, posSize*FSIZE, 0);
        this.gl.enableVertexAttribArray(locations.a_center);
        this.gl.vertexAttribPointer(locations.a_centerL, 3,this.gl.FLOAT, false,  posSize*FSIZE, (posSize-3)*FSIZE);
        this.gl.enableVertexAttribArray(locations.a_centerL);
        this.gl.vertexAttribDivisor(locations.a_center,1);
        this.gl.vertexAttribDivisor(locations.a_centerL,1);
        filled.a_color = this._createVerBuffer(locations.a_color,"FLOAT",4);
        this.gl.vertexAttribDivisor(locations.a_color,1);
        filled.a_threshold=this._createVerBuffer(locations.a_threshold,"FLOAT",4);
        this.gl.vertexAttribDivisor(locations.a_threshold,1);
        filled.a_size=this._createVerBuffer(locations.a_size,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_size,1);
        filled.a_freq=this._createVerBuffer(locations.a_freq,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_freq,1);
        filled.a_maxSize=this._createVerBuffer(locations.a_maxSize,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_maxSize,1);

        //索引
        filled.index = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null);
        this.gl.bindVertexArray(null);
        this._upBuffer=false;
        return  filled;
    }


    /**
     * 创建模型多边形面数据
     * @private
     */
    static _createFilledCircle(div=50){
        let r=1.0;
        let posArray=[0,0,0];
        let eleArray=[0];
        for(let i=0;i<=div;i++){
            const angle=2.0*Math.PI/div*i;
            const x=r*Math.cos(angle);
            const y=r*Math.sin(angle);
            posArray.push(x,y,0.0);
            eleArray.push(i+1);
        }
        return{
            positions:posArray,
            indices:eleArray,
            count:eleArray.length
        };
    }
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.HeatmapRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize){
        super();
        this.CLASS_NAME="hmap.render.HeatmapRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._programs={
            texture:new hmap.program.HeatmapProgram(this.gl,hmap.shader.HeatmapShader.frameVsShader,hmap.shader.HeatmapShader.frameFsShader),
            render:new hmap.program.HeatmapProgram(this.gl,hmap.shader.HeatmapShader.vsShader,hmap.shader.HeatmapShader.fsShader),
            color:new hmap.program.HeatmapProgram(this.gl,hmap.shader.HeatmapShader.colorVsShader,hmap.shader.HeatmapShader.colorFsShader)
        };
        this._vaos={
            "texture":this.gl.createVertexArray(),
            "render":this.gl.createVertexArray(),
            "color":this.gl.createVertexArray()
        };
        this._buffers=this._createBuffers();
        this._frameBuffer=this._createFrameBuffer(this.gl.canvas.clientWidth, this.gl.canvas.clientHeight,0);
        this._colorFrame=this._createFrameBuffer(this.gl.canvas.clientWidth, this.gl.canvas.clientHeight,0);
        this._addStaticBufferD();
    }

    draw(dataMap,uniforms){

        //draw render,将帧缓冲区绘制到屏幕上
        {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.viewport(0, 0, this.gl.canvas.clientWidth,this.gl.canvas.clientHeight);
            this._drawRender(uniforms);
        }
    }

    drawFrame(dataMap,uniforms){
        let gl=this.gl;
        // this._addChangeBufferD(dataMap);
        //draw texture,绘制帧缓冲区
        {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._frameBuffer.depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.canvas.clientWidth, gl.canvas.clientHeight);

            gl.bindTexture(gl.TEXTURE_2D, this._frameBuffer.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER,this._frameBuffer.frameBuffer);
            gl.viewport(0, 0, gl.canvas.clientWidth,gl.canvas.clientHeight);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ONE);
            gl.disable(gl.DEPTH_TEST);
            this._drawTexture(dataMap,uniforms);
        }
        //draw color,绘制帧缓冲区
        {
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._colorFrame.depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.canvas.clientWidth, gl.canvas.clientHeight);

            gl.bindTexture(gl.TEXTURE_2D, this._colorFrame.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER,this._colorFrame.frameBuffer);
            gl.viewport(0, 0, gl.canvas.clientWidth,gl.canvas.clientHeight);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO);
            // gl.disable(gl.DEPTH_TEST);
            this._drawColor();
        }
    }

    /**
     * 最终绘制
     * @private
     */
    _drawRender(uniforms) {
        const gl = this.gl, program = this._programs.render;
        gl.bindVertexArray(this._vaos.render);
        program.useProgram();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._frameBuffer.texture);
        gl.uniform1i(program.uniforms.u_texture, 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this._colorFrame.texture);
        gl.uniform1i(program.uniforms.u_colorTexture, 1);
        program.setRenderUniforms(uniforms);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindVertexArray(null);
    }

    _drawTexture(drawMap,uniforms,mode=null){
        let program=this._programs.texture;
        this.gl.bindVertexArray(this._vaos.texture);
        program.useProgram();
        program.setTextureUniforms(uniforms);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLE_FAN,52,this.gl.UNSIGNED_BYTE,0,drawMap.idArray.length);
        this.gl.bindVertexArray(null);
    }

    /**
     * 绘制color到frame
     * @private
     */
    _drawColor(){
        this.gl.bindVertexArray(this._vaos.color);
        this.gl.useProgram(this._programs.color.program);
        this.gl.drawArrays(this.gl.LINE_STRIP,0,5);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        //添加最终热力图绘制数据
        this.gl.bindVertexArray(this._vaos.render);
        const renderD=hmap.render.HeatmapRender._getRenderData();
        const buffersR=this._buffers.render;
        this._addVerBuffer(buffersR.a_position,new Float32Array(renderD.positions),false);
        this._addVerBuffer(buffersR.a_texCoord,new Float32Array(renderD.texCoords),false);
        this.gl.bindVertexArray(null);
        //添加颜色处理静态数据
        this.gl.bindVertexArray(this._vaos.color);
        const buffersC=this._buffers.color;
        const colorD=hmap.render.HeatmapRender._getRenderColor();
        this._addVerBuffer(buffersC.a_position,new Float32Array(colorD.positions),false);
        this.gl.bindVertexArray(null);
        //添加数据计算静态数据
        this.gl.bindVertexArray(this._vaos.texture);
        const texD=hmap.render.HeatmapRender._createFilledCircle();
        const buffersT=this._buffers.texture;
        this._addVerBuffer(buffersT.a_position,new Float32Array(texD.positions),false);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,buffersT.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(texD.indices),this.gl.STATIC_DRAW);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(dataMap){
        //颜色
        this.gl.bindVertexArray(this._vaos.color);
        const buffersC=this._buffers.color;
        this._addVerBuffer(buffersC.a_color,new Float32Array(dataMap.colors),false);
        this.gl.bindVertexArray(null);
        //纹理
        this.gl.bindVertexArray(this._vaos.texture);
        const buffersT=this._buffers.texture;
        this._addVerBuffer(buffersT.a_center,new Float32Array(dataMap.centers),false);
        this._addVerBuffer(buffersT.a_value,new Float32Array(dataMap.values),false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        this._upBuffer=false;
        return{
            "texture":this._createTextureBuffers(),
            "render":this._createRenderBuffers(),
            "color":this._createColorBuffers()
        };
    }
    _createRenderBuffers(){
        let gl=this.gl, locations=this._programs.render.getAttributeLocations();
        gl.bindVertexArray(this._vaos.render);
        let render={};
        render.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        render.a_texCoord=this._createVerBuffer(locations.a_texCoord,"FLOAT",2);
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        return render;
    }

    _createTextureBuffers(){
        let gl=this.gl,locations=this._programs.texture.getAttributeLocations();
        const FSIZE=4,posSize=this._posSize;
        gl.bindVertexArray(this._vaos.texture);
        let tex={};
        tex.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        tex.a_center=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,tex.a_center);
        gl.vertexAttribPointer(locations.a_center,3,gl.FLOAT,false,posSize*FSIZE,0);
        gl.enableVertexAttribArray(locations.a_center);
        gl.vertexAttribPointer(locations.a_centerL,3,gl.FLOAT,false,posSize*FSIZE,(posSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_centerL);
        gl.vertexAttribDivisor(locations.a_center,1);
        gl.vertexAttribDivisor(locations.a_centerL,1);
        tex.a_value=this._createVerBuffer(locations.a_value,"FLOAT",1);
        gl.vertexAttribDivisor(locations.a_value,1);
        tex.index=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        return tex;
    }

    _createColorBuffers(){
        const gl=this.gl,locations=this._programs.color.getAttributeLocations();
        gl.bindVertexArray(this._vaos.color);
        let c={};
        c.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        c.a_color=this._createVerBuffer(locations.a_color,"FLOAT",4);
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        return c;
    }


    /**
     * 创建模型多边形面数据
     * @private
     */
    static _createFilledCircle(div=50) {
        let r = 1.0;
        let posArray = [0, 0, 0];
        let eleArray = [0];
        for (let i = 0; i <= div; i++) {
            const angle = 2.0 * Math.PI / div * i;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            posArray.push(x, y, 0.0);
            eleArray.push(i + 1);
        }
        return {
            positions: posArray,
            indices: eleArray,
            count: eleArray.length
        };
    }

    /**
     * 渲染到canvas上使用的固定数据
     * @private
     * @returns {Object} 返回数据
     */
    static _getRenderData(){
        let positions = [
            -1.0, 1.0,0.0,
            -1.0,-1.0,0.0,
            1.0, 1.0,0.0,
            1.0,-1.0,0.0
        ];
        let indices=[
            0,1,2,
            2,1,3
        ];

        let texCoords=[
            0,1,
            0,0,
            1,1,
            1,0
        ];
        return{
            positions:positions,
            texCoords:texCoords,
            indices:indices,
            count:6
        };
    }

    /**
     * 渲染颜色使用数据
     * @private
     * @returns {Object} 返回JSON格式的渲染颜色的数据
     */
    static _getRenderColor(){
        let positions=[
            -1.0,0.0,0.0,
            -0.5,0.0,0.0,
            0.0,0.0,0.0,
            0.5,0.0,0.0,
            1.0,0.0,0.0
        ];
        let indices=[0,1,2,3,4];
        return{
            positions:positions,
            indices:indices,
            count:5
        };
    }
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.PieRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize,sideNum){
        super();
        this.CLASS_NAME="hmap.render.PieRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._program=new hmap.program.PieProgram(this.gl);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
    }

    draw(drawMap,uniforms,mode){
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(drawMap);
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this.gl.drawElements(this.gl.TRIANGLE_FAN,drawMap.indices.length,this.gl.UNSIGNED_SHORT,0);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据，此处指circle的数据
     * @private
     */
    _addStaticBufferD(){
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_position,new Float32Array(drawMap.positions),false);
        this._addVerBuffer(this._buffers.a_weight,new Float32Array(drawMap.weights),false);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(drawMap.colors),false);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(drawMap.indices),this.gl.STATIC_DRAW);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers(){
        let locations=this._program.getAttributeLocations();
        this.gl.bindVertexArray(this._vao);
        let p={};
        p.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        p.a_color=this._createVerBuffer(locations.a_color,"FLOAT",4);
        p.a_weight=this._createVerBuffer(locations.a_weight,"FLOAT",1);
        p.index=this.gl.createBuffer();
        this.gl.bindVertexArray(null);
        this._upBuffer=false;
        return p;
    }

    /**
     * 创建模型多边形面数据
     * @private
     */
    static _createFilledCircle(div=50){
        let r=1.0;
        let posArray=[];
        let eleArray=[0];
        for(let i=0;i<=div;i++){
            const angle=2.0*Math.PI/div*i;
            const x=r*Math.cos(angle);
            const y=r*Math.sin(angle);
            posArray.push(x,y,0.0);
            eleArray.push(i+1);
        }
        return{
            positions:posArray,
            indices:eleArray,
            count:eleArray.length
        };
    }
};;"use strict";
hmap.render=hmap.render||{};
hmap.render.ScatterRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize,sideNum){
        super();
        this.CLASS_NAME="hmap.render.ScatterRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    _initToRender() {
        this._programs={
            bubble:new hmap.program.ScatterProgram(this.gl,hmap.shader.ScatterShader.bubblePointVs,hmap.shader.ScatterShader.bubblePointFs),
            breath:new hmap.program.ScatterProgram(this.gl,hmap.shader.ScatterShader.breathPointVs,hmap.shader.ScatterShader.breathPointFs),
            circle:new hmap.program.ScatterProgram(this.gl,hmap.shader.ScatterShader.circleVs,hmap.shader.ScatterShader.circleFs)
        };
        this._vaos={
            bubble:this.gl.createVertexArray(),
            breath:this.gl.createVertexArray(),
            circle:this.gl.createVertexArray()
        };

        this._buffers=this._createBuffers();
        this._drawCount=this._addStaticBufferD();
    }

    draw(drawMap,uniforms,mode){
        if(drawMap.bubble.idArray.length>0){
            this.gl.bindVertexArray(this._vaos.bubble);
            this._programs.bubble.useProgram();
            this._programs.bubble.setPointUniforms(uniforms);
            this.gl.drawArrays(this.gl.POINTS,0,drawMap.bubble.idArray.length);
            this.gl.bindVertexArray(null);
        }
        if(drawMap.breath.idArray.length>0){
            this.gl.bindVertexArray(this._vaos.breath);
            this._programs.breath.useProgram();
            this._programs.breath.setPointUniforms(uniforms);
            this.gl.drawArrays(this.gl.POINTS,0,drawMap.breath.idArray.length);
            this.gl.bindVertexArray(null);
        }
        if(drawMap.circle.idArray.length>0){
            this.gl.bindVertexArray(this._vaos.circle);
            this._programs.circle.useProgram();
            this._programs.circle.setCircleUniforms(uniforms);
            this.gl.drawArraysInstanced(this.gl.LINE_STRIP||this.gl[mode],0,this._drawCount,drawMap.circle.idArray.length);
            this.gl.bindVertexArray(null);
        }
    }

    /**
     * 添加静态缓存数据，此处指circle的数据
     * @private
     */
    _addStaticBufferD(){
        const circleData=hmap.render.ScatterRender._createCircle(this._sideNum);
        this.gl.bindVertexArray(this._vaos.circle);
        this._addVerBuffer(this._buffers.circle.a_position,new Float32Array(circleData.positions),false);
        this.gl.bindVertexArray(null);
        return circleData.count;
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        for(const [objName,objD] of Object.entries(drawMap)){
            if(objD.idArray.length>0){
                this.gl.bindVertexArray(this._vaos[objName]);
                const buffers=this._buffers[objName];
                for(const [name,array] of Object.entries(objD)){
                    if(name!=='positions'&&name!=='idArray'){
                        const nameD="a_"+name.substr(0,name.length-1);
                        this._addVerBuffer(buffers[nameD],new Float32Array(array),false);
                    }
                }
                this.gl.bindVertexArray(null);
            }
        }
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        this._upBuffer=false;
        return {
            bubble:this._createBubbleBuffers(),
            breath:this._createBreathBuffers(),
            circle:this._createCircleBuffers()
        };
    }

    _createBubbleBuffers(){
        const locations=this._programs.bubble.getAttributeLocations();
        this.gl.bindVertexArray(this._vaos.bubble);
        let bubble={};
        bubble.a_center=this._createVerBuffer(locations.a_center,"FLOAT",3);
        bubble.a_size=this._createVerBuffer(locations.a_size,"FLOAT",1);
        bubble.a_maxSize=this._createVerBuffer(locations.a_maxSize,"FLOAT",1);
        bubble.a_freq=this._createVerBuffer(locations.a_freq,"FLOAT",1);
        bubble.a_color=this._createVerBuffer(locations.a_color,"FLOAT",4);
        bubble.a_colorC=this._createVerBuffer(locations.a_colorC,"FLOAT",4);
        bubble.a_alpha=this._createVerBuffer(locations.a_alpha,"FLOAT",2);
        this.gl.bindVertexArray(null);
        return bubble;
    }
    _createBreathBuffers(){
        const locations=this._programs.breath.getAttributeLocations();
        this.gl.bindVertexArray(this._vaos.breath);
        let breath={};
        breath.a_center=this._createVerBuffer(locations.a_center,"FLOAT",3);
        breath.a_size=this._createVerBuffer(locations.a_size,"FLOAT",1);
        breath.a_maxSize=this._createVerBuffer(locations.a_maxSize,"FLOAT",1);
        breath.a_freq=this._createVerBuffer(locations.a_freq,"FLOAT",1);
        breath.a_color=this._createVerBuffer(locations.a_color,"FLOAT",4);
        this.gl.bindVertexArray(null);
        return breath;
    }
    _createCircleBuffers(){
        const locations=this._programs.circle.getAttributeLocations();
        this.gl.bindVertexArray(this._vaos.circle);
        let circle={};
        circle.a_position=this._createVerBuffer(locations.a_position,"FLOAT",3);
        circle.a_center=this._createVerBuffer(locations.a_center,"FLOAT",3);
        this.gl.vertexAttribDivisor(locations.a_center,1);
        circle.a_color=this._createVerBuffer(locations.a_color,"FLOAT",4);
        this.gl.vertexAttribDivisor(locations.a_color,1);
        circle.a_size=this._createVerBuffer(locations.a_size,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_size,1);
        circle.a_maxSize=this._createVerBuffer(locations.a_maxSize,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_maxSize,1);
        circle.a_freq=this._createVerBuffer(locations.a_freq,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_freq,1);
        circle.a_alpha=this._createVerBuffer(locations.a_alpha,"FLOAT",2);
        this.gl.vertexAttribDivisor(locations.a_alpha,1);
        circle.a_cycle=this._createVerBuffer(locations.a_cycle,"FLOAT",1);
        this.gl.vertexAttribDivisor(locations.a_cycle,1);
        this.gl.bindVertexArray(null);
        return circle;
    }

    /**
     * 创建circle实例模型
     * @param div，边数或者组成顶点数
     * @returns {{positions: Array, indices: Array}}
     * @private
     */
    static _createCircle(div=50){
        let positions=[],indices=[];
        for(let i=0;i<=div;i++){
            const angle=2.0*Math.PI/div*i;
            const x=Math.cos(angle);
            const y=Math.sin(angle);
            positions.push(x,y,0);
            indices.push(i);
        }
        return {
            positions:positions,
            indices:indices,
            count:positions.length/3
        };
    }
};;"use strict";
/**
 * 地理解决方案中蝌蚪图渲染使用
 * @type {hmap.render.TadpoleRender}
 * @private
 */
hmap.render.TadpoleRender = class extends hmap.render.MathModelRender{
    /**
     * 构造函数
     * @param gl webgl上下文
     * @param posSize 单个顶点的数量，用来区分使用使用了RTE。正常为3，包括x，y，z。
     * @param disableBlend 是否禁用混合
     * @private
     */
    constructor(gl,posSize,disableBlend) {
        super();
        this.CLASS_NAME = "hmap.render.TadpoleRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.gl = gl;
        this._posSize=posSize;
        this._disableBlend = disableBlend;        //开启要素点颜色混合
        this._upBuffer=false;
        this._initToRender();
        this._configGL();
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.TadpoleProgram(this.gl,hmap.shader.TadpoleShader.vsShader, hmap.shader.TadpoleShader.fsShader);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
    }

    /**
     * 设置渲染上下文
     * @private
     */
    _configGL() {
        if(this._disableBlend){
            this.gl.disable(this.gl.BLEND);            //关闭混合
        }else{
            this.gl.enable(this.gl.BLEND);            //允许混合
            this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);      //混合模式
        }
    }

    /**
     * 绘制方法
     * @param uniforms
     * @param params,参数,包括绘制group的count和使用顶点的offset
     * @private
     */
    draw(uniforms,params) {
        //设置全局量
        const locations=this._program.getAttributeLocations();
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this.gl.vertexAttrib4fv(locations.a_color,uniforms.color);
        this.gl.vertexAttrib2fv(locations.a_size,uniforms.size);
        this.gl.vertexAttrib1f(locations.a_count,params.count);
        this._drawTadpole(params);
    }

    /**
     * 绘制蝌蚪图
     * @param params,参数,包括顶点的偏移量,其它属性的偏移量,group包括的顶点count
     * @private
     */
    _drawTadpole(params) {
        if((!this._upBuffer)||params.count===0)return;
        this.gl.bindVertexArray(this._vao);
        const locations=this._program.getAttributeLocations();
        const FSIZE=4,pSize=this._posSize,offsetP=params.offsetPos,offsetO=params.offsetOther;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this._buffers.positionBuffer);
        this.gl.vertexAttribPointer(locations.a_positionH,3,this.gl.FLOAT,false,pSize*FSIZE,pSize*FSIZE*offsetP);
        this.gl.vertexAttribPointer(locations.a_positionL, 3, this.gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE+pSize*FSIZE*offsetP);
        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.colorBuffer);
        // this.gl.vertexAttribPointer(this.locations.a_color,4,this.gl.FLOAT,false,0,4*FSIZE*offsetO);
        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.sizeBuffer);
        // this.gl.vertexAttribPointer(this.locations.a_size,1,this.gl.FLOAT,false,0,FSIZE*offsetO);
        this.gl.drawArrays(this.gl.POINTS,0,params.count);
        this.gl.bindVertexArray(null);
    }




    /**
     * 向buffer内填充数据
     * @param dataMap
     * @param {Boolean} dynamic 绘制数据的使用方式.默认false,使用静态缓存,写入显卡
     * 注: false,数据存储在显存中,数据处理速度快,但I/O操作缓慢,适合变动率小的数据.
     *     true,数据存储在内存为显存单独开辟的区域中,访问区域高于内存,适合变动数据
     *  @private
     */
    _addChangeBufferD(dataMap,dynamic=false){
        this.gl.bindVertexArray(this._vao);
        const buffers=this._buffers;
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 更新绘制数据(等量替换数据)
     * @param {"tadpole"|"line"} name
     * @param {json} params {update:{position:bool,color:bool,size:bool},
     *                       array:{position:[],color:[],size:[]},
     *                       offset:{position:number,color:number,size:number}}
     * 注:offset按点计算,比如偏移一个点,对应的position的offset为1,color的offet为1,size为1
     * @private
     */
    updataBuffer(name,params){
        this.gl.bindVertexArray(this.vao[name]);
        const update=params.update;
        const array=params.array;
        const offset=params.offset;
        const buffers=this.buffer[name];
        if(update.position){
            this._upVerBuffer(buffers.positionBuffer,new Float32Array(array.position),offset.position*4*this._posSize);
        }
        if(update.color){
            this._upVerBuffer(buffers.colorBuffer,new Float32Array(array.color),offset.color*4*4);
        }
        if(update.size){
            this._upVerBuffer(buffers.sizeBuffer,new Float32Array(array.size),offset.size*4);
        }
        this.gl.bindVertexArray(null);
    }


    _createBuffers() {
        const locations=this._program.getAttributeLocations();
        let FSIZE=4,pSize=this._posSize;
        let tad = {};
        this.gl.bindVertexArray(this._vao);
        tad.positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tad.positionBuffer);
        this.gl.vertexAttribPointer(locations.a_positionH, 3, this.gl.FLOAT, false, pSize*FSIZE, 0);
        this.gl.enableVertexAttribArray(locations.a_positionH);
        this.gl.vertexAttribPointer(locations.a_positionL, 3, this.gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        this.gl.enableVertexAttribArray(locations.a_positionL);

        // //颜色
        // tad.colorBuffer = this.gl.createBuffer();
        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tad.colorBuffer);
        // this.gl.vertexAttribPointer(locations.a_color, 4, this.gl.FLOAT, false, 0, 0);
        // this.gl.enableVertexAttribArray(locations.a_color);
        //
        // //大小
        // tad.sizeBuffer = this.gl.createBuffer();
        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, tad.sizeBuffer);
        // this.gl.vertexAttribPointer(locations.a_size, 1, this.gl.FLOAT, false, 0, 0);
        // this.gl.enableVertexAttribArray(locations.a_size);
        this.gl.bindVertexArray(null);
        this._upBuffer=false;
        return tad;
    }

};;"use strict";
hmap.render=hmap.render||{};
/**
 * 地理解决方案中可视域渲染使用
 * @type {hmap.ViewshedRender}
 * @private
 */
hmap.render.ViewshedRender=class extends hmap.render.MathModelRender{
    constructor(gl){
        super();
        this.CLASS_NAME="hmap.render.ViewshedRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._initToRender();
    }

    /**
     * 初始化绘制需要的东西
     * program：着色器程序
     * location：着色器属性索引地址
     * vao：顶点数组对象
     * buffer：VBOs
     * addStaticBufferD：将模型数据添加进VBOs
     * @private
     */
    _initToRender() {
        this._program=new hmap.program.ViewshedProgram(this.gl);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }

    /**
     * 绘制函数,根据数据绘制可视域模型
     * @param dataMap 可变数据
     * @param mode 第二种绘制类型，默认单指绘线
     * @private
     */
    draw(dataMap,mode){
        const uniformLocation=this._program.getUniformLocations();
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(dataMap);
        this._program.useProgram();
        this.gl.uniformMatrix4fv(uniformLocation.u_mvpMatrix,false,this._vpMatrix.getElements());
        this.gl.lineWidth(2.0);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(dataMap.a_color),false);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLES,12,this.gl.UNSIGNED_BYTE,0,dataMap.idArray.length);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(dataMap.a_colorSide),false);
        this.gl.drawElementsInstanced(this.gl.LINE_STRIP,12,this.gl.UNSIGNED_BYTE,0,dataMap.idArray.length);
        this.gl.bindVertexArray(null);
        this.gl.lineWidth(1.0);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        let coneData=hmap.render.ViewshedRender._createCone();
        this.gl.bindVertexArray(this._vao);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this._buffers.a_position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(coneData.posArray),this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(coneData.eleArray),this.gl.STATIC_DRAW);

        this.gl.bindVertexArray(null);
    }

    /**
     * 添加随可视域变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(drawMap.a_color),false);
        this._addVerBuffer(this._buffers.a_radius,new Float32Array(drawMap.a_radius),false);
        this._addVerBuffer(this._buffers.a_scale,new Float32Array(drawMap.a_scale),false);
        this._addVerBuffer(this._buffers.a_orien,new Float32Array(drawMap.a_orien),false);
        this._addVerBuffer(this._buffers.a_location,new Float32Array(drawMap.a_location),false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        let gl = this.gl;
        const locations=this._program.getAttributeLocations();
        gl.bindVertexArray(this._vao);
        let  viewshed= {};
        //可视域顶点
        viewshed.a_position = this._createVerBuffer(locations.a_position,"FLOAT",3);
        viewshed.a_color = this._createVerBuffer(locations.a_color,"FLOAT",4);
        gl.vertexAttribDivisor(locations.a_color,1);
        viewshed.a_radius=this._createVerBuffer(locations.a_radius,"FLOAT",1);
        gl.vertexAttribDivisor(locations.a_radius,1);
        viewshed.a_orien=this._createVerBuffer(locations.a_orien,"FLOAT",3);
        gl.vertexAttribDivisor(locations.a_orien,1);
        viewshed.a_scale=this._createVerBuffer(locations.a_scale,"FLOAT",3);
        gl.vertexAttribDivisor(locations.a_scale,1);
        viewshed.a_location=this._createVerBuffer(locations.a_location,"FLOAT",3);
        gl.vertexAttribDivisor(locations.a_location,1);

        //索引
        viewshed.index = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        this._upBuffer=false;
        return  viewshed;
    }

    /**
     * 创建四棱锥型数据
     * @private
     */
    static _createCone() {
        let cone = {};
        //默认朝下
        // cone.posArray = [
        //     0, 0, 0,
        //     -.5, .5, -1.0,
        //     -.5, -.5, -1.0,
        //     .5, -.5, -1.0,
        //     .5, .5, -1.0
        // ];
        //默认x正半轴
        cone.posArray=[
            0, 0, 0,
            1.0, .5, -0.5,
            1.0, -.5, -0.5,
            1.0, -.5, 0.5,
            1.0, .5, 0.5
        ];
        cone.eleArray = [
            0, 2, 1,
            0, 3, 2,
            0, 4, 3,
            0, 1, 4,
        ];
        return cone;
    }
};;"use strict";
/**
 * 地理解决方案-水填充特效
 * @type {hmap.render.FillWaterRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.FillWaterRender=class extends hmap.render.MathModelRender{
    constructor(gl){
        super();
        this.CLASS_NAME="hmap.render.FillWaterRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._initToRender();
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.FillWaterProgram(this.gl, hmap.shader.FillWaterShader.vsShader, hmap.shader.FillWaterShader.fsShader);
        this.vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(uniforms,drawOpt) {
        let gl = this.gl;
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this._drawFillWater(drawOpt);
    }

    /**
     * 绘制水填充特效
     * @param dataMap 顶点数据
     * @private
     */
    _drawFillWater(drawOpt) {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        //更新顶点
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer.positionBuffer);
        //更新索引
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer.indexBuffer);
        gl.drawElements(gl.TRIANGLES, drawOpt.count, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap,dynamic=false){
        this.gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,buffers.indexBuffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(dataMap.indices),this.gl.STATIC_DRAW);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){

    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let tad = {},locations=this._program.getAttributeLocations();
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_position);

        // indexes
        tad.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tad.indexBuffer);
        gl.bindVertexArray(null)
        return tad;
    }
};;"use strict";
/**
 * 地理解决方案中流线动画渲染使用
 * @type {hmap.FlowRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.FlowRender=class extends hmap.render.MathModelRender{
    /**
     * 构造函数
     * @param gl webgl上下文
     * @param posSize 单个顶点的数量，用来区分使用使用了RTE。正常为3，包括x，y，z。
     * @private
     */
    constructor(gl,posSize,sideNum) {
        super();
        this.CLASS_NAME = "hmap.FlowRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this.gl=gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;       //buffer里面是否有可变数据
        this._initToRender();
    }

    setResolution(res){
        this.res=res;
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.FlowProgram(this.gl, hmap.shader.FlowShader.vsShader, hmap.shader.FlowShader.fsShader);
        this.vao = this.gl.createVertexArray();
        this.buffer=this._createBuffer()
    }

    /**
     * 绘制方法
     * @param uniforms
     * @param params,参数,包括绘制group的count和使用顶点的offset
     * @private
     */
    draw(uniforms,drawOpt) {
        let gl = this.gl;
        //设置全局量,因为精度补偿 稍等使用program中的public方法
        this._program.useProgram();
        gl.uniform1i(this._program.uniforms.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this._program.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this._program.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this._program.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this._program.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);

        this._program.setPrivateUniforms(uniforms);

        this._drawFlows(drawOpt);
    }

    /**
     * 绘制流线
     * @param params,参数,包括顶点的偏移量,其它属性的偏移量,group包括的顶点count
     * @private
     */
    _drawFlows(drawOpt) {
        if(drawOpt.count===0)return;
        this.gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.positionBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.colorBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.prevFrameNumBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.currFrameNumBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.nextFrameNumBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.routeFrameSumBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.selfFrameSumBuffer);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.startFrameNumBuffer);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.offsetPerFrameBuffer);

        this.gl.drawArrays(this.gl.LINES,0,drawOpt.count);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap,dynamic=false){
        this.gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this._addVerBuffer(buffers.colorBuffer, new Float32Array(dataMap.colors), false);
        this._addVerBuffer(buffers.prevFrameNumBuffer, new Float32Array(dataMap.prevFrameNums), false);
        this._addVerBuffer(buffers.currFrameNumBuffer, new Float32Array(dataMap.currFrameNums), false);
        this._addVerBuffer(buffers.nextFrameNumBuffer, new Float32Array(dataMap.nextFrameNums), false);
        this._addVerBuffer(buffers.routeFrameSumBuffer, new Float32Array(dataMap.routeFrameSums), false);
        this._addVerBuffer(buffers.selfFrameSumBuffer, new Float32Array(dataMap.selfFrameSums), false);
        this._addVerBuffer(buffers.startFrameNumBuffer, new Float32Array(dataMap.startFrameNums), false);
        this._addVerBuffer(buffers.offsetPerFrameBuffer, new Float32Array(dataMap.offsetPerFrames), false);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){

    }

    /**
     * 创建buffer
     * param {"flow"|"line"} name 创建的缓冲区使用对象,枚举型
     * @returns {{}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let tad = {},locations=this._program.getAttributeLocations();
        //位置
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(locations.a_positionH);
        gl.vertexAttribPointer(locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_positionL);

        //颜色
        tad.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.colorBuffer);
        gl.vertexAttribPointer(locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_color);

        //上一个顶点帧号
        tad.prevFrameNumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.prevFrameNumBuffer);
        gl.vertexAttribPointer(locations.a_prevFrameNum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_prevFrameNum);

        //当前顶点帧号
        tad.currFrameNumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.currFrameNumBuffer);
        gl.vertexAttribPointer(locations.a_currFrameNum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_currFrameNum);

        //下一个顶点帧号
        tad.nextFrameNumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.nextFrameNumBuffer);
        gl.vertexAttribPointer(locations.a_nextFrameNum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_nextFrameNum);

        //整个路径的帧总数
        tad.routeFrameSumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.routeFrameSumBuffer);
        gl.vertexAttribPointer(locations.a_routeFrameSum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_routeFrameSum);

        //流线自身的帧总数
        tad.selfFrameSumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.selfFrameSumBuffer);
        gl.vertexAttribPointer(locations.a_selfFrameSum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_selfFrameSum);

        //开始的帧数
        tad.startFrameNumBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.startFrameNumBuffer);
        gl.vertexAttribPointer(locations.a_startFrameNum, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_startFrameNum);

        //位置偏移量vec3
        tad.offsetPerFrameBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.offsetPerFrameBuffer);
        gl.vertexAttribPointer(locations.a_offsetPerFrame, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_offsetPerFrame);

        gl.bindVertexArray(null);
        return tad;
    }
};;"use strict";
/**
 * 地理解决方案-粒子系统渲染
 * @type {hmap.render.ParticleRender}
 * @private
 */
hmap.render.ParticleRender=class extends hmap.render.MathModelRender{
    constructor(gl, posSize, sideNum){
        super();
        this.CLASS_NAME="hmap.render.ParticleRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._sideNum=sideNum;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._initToRender();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(dataMap,uniforms) {
        if(dataMap.positions.length === 0) return;
        let gl = this.gl;
        //设置全局量
        this._program.useProgram();
        gl.uniform1f(this._program.uniforms.u_unit,uniforms.u_unit);
        gl.uniform1i(this._program.uniforms.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this._program.uniforms.u_vpMatrix,false,uniforms.u_vpMatrix.getElements());
        const camera=uniforms.u_camera;
        gl.uniform3fv(this._program.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this._program.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        gl.uniform1f(this._program.uniforms.u_res,uniforms.u_res[0]);
        gl.uniform1f(this._program.uniforms.u_resL,uniforms.u_res[1]);
        this._program.setPrivateUniforms(uniforms);
        gl.bindVertexArray(this.vao);
        this._addVerBuffer(this.buffers.positionBuffer, new Float32Array(dataMap.positions), true);
        this._addVerBuffer(this.buffers.forceBuffer, new Float32Array(dataMap.originForce), true);
        this._addVerBuffer(this.buffers.offsetIndexBuffer, new Float32Array(dataMap.offsetIndex), true);
        let drawCount = dataMap.positions.length/3;
        gl.drawArrays(gl.POINTS, 0, drawCount);
        gl.bindVertexArray(null);
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.ParticleProgram(this.gl, hmap.shader.ParticleShader.vsShader, hmap.shader.ParticleShader.fsShader);
        this.vao = this.gl.createVertexArray();
        this.buffers = this._createBuffer();
    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let tad = {},locations=this._program.getAttributeLocations();
        //位置
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(locations.a_positionH);
        gl.vertexAttribPointer(locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_positionL);

        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_position);

        tad.forceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.forceBuffer);
        gl.vertexAttribPointer(locations.a_originForce, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_originForce);

        tad.offsetIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.offsetIndexBuffer);
        gl.vertexAttribPointer(locations.a_offsetIndex, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_offsetIndex);

        tad.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tad.indexBuffer);
        return tad;
    }
};;"use strict";
/**
 * 地理解决方案-线纹理动画
 * @type {hmap.render.TrailRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.TrailRender=class extends hmap.render.MathModelRender{
    constructor(gl,posSize){
        super();
        this.CLASS_NAME="hmap.render.TrailRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._initToRender();
        this.texture = {};                  //保存所有的纹理
        this.promises = {};
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.TrailProgram(this.gl, hmap.shader.TrailShader.vsShader, hmap.shader.TrailShader.fsShader);
        this.vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 将图标添加到纹理
     * @private
     */
    addSymbolToTexture(symbolSrc){
        const me = this;
        if(!this.promises[symbolSrc]){
            let promise = new Promise(function(resolve,reject){
                let image = new Image();
                image.src = symbolSrc;
                image.onload = function(){
                    let texture = me._program.addGLTexture(image,0).texture;
                    resolve(texture);
                }
            })
            this.promises[symbolSrc] = promise;
        }
        this.promises[symbolSrc].then(function(texture){
            if(!me.texture[symbolSrc]){
                me.texture[symbolSrc] = texture;
            }
        })
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(dataMap, uniforms) {
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this._drawTrail(dataMap);
    }

    /**
     * 绘制线纹理
     * @param dataMap 顶点数据
     * @private
     */
    _drawTrail(dataMap) {
        const gl = this.gl;
        gl.bindVertexArray(this.vao);
        this._addVerBuffer(this.buffer.positionBuffer, new Float32Array(dataMap.positions), false);
        this._addVerBuffer(this.buffer.previousBuffer, new Float32Array(dataMap.previous), false);
        this._addVerBuffer(this.buffer.nextBuffer, new Float32Array(dataMap.next), false);
        this._addVerBuffer(this.buffer.sideBuffer, new Float32Array(dataMap.side), false);
        this._addVerBuffer(this.buffer.uvsBuffer, new Float32Array(dataMap.uvs), false);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(dataMap.indices),gl.STATIC_DRAW);

        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture[dataMap.symbolSrc] || null);

        const count = dataMap.indices.length;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap,dynamic=false){
        const gl = this.gl;
        gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this._addVerBuffer(buffers.previousBuffer, new Float32Array(dataMap.previous), false);
        this._addVerBuffer(buffers.nextBuffer, new Float32Array(dataMap.next), false);
        this._addVerBuffer(buffers.sideBuffer, new Float32Array(dataMap.side), false);
        this._addVerBuffer(buffers.uvsBuffer, new Float32Array(dataMap.uvs), false);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffers.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(dataMap.indices),gl.STATIC_DRAW);
        gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){

    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        const gl = this.gl;
        gl.bindVertexArray(this.vao);
        let tad = {},locations=this._program.getAttributeLocations();
        let FSIZE=4,pSize=this._posSize;

        //先前点
        tad.previousBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.previousBuffer);
        gl.vertexAttribPointer(locations.a_previousH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(locations.a_previousH);
        gl.vertexAttribPointer(locations.a_previousL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_previousL);

        //当前点
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(locations.a_positionH);
        gl.vertexAttribPointer(locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_positionL);

        //下个点
        tad.nextBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.nextBuffer);
        gl.vertexAttribPointer(locations.a_nextH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(locations.a_nextH);
        gl.vertexAttribPointer(locations.a_nextL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(locations.a_nextL);

        //正方向或反方向偏移
        tad.sideBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.sideBuffer);
        gl.vertexAttribPointer(locations.a_side, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_side);

        //纹理坐标
        tad.uvsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.uvsBuffer);
        gl.vertexAttribPointer(locations.a_uv, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_uv);

        // indexes
        tad.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tad.indexBuffer);
        return tad;
    }
};;"use strict";
/**
 * 地理解决方案-雨特效
 * @type {hmap.render.RainRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.RainRender=class extends hmap.render.MathModelRender{
    constructor(gl){
        super();
        this.CLASS_NAME="hmap.render.RainRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._initToRender();
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.RainProgram(this.gl, hmap.shader.RainShader.vsShader, hmap.shader.RainShader.fsShader);
        this._vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(dataMap,uniforms) {
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this._drawRain(dataMap);
    }

    /**
     * 填充顶点数据，并绘制
     * @param dataMap 顶点数据
     * @private
     */
    _drawRain(dataMap) {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        let count = dataMap.a_position.length/3;
        gl.drawArrays(gl.POINTS, 0, count);
        gl.bindVertexArray(null);
    }



    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap,dynamic=false){
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(dataMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this.buffer.positionBuffer, new Float32Array(dataMap.a_position), false);
        this._addVerBuffer(this.buffer.numberBuffer, new Float32Array(dataMap.a_number), false);
        this._addVerBuffer(this.buffer.timeDelayBuffer, new Float32Array(dataMap.a_timeDelay), false);
        this._addVerBuffer(this.buffer.sizeBuffer, new Float32Array(dataMap.a_size), false);
        this._addVerBuffer(this.buffer.speedBuffer, new Float32Array(dataMap.a_speed), false);
        this._addVerBuffer(this.buffer.colorBuffer, new Float32Array(dataMap.a_color), false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 创建buffer、绑定到目标、将缓冲区分配给着色器的变量并激活变量，注意没有传输数据，具体传输数据的工作在具体的绘制环节
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        let tad = {},locations=this._program.getAttributeLocations();
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_position);

        tad.numberBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.numberBuffer);
        gl.vertexAttribPointer(locations.a_number, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_number);

        tad.timeDelayBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.timeDelayBuffer);
        gl.vertexAttribPointer(locations.a_timeDelay, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_timeDelay);

        tad.speedBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.speedBuffer);
        gl.vertexAttribPointer(locations.a_speed, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_speed);

        tad.sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.sizeBuffer);
        gl.vertexAttribPointer(locations.a_size, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_size);

        tad.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.colorBuffer);
        gl.vertexAttribPointer(locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_color);


        return tad;
    }
};;"use strict";
/**
 * 地理解决方案-水填充特效
 * @type {hmap.render.SnowRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.SnowRender=class extends hmap.render.MathModelRender{
    constructor(gl){
        super();
        this.CLASS_NAME="hmap.render.SnowRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._initToRender();
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.SnowProgram(this.gl, hmap.shader.SnowShader.vsShader, hmap.shader.SnowShader.fsShader);
        this._vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(dataMap,uniforms) {
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this.gl.bindTexture(this.gl.TEXTURE_2D,dataMap.textures[0]||null);
        this._drawSnow(dataMap);
    }

    /**
     * 填充顶点数据，并绘制
     * @param dataMap 顶点数据
     * @private
     */
    _drawSnow(dataMap) {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        let count = dataMap.a_position.length/3;
        gl.enable(gl.BLEND);            //允许混合
        // gl.blendEquation( gl.FUNC_ADD );
        // gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA ); 
        // gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ZERO,gl.ZERO,gl.ONE);               //加法混合
        //gl.disable(gl.DEPTH_TEST);
        gl.drawArrays(gl.POINTS, 0, count);
        gl.bindVertexArray(null);
    }
    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap,dynamic=false){
    }

        /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(dataMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this.buffer.positionBuffer, new Float32Array(dataMap.a_position), false);
        this._addVerBuffer(this.buffer.rotationBuffer, new Float32Array(dataMap.a_rotation), false);
        this._addVerBuffer(this.buffer.speedBuffer, new Float32Array(dataMap.a_speed), false);
        this._addVerBuffer(this.buffer.sizeBuffer, new Float32Array(dataMap.a_size), false);
        this._addVerBuffer(this.buffer.timeDelayBuffer, new Float32Array(dataMap.a_timeDelay), false);
        this.gl.bindVertexArray(null);
        this._upBuffer=true;
    }

    /**
     * 创建buffer、绑定到目标、将缓冲区分配给着色器的变量并激活变量，注意没有传输数据，具体传输数据的工作在具体的绘制环节
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        let tad = {},locations=this._program.getAttributeLocations();
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_position);

        tad.rotationBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.rotationBuffer);
        gl.vertexAttribPointer(locations.a_rotation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_rotation);

        tad.speedBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.speedBuffer);
        gl.vertexAttribPointer(locations.a_speed, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_speed);

        tad.sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.sizeBuffer);
        gl.vertexAttribPointer(locations.a_size, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_size);

        tad.timeDelayBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.timeDelayBuffer);
        gl.vertexAttribPointer(locations.a_timeDelay, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_timeDelay);

        return tad;
    }
};;"use strict";
/**
 * 地理解决方案-网格热力图
 * @type {hmap.render.GridHeatRender}
 * @private
 */
hmap.render = hmap.render || {};
hmap.render.GridHeatRender = class extends hmap.render.MathModelRender {
    constructor(gl,posSize,disableBlend) {
        super();
        this.CLASS_NAME = "hmap.render.GridHeatRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        //this._posSize=posSize;
        this._disableBlend = disableBlend;        //开启要素点颜色混合
        this._initToRender();
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.GridHeatProgram(this.gl, hmap.shader.GridHeatShader.vsShader, hmap.shader.GridHeatShader.fsShader);
        this._vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @param dimension 维度
     * @private
     */
    _draw(dataMap, uniforms,dimension) {
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this._drawGridHeat(dataMap,dimension);
    }

    /**
     * 填充顶点数据，并绘制
     * @param dataMap 顶点数据
     * @param dimension 维度
     * @private
     */
    _drawGridHeat(dataMap,dimension) {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        if (dimension == 2) {
            let count = dataMap.a_positionH.length / 3;
            gl.disable(gl.DEPTH_TEST);
            gl.drawArrays(gl.TRIANGLES, 0, count);
        } else {
            let count = dataMap.a_indices.length;
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE)
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        }

        gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap, dynamic = false) {
        const gl = this.gl;
        gl.bindVertexArray(this._vao);
        this._addVerBuffer(this.buffer.positionHBuffer, new Float32Array(dataMap.a_positionH), false);
        this._addVerBuffer(this.buffer.positionLBuffer, new Float32Array(dataMap.a_positionL), false);
        this._addVerBuffer(this.buffer.colorBuffer, new Float32Array(dataMap.a_color), false);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer.indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.a_indices), gl.STATIC_DRAW);
        gl.bindVertexArray(null);
        this._upBuffer = true;
    }

    /**
     * 创建buffer、绑定到目标、将缓冲区分配给着色器的变量并激活变量，注意没有传输数据，具体传输数据的工作在具体的绘制环节
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        const locations = this._program.getAttributeLocations();

        const positionHBuffer = this.gl.createBuffer();
        gl.bindBuffer(this.gl.ARRAY_BUFFER, positionHBuffer);
        gl.vertexAttribPointer(locations.a_positionH, 3, this.gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_positionH);


        const positionLBuffer = this.gl.createBuffer();
        gl.bindBuffer(this.gl.ARRAY_BUFFER, positionLBuffer);
        gl.vertexAttribPointer(locations.a_positionL, 3, this.gl.FLOAT, false, 0,0);
        gl.enableVertexAttribArray(locations.a_positionL);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_color);

        const indicesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
        gl.bindVertexArray(null);
        this._upBuffer=false;
        return {positionHBuffer,positionLBuffer, colorBuffer,indicesBuffer};
    }
};;"use strict";
/**
 * 地理解决方案-蜂窝热力图
 * @type {hmap.render.HexGridHeatRender}
 * @private
 */
hmap.render=hmap.render||{};
hmap.render.HexGridHeatRender=class extends hmap.render.MathModelRender{
    constructor(gl){
        super();
        this.CLASS_NAME="hmap.render.HexGridHeatRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._initToRender();
    }

    /**
     * 初始化绘制所需，包括program、vao、buffers
     * @private
     */
    _initToRender() {
        this._program = new hmap.program.HexGridHeatProgram(this.gl, hmap.shader.HexGridHeatShader.vsShader, hmap.shader.HexGridHeatShader.fsShader);
        this._vao = this.gl.createVertexArray();
        this.buffer = this._createBuffer();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @param dimension 维度
     * @private
     */
    _draw(dataMap, uniforms,dimension) {
        this._program.useProgram();
        this._program.setPrivateUniforms(uniforms);
        this._drawGridHeat(dataMap,dimension);
    }

    /**
     * 填充顶点数据，并绘制
     * @param dataMap 顶点数据
     * @param dimension 维度
     * @private
     */
    _drawGridHeat(dataMap,dimension) {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        if (dimension == 2) {
            let count = dataMap.a_positionH.length / 3;
            gl.disable(gl.DEPTH_TEST);
            gl.drawArrays(gl.TRIANGLES, 0, count);
        } else {
            let count = dataMap.a_indices.length;
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE)
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        }

        gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(dataMap) {
        const gl = this.gl;
        gl.bindVertexArray(this._vao);
        this._addVerBuffer(this.buffer.positionHBuffer, new Float32Array(dataMap.a_positionH), true);
        this._addVerBuffer(this.buffer.positionLBuffer, new Float32Array(dataMap.a_positionL), true);
        this._addVerBuffer(this.buffer.colorBuffer, new Float32Array(dataMap.a_color), true);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer.indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.a_indices), gl.STATIC_DRAW);
        gl.bindVertexArray(null);
        this._upBuffer = true;
    }

    /**
     * 创建buffer、绑定到目标、将缓冲区分配给着色器的变量并激活变量，注意没有传输数据，具体传输数据的工作在具体的绘制环节
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        const locations = this._program.getAttributeLocations();
        const positionHBuffer = this.gl.createBuffer();
        gl.bindBuffer(this.gl.ARRAY_BUFFER, positionHBuffer);
        gl.vertexAttribPointer(locations.a_positionH, 3, this.gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_positionH);


        const positionLBuffer = this.gl.createBuffer();
        gl.bindBuffer(this.gl.ARRAY_BUFFER, positionLBuffer);
        gl.vertexAttribPointer(locations.a_positionL, 3, this.gl.FLOAT, false, 0,0);
        gl.enableVertexAttribArray(locations.a_positionL);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(locations.a_color);

        const indicesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
        this._upBuffer=false;
        return {positionHBuffer,positionLBuffer, colorBuffer,indicesBuffer};
    }
};;"use strict";
hmap.core = hmap.core || {};
hmap.core.painter = hmap.core.painter || {};
/**
 * 点云绘制
 * @private
 */
hmap.core.painter.PointCloudPainter = class extends hmap.core.painter.Painter {
    constructor(layer, blockSize, isCircle) {
        super(layer, "symbol");
        this._blockHelper = new hmap.help.PointsBlockHelper(this._blocks, blockSize);
        this._program = new hmap.program.PointCloudProgram(this._gl, isCircle);
    }

    _addAndOctree(feature) {
        this._add(feature);
        feature.id = `${feature[0]}-${feature[1]}-${feature[2]}`;
        this.taskManager.addHeavy(this, function (f) {
            const coord = new hmap.basetype.Coordinate(f[0], f[1], f[2]);
            coord._id = feature.id;
            coord._bbox = new hmap.basetype.BBox(f[0], f[1], f[2], f[0], f[1], f[2]);
            coord.rgba = [f[3], f[4], f[5], f[6]];
            coord.data = f[7];
            this.owner.layerOctree.put(coord);
        }, feature);
    }

    runTask(block) {
        this.bufferToGPU(block);
    }

    /**
     * block中所有feature的绘制数据全部追加到block的绘制数据后，把绘制数据写入显存，并更新block的相关状态
     * @param block
     * @private
     */
    bufferToGPU(block) {
        let vaoInfo = block.buffer ? block.buffer : this.program.createVAO();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vaoInfo.vbos.a_position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(block.points), this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vaoInfo.vbos.a_color);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(block.colors), this.gl.STATIC_DRAW);
        block.buffer = vaoInfo;
    }
    removeBlock(block){
        const id=block.id;
        if (block.buffer) {
            this.program.deleteVBOS(block.buffer.vao);
        }
        else {
            block.doTask = 0;
            this.taskManager._simpleTaskFag.delete(this.id + block.id);
        }
        block.clear();
        this.blocks.delete(id);
        if(this.blockHelper._curBlock && block.id===this.blockHelper._curBlock.id)
            this.blockHelper._curBlock=null;
        block=null;
    }
    _removeAll() {
        this._blocks.forEach((value,key) => {
            this.removeBlock(value);
        });
        this.owner._map.af.active();
        return this;
    }
    destroy(){
        this.gl.deleteProgram(this._program);
    }

    /**
     * 绘制
     * @param filterObject
     */
    draw() {
        const map = this.owner._map;
        const blocks = this._filterBlocks();

        this.program.active().setPublicUniforms({
            u_vpMatrix: map.getVPMatrix().getElements(),
            u_size: this.owner.pointSize

        });
        this.program.draw(blocks);
    }

};
;"use strict";

/**
 * 地理解决方案中可视域渲染使用
 * @type {hmap.ViewshedRender}
 * @private
 */
hmap.ViewshedRender=class{
    constructor(gl){
        this.CLASS_NAME="hmap.ViewshedRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._initToRender();
    }

    /**
     * 初始化绘制需要的东西
     * program：着色器程序
     * location：着色器属性索引地址
     * vao：顶点数组对象
     * buffer：VBOs
     * addStaticBufferD：将模型数据添加进VBOs
     * @private
     */
    _initToRender() {
        this._program=this._createProgram(hmap.shader.ViewsedShaderO.vsShader,hmap.shader.ViewsedShaderO.fsShader);
        this._location=hmap.shader.ViewsedShaderO.getLocation(this.gl,this._program);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }

    /**
     * 绘制函数,根据数据绘制可视域模型
     * @param dataMap 可变数据
     * @param mode 第二种绘制类型，默认单指绘线
     * @private
     */
    draw(dataMap,mode){
        this.gl.disable(this.gl.CULL_FACE);
        this.gl.depthFunc(this.gl.LEQUAL);
        this.gl.bindVertexArray(this._vao);
        this._addChangeBufferD(dataMap);
        this.gl.useProgram(this._program);
        this.gl.uniformMatrix4fv(this._location.u_mvpMatrix,false,this._vpMatrix.getElements());
        this.gl.drawElementsInstanced(this.gl.LINE_STRIP,12,this.gl.UNSIGNED_BYTE,0,dataMap.idArray.length);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(dataMap.a_color),false);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLES,12,this.gl.UNSIGNED_BYTE,0,dataMap.idArray.length);
        this.gl.bindVertexArray(null);
    }

    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        let coneData=hmap.ViewshedRender._createCone();
        this.gl.bindVertexArray(this._vao);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this._buffers.a_position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(coneData.posArray),this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(coneData.eleArray),this.gl.STATIC_DRAW);

        this.gl.bindVertexArray(null);
    }

    /**
     * 添加随可视域变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this._addVerBuffer(this._buffers.a_color,new Float32Array(drawMap.a_colorSide),false);
        this._addVerBuffer(this._buffers.a_radius,new Float32Array(drawMap.a_radius),false);
        this._addVerBuffer(this._buffers.a_scale,new Float32Array(drawMap.a_scale),false);
        this._addVerBuffer(this._buffers.a_orien,new Float32Array(drawMap.a_orien),false);
        this._addVerBuffer(this._buffers.a_location,new Float32Array(drawMap.a_location),false);
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        let gl = this.gl;
        gl.bindVertexArray(this._vao);
        let  viewshed= {};
        //可视域顶点
        viewshed.a_position = this._createVerBuffer("a_position","FLOAT",3);
        viewshed.a_color = this._createVerBuffer("a_color","FLOAT",4);
        gl.vertexAttribDivisor(this._location.a_color,1);
        viewshed.a_radius=this._createVerBuffer("a_radius","FLOAT",1);
        gl.vertexAttribDivisor(this._location.a_radius,1);
        viewshed.a_orien=this._createVerBuffer("a_orien","FLOAT",3);
        gl.vertexAttribDivisor(this._location.a_orien,1);
        viewshed.a_scale=this._createVerBuffer("a_scale","FLOAT",3);
        gl.vertexAttribDivisor(this._location.a_scale,1);
        viewshed.a_location=this._createVerBuffer("a_location","FLOAT",3);
        gl.vertexAttribDivisor(this._location.a_location,1);

        //索引
        viewshed.index = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        return  viewshed;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建顶点数组
     * @param name
     * @param dataType
     * @param size
     * @returns {AudioBuffer | WebGLBuffer}
     * @private
     */
    _createVerBuffer(name,dataType,size){
        let buffer=this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffer);
        this.gl.vertexAttribPointer(this._location[name], size,this.gl[dataType], false, 0, 0);
        this.gl.enableVertexAttribArray(this._location[name]);
        return buffer;
    }

    /**
     * 创建program
     * @param vs 顶点着色器源码
     * @param fs 片元着色器源码
     * @throws 当着色器程序编译失败时
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @throws 当着色器编译失败时
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }

    /**
     * 创建四棱锥型数据
     * @private
     */
    static _createCone() {
        let cone = {};
        //默认朝下
        // cone.posArray = [
        //     0, 0, 0,
        //     -.5, .5, -1.0,
        //     -.5, -.5, -1.0,
        //     .5, -.5, -1.0,
        //     .5, .5, -1.0
        // ];
        //默认x正半轴
        cone.posArray=[
            0, 0, 0,
            1.0, .5, -0.5,
            1.0, -.5, -0.5,
            1.0, -.5, 0.5,
            1.0, .5, 0.5
        ];
        cone.eleArray = [
            0, 2, 1,
            0, 3, 2,
            0, 4, 3,
            0, 1, 4,
        ];
        return cone;
    }
};;"use strict";
/**
 * 地理解决方案中散点图渲染使用
 * @type {hmap.ScatterRender}
 * @private
 */
hmap.ScatterRender=class{
    /**
     * 渲染器构造函数
     * @param glContext
     * @private
     */
    constructor(glContext) {
        this.gl = glContext;
        this.CLASS_NAME = "hmap.ScatterRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //水波纹使用数组
        this.rippeArr=[0,10,20];
        //呼吸效果分界标识（呼/吸）
        this.flag={
            breath:true,
        };
        //动态增加量
        this.sizeAdd={
            breath:1,
            bubble:1,
            bubbleCopy:1,
            twinkle:1
        };
        //每帧动态增加步幅
        this.addStep={
            breath: 20,
            bubble:20,
            twinkle:20,
        };
        //变化的透明度
        this.changeAlpha={
            breath:1.0,
            bubble:1.0,
            bubbleCopy:1.0,
            twinkle:1.0
        };
        this.change=0.0;
        //ripple使用
        this.changeStep=0.1;
        //参数
        this.locations=null;
        this.programs=null;
        this.vpMatrix=null;
        this._vao={};
    }

    /**
     * 获取gl
     * @returns {null|*}
     * @private
     */
    getGL() {
        return this.gl;
    }

    /**
     * 配置WebGL的上下文环境
     * @private
     */
    setGL(gl) {
        this.gl = gl;
        //开启@混合
        this.gl.enable(gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.clearColor(0.0,0.0,0.0,0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);
    }

    /**
     * 设置其他需要的options
     * @param options
     * @private
     */
    setGLOptions(options){
        this.locations=options.locations;
        this.programs=options.programs;
        this._vao=options.vaos;
    }
    /**
     * 创建buffer并添加点数据
     * @param {JSON}dataMap:positions,sizes,colors,changeColors
     * @param {hmap.animation.PointType}type:类型,breathPoint,bubble,ripple,sparkPoint
     * @return {number}:返回点的count
     * @private
     */
    bufferDataPoints(dataMap,type="breathPoint"){
        if(!dataMap||dataMap.positions.length<=0){
            return; 
        }
        let gl=this.gl;
        let positions=dataMap.positions;
        let sizes=dataMap.sizes;
        let colors=dataMap.colors;
        let count=positions.length/3;

        //buffer start
        gl.bindVertexArray(this._vao.get(type));
        let positionBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
        gl.enableVertexAttribArray(this.locations[type].positionAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.locations[type].positionAttributeLocation,3,gl.FLOAT,false,0,0);

        let sizeBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,sizeBuffer);
        gl.enableVertexAttribArray(this.locations[type].sizeAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(sizes),gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.locations[type].sizeAttributeLocation,1,gl.FLOAT,false,0,0);

        let colorBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
        gl.enableVertexAttribArray(this.locations[type].colorAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(colors),gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.locations[type].colorAttributeLocation,4,gl.FLOAT,false,0,0);

        switch(type){
            case "bubblePoint":
                let changeColors=dataMap.changeColors;
                let changeCBuffer=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,changeCBuffer);
                gl.enableVertexAttribArray(this.locations[type].changeColorAttributeLocation);
                gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(changeColors),gl.STATIC_DRAW);
                gl.vertexAttribPointer(this.locations[type].changeColorAttributeLocation,4,gl.FLOAT,false,0,0);
                break;
            default:
                break;
        }
        return count;
    }

    /**
     * 添加circle的buffer数据,circle的边数放开后可以得到多边形数据
     * @private
     */
    bufferDataCircle(div){
        //获取生成好的数据
        let dataMap=modelData.circle(div);
        if (dataMap.positions.length<=0)return;
        let gl=this.gl;
        let positions=dataMap.positions;
        gl.bindVertexArray(this._vao.get("circle"));
        let positionBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
        gl.enableVertexAttribArray(this.locations["circle"].positionAttributeLocation);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);
        gl.vertexAttribPointer(this.locations["circle"].positionAttributeLocation,3,gl.FLOAT,false,0,0);
        return dataMap.count;
    }
    /**
     * 绘制点
     * @param type:breathPoint,bubblePoint,ripplePoint,除spark
     * @param count:绘制的个数
     * @param sizeAdd:size加量
     * @param alpha:不透明度
     * @private
     */
    drawPoints(type,count,sizeAdd=0,alpha=1.0){
        if(!count)return;
        let gl=this.gl;
        gl.useProgram(this.programs[type]);
        gl.bindVertexArray(this._vao.get(type));
        gl.uniformMatrix4fv(this.locations[type].mvpMatrixLocation,false,this.vpMatrix.getElements());
        gl.uniform1f(this.locations[type].sizeAddLocation,sizeAdd);
        gl.uniform1f(this.locations[type].alphaLocation,alpha);
        gl.flush();
        gl.drawArrays(gl.POINTS,0,count);
    }
    /**
     * 绘制单层,最简单circle
     * @param dataMap:size,center,color,alpha
     * @param drawType
     * @private
     */
    drawCircle(dataMap,drawType="LINE_LOOP"){
        if(!dataMap.count)return;
        let gl=this.gl;
        gl.useProgram(this.programs["circle"]);
        gl.bindVertexArray(this._vao.get("circle"));
        gl.uniformMatrix4fv(this.locations["circle"].mvpMatrixLocation,false,this.vpMatrix.getElements());
        gl.uniform2fv(this.locations["circle"].viewportLocation,[gl.canvas.clientWidth,gl.canvas.clientHeight]);
        gl.uniform1f(this.locations["circle"].sizeLocation,dataMap.size);
        gl.uniform3fv(this.locations["circle"].centerLocation,dataMap.center);
        gl.uniform4fv(this.locations["circle"].colorLocation,dataMap.color);
        gl.uniform1f(this.locations["circle"].alphaLocation,dataMap.alpha);
        gl.drawArrays(gl[drawType],0,dataMap.count);
    }
    /**
     * 不同类型的circle效果:twinkle,ripple,bubble
     * @param {json}dataMap:center,size,color
     * @param {number}count:顶点数量
     * @param {hmap.animation.CircleType}type:效果类型,"bubble","twinkle","ripple",默认为"ripple"
     * @param {"LINE_LOOP"|"LINES"}drawType
     * @private
     */
    drawCircleType(dataMap,count,type,drawType="LINE_LOOP"){
        if(!count)return;
        let gl=this.gl;
        gl.useProgram(this.programs["circle"]);
        gl.bindVertexArray(this._vao.get("circle"));
        gl.uniformMatrix4fv(this.locations["circle"].mvpMatrixLocation,false,this.vpMatrix.getElements());
        gl.uniform2fv(this.locations["circle"].viewportLocation,[gl.canvas.clientWidth,gl.canvas.clientHeight]);
        gl.uniform3fv(this.locations["circle"].centerLocation,dataMap.center);
        gl.uniform4fv(this.locations["circle"].colorLocation,dataMap.color);
        switch(type){
            case "breathCircle":
                for(let j=0;j<3;j++){
                    let sizeA;
                    sizeA=this.sizeAdd.breath/4*j*j+10;
                    let alpha=1.0-1.0/4*j;
                    gl.uniform1f(this.locations["circle"].sizeLocation,(sizeA+dataMap.size));
                    gl.uniform1f(this.locations["circle"].alphaLocation,alpha);
                    gl.drawArrays(gl[drawType],0,count);
                }
                break;
            case "bubbleCircle":
                for(let j=0;j<3;j++){
                    let sizeA;
                    sizeA=this.sizeAdd.bubble/4*j*j;
                    let alpha=1.0-1.0/4*j;
                    gl.uniform1f(this.locations["circle"].sizeLocation,(sizeA+dataMap.size));
                    gl.uniform1f(this.locations["circle"].alphaLocation,alpha);
                    gl.drawArrays(gl[drawType],0,count);
                }
                break;
            case "twinkleCircle":
                let sizeMod=Math.floor(this.sizeAdd.twinkle%30);
                for(let j=0;j<3;j++){
                    let sizeA;
                    sizeA=sizeMod/4*j*j+10;
                    let alpha=1.0-1.0/4*j;
                    gl.uniform1f(this.locations["circle"].sizeLocation,(sizeA+dataMap.size));
                    gl.uniform1f(this.locations["circle"].alphaLocation,alpha);
                    gl.drawArrays(gl[drawType],0,count);
                }
                break;
            case "normalCircle":
                gl.uniform1f(this.locations["circle"].sizeLocation,(dataMap.size));
                gl.uniform1f(this.locations["circle"].alphaLocation,1.0);
                gl.drawArrays(gl[drawType],0,count);
                break;
            default:
                for(let i=0;i<this.rippeArr.length;i++){
                    this.rippeArr[i]+=this.change;
                    let r=this.rippeArr[i];
                    let alpha=1.0-(r-0)/31;//暂时未放开间隔
                    gl.uniform1f(this.locations["circle"].sizeLocation,(r+dataMap.size));
                    gl.uniform1f(this.locations["circle"].alphaLocation,alpha);
                    gl.drawArrays(gl[drawType],0,count);
                }
                break;
        }
    }

    /**
     * 绘制spark或者纹理的点
     * @param {number}count
     * @param {0|1}texIf
     * @param {Image}img
     * @param {array}color,归一化的RGBA数组
     * @private
     */
    drawSparkPoint(count,texIf,img=null,color=[0,0,0,0]){
        if(!count)return;
        let gl=this.gl;
        gl.useProgram(this.programs["sparkPoint"]);
        gl.bindVertexArray(this._vao.get("sparkPoint"));
        gl.uniformMatrix4fv(this.locations["sparkPoint"].mvpMatrixLocation,false,this.vpMatrix.getElements());
        gl.uniform4fv(this.locations["sparkPoint"].colorLocation,color);
        gl.uniform1i(this.locations["sparkPoint"].textureIfLocation,texIf);
        const texMap=this._glTexture(img,0);
        gl.uniform1i(this.locations["sparkPoint"].patternLocation,texMap.unit);
        gl.drawArrays(gl.POINTS,0,count);
    }

    /**
     * 纹理处理
     * @param {Image}image
     * @param {number}unit
     * @return {{texture: WebGLTexture | *, unit: *}}
     * @private
     */
    _glTexture(image,unit=0){
        let gl=this.gl;
        let texture=gl.createTexture();
        gl.activeTexture(gl.TEXTURE0+unit);
        gl.bindTexture(gl.TEXTURE_2D,texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        if(!image){
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));
            return{texture:texture,unit:unit};
        }else{
            image.onload=function () {
                gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
            };
        }
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
        gl.generateMipmap(gl.TEXTURE_2D);

        return{
            texture:texture,
            unit:unit
        };
    }
};;"use strict";
/**
 * 地理解决方案中绘制饼状图使用着色器
 * @type {hmap.PieRender}
 * @private
 */
hmap.PieRender=class{
    constructor(gl){
        this.CLASS_NAME="hmap.PieRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._initToRender();
    }

    /**
     * 初始化绘制需要的东西
     * program:着色器程序
     * locations：属性索引值
     * vaoCircle0：饼状图底面顶点数组对象
     * vaoCircleH：饼状图顶面顶点数组对象
     * vaoSide：饼状图侧面顶点数组对象
     * circle0：饼状图底面buffers对象
     * circleH：饼状图顶面buffers对象
     * side：饼状图侧面buffers对象
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.PieShaderO.vsShader, hmap.shader.PieShaderO.fsShader);
        this.locations = hmap.shader.PieShaderO.getLocation(this.gl, this.program);
        this.vaoCircle0 = this.gl.createVertexArray();
        this.vaoCircleH=this.gl.createVertexArray();
        this.vaoSide=this.gl.createVertexArray();
        this.circle0 = this._createBuffer(this.vaoCircle0);
        this.circleH=this._createBuffer(this.vaoCircleH);
        this.side=this._createBuffer(this.vaoSide);
    }

    /**
     * 绘制使用函数
     * 注:根据顶点进行绘制,绘制包括上下面的圆以及侧边缘，
     *    由于面的干涉以及透视投影导致变形问题，暂仅绘制底面，其它接口保留
     * @param dataMap
     * @private
     */
    draw(dataMap){
        let pieCount=dataMap.trans.length;
        let pointNum = 0,indNum=0,FSIZE=4;
        let pointSNum=0,indSNum=0;
        let gl=this.gl;
        // gl.bindVertexArray(this.vaoCircle0);
        for (let i = 0; i < pieCount; i++) {
            if (i === 0) {
                pointNum += 0;
                indNum+=0;
                pointSNum+=0;
                indSNum+=0;
            } else {
                pointNum += dataMap.counts[2*i - 2];
                indNum+=dataMap.indCounts[2*i-2];
                pointSNum+=dataMap.counts[2*i-1];
                indSNum+=dataMap.indCounts[2*i-1];
            }

            gl.useProgram(this.program);
            gl.uniformMatrix4fv(this.locations.mvpMatrixLocation,false,this._vpMatrix.getElements());
            const trans=dataMap.trans[i];
            gl.uniform3fv(this.locations.transLocation, trans);
            gl.bindVertexArray(this.vaoCircle0);
            gl.bindBuffer(gl.ARRAY_BUFFER,this.circle0.positionBuffer);
            gl.vertexAttribPointer(this.locations.positionAttributeLocation,3,gl.FLOAT,false,0,pointNum*3*FSIZE);
            gl.bindBuffer(gl.ARRAY_BUFFER,this.circle0.colorBuffer);
            gl.vertexAttribPointer(this.locations.colorAttributeLocation,4,gl.FLOAT,false,0,pointNum*4*FSIZE);
            gl.bindBuffer(gl.ARRAY_BUFFER,this.circle0.radiusBuffer);
            gl.vertexAttribPointer(this.locations.radiusAttributeLocation,1,gl.FLOAT,false,0,pointNum*FSIZE);
            gl.bindBuffer(gl.ARRAY_BUFFER,this.circle0.heightBuffer);
            gl.vertexAttribPointer(this.locations.heightAttributeLocation,1,gl.FLOAT,false,2*FSIZE,pointNum*FSIZE);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.circle0.indexBuffer);
            gl.drawElements(gl.TRIANGLE_FAN, dataMap.indCounts[2*i],gl.UNSIGNED_SHORT,indNum*2);

            //绘制顶面
            // gl.vertexAttribPointer(this.locations.heightAttributeLocation,1,gl.FLOAT,false,2*FSIZE,(pointNum+1)*FSIZE);
            // gl.drawElements(gl.TRIANGLE_FAN, dataMap.indCounts[2*i],gl.UNSIGNED_SHORT,indNum);

            //绘制边围
            // gl.bindVertexArray(this.vaoSide);
            // gl.bindBuffer(gl.ARRAY_BUFFER,this.side.positionBuffer);
            // gl.vertexAttribPointer(this.locations.positionAttributeLocation,3,gl.FLOAT,false,0,pointSNum*3*FSIZE);
            // gl.bindBuffer(gl.ARRAY_BUFFER,this.side.colorBuffer);
            // gl.vertexAttribPointer(this.locations.colorAttributeLocation,4,gl.FLOAT,false,0,pointSNum*4*FSIZE);
            // gl.bindBuffer(gl.ARRAY_BUFFER,this.side.radiusBuffer);
            // gl.vertexAttribPointer(this.locations.radiusAttributeLocation,1,gl.FLOAT,false,0,pointSNum*FSIZE);
            // gl.bindBuffer(gl.ARRAY_BUFFER,this.side.heightBuffer);
            // gl.vertexAttribPointer(this.locations.heightAttributeLocation,1,gl.FLOAT,false,2*FSIZE,(pointSNum+1)*FSIZE);
            // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.side.indexBuffer);
            // gl.drawElements(gl.TRIANGLE_STRIP, dataMap.indCounts[2*i+1],gl.UNSIGNED_SHORT,indSNum);
            gl.bindVertexArray(null);
        }
    }

    /**
     * 添加Buffer数据
     * @param vers
     * @private
     */
    addBuffer(vers){
        let gl=this.gl;
        gl.bindVertexArray(this.vaoCircle0);
        this._addVerBuffer(this.circle0.positionBuffer,new Float32Array(vers.positions),false);
        this._addVerBuffer(this.circle0.colorBuffer,new Float32Array(vers.colors),false);
        this._addVerBuffer(this.circle0.radiusBuffer,new Float32Array(vers.rs),false);
        this._addVerBuffer(this.circle0.heightBuffer,new Float32Array(vers.hs),false);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.circle0.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(vers.indices),gl.STATIC_DRAW);

        gl.bindVertexArray(this.vaoSide);
        this._addVerBuffer(this.side.positionBuffer,new Float32Array(vers.positionsS),false);
        this._addVerBuffer(this.side.colorBuffer, new Float32Array(vers.colorsS),false);
        this._addVerBuffer(this.side.radiusBuffer,new Float32Array(vers.rsS),false);
        this._addVerBuffer(this.side.heightBuffer,new Float32Array(vers.hsS),false);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.side.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(vers.indicesS),gl.STATIC_DRAW);

        gl.bindVertexArray(null);
    }
    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffer(vao) {
        let gl = this.gl;
        gl.bindVertexArray(vao);
        let  pie= {};
        //顶点
        pie.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,  pie.positionBuffer);
        gl.vertexAttribPointer(this.locations.positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.positionAttributeLocation);

        //颜色
         pie.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,  pie.colorBuffer);
        gl.vertexAttribPointer(this.locations.colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.colorAttributeLocation);

        //半径
        pie.radiusBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,pie.radiusBuffer);
        gl.vertexAttribPointer(this.locations.radiusAttributeLocation,1,gl.FLOAT,false,0,0);
        gl.enableVertexAttribArray(this.locations.radiusAttributeLocation);

        //高度
        pie.heightBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,pie.heightBuffer);
        gl.vertexAttribPointer(this.locations.heightAttributeLocation,1,gl.FLOAT,false,0,0);
        gl.enableVertexAttribArray(this.locations.heightAttributeLocation);

        //indexes
         pie.indexBuffer = gl.createBuffer();
        // //纹理
        //  pie.texCoordBuffer=gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, pie.texCoordBuffer);
        // gl.vertexAttribPointer(this.locations.texCoordAttributeLocation,2,gl.FLOAT,false,0,0);
        // gl.enableVertexAttribArray(this.locations.texCoordAttributeLocation);
        gl.bindVertexArray(null);
        return  pie;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs 顶点着色器源码
     * @param fs 片元着色器源码
     * @throws 当着色器程序编译失败时
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @throws 当着色器编译失败时
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
/**
 * 地理解决方案中电子墙使用
 * @type {hmap.EleWallRender}
 * @private
 */
hmap.EleWallRender=class{
    constructor(gl,posSize) {
        this.CLASS_NAME = "hmap.EleWallRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._initToRender();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @param drawType0 绘制类型，默认为线
     * @param drawType1 绘制类型，默认为null
     * @private
     */
    draw(dataMap,uniforms,drawType0="LINES",drawType1=null) {
        if(dataMap.positions.length === 0) return;
        let gl = this.gl;
        // this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
        // this.gl.polygonOffset(2,2);
        //设置全局量
        gl.useProgram(this.program);
        gl.uniform1i(this.locations.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this.locations.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this.locations.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        gl.bindVertexArray(this.vao);
        this._drawEleWall(dataMap,drawType0,drawType1);
    }

    /**
     * 绘制电子墙方法，主要更新buffer数据
     * @param dataMap 顶点数据
     * @param drawType0 绘制类型1
     * @param drawType1 绘制类型2
     * @private
     */
    _drawEleWall(dataMap,drawType0,drawType1) {
        let gl = this.gl;
        //更新顶点
        this._addVerBuffer(this.ele.positionBuffer, new Float32Array(dataMap.positions), true);
        this._addVerBuffer(this.ele.colorBuffer, new Float32Array(dataMap.colors), true);
        this._addVerBuffer(this.ele.sizeBuffer, new Float32Array(dataMap.sizes), true);
        // this._addVerBuffer(this.ele.verNormalBuffer, dataMap.normals, true);
        const count = dataMap.indices.length;       //dataMap.indices.length
        //更新索引
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ele.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.indices), gl.STATIC_DRAW);
        gl.drawElements(gl[drawType0], count, gl.UNSIGNED_SHORT, 0);

        if(drawType1){
            gl.drawElements(gl[drawType1], count, gl.UNSIGNED_SHORT, 0);
        }
        gl.bindVertexArray(null);
    }


    /**
     * 初始化绘制所需，包括program、Locations、vao、buffers
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.EleWallShaderO.vsShader, hmap.shader.EleWallShaderO.fsShader);
        this.locations = hmap.shader.EleWallShaderO.getLocations(this.gl, this.program);
        this.vao = this.gl.createVertexArray();
        this.ele = this._createBuffer();
    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let ele = {};
        ele.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_positionH);
        gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_positionL);

        //颜色
        ele.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.colorBuffer);
        gl.vertexAttribPointer(this.locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_color);

        //绘制大小
        ele.sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.sizeBuffer);
        gl.vertexAttribPointer(this.locations.a_size, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_size);

        // indexes
        ele.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ele.indexBuffer);
        return ele;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @returns program
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
/**
 * 地理解决方案中蝌蚪图渲染使用
 * @type {hmap.TadpoleRender}
 * @private
 */
hmap.TadpoleRender = class {
    /**
     * 构造函数
     * @param gl webgl上下文
     * @param posSize 单个顶点的数量，用来区分使用使用了RTE。正常为3，包括x，y，z。
     * @param disableBlend 是否禁用混合
     * @private
     */
    constructor(gl,posSize,disableBlend) {
        this.CLASS_NAME = "hmap.TadpoleRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._disableBlend = disableBlend;        //开启要素点颜色混合
        this._initToRender();
        this._configGL();
        this._isAdd={tadpole:false,line:false};
    }

    /**
     * 设置渲染上下文
     * @private
     */
    _configGL() {
        if(this._disableBlend){
            this.gl.disable(this.gl.BLEND);            //关闭混合
        }else{
            this.gl.enable(this.gl.BLEND);            //允许混合
            this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);      //混合模式
        }
    }

    /**
     * 绘制方法
     * @param uniforms
     * @param params,参数,包括绘制group的count和使用顶点的offset
     * @private
     */
    draw(uniforms,params) {
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniform1i(this.locations.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this.locations.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this.locations.u_cameraL,[camera.clx,camera.cly,camera.clz]);

        this._drawStepLine(params);
        this._drawTadpole(params);
    }

    /**
     * 绘制蝌蚪图
     * @param params,参数,包括顶点的偏移量,其它属性的偏移量,group包括的顶点count
     * @private
     */
    _drawTadpole(params) {
        if((!this._isAdd.tadpole)||params.count===0)return;
        this.gl.bindVertexArray(this.vao.tadpole);
        const buffers=this.buffer.tadpole;
        const FSIZE=4,pSize=this._posSize,offsetP=params.offsetPos,offsetO=params.offsetOther;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.positionBuffer);
        this.gl.vertexAttribPointer(this.locations.a_positionH,3,this.gl.FLOAT,false,pSize*FSIZE,pSize*FSIZE*offsetP);
        this.gl.vertexAttribPointer(this.locations.a_positionL, 3, this.gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE+pSize*FSIZE*offsetP);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.colorBuffer);
        this.gl.vertexAttribPointer(this.locations.a_color,4,this.gl.FLOAT,false,0,4*FSIZE*offsetO);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.sizeBuffer);
        this.gl.vertexAttribPointer(this.locations.a_size,1,this.gl.FLOAT,false,0,FSIZE*offsetO);
        this.gl.drawArrays(this.gl.POINTS,0,params.count);
        this.gl.bindVertexArray(null);
    }

    /**
     * 绘制线
     * @param params,属性控制参数.包括顶点的偏移量
     * @private
     */
    _drawStepLine(params){
        if((!this._isAdd.line)||params.count===0)return;
        this.gl.bindVertexArray(this.vao.line);
        const buffers=this.buffer.line;
        const FSIZE=4,pSize=this._posSize,offsetP=params.offsetPos;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.positionBuffer);
        this.gl.vertexAttribPointer(this.locations.a_positionH,3,gl.FLOAT,false,pSize*FSIZE,pSize*FSIZE*offsetP);
        this.gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE+pSize*FSIZE*offsetP);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.colorBuffer);
        this.gl.vertexAttribPointer(this.locations.a_color,4,gl.FLOAT,false,0,4*FSIZE*offsetPos);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.sizeBuffer);
        this.gl.vertexAttribPointer(this.locations.a_size,1,gl.FLOAT,false,0,FSIZE*offsetPos);
        this.gl.drawArrays(this.gl.LINE_STRIP,0,params.count);
        this.gl.bindVertexArray(null);
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.TadpoleShaderO.vsShader, hmap.shader.TadpoleShaderO.fsShader);
        this.locations = hmap.shader.TadpoleShaderO.getLocation(this.gl, this.program);
        this.vao = {tadpole:this.gl.createVertexArray(),
            line:this.gl.createVertexArray()};
        this.buffer={tadpole:this._createBuffer("tadpole"),
            line:this._createBuffer("line")};
    }

    /**
     * 向buffer内填充数据
     * @param dataMap
     * @param {"tadpole"|"line"} name 填充的数据类型,枚举型
     * @param {Boolean} dynamic 绘制数据的使用方式.默认false,使用静态缓存,写入显卡
     * 注: false,数据存储在显存中,数据处理速度快,但I/O操作缓慢,适合变动率小的数据.
     *     true,数据存储在内存为显存单独开辟的区域中,访问区域高于内存,适合变动数据
     *  @private
     */
    addBufferData(dataMap,name,dynamic=false){
        this.gl.bindVertexArray(this.vao[name]);
        const buffers=this.buffer[name];
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this._addVerBuffer(buffers.colorBuffer, new Float32Array(dataMap.colors), false);
        this._addVerBuffer(buffers.sizeBuffer, new Float32Array(dataMap.sizes), false);
        this.gl.bindVertexArray(null);
        this._isAdd[name]=true;
    }

    /**
     * 更新绘制数据(等量替换数据)
     * @param {"tadpole"|"line"} name
     * @param {json} params {update:{position:bool,color:bool,size:bool},
     *                       array:{position:[],color:[],size:[]},
     *                       offset:{position:number,color:number,size:number}}
     * 注:offset按点计算,比如偏移一个点,对应的position的offset为1,color的offet为1,size为1
     * @private
     */
    updataBuffer(name,params){
        this.gl.bindVertexArray(this.vao[name]);
        const update=params.update;
        const array=params.array;
        const offset=params.offset;
        const buffers=this.buffer[name];
        if(update.position){
            this._upVerBuffer(buffers.positionBuffer,new Float32Array(array.position),offset.position*4*this._posSize);
        }
        if(update.color){
            this._upVerBuffer(buffers.colorBuffer,new Float32Array(array.color),offset.color*4*4);
        }
        if(update.size){
            this._upVerBuffer(buffers.sizeBuffer,new Float32Array(array.size),offset.size*4);
        }
        this.gl.bindVertexArray(null);
    }

    /**
     * 根据类型名称删除对应buffer
     * @param {"tadpole"|"line"} name,枚举型
     * @private
     */
    deleteBuffers(name){
        this.gl.deleteVertexArray(this.vao[name]);
        const buffers=this.buffer[name];
        this.gl.deleteBuffer(buffers.positionBuffer);
        this.gl.deleteBuffer(buffers.colorBuffer);
        this.gl.deleteBuffer(buffers.sizeBuffer);
    }
    /**
     * 创建buffer
     * param {"tadpole"|"line"} name 创建的缓冲区使用对象,枚举型
     * @returns {{}}
     * @private
     */
    _createBuffer(name) {
        let gl = this.gl;
        gl.bindVertexArray(this.vao[name]);
        let FSIZE=4,pSize=this._posSize;
        let tad = {};
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_positionH);
        gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_positionL);

        //颜色
        tad.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.colorBuffer);
        gl.vertexAttribPointer(this.locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_color);

        //大小
        tad.sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.sizeBuffer);
        gl.vertexAttribPointer(this.locations.a_size, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_size);
        gl.bindVertexArray(null);
        return tad;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param offset, 字节偏移量
     * @private
     */
    _upVerBuffer(buffer, array, offset) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @throws 当着色器程序编译失败时
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @throws 当着色器编译失败时
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
/**
 * 地理解决方案中流线动画渲染使用
 * @type {hmap.FlowsRender}
 * @private
 */
hmap.FlowsOldRender = class {
    /**
     * 构造函数
     * @param gl webgl上下文
     * @param posSize 单个顶点的数量，用来区分使用使用了RTE。正常为3，包括x，y，z。
     * @param disableBlend 是否禁用混合
     * @private
     */
    constructor(gl,posSize,disableBlend) {
        this.CLASS_NAME = "hmap.FlowsOldRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._disableBlend = disableBlend;        //开启要素点颜色混合
        this._initToRender();
        this._configGL();
        this._isAdd=false;
    }

    /**
     * 设置渲染上下文
     * @private
     */
    _configGL() {
        if(this._disableBlend){
            this.gl.disable(this.gl.BLEND);            //关闭混合
        }else{
            this.gl.enable(this.gl.BLEND);            //允许混合
            this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);      //混合模式
        }
    }

    /**
     * 绘制方法
     * @param uniforms
     * @param params,参数,包括绘制group的count和使用顶点的offset
     * @private
     */
    draw(uniforms,params) {
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniform1i(this.locations.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this.locations.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this.locations.u_cameraL,[camera.clx,camera.cly,camera.clz]);

        this._drawFlows(params);
    }

    /**
     * 绘制蝌蚪图
     * @param params,参数,包括顶点的偏移量,其它属性的偏移量,group包括的顶点count
     * @private
     */
    _drawFlows(params) {
        if((!this._isAdd)||params.count===0)return;
        this.gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        const FSIZE=4,pSize=this._posSize,offsetP=params.offsetPos,offsetO=params.offsetOther;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.positionBuffer);
        this.gl.vertexAttribPointer(this.locations.a_positionH,3,this.gl.FLOAT,false,pSize*FSIZE,pSize*FSIZE*offsetP);
        this.gl.vertexAttribPointer(this.locations.a_positionL, 3, this.gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE+pSize*FSIZE*offsetP);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffers.colorBuffer);
        this.gl.vertexAttribPointer(this.locations.a_color,4,this.gl.FLOAT,false,0,4*FSIZE*offsetO);
        this.gl.drawArrays(this.gl.LINE_STRIP,0,params.count);
        this.gl.bindVertexArray(null);
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.FlowsOldShader.vsShader, hmap.shader.FlowsOldShader.fsShader);
        this.locations = hmap.shader.FlowsOldShader.getLocation(this.gl, this.program);
        this.vao = this.gl.createVertexArray();
        this.buffer=this._createBuffer()
    }

    /**
     * 向buffer内填充数据
     * @param dataMap
     * @param {"flow"|"line"} name 填充的数据类型,枚举型
     * @param {Boolean} dynamic 绘制数据的使用方式.默认false,使用静态缓存,写入显卡
     * 注: false,数据存储在显存中,数据处理速度快,但I/O操作缓慢,适合变动率小的数据.
     *     true,数据存储在内存为显存单独开辟的区域中,访问区域高于内存,适合变动数据
     *  @private
     */
    addBufferData(dataMap,dynamic=false){
        this.gl.bindVertexArray(this.vao);
        const buffers=this.buffer;
        this._addVerBuffer(buffers.positionBuffer, new Float32Array(dataMap.positions), false);
        this._addVerBuffer(buffers.colorBuffer, new Float32Array(dataMap.colors), false);
        this.gl.bindVertexArray(null);
        this._isAdd=true;
    }

    /**
     * 更新绘制数据(等量替换数据)
     * @param {"flow"|"line"} name
     * @param {json} params {update:{position:bool,color:bool,size:bool},
     *                       array:{position:[],color:[]},
     *                       offset:{position:number,color:number,size:number}}
     * 注:offset按点计算,比如偏移一个点,对应的position的offset为1,color的offet为1,size为1
     * @private
     */
    updataBuffer(name,params){
        this.gl.bindVertexArray(this.vao[name]);
        const update=params.update;
        const array=params.array;
        const offset=params.offset;
        const buffers=this.buffer[name];
        if(update.position){
            this._upVerBuffer(buffers.positionBuffer,new Float32Array(array.position),offset.position*4*this._posSize);
        }
        if(update.color){
            this._upVerBuffer(buffers.colorBuffer,new Float32Array(array.color),offset.color*4*4);
        }
        this.gl.bindVertexArray(null);
    }

    /**
     * 根据类型名称删除对应buffer
     * @param {"flow"|"line"} name,枚举型
     * @private
     */
    deleteBuffers(name){
        this.gl.deleteVertexArray(this.vao);
        const buffers=this.buffer;
        this.gl.deleteBuffer(buffers.positionBuffer);
        this.gl.deleteBuffer(buffers.colorBuffer);
    }
    /**
     * 创建buffer
     * param {"flow"|"line"} name 创建的缓冲区使用对象,枚举型
     * @returns {{}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let tad = {};
        //位置
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_positionH);
        gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_positionL);

        //颜色
        tad.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.colorBuffer);
        gl.vertexAttribPointer(this.locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_color);

        gl.bindVertexArray(null);
        return tad;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param offset, 字节偏移量
     * @private
     */
    _upVerBuffer(buffer, array, offset) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @throws 当着色器程序编译失败时
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @throws 当着色器编译失败时
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
/**
 * 柱状图的渲染环境
 * @type {hmap.PillarRender}
 * @private
 */
hmap.PillarRender=class{
    /**
     * 构造函数.构造时,获取模型数据,并将柱状图模型数据填充到渲染缓冲区
     * @param gl,webgl上下文
     * @param programs,渲染柱状图的着色器程序
     * @param locations,渲染柱状图的着色器属性索引地址
     * @private
     */
    constructor(gl,programs,locations){
        this.gl = gl;
        this.CLASS_NAME = "hmap.PillarRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        //参数
        this.locations=locations;
        this.programs=programs;
        this.vpMatrix=null;
        this.pillarModel=this.createModel();//模型数据
        this.initPillarBuffer();
    }

    /**
     * 初始化柱状图的渲染缓冲区,并填充柱状图模型数据
     * @private
     */
    initPillarBuffer(){
        const dataMap=this.pillarModel;
        const locations=this.locations.pillar;
        let gl=this.gl;

        //顶点array对象,管理buffer
        let vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        //顶点数据缓冲区操作
        let positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(locations.positionAttributeLocation);
        gl.vertexAttribPointer(locations.positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dataMap.positions), gl.STATIC_DRAW);

        //纹理坐标缓冲区操作
        let texBuffer=gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,texBuffer);
        gl.enableVertexAttribArray(locations.texCoordAttributeLocation);
        gl.vertexAttribPointer(locations.texCoordAttributeLocation,2,gl.FLOAT,false,0,0);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(dataMap.texCoords),gl.STATIC_DRAW);
        //清除当前缓冲区绑定
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        //索引数组缓冲区操作
        let indicesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.indices), gl.STATIC_DRAW);
    }

    /**
     * 根据柱状图的改变属性,绘制模型
     * @param {number}x,当前柱状体放置底图位置的地理坐标x分量
     * @param {number}y,当前柱状体置底图位置的地理坐标y分量
     * @param {number}z,当前柱状体放置底图位置的地理坐标z分量
     * @param {string}label,当前柱状体的用户自定义标签描述等
     * @param {number}weight,用户传入的作为高度属性的最大值
     * @param {array}color,归一化的RGBA颜色数组
     * @param {array}scale,当前柱状体放置到底图位置的缩放比例
     * @private
     */
    draw(x,y,z, label, weight, color, scale){
        const gl=this.gl;
        const program=this.programs.pillar;
        const locations=this.locations.pillar;
        gl.useProgram(program);
        gl.uniform4fv(locations.colorLocation,color);
        gl.uniform1i(locations.ifTexLocation,0);
        gl.uniform4fv(locations.fogColorLocation,this.fogColor);
        gl.uniform2fv(locations.fogDistLocation,this.fogDist);
        let matrix=this.vpMatrix.clone().translate(x,y,z).scale(scale[0],scale[1],scale[2]);
        gl.uniformMatrix4fv(locations.mvpMatrixLocation,false,matrix.getElements());
        const count=this.pillarModel.indices.length;
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
    }

    /**
     * 纹理方法
     * @param gl
     * @private
     */
    _glTexture(gl){
        let img=new Image();
        img.src="img/worldMask.jpg";
        let texture=gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D,texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
            new Uint8Array([0, 0, 255, 255]));
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
        gl.generateMipmap(gl.TEXTURE_2D);
        img.onload=function () {
            gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
        }
    }

    /**
     * 以xoy平面原点生成的三维立方体数据{不对外开放}
     *
     *   v6----- v5
     *   /|      /|
     *  v1------v0|
     *  | |     | |
     *  | |v7---|-|v4
     *  |/      |/
     *  v2------v3
     * @private
     */
    createModel(){
        // Create a cube
        //    v6----- v5
        //   /|      /|
        //  v1------v0|
        //  | |     | |
        //  | |v7---|-|v4
        //  |/      |/
        //  v2------v3
        //顶点坐标
        const posArray=[
            .5, .5, 1.0,  -.5, .5, 1.0,  -.5,-.5, 1.0,   .5,-.5, 1.0, // v0-v1-v2-v3 front
            .5, .5, 1.0,   .5,-.5, 1.0,   .5,-.5,0.0,   .5, .5,0.0, // v0-v3-v4-v5 right
            .5, .5, 1.0,   .5, .5,0.0,  -.5, .5,0.0,  -.5, .5, 1.0, // v0-v5-v6-v1 up
            -.5, .5, 1.0,  -.5, .5,0.0,  -.5,-.5,0.0,  -.5,-.5, 1.0, // v1-v6-v7-v2 left
            -.5,-.5,0.0,   .5,-.5,0.0,   .5,-.5, 1.0,  -.5,-.5, 1.0, // v7-v4-v3-v2 down
            .5,-.5,0.0,  -.5,-.5,0.0,  -.5, .5,0.0,   .5, .5,0.0  // v4-v7-v6-v5 back
        ];
        //纹理坐标
        const texCoords=[
            1.0, 1.0,   0.0, 1.0,   0.0, 0.0,   1.0, 0.0,    // v0-v1-v2-v3 front
            0.0, 1.0,   0.0, 0.0,   1.0, 0.0,   1.0, 1.0,    // v0-v3-v4-v5 right
            1.0, 0.0,   1.0, 1.0,   0.0, 1.0,   0.0, 0.0,    // v0-v5-v6-v1 up
            1.0, 1.0,   0.0, 1.0,   0.0, 0.0,   1.0, 0.0,    // v1-v6-v7-v2 left
            0.0, 0.0,   1.0, 0.0,   1.0, 1.0,   0.0, 1.0,    // v7-v4-v3-v2 down
            0.0, 0.0,   1.0, 0.0,   1.0, 1.0,   0.0, 1.0     // v4-v7-v6-v5 back
        ];
        //顶点索引
        const indices=[
            0, 1, 2,   0, 2, 3,    // front
            4, 5, 6,   4, 6, 7,    // right
            8, 9,10,   8,10,11,    // up
            12,13,14,  12,14,15,    // left
            16,17,18,  16,18,19,    // down
            20,21,22,  20,22,23     // back
        ];
        //法线
        const normals =[    // Normal
            0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
            1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
            0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
            -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
            0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // v7-v4-v3-v2 down
            0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // v4-v7-v6-v5 back
        ];

        return{
            positions:posArray,
            texCoords:texCoords,
            indices:indices,
            count:indices.length
        };
    }
}
;"use strict";
/**
 * 地理解决方案中泛光渲染使用
 * @type {hmap.ShineRender}
 * @private
 */
hmap.ShineRender = class {
    /**
     * 构造函数
     * @param gl
     * @param posSize
     * @private
     */
    constructor(gl,posSize) {
        this.CLASS_NAME = "hmap.ShineRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成

        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._initToRender();
        this._configGL();
    }

    /**
     * 设置上下文环境
     * @private
     */
    _configGL() {
        this.gl.enable(this.gl.BLEND);                          //允许混合
        this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);      //混合模式
    }

    /**
     * 绘制调用，layer使用接口
     * @param dataMap
     * @param uniforms
     */
    draw(dataMap,uniforms) {
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        //gl.uniformMatrix4fv(this.locations.mvpMatrixLocation, false, this._vpMatrix.getElements());
        gl.uniform1i(this.locations.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this.locations.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this.locations.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        gl.bindVertexArray(this.vao);

        this._drawShine(dataMap);
    }

    /**
     * 使用顶点数据绘制泛光接口
     * @param dataMap
     * @private
     */
    _drawShine(dataMap) {
        let gl = this.gl;
        if(dataMap.positions.length == 0) return;
        //更新顶点
        this._addVerBuffer(this.tad.prevPositionBuffer, new Float32Array(dataMap.prevPositions), true);
        this._addVerBuffer(this.tad.positionBuffer, new Float32Array(dataMap.positions), true);
        this._addVerBuffer(this.tad.nextPositionBuffer, new Float32Array(dataMap.nextPositions), true);

        this._addVerBuffer(this.tad.isOffsetBuffer, new Float32Array(dataMap.isOffset), true);
        this._addVerBuffer(this.tad.scaleBuffer, new Float32Array(dataMap.scale), true);
        this._addVerBuffer(this.tad.colorBuffer, new Float32Array(dataMap.colors), true);

        const count = dataMap.indices.length;       //索引
        //更新索引
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.tad.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.indices), gl.STATIC_DRAW);

        gl.drawElements(gl.TRIANGLE_STRIP, count, gl.UNSIGNED_SHORT, 0);
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.ShineShader.vsShader, hmap.shader.ShineShader.fsShader);
        this.locations = hmap.shader.ShineShader.getLocation(this.gl, this.program);
        this.vao = this.gl.createVertexArray();
        this.tad = this._createBuffer();
    }

    /**
     * 创建绘制使用buffers
     * @returns {{}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let tad = {};

        //先前点
        tad.prevPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.prevPositionBuffer);
        gl.vertexAttribPointer(this.locations.a_prePositionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_prePositionH);
        gl.vertexAttribPointer(this.locations.a_prePositionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_prePositionL);

        //当前点
        tad.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_positionH);
        gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_positionL);

        //下个点
        tad.nextPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.nextPositionBuffer);
        gl.vertexAttribPointer(this.locations.a_nextPositionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_nextPositionH);
        gl.vertexAttribPointer(this.locations.a_nextPositionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_nextPositionL);

        //是否需要偏移
        tad.isOffsetBuffer = gl.createBuffer();             //isOffsetBuffer  是否需要偏移
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.isOffsetBuffer);
        gl.vertexAttribPointer(this.locations.isOffset, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.isOffset);

        //阴影的比例，和预设的相比较
        tad.scaleBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.scaleBuffer);
        gl.vertexAttribPointer(this.locations.scale, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.scale);

        //颜色
        tad.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tad.colorBuffer);
        gl.vertexAttribPointer(this.locations.color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.color);

        //索引
        tad.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tad.indexBuffer);
        return tad;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @throws 当着色器程序编译失败时
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @throws 当着色器编译失败时
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
hmap.FilledCircleRender=class{
    constructor(gl,posSize){
        this.CLASS_NAME="hmap.FilledCircleRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl=gl;
        this._vpMatrix=null;
        this._posSize=posSize;
        this._upBuffer=false;//buffer里面是否有可变数据
        this._initToRender();
    }

    setResolution(res){
        this.res=res;
    }

    _initToRender() {
        this._program=new hmap.program.FilledCircleProgram(this.gl);
        this._vao=this.gl.createVertexArray();
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }

    draw(dataMap,uniforms,mode){
        this.gl.bindVertexArray(this._vao);
        // this._addChangeBufferD(dataMap);
        this._program.useProgram();
        this._program.setPriviteUniforms(uniforms);
        this.gl.drawElementsInstanced(this.gl[mode]||this.gl.TRIANGLES,52,this.gl.UNSIGNED_BYTE,0,dataMap.idArray.length);
        this.gl.bindVertexArray(null);
    }

    /**
     * 根据更新变量，更新动态数据的缓存
     * @param dataMap
     * @param flags
     * @private
     * 注：暂未实现
     */
    _upChangeBufferD(dataMap,flags){
        if(this._upBuffer&&flags.isChange&&flags.update==="R"){
            this._upVerBuffer()
        }else{
            this._addChangeBufferD(dataMap);
        }
    }
    /**
     * 添加静态缓存数据
     * @private
     */
    _addStaticBufferD(){
        let filledData=hmap.FilledCircleRender._createFilledCircle();
        this.gl.bindVertexArray(this._vao);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this._buffers.a_position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(filledData.positions),this.gl.STATIC_DRAW);

        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this._buffers.index);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint8Array(filledData.indices),this.gl.STATIC_DRAW);

        this.gl.bindVertexArray(null);
    }

    /**
     * 添加变化缓存数据
     * @private
     */
    _addChangeBufferD(drawMap){
        this.gl.bindVertexArray(this._vao);
        this._addVerBuffer(this._buffers.a_center,new Float32Array(drawMap.centers),false);
        this._addVerBuffer(this._buffers.a_color,new Float32Array(drawMap.colors),false);
        this._addVerBuffer(this._buffers.a_threshold,new Float32Array(drawMap.thresholds),false);
        this._addVerBuffer(this._buffers.a_size,new Float32Array(drawMap.sizes),false);
        this._addVerBuffer(this._buffers.a_freq,new Float32Array(drawMap.freqs),false);
        this._addVerBuffer(this._buffers.a_maxSize,new Float32Array(drawMap.maxSizes),false);
        this._upBuffer=true;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffers() {
        let gl = this.gl,locations=this._program.attributes;
        gl.bindVertexArray(this._vao);
        const FSIZE=4,posSize=this._posSize;
        let filled={};
        //填充面属性
        filled.a_position= this._createVerBuffer("a_position","FLOAT",3);
        filled.a_center=this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,filled.a_center);
        this.gl.vertexAttribPointer(this._program.attributes["a_center"], 3,this.gl.FLOAT, false, posSize*FSIZE, 0);
        this.gl.enableVertexAttribArray(this._program.attributes["a_center"]);
        this.gl.vertexAttribPointer(this._program.attributes["a_centerL"], 3,this.gl.FLOAT, false,  posSize*FSIZE, (posSize-3)*FSIZE);
        this.gl.enableVertexAttribArray(this._program.attributes["a_centerL"]);
        gl.vertexAttribDivisor(locations.a_center,1);
        gl.vertexAttribDivisor(locations.a_centerL,1);
        filled.a_color = this._createVerBuffer("a_color","FLOAT",4);
        gl.vertexAttribDivisor(locations.a_color,1);
        filled.a_threshold=this._createVerBuffer("a_threshold","FLOAT",4);
        gl.vertexAttribDivisor(locations.a_threshold,1);
        filled.a_size=this._createVerBuffer("a_size","FLOAT",1);
        gl.vertexAttribDivisor(locations.a_size,1);
        filled.a_freq=this._createVerBuffer("a_freq","FLOAT",1);
        gl.vertexAttribDivisor(locations.a_freq,1);
        filled.a_maxSize=this._createVerBuffer("a_maxSize","FLOAT",1);
        gl.vertexAttribDivisor(locations.a_maxSize,1);

        //索引
        filled.index = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,null);
        gl.bindVertexArray(null);
        this._upBuffer=false;
        return  filled;
    }

    _deleteBuffers(){
        for(const [name,buffer] of Object.entries(this._buffers)){
            this.gl.deleteBuffer(buffer);
        }
        this._buffers=this._createBuffers();
        this._addStaticBufferD();
    }
    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param offset,偏移量
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array,offset, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建顶点数组
     * @param name
     * @param dataType
     * @param size
     * @returns {AudioBuffer | WebGLBuffer}
     * @private
     */
    _createVerBuffer(name,dataType,size){
        let buffer=this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER,buffer);
        this.gl.vertexAttribPointer(this._program.attributes[name], size,this.gl[dataType], false, 0, 0);
        this.gl.enableVertexAttribArray(this._program.attributes[name]);
        return buffer;
    }

    /**
     * 创建四棱锥型数据
     * @private
     */
    static _createFilledCircle(div=50){
        let r=1.0;
        let posArray=[0,0,0];
        let eleArray=[0];
        for(let i=0;i<=div;i++){
            const angle=2.0*Math.PI/div*i;
            const x=r*Math.cos(angle);
            const y=r*Math.sin(angle);
            posArray.push(x,y,0.0);
            eleArray.push(i+1);
        }
        return{
            positions:posArray,
            indices:eleArray,
            count:eleArray.length
        };
    }
};;"use strict";
/**
 * 地理解决方案中填充特效，当前是水特效
 * @type {hmap.FlowLightRender}
 * @private
 */
hmap.FillWaterOldRender=class{
    constructor(gl,fillType){
        this.CLASS_NAME="hmap.FillWaterOldRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this.fillType = fillType;
        this._initToRender();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @param drawType0 绘制类型，默认为线
     * @param drawType1 绘制类型，默认为null
     * @private
     */
    draw(dataMap,uniforms) {
        if(dataMap.positions.length === 0) return;
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        gl.uniform1f(this.locations.u_time, uniforms.u_time);

        gl.bindVertexArray(this.vao);
        this._drawFillWater(dataMap);
    }

    /**
     * 绘制填充特效
     * @param dataMap 顶点数据
     * @private
     */
    _drawFillWater(dataMap) {
        let gl = this.gl;
        //更新顶点
        this._addVerBuffer(this.ele.positionBuffer, new Float32Array(dataMap.positions), true);

        const count = dataMap.indices.length;
        //更新索引
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ele.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.indices), gl.STATIC_DRAW);
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }


    /**
     * 初始化绘制所需，包括program、Locations、vao、buffers
     * @private
     */
    _initToRender() {
        let shader = hmap.shader.FillWaterOldShader;
        this.program = this._createProgram(shader.vsShader, shader.fsShader);
        this.locations = shader.getLocations(this.gl, this.program);
        this.vao = this.gl.createVertexArray();
        this.ele = this._createBuffer();
    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let ele = {};
        ele.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_position);

        // indexes
        ele.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ele.indexBuffer);
        return ele;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @returns program
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
/**
 * 地理解决方案中粒子系统
 * @type {hmap.ParticleRender}
 * @private
 */
hmap.ParticleOldRender=class{
    constructor(gl){
        this.CLASS_NAME="hmap.ParticleOldRender";
        this._id=hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this._vpMatrix = null;
        this._initToRender();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @param drawType0 绘制类型，默认为线
     * @param drawType1 绘制类型，默认为null
     * @private
     */
    draw(dataMap,uniforms) {
        if(dataMap.positions.length === 0) return;
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        gl.uniform4fv(this.locations.u_color,new Float32Array(uniforms.u_color));
        gl.uniform1fv(this.locations.u_size,new Float32Array(uniforms.u_size));
        gl.uniform1fv(this.locations.u_offsetCount,new Float32Array(uniforms.u_offsetCount));
        gl.uniform1fv(this.locations.u_ctrlOffset,new Float32Array(uniforms.u_ctrlOffset));
        gl.uniform3fv(this.locations.u_originPosition,new Float32Array(uniforms.u_originPosition));
        gl.uniform3fv(this.locations.u_gravity,new Float32Array(uniforms.u_gravity));
        gl.uniform3fv(this.locations.u_inertia,new Float32Array(uniforms.u_inertia));

        gl.bindVertexArray(this.vao);
        this._drawParticles(dataMap);
    }

    /**
     * 绘制，主要更新buffer数据
     * @param dataMap 顶点数据
     * @private
     */
    _drawParticles(dataMap) {
        let gl = this.gl;
        //更新顶点
        this._addVerBuffer(this.ele.positionBuffer, new Float32Array(dataMap.positions), true);
        this._addVerBuffer(this.ele.forceBuffer, new Float32Array(dataMap.originForce), true);
        this._addVerBuffer(this.ele.offsetIndexBuffer, new Float32Array(dataMap.offsetIndex), true);
        const count = dataMap.positions.length/3;
        gl.drawArrays(gl.POINTS, 0, count);
        gl.bindVertexArray(null);
    }


    /**
     * 初始化绘制所需，包括program、Locations、vao、buffers
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.ParticleOldShader.vsShader, hmap.shader.ParticleOldShader.fsShader);
        this.locations = hmap.shader.ParticleOldShader.getLocations(this.gl, this.program);
        this.vao = this.gl.createVertexArray();

        this.ele = this._createBuffer();

        /*this.gl.enable(this.gl.BLEND);            //允许混合
        this.gl.blendEquation( this.gl.FUNC_ADD );
        this.gl.blendFunc( this.gl.SRC_ALPHA, this.gl.ONE );                //加法混合
        this.gl.disable(this.gl.DEPTH_TEST);*/
    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let ele = {};
        ele.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_position);

        ele.forceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.forceBuffer);
        gl.vertexAttribPointer(this.locations.a_originForce, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_originForce);

        ele.offsetIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.offsetIndexBuffer);
        gl.vertexAttribPointer(this.locations.a_offsetIndex, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_offsetIndex);

        // indexes
        ele.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ele.indexBuffer);
        return ele;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @returns program
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }



};;"use strict";
hmap.renderer=hmap.renderer||{};
/**
 * @type {hmap.renderer.Renderer}
 * @private
 */
hmap.renderer.Renderer=class {
    constructor(gl,options){
        this.gl=gl;
        this.uniformPublic={};
        options=options||{};
        //添加地图单位,方便处理精度数据
        this.mapUnit=options.mapUnit?options.mapUnit:"degrees";
        //是否对地理坐标进行精度补偿,layer中默认为false
        this._isRTE=options.isRTE?options.isRTE:false;
        //是否对深度缓存进行精度补偿,layer中默认为true
        this._isLGD=options.isLGD?options.isLGD:false;
        this.isDrawFogAndLand=false;
    }
    /**
     * 添加feature
     * @param feature
     */
	addFeature(feature){
	}

    /**
     * 更新feature
     * @param feature
     */
	updateFeature(feature){
	}

    /**
     * 根据fid属性删除feature
     * @param fid
     */
	deleteFeatureByFid(fid){
	}

    /**
     * 渲染
     */
	render(){
	}
    /**
     * 设置雾化颜色
     * @param u_fogColor
     */
	setFogColor(u_fogColor){
        this.uniformPublic.u_fogColor=u_fogColor;
    }

    /**
     * 设置雾化距离
     * @param u_fogDist
     */
    setFogDist(u_fogDist){
        this.uniformPublic.u_fogDist=u_fogDist;
    }

    /**
     * 设置地图使用的模型视图投影变换矩阵
     * @param u_mvpMatrix
     */
    setVpMatrix(u_mvpMatrix){
        this.uniformPublic.u_mvpMatrix=u_mvpMatrix;
    }

    /**
     * 设置分辨率
     * @param resolution
     */
    setResolution(resolution){
    	this.resolution=resolution;
    };

    /**
     * 设置精度拆分使用的数据,包括camera,视图矩阵和投影变换矩阵
     * @param values
     */
	setRTE(values){
        this.RTE={};
        this.RTE.camera=this._splitCameraPrecision(values.camera);
        this.RTE.mvMatrix=values.mvMatrix;
        this.RTE.projMatrix=values.projMatrix;
        this.RTE.ifRTE=this._isRTE;
    }

    /**
     * 设置对数深度使用的数据
     * @param values
     */
    setLGD(values){
	    this.LGD={};
	    this.LGD.farPlaneD=values.farPlaneD*100000.0;
	    this.LGD.ifLGD=this._isLGD;
	    this.LGD.logConstant=0.00000001;
	}

	setOpacity(opacity) {
        this._opacity = opacity;
    }

    /**
     * 设置清空上下文的颜色，并清空上下文和深度缓冲
     * @param r，范围为0-1
     * @param g，范围为0-1
     * @param b，范围为0-1
     * @param a，范围为0-1，默认为0.5
     * @private
     */
	_clearCanvas(r=0.0, g=0.0, b=0.0, a=0.50){
		const gl=this.gl;
		gl.clearColor(r,g,b,a);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	}

	/**
	 * 重新设置视口大小
     * @private
	 */
	_setViewPort(gl){
		gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
	}

	/**
	 * 根据canvas调整宽和高
     * @private
	 */
	_resizeCanvasToDisplaySize(canvas,multiplier){
		multiplier=multiplier||1;
		const width=canvas.clientWidth*multiplier|0;
		const height=canvas.clientHeight*multiplier|0;
		if(canvas.width!==width || canvas.height!==height){
			canvas.width=width;
			canvas.height=height;
			return true;
		}
		return false;
	}

	/**
	 * 从canvas中获取WebGL2上下文
     * @private
	 */
	_getGL(canvas){
		let element_canvas = (typeof canvas === 'string') ? document.getElementById(canvas) : canvas;
		let gl=element_canvas.getContext("webgl2");
		if(!gl){
			return;
		}
		return gl;
	}

	/**
	 * 检查当前WebGL2上下文是否丢失
     * @private
	 */
	_isGlMissed(gl){

	}


	/*---------------------私有方法-----------------*/
    /**
     * 根据顶点数据初始化数据池
     * @param dataBook
     * @private
     */
    // _initDataBook(dataBook){
    // }

    /**
     * 更新章节，将data按照name插入章节，并检查是否更新page
     * @private
     */
    _updateChapter(cName,pData){
    }

    /**
     * 更新Page
     * @private
     */
    // _updatePage(cName){
    // }

    /**
     * 绑定VAO和Page
     * 注：以pageId为索引，来索引vao，及其对应的vbo
     * @param pageId
     * @param vaoInfo
     * @private
     */
    _bindVaoInfoAndPage(pageId,vaoInfo){
        this._vaoMap.set(pageId,vaoInfo);
    }

    /**
     * 创建一个新的vaoInfo
     * 注：包括创建顶点数组对象，并创建对应的VBOS
     * @param gl
     * @param program
     * @returns {{vao: *, vbos}}
     * @private
     */
    _createVaoInfo(gl,program){
        //创建顶点数组对象
        const vao=gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbos=program.createVBOs(gl);
        gl.bindVertexArray(null);
        return {'vao':vao,'vbos':vbos};
    }

    /**
     * 设置VAO绑定的数据
     * @param gl，渲染上下文
     * @param program，着色器程序
     * @param vbos，缓冲区对象
     * @param data，数据
     * @private
     */
    _setVaoData(gl,program,vbos,data){
        program.setGL(gl);
        program.setVBOs(vbos,data);
    }

    /**
     * 将newData中的属性合并到data中
     * @param data
     * @param newData
     * @returns {*}
     * @private
     */
    _mergeAttributes(data,newData){
        for(let i in newData){
            data[i]=newData[i];
        }
        return data;
    }

    /**
     * 判断数据是否为空
     * @param pages
     * @returns {number}，如果为空返回0，否则返回1
     * @private
     */
    _checkData(pages){
        if(pages.length===1 && pages[0].getIndexCount()===0){
            return 0;
        }else{
            return 1;
        }
    }

    /**
     * 将map转换为对象
     * @param strMap
     * @returns {object}
     * @private
     */
    _strMapToObj(strMap) {
      let obj = Object.create(null);
      for (let [k,v] of strMap) {
        obj[k] = v;
      }
      return obj;
    }

    /**
     * 从MarkerSymbol中获取icon的渲染数据，包括size、opacity、offset、textureCoord
     * @param markerSymbol
     * @param resolution
     * @returns {Promise<any>}
     * @private
     */
    _getIconAsyncData(markerSymbol,resolution){
        const me = this;
        return new Promise(function(res,rej){
            markerSymbol.getRenderData({resolution: resolution,atlasMgr:me._atlasMgr}, function (info) {
                const iconInfo={};
                //转化成着色器能用的数据
                iconInfo["a_texAttr"]=info.textureCoord;
                iconInfo["a_offsets"]=info.offset;
                iconInfo["a_color"]=info.textColor;
                iconInfo["a_bgColor"]=info.bgColor;//文字背景
                iconInfo["a_size"]=info.size;
                iconInfo["a_angle"]=info.angle;
                iconInfo["a_hasHalo"]=info.hasHalo;

                // iconInfo["a_opacity"]=info.opacity;
                //iconInfo["a_textureColor"]=info.textColor;//注意这个在原来的着色器中没传递
                res(iconInfo);
            });
        });
    }

    /**
     * 获取text的渲染数据，从TextSymbol中
     * @param textSymbol
     * @param resolution
     * @param text
     * @returns {Promise<any>}
     * @private
     */
    _getTextAsyncData(textSymbol,resolution,text){
        const me = this;
        return new Promise(function(res,rej){
            textSymbol.getRenderData({text: text, resolution: resolution,atlasMgr:me._atlasMgr}, function (info) {
                const textInfo={};
                //转化成着色器能用的数据
                textInfo["a_texAttr"]=info.textureCoord;
                textInfo["a_offsets"]=info.offset;
                textInfo["a_color"]=info.textColor;//文字颜色
                textInfo["a_bgColor"]=info.bgColor;//文字背景
                textInfo["a_size"]=info.size;
                textInfo["a_angle"]=info.angle;
                textInfo["a_hasHalo"]=info.hasHalo;
                // textInfo["a_opacity"]=info.opacity;
                textInfo["textNum"]=info.textNum;
                res(textInfo);
            });
        });
    }

    /**
     * 解析线符号
     * @param fid，线符号的fid
     * @param xyzs，坐标数组
     * @param style，样式
     * @private
     */
    _addLineXYZs(fid,xyzs,style){
        const lineSymbols=style.getLineSymbols();
        for (let i = 0, len = lineSymbols.length; i < len; i++) {
            const lineSymbol = lineSymbols[i];

            const lineStyle = lineSymbol.getLineStyle();//solid或其它
            const lineColor = lineSymbol.getColor().toNormalizeArray();
            const lineWidth = lineSymbol.getWidth();
            const isOutLine = (i === 0 && len > 1) ? true : false;
            const lineOffset = lineSymbol.getLineOffset();
            const lineCap = lineSymbol.getLineCap();
            const lineJoin = lineSymbol.getLineJoin();
            const lineMiterLimit = lineSymbol.getMiterLimit();
            const lineOffsetAngle=lineSymbol.getOffsetAngle();

            if(lineWidth>1){//处理宽线
                const lineData=this._preLineWidthData(xyzs,lineStyle==='solid');
                //补充到lineData中
                const pc=lineData.positionCount[0];
                //根据是否进行精度补偿来确定缓存的数据类型
                if(this._isRTE){
                    const arrays=this._change2RTEArray(lineData.a_position);
                    lineData['a_position']=arrays.posH;
                    lineData['a_positionL']=arrays.posL;
                }else{
                    lineData['a_positionL']=new Array(pc*3).fill(0);
                }

                lineData['fid']=[fid];
                //lineData['a_color']=new Array(pc).fill(lineColor).flat();
                lineData["a_color"]=[].concat.apply([], new Array(pc).fill(lineColor));
                lineData['a_lineWidth']=new Array(pc).fill(lineWidth);
                lineData['a_offset']=new Array(pc).fill(lineOffset);
                lineData['a_offAngle']=new Array(pc).fill(lineOffsetAngle);
                lineData['a_checked']=new Array(pc).fill(0);
                if(lineStyle==='solid'){
                    this._updateChapter("lineWidthProgram",lineData);
                }else{
                    this._updateChapter("lineWidthTextureProgram"+lineStyle,lineData);
                }
            }else{//处理细线
                const lineData=this._preLineData(xyzs,lineStyle==='solid');
                //确定数据数量
                const pc=lineData.positionCount[0];
                //根据是否进行精度补偿来确定缓存的数据类型
                if(this._isRTE){
                    const arrays=this._change2RTEArray(xyzs);
                    lineData['a_position']=arrays.posH;
                    lineData['a_positionL']=arrays.posL;
                }else{
                    lineData['a_positionL']=new Array(pc*3).fill(0);
                }

                lineData['fid']=[fid];
                //lineData['a_color']=new Array(pc).fill(lineColor).flat();
                lineData["a_color"]=[].concat.apply([], new Array(pc).fill(lineColor));
                lineData['a_lineWidth']=new Array(pc).fill(lineWidth);
                lineData['a_offset']=new Array(pc).fill(lineOffset);
                lineData['a_offAngle']=new Array(pc).fill(lineOffsetAngle);
                lineData['a_checked']=new Array(pc).fill(0);
                if(lineStyle==='solid'){
                    this._updateChapter("lineProgram",lineData);
                }else{
                    this._updateChapter("lineTextureProgram"+lineStyle,lineData);
                }
            }

        }
    }

    /**
     * 获取虚线的类型
     * @private
     */
    _getLineDashstyle(string){
        // const index=string.lastIndexOf("\-");
        return string.match(/Program(\S*)/)[1];
    }
    /**
     * 处理1px线数据
     * 注：组织index使用gl.LINES绘制（后期可优化）
     * @param xyzs，顶点数组
     * @param isSolid，是否是实线
     * @returns {Object} like:{{a_position: *, index: Array, a_lineD: number[], indexCount: *[], positionCount: *[]}}
     * @private
     */
    _preLineData(xyzs,isSolid){
        const index=[];
        const lineD=[0];

        if (isSolid) {//实线
            for(let j=0,jLen=xyzs.length/3-1;j<jLen;j++){
                index.push(j);
                index.push(j+1);
            }
        }else{//非实线
            let distance=0;
            for(let j=1,jLen=xyzs.length/3;j<jLen;j++){
                index.push(j-1);
                index.push(j);
                const cur=[xyzs[3*j],xyzs[3*j+1],xyzs[3*j+2]];
                const pre=[xyzs[3*(j-1)],xyzs[3*(j-1)+1],xyzs[3*(j-1)+2]];
                const dx = cur[0] - pre[0];
                const dy = cur[1] - pre[1];
                const dz = cur[2] - pre[2];
                distance += Math.sqrt(dx * dx + dy * dy + dz * dz);
                lineD.push(distance);
            }
        }
        //返回线索引
        return {a_position:xyzs,index:index,a_lineD:lineD,indexCount:[index.length],positionCount:[xyzs.length/3]};
    }

    /**
     * 处理Npx宽线数据
     * 注：组织index使用gl.TRANGLES绘制，外部拓宽为处理xoy平面，存在缺陷
     * @param xyzs，顶点数组
     * @param isSolid，是否是实线
     * @returns {Object} like:{{a_position: Array, index: Array, a_side: Array, a_lineD: Array, positionCount: *[], indexCount: *[]}}
     * @private
     */
    _preLineWidthData(xyzs,isSolid){
        const positions = [];
        const side = [];
        const lineD = [];
        const index=[];
        let c=0;
        if (isSolid) {//实线
            for(let i=0,len=xyzs.length/3;i<len;i++){
                //i不是第一个点也不是最后一个点，计算拐点处需要的小矩形
                if(i>0&&i<len-1){
                    //在拐点处阔成三个点
                    positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                    positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                    c+=2;
                    const delta=this._getDelta(xyzs,i);
                    const x1=delta[0],y1=delta[1];
                    side.push(-y1,x1,y1,-x1);
                    index.push(c-2,c-1,c);
                    index.push(c,c-1,c+1);
                }
                //存入第i个点对应的坐标值
                positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                c+=2;
                //拐点处三角形
                if(i<len-1){
                    const delta=this._getDelta(xyzs,i+1);
                    const x=delta[0],y=delta[1];
                    side.push(-y,x,y,-x);
                    //第一个三角形
                    index.push(c-2,c-1,c);
                    //第二个三角形
                    index.push(c,c-1,c+1);
                }else{// i==len -1 最后一个点
                    const delta=this._getDelta(xyzs,i);
                    const x2=delta[0],y2=delta[1];
                    side.push(-y2,x2,y2,-x2);
                }
            }
        }else{//非实线
            let distance=0;
            for(let i=0,len=xyzs.length/3;i<len;i++) {
                const cur=[xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]];
                //如果是第一个点就赋成第一个点
                let pre = i===0?cur:[xyzs[3*(i-1)],xyzs[3*(i-1)+1],xyzs[3*(i-1)+2]];
                //如果是最后一个点就赋成最后一个点
                let next= (i===len-1)?cur:[xyzs[3*(i+1)],xyzs[3*(i+1)+1],xyzs[3*(i+1)+2]];
                //i不是第一个点也不是最后一个点，计算拐点处需要的小矩形
                if(i>0&&i<len-1){
                    //在拐点处扩成三个点
                    positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                    positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                    c+=2;
                    const delta=this._getDelta(xyzs,i);
                    const x1=delta[0],y1=delta[1];
                    side.push(-y1,x1,y1,-x1);
                    index.push(c-2,c-1,c);
                    index.push(c,c-1,c+1);

                    const dx = cur[0] - pre[0];
                    const dy = cur[1] - pre[1];
                    const dz = cur[2] - pre[2];
                    distance += Math.sqrt(dx * dx + dy * dy + dz * dz);
                    for(let k=0;k<2;k++){
                        lineD.push(distance);
                    }
                }
                //存入第i个点对应的坐标值
                positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                positions.push(xyzs[3*i],xyzs[3*i+1],xyzs[3*i+2]);
                c+=2;
                if(i<len-1){
                    const delta=this._getDelta(xyzs,i+1);
                    const x=delta[0],y=delta[1];
                    side.push(-y,x,y,-x);
                    //第一个三角形
                    index.push(c-2,c-1,c);
                    //第二个三角形
                    index.push(c,c-1,c+1);
                }else{// i==len-1 最后一个点
                    const delta=this._getDelta(xyzs,i);
                    const x2=delta[0],y2=delta[1];
                    side.push(-y2,x2,y2,-x2);
                }
                const dx = cur[0] - pre[0];
                const dy = cur[1] - pre[1];
                const dz = cur[2] - pre[2];
                distance += Math.sqrt(dx * dx + dy * dy + dz * dz);
                for(let k=0;k<2;k++){
                    lineD.push(distance);
                }
            }
        }
        return {a_position: positions,index:index,a_side: side,a_lineD: lineD,positionCount: [positions.length/3],indexCount:[index.length]};
    }
	 /**
     * 计算偏移分量
     * @returns [x,y]
     * @private
     */
	_getDelta(xyzs,i) {
         const x = xyzs[3 * (i)] - xyzs[3 * (i - 1)],
             y = xyzs[3 * (i) + 1] - xyzs[3 * (i - 1) + 1];
         if (x !== 0 || y !== 0) {
             return [x, y]
         } else {
             const z = xyzs[3 * (i) + 2] - xyzs[3 * (i - 1) + 2];
             return [x, z]
         }
     }

    /**
     * 根据地图单位对视点坐标进行精度拆分
     * @returns {{chx: *, clx: *, chy: *, cly: *, chz: *, clz: *}}
     * @private
     */
    _splitCameraPrecision(coord){
        // const coord=this.getMap().getCamera().getCoordinate();
        const x=coord.getOrdinate("X"),y=coord.getOrdinate("Y"),z=coord.getOrdinate("Z");
        const xx=this._float32FromDouble64(x),yy=this._float32FromDouble64(y),zz=this._float32FromDouble64(z);
        const splitPrecision={
            chx:xx[0],
            clx:xx[1],
            chy:yy[0],
            cly:yy[1],
            chz:zz[0],
            clz:zz[1]
        };
        return splitPrecision;
    }

    /**
     * 根据地图单位对数据进行精度拆分
     * 使用两个 32bit 浮点数来表示一个 64bit 浮点数
     * @param num 传入的浮点型数字(layer中存在类似代码)
     * @private
     */
    _float32FromDouble64(num){

        let high=0,low=0,tempHigh=0;
        if(this.mapUnit=="degrees"){
            high=Math.floor(num);
            low=(num-high)*Math.pow(10,7);
            low=Math.floor(low);
        }else{
            if(num>0){
                tempHigh = Math.floor(num / 65536) * 65536;
                high = tempHigh;
                low = num - tempHigh;
            }else{
                tempHigh = Math.floor(-num / 65536) * 65536;
                high = -tempHigh;
                low = num + tempHigh
            }
        }
        return [high,low];
    }

    /**
     * 将数组转换为按视点精度补偿使用的数组
     * @param xyzs
     * @returns {{posH: Array, posL: Array}}
     * @private
     */
    _change2RTEArray(xyzs){
        let posH=[],posL=[];
        for(let i=0,len=xyzs.length;i<len;i=i+3){
            const x=xyzs[i],y=xyzs[i+1],z=xyzs[i+2];
            const xs=this._float32FromDouble64(x),ys=this._float32FromDouble64(y),zs=this._float32FromDouble64(z);
            posH.push(xs[0],ys[0],zs[0]);
            posL.push(xs[1],ys[1],zs[1]);
        }
        return{posH:posH,posL:posL};
    }
}
;"use strict";
hmap.renderer = hmap.renderer || {};

hmap.renderer.ObjRender = class extends hmap.renderer.Renderer {
    /**
     * @param {WebGL2RenderingContext} gl 渲染上下文
     * @param {Object} options 渲染选项
     */
    constructor(gl, options) {
        super(gl, options);
        this.CLASS_NAME = "hmap.renderer.ObjRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this._fid = this._id;
        this.gl = gl;
        this._vMatrix = null;
        this._pMatrix = null;
        this._timerId = null;
        this._isRTE = false;
        this._isLGD = false;
        this._initToRender();
        this.event=options.event;
    }

    /**
     * 初始化绘制需要的东西
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.ObjShader.vsShader, hmap.shader.ObjShader.fsShader);
        this.locations = hmap.shader.ObjShader.getLocation(this.gl, this.program);
    }

    setLightPosition(lightPosition){
        this.lightPosition = lightPosition;
    }

    setCameraPosition(cameraPosition){
        this.cameraPosition = cameraPosition;
    }

    setMatrices(modelMatrix, viewMatrix, projectionMatrix){
        this.mMatrix = modelMatrix.getElements();
        this.vMatrix = viewMatrix.getElements();
        this.pMatrix = projectionMatrix.getElements();
        this.normalMatrix = new hmap.util.Matrix4().setInverseOf(modelMatrix).transpose().getElements();
    }

    /**
     * 绘制,外部调用接口
     * @param {hmap.model.Obj} model Obj模型对象
     */
    draw(model) {
        let gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniformMatrix4fv(this.locations.mMatrixLocation, false, this.mMatrix);
        gl.uniformMatrix4fv(this.locations.vMatrixLocation, false, this.vMatrix);
        gl.uniformMatrix4fv(this.locations.pMatrixLocation, false, this.pMatrix);
        gl.uniformMatrix4fv(this.locations.normalMatrixLocation, false, this.normalMatrix);
        gl.uniform4fv(this.locations.fogColorLocation, this.uniformPublic.u_fogColor);
        gl.uniform2fv(this.locations.fogDistLocation, this.uniformPublic.u_fogDist);
        gl.uniform1f(this.locations.alpha, model.getAlpha());
        gl.uniform1f(this.locations.uOpacity, this._opacity);

        if (this._isRTE) {
            gl.uniform1i(this.locations.isRTE, 1);
            model.mesh.verticesLow = new Array(model.mesh.vertices.length);
            const invertMMatrix = new hmap.util.Matrix4(this.mMatrix).invert();
            // 相机坐标精度拆分
            const cameraPositionHigh = [];
            const cameraPositionLow = [];
            const cameraPositionVec = new hmap.util.Vector3(...this.cameraPosition);
            const cameraModelPositionVec = invertMMatrix.multiplyVector3(cameraPositionVec);
            for (const coord of cameraModelPositionVec.getElements()) {
                const [high, low] = this._float32FromDouble64(coord);
                cameraPositionHigh.push(high);
                cameraPositionLow.push(low);
            }
            gl.uniform3fv(this.locations.cameraPositionLocation, cameraPositionHigh);
            gl.uniform3fv(this.locations.cameraPositionLocationLow, cameraPositionLow);

            // 光照坐标精度拆分
            const lightPositionHigh = [];
            const lightPositionLow = [];
            const lightPositionVec = new hmap.util.Vector3(...this.lightPosition);
            const lightModelPositionVec = invertMMatrix.multiplyVector3(lightPositionVec);
            for (const coord of lightModelPositionVec.getElements()) {
                const [high, low] = this._float32FromDouble64(coord);
                lightPositionHigh.push(high);
                lightPositionLow.push(low);
            }
            gl.uniform3fv(this.locations.lightPosition, lightPositionHigh);
            gl.uniform3fv(this.locations.lightPositionLow, lightPositionLow);
        } else {
            gl.uniform1i(this.locations.isRTE, 0);
            gl.uniform3fv(this.locations.cameraPositionLocation, this.cameraPosition);
            gl.uniform3fv(this.locations.lightPosition, this.lightPosition);
        }
        if (this._isLGD) {
            //添加LGD
            this.gl.uniform1i(this.locations.isLGD, 1);
            this.gl.uniform1f(this.locations.uFarPlaneD, this.LGD.farPlaneD);
            this.gl.uniform1f(this.locations.uLogConstant, this.LGD.logConstant);
        } else {
            this.gl.uniform1i(this.locations.isLGD, 0);
        }

        this.createVAO(model);
        gl.useProgram(this.program);
        const vaoInfo = model.mesh.vao;
        gl.bindVertexArray(vaoInfo.vao);
        if (!model.mesh.indicesPerMaterial) {
            this._drawObjectMaterial(vaoInfo, model.mesh.materialsByIndex[0], 0, vaoInfo.numItem);
        } else {
            let start = 0;
            const len = model.mesh.indices.length;
            for (let i = 0; i < len; i++) {
                if (model.mesh.indices[i].length === 0)
                    continue;
                const material = model.mesh.materialsByIndex[i];
                this._drawObjectMaterial(vaoInfo, material, start, model.mesh.indices[i].length);
                start += model.mesh.indices[i].length;
            }
        }
        gl.bindVertexArray(null);

        this.event.dispatch(new hmap.event.Event(EventType.VECTOR_MODELDRAWEND)); // TODO:绘制结束事件
    }

    createVAO(model) {
        if (!model.mesh.vao) {
            let gl = this.gl;
            let vao = this.gl.createVertexArray();
            gl.bindVertexArray(vao);
            this._createBuffer();
            this._initBuffers(model);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.mesh.vertexBuffer);
            this.program.applyAttributePointers(model);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.mesh.indexBuffer);
            //const =dataMap.mesh.indexBuffer.numItems;
            model.mesh.vao = {numItem: model.mesh.indexBuffer.numItems, vao: vao};
            gl.bindVertexArray(null);
        }
    }

    _drawObjectMaterial(vaoInfo, material, start, length) {
        const gl = this.gl;
        const activeTextureGenerator = this._activeTextureGenerator();
        this._useMapTexure(vaoInfo, material, "Ambient", activeTextureGenerator);
        this._useMapTexure(vaoInfo, material, "Diffuse", activeTextureGenerator);
        this._useMapTexure(vaoInfo, material, "Specular", activeTextureGenerator);
        gl.drawElements(gl.TRIANGLES, length, gl.UNSIGNED_INT, start * 4);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    }

    _useMapTexure(vaoInfo, material, mapType, activeTextureGenerator) {
        const light = material[`map${mapType}`];
        const useMapLocation = this.gl.getUniformLocation(this.program, `uUseMap${mapType}`);
        if (!light || !light.texture) {
            this.gl.uniform1i(useMapLocation, 0);
            return;
        }
        const texture = light.texture;
        this.gl.uniform1i(useMapLocation, 1);
        const textureName = `map${mapType}Texture`;
        vaoInfo[textureName] = this._bindTexture(vaoInfo[textureName], texture, `uMap${mapType}Sampler`, activeTextureGenerator);
    }

    _bindTexture(texture, img, samplerUniformName, activeTextureGenerator) {
        if (!texture) {
            texture = this._initTexture(img);
        }
        const u_sampler = this.gl.getUniformLocation(this.program, samplerUniformName);
        const i = activeTextureGenerator.next();
        this.gl.uniform1i(u_sampler, i.value);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        return texture;
    }

    * _activeTextureGenerator() {
        const maxTextures = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        for (let i = 0; i < maxTextures; i++) {
            this.gl.activeTexture(this.gl.TEXTURE0 + i);
            yield i;
            i = i == maxTextures - 1 ? -1 : i;
        }
    }

    /**
     * 根据地图单位单位对数据进行精度拆分
     * 个使用两个 32bit 浮点数来表示一个 64bit 浮点数
     * @private
     * @param num 传入的浮点型数字(迁移到renderer中处理)
     */
    _float32FromDouble64(num, numBitBias = 0, lowerBitBias = 23) {
        let high, low;
        const offsetNum = num << numBitBias;
        high = Math.floor(offsetNum);
        low = (offsetNum - high) << lowerBitBias;
        // low=Math.floor(low);
        return [high, low];
    }

    _initBuffers(model) {
        const gl = this.gl;
        const attributes = [
            hmap.format.obj.Layout.POSITION,
            hmap.format.obj.Layout.NORMAL,
            hmap.format.obj.Layout.DIFFUSE,
            hmap.format.obj.Layout.AMBIENT,
            hmap.format.obj.Layout.UV,
            hmap.format.obj.Layout.SPECULAR,
            hmap.format.obj.Layout.SPECULAR_EXPONENT,
            hmap.format.obj.Layout.DISSOLVE
        ];
        if (this._isRTE) {
            attributes.push(hmap.format.obj.Layout.POSITION_LOW);
            // 坐标精度拆分
            for (let i = 0; i < model.mesh.vertices.length; i++) {
                const [high, low] = this._float32FromDouble64(model.mesh.vertices[i]);
                model.mesh.vertices[i] = high;
                model.mesh.verticesLow[i] = low;
            }
        }
        let layout = new hmap.format.obj.Layout(...attributes);

        // Create the vertex buffer for this mesh
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        const vertexData = model.mesh.makeBufferData(layout);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        vertexBuffer.numItems = vertexData.numItems;
        vertexBuffer.layout = layout;
        model.mesh.vertexBuffer = vertexBuffer;

        //create textureCoordbuffer
        const textureBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        const textureData = new Uint32Array(model.mesh.textures);
        gl.bufferData(gl.ARRAY_BUFFER, textureData, gl.STATIC_DRAW);
        //textureBuffer.numItems = vertexData.numItems;
        textureBuffer.layout = layout;
        model.mesh.textureBuffer = textureBuffer;

        // Create the index buffer for this mesh
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        const indexData = model.mesh.makeIndexBufferData();
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
        indexBuffer.numItems = indexData.numItems;
        model.mesh.indexBuffer = indexBuffer;
    }

    /**
     * 内部初始化buffer接口,创建buffer并关联开启索引地址
     * 因有些属性没有添加,创建buffer的代码注释掉了
     * @returns {{}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        const attrs = {
            aVertexPosition: hmap.format.obj.Layout.POSITION.key,
            // aVertexPositionL: hmap.format.obj.Layout.POSITION_LOW.key,
            aVertexNormal: hmap.format.obj.Layout.NORMAL.key,
            aTextureCoord: hmap.format.obj.Layout.UV.key,
            aDiffuse: hmap.format.obj.Layout.DIFFUSE.key,
            aSpecular: hmap.format.obj.Layout.SPECULAR.key,
            aAmbient: hmap.format.obj.Layout.AMBIENT.key,
            aSpecularExponent: hmap.format.obj.Layout.SPECULAR_EXPONENT.key,
            aDissolve: hmap.format.obj.Layout.DISSOLVE.key
        };

        const shaderProgram = this.program;
        shaderProgram.attrIndices = {};
        for (const attrName in attrs) {
            if (!attrs.hasOwnProperty(attrName)) {
                continue;
            }
            shaderProgram.attrIndices[attrName] = gl.getAttribLocation(shaderProgram, attrName);
            if (shaderProgram.attrIndices[attrName] !== -1) {
                gl.enableVertexAttribArray(shaderProgram.attrIndices[attrName]);
            } else {
                console.warn(
                    'Shader attribute "' +
                    attrName +
                    '" not found in shader. Is it undeclared or unused in the shader code?'
                );
            }
        }

        shaderProgram.applyAttributePointers = function (model) {
            const layout = model.mesh.vertexBuffer.layout;
            for (const attrName in attrs) {
                if (!attrs.hasOwnProperty(attrName) || shaderProgram.attrIndices[attrName] === -1) {
                    continue;
                }
                const layoutKey = attrs[attrName];
                if (shaderProgram.attrIndices[attrName] !== -1) {
                    const attr = layout[layoutKey];
                    gl.vertexAttribPointer(
                        shaderProgram.attrIndices[attrName],
                        attr.size,
                        gl[attr.type],
                        attr.normalized,
                        attr.stride,
                        attr.offset
                    );
                }
            }
        };
    }

    _initTexture(img) {
        //配置纹理------------套路
        let texture = this.gl.createTexture();
        //对纹理图像进行Y轴反转
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 1);
        //绑定纹理单元
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        //配置纹理参数
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
        //为当前纹理配置图像
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        return texture;
    }

    // /**
    //  * 使用纹理接口
    //  * @param gl
    //  * @param texture
    //  * @private
    //  */
    // _glTexture(gl, texture) {
    //     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    //     gl.bindTexture(gl.TEXTURE_2D, texture);
    //     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    //     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    //     gl.generateMipmap(gl.TEXTURE_2D);
    //     gl.bindTexture(gl.TEXTURE_2D, null);
    // }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};
;"use strict";
hmap.renderer = hmap.renderer || {};
/**
 * 渲染FBX模型
 * @type {hmap.renderer.FbxRender}
 * @extends hmap.renderer.Renderer
 */
hmap.renderer.FbxRender = class extends hmap.renderer.Renderer {
    /**
     * @param {WebGL2RenderingContext} gl 渲染上下文
     * @param {Object} options 渲染选项
     */
    constructor(gl, options) {
        super(gl,options);
        this.CLASS_NAME = "hmap.renderer.FbxRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.program = new hmap.program.FbxProgram(gl);
        this.models = new Map();
        this.modelTextureMap = new Map();//key=Mid,value=Map(imgsrc,texture)
        this.modelMaterialMap = new Map();//key=Mid,value=Map(name,material)
        this.owner = options.layer;
    }

    addFbxModel(model){
        return model.promise.then(function(){
            const meshMap = new Map();//存储一个model中所有的mesh
            const mId = model.getMid();
            if(!this.modelTextureMap.has(mId)) this.modelTextureMap.set(mId,new Map());
            if(!this.modelMaterialMap.has(mId)) this.modelMaterialMap.set(mId,new Map());
            const materialData = this.modelMaterialMap.get(mId);//材质库
            const textureMap = this.modelTextureMap.get(mId);//纹理库

            // 遍历mesh
            for(let i=0,len=model.modelData.length;i<len;i++){
                const mesh = model.modelData[i];
                const meshGeoData = new Map();
                
                const a_position = Array.from(mesh.geometry.get("position").item);
                let a_color=[];
                if(!mesh.geometry.get("color")){
                    for(let i=0,len=a_position.length/3;i<len;i++){
                        a_color.push(...model.color);
                    }
                }else{
                    a_color = Array.from(mesh.geometry.get("color").item);
                }
                const a_normal = Array.from(mesh.geometry.get("normal").item);
                const a_texCoord = mesh.geometry.get("uv")?Array.from(mesh.geometry.get("uv").item):[];//纹理坐标
                const u_pmatrix = mesh.matrixWorld.multiply(mesh.matrix);//一个mesh一个矩阵
                const u_useTexture = (a_texCoord.length>0)?true:false;

                // 遍历group
                if(mesh.material instanceof Array){

                    mesh.geometry.group.map(function(item){
                        const group={};
                        group.a_position = a_position.slice(item.start*3,(item.start+item.count)*3);
                        group.a_normal = a_normal.slice(item.start*3,(item.start+item.count)*3);
                        group.a_color = a_color.slice(item.start*3,(item.start+item.count)*3);
                        group.a_texCoord = a_texCoord.slice(item.start*2,(item.start+item.count)*2);
                        group.positionCount = item.count;

                        //存储材质信息
                        const materialName = this.dealMaterial(mesh.material[item.materialIndex],u_useTexture,materialData,textureMap);

                        //存mesh的几何信息
                        if(!meshGeoData.get(materialName)){
                            meshGeoData.set(materialName,group);
                        }else{
                            const newGroup = this.mergeGroup(meshGeoData.get(materialName),group);//合并group
                            meshGeoData.set(materialName,newGroup);
                        }
                    }.bind(this));

                }else{
                    let group={};
                    group.a_position = a_position;
                    group.a_normal = a_normal;
                    group.a_color = a_color;
                    group.a_texCoord = a_texCoord;
                    group.positionCount = a_position.length/3;

                    //存储材质信息
                    const materialName = this.dealMaterial(mesh.material,u_useTexture,materialData,textureMap);

                    //存mesh的几何信息
                    if(!meshGeoData.get(materialName)){
                        meshGeoData.set(materialName,group);
                    }else{
                        const newGroup = this.mergeGroup(meshGeoData.get(materialName),group);//合并group
                        meshGeoData.set(materialName,newGroup);
                    }
                }
                // 生成vao
                this.setVaoDatas(meshGeoData);
                // mesh的公共信息
                // meshGeoData.u_allMMatrix = new hmap.util.Matrix4();
                // meshGeoData.u_allMMatrix.multiply(model.modelMatrix);
                // meshGeoData.u_allMMatrix.multiply(u_pmatrix);

                // meshGeoData.u_normalMatrix = new hmap.util.Matrix4();
                // meshGeoData.u_normalMatrix.setInverseOf(meshGeoData.u_allMMatrix);
                // meshGeoData.u_normalMatrix.transpose();

                meshGeoData.u_pmatrix = u_pmatrix;
                
                // 存储mesh
                meshMap.set(mesh.ID,meshGeoData);
            }//for_end
            
            // model的属性设置
            meshMap.uniforms = {
                modelMatrix:model.modelMatrix,
                useEmissive:model.useEmissive,
                useAmbient:model.useAmbient,

                usePointDiffuse:model.usePointDiffuse,
                lightPosition:model.lightPosition,

                useDirectDiffuse:model.useDirectDiffuse,
                lightDirection:model.lightDirection,
                useSpecular:model.useSpecular,

                u_opacityFactor:model.opacityFactor
            };

            this.models.set(model.getMid(),meshMap);
        }.bind(this));
    }
    mergeGroup(oldGroup,newGroup){
        const group = {};
        group.a_position = oldGroup.a_position.concat(newGroup.a_position);
        group.a_normal = oldGroup.a_normal.concat(newGroup.a_normal);
        group.a_color = oldGroup.a_color.concat(newGroup.a_color);
        group.a_texCoord = oldGroup.a_texCoord.concat(newGroup.a_texCoord);
        group.positionCount = oldGroup.positionCount + newGroup.positionCount;
        return group;
    }

    dealMaterial(material,u_useTexture,materialData,textureMap){

        if(!materialData.get(material.name)){//材质不存在

            let data = {};
            // 整理
            // light
            data.emissive = material.light.getEmissive();
            data.ambient = material.light.getAmbient();
            data.diffuse = material.light.getDiffuse();
            data.specular = material.light.getSpecular();
            data.shininess = material.light.getShininess(),
            // opacity
            data.opacity = material.opacity;
            // imgSrc、u_useTexture
            if(material.map&&u_useTexture){//贴纹理
                data.u_useTexture=true;
                material.map.loadPromise.then(function(){
                    let imgSrc = material.map.image.src;
                    data.imgSrc = imgSrc;// 标记
                    if(!textureMap.get(imgSrc)){//纹理不存在
                        // 创建
                        let glTexture = this.createTexture(material.map);
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl[material.map.format], this.gl[material.map.format], this.gl[material.map.type], material.map.image);
                        // 添加
                        textureMap.set(imgSrc,glTexture);
                        // 重绘
                        this.render();
                    }
                }.bind(this));
            }else{//不贴纹理
                data.imgSrc = null;
                data.u_useTexture=false;
            }
            // 存
            materialData.set(material.name,data);
        }//材质不存在_end
        return material.name;
    }

    createTexture(textureData,unit=0) {
        let texture = this.gl.createTexture();
        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);

        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 1);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl[textureData.wrapS]);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl[textureData.wrapT]);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl[textureData.minFilter]);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl[textureData.magFilter]);
        return texture;
    }

    setVaoDatas(meshGeoData){
        for(let group of meshGeoData.values()){
            this.setVaoData(group);
        }
    }

    setVaoData(group){
        if(this._isRTE){
            const arrays=this._change2RTEArray(group.a_position);
            group['a_position']=arrays.posH;
            group['a_positionL']=arrays.posL;
        }else{
            group['a_positionL']=new Array(group.positionCount*3).fill(0);
        }
        let info = this._createVaoInfo(this.gl,this.program);
        this.program.setVBOs(info.vbos,group);
        for(let name in info.vbos){
            this.program.deleteVBO(info.vbos[name]);
            info.vbos[name] = null;
        }

        group["vao"]=info.vao;
        group["a_position"]='';
        group["a_positionL"]='';
        group["a_normal"]='';
        group["a_color"]='';
        group["a_texCoord"]='';
    }

    removeModelById(mId){
        const meshMap = this.models.get(mId);
        if(!meshMap){return;}
        // mesh
        for(let [meshId,mesh] of meshMap){
            for(let [materialName,group] of mesh){
                this.program.deleteVAO(group.vao);//vao
                for(const e in group){delete group[e];}//group
            }
            mesh.clear();
            for(const e in mesh){delete mesh[e];}
        }
        meshMap.clear();
        for(const e in meshMap){delete meshMap[e];}

        // 纹理
        const textureMap = this.modelTextureMap.get(mId);
        for(let [imgSrc,texture] of textureMap){
            this.gl.deleteTexture(texture);
        }
        textureMap.clear();
        
        // material
        const materialData = this.modelMaterialMap.get(mId);
        for(let [name,material] of materialData){
            for(const e in material){delete material[e];}
        }
        materialData.clear();

        this.models.delete(mId);
    }

    removeAllModels(){
        for(let mId of this.models.keys()){
            this.removeModelById(mId);
        }
    }

    render(){
        this.program.useProgram();
        this.program.setPublicUniforms({
                u_mvMatrix: this.RTE.mvMatrix,
                u_projMatrix: this.RTE.projMatrix,
                u_ifRTE: this.RTE.ifRTE,
                u_camera: this.RTE.camera,

                u_farPlaneD: this.LGD.farPlaneD,
                u_ifLGD: this.LGD.ifLGD,
                u_logConstant: this.LGD.logConstant,
                eyePosition:[0.0,0.0,0.0],
                u_opacity: this._opacity,
        });
        this.models.forEach(function(meshMap,modelId){

            const materialData = this.modelMaterialMap.get(modelId);
            const textureMap = this.modelTextureMap.get(modelId);
            
            this.program.setModelLightUniforms(meshMap.uniforms);//model

            meshMap.forEach(function(meshGeoData,meshId){
                meshGeoData.u_allMMatrix = new hmap.util.Matrix4();
                meshGeoData.u_allMMatrix.multiply(meshMap.uniforms.modelMatrix);
                meshGeoData.u_allMMatrix.multiply(meshGeoData.u_pmatrix);

                meshGeoData.u_normalMatrix = new hmap.util.Matrix4();
                meshGeoData.u_normalMatrix.setInverseOf(meshGeoData.u_allMMatrix);
                meshGeoData.u_normalMatrix.transpose();

                this.program.setMeshPublic(meshGeoData);//mesh

                meshGeoData.forEach(function(group,materialName){
                    const material = materialData.get(materialName);
                    material.u_sampler = 0;
                    this.program.setGroupUniform(material);//group

                    this.gl.bindTexture(this.gl.TEXTURE_2D, textureMap.get(material.imgSrc));
                    this.gl.bindVertexArray(group.vao);
                    this.program.draw(group.positionCount);
                    this.gl.bindVertexArray(null);
                }.bind(this));

            }.bind(this));

        }.bind(this));
    }



}
;"use strict";
/**
 * 地理解决方案中流光图层使用
 * @type {hmap.FlowLightRender}
 * @private
 */
hmap.FlowLightRender=class{
    constructor(gl,posSize) {
        this.CLASS_NAME = "hmap.FlowLightRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.gl = gl;
        this._vpMatrix = null;
        this._posSize=posSize;
        this._initToRender();
    }

    /**
     * 绘制调用总方法
     * @param dataMap 数据
     * @param uniforms uniforms变量
     * @private
     */
    draw(dataMap,uniforms) {
        if(dataMap.positions.length === 0) return;
        const gl = this.gl;
        //设置全局量
        gl.useProgram(this.program);
        gl.uniform1i(this.locations.u_ifRTE,uniforms.u_ifRTE);
        gl.uniformMatrix4fv(this.locations.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        gl.uniformMatrix4fv(this.locations.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        const camera=uniforms.u_camera;
        gl.uniform3fv(this.locations.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        gl.uniform3fv(this.locations.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        gl.bindVertexArray(this.vao);
        this._draw(dataMap);
    }

    /**
     * 绘制符号方法，主要更新buffer数据
     * @param dataMap 顶点数据
     * @private
     */
    _draw(dataMap) {
        let gl = this.gl;
        //更新顶点
        this._addVerBuffer(this.ele.positionBuffer, new Float32Array(dataMap.positions), true);
        this._addVerBuffer(this.ele.colorBuffer, new Float32Array(dataMap.colors), true);
        const count = dataMap.indices.length;       //dataMap.indices.length
        //更新索引
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ele.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(dataMap.indices), gl.STATIC_DRAW);
        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
    }


    /**
     * 初始化绘制所需，包括program、Locations、vao、buffers
     * @private
     */
    _initToRender() {
        this.program = this._createProgram(hmap.shader.FlowLightShader.vsShader, hmap.shader.FlowLightShader.fsShader);
        this.locations = hmap.shader.FlowLightShader.getLocations(this.gl, this.program);
        this.vao = this.gl.createVertexArray();
        this.ele = this._createBuffer();
    }

    /**
     * 创建buffer
     * @returns {{buffers}}
     * @private
     */
    _createBuffer() {
        let gl = this.gl;
        gl.bindVertexArray(this.vao);
        let FSIZE=4,pSize=this._posSize;
        let ele = {};
        ele.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.positionBuffer);
        gl.vertexAttribPointer(this.locations.a_positionH, 3, gl.FLOAT, false, pSize*FSIZE, 0);
        gl.enableVertexAttribArray(this.locations.a_positionH);
        gl.vertexAttribPointer(this.locations.a_positionL, 3, gl.FLOAT, false, pSize*FSIZE, (pSize-3)*FSIZE);
        gl.enableVertexAttribArray(this.locations.a_positionL);

        //颜色
        ele.colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ele.colorBuffer);
        gl.vertexAttribPointer(this.locations.a_color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.locations.a_color);

        // indexes
        ele.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ele.indexBuffer);
        return ele;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, dynamic = false) {
        let gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 创建program
     * @param vs
     * @param fs
     * @returns program
     * @private
     */
    _createProgram(vs, fs) {
        let gl = this.gl;
        const shaderMap = this._initShader(vs, fs);
        const vsShader = shaderMap.get("vsShader");
        const fsShader = shaderMap.get("fsShader");
        const program = gl.createProgram();
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = gl.getProgramInfoLog(program);
            throw "Could not compile WebGL program. \n\n" + info;
        }
        return program;
    }

    /**
     * 初始化着色器
     * @param vs
     * @param fs
     * @returns Map()
     * @private
     */
    _initShader(vs, fs) {
        let gl = this.gl;
        const vsShader = this._compileShader(vs, gl.VERTEX_SHADER);
        const fsShader = this._compileShader(fs, gl.FRAGMENT_SHADER);
        const shaderMap = new Map();
        shaderMap.set("vsShader", vsShader).set("fsShader", fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器
     * @param shaderSrc
     * @param shaderType
     * @returns {shader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        let gl = this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw "Could not compile WebGL shader. \n\n" + info;
        }
        return shader;
    }
};;"use strict";
hmap.renderer = hmap.renderer || {};
hmap.renderer.GLTFRender = class {
    constructor(gl, options) {
        this.CLASS_NAME = "hmap.renderer.GLTFRender";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);//自动生成
        this.gl = gl;
        this.gltfMap = new Map();
        this.modelMap = new Map();
        this.shaderSouces = new Map();
        this.program = new hmap.program.GLTFProgram(this.gl);
        this.uniforms = {};
        this._flag = {textureCount: 0, promises: []};
        this._IsRender=new Map();
    }

    setVPMatrix(vpMatrix) {
        this.uniforms.vpMatrix = vpMatrix;
    };

    setOpacity(opacity) {
        this.uniforms.opacity = opacity;
    }

    // /**
    //  * 添加由hgis.gltf.GLTF解析出来的gltf文件（json），并进行绘制初始化
    //  * @param promise
    //  * @param modelMatrix
    //  */
    // addGLTF(promise,modelMatrix){
    //
    //     this._flag.add=true;
    //     this._flag.end=false;
    //     this._flag.promises.push(promise);
    //     promise.then((gltf)=>{
    //         this.gltfMap.set(gltf._id,gltf);
    //         this.modelMap.set(gltf._id,modelMatrix);
    //         gltf.nodes=gltf.nodes.map((n)=>{
    //             for(const drawable of n.drawables){
    //                 const primitives=drawable.getPrimitives();
    //                 for(let i=0,len=primitives.length;i<len;i++){
    //                     const primitive=primitives[i];
    //                     primitive.drawInfo=this._createWebGLBuffer(primitive.bufferInfo);
    //                 }
    //             }
    //             return n;
    //         });
    //         this._flag.add=false;
    //         this._flag.end=true;
    //     })
    //
    // }


    /**
     * 添加gltf解析出的文件，同时给需绘制图元创建缓冲区等
     * @param gltf
     * @param modelMatrix
     */
    addGLTF(gltf, modelMatrix,layerOctree) {
        this.gltfMap.set(gltf._id, gltf);
        this._IsRender.set(gltf._id,true);
        this.modelMap.set(gltf._id, modelMatrix);
        let me = this;
        this._flag.promises.push(...gltf.images);

        gltf.nodes = gltf.nodes.map((n) => {
            for (const drawable of n.drawables) {
                const primitives = drawable.getPrimitives();
                for (let i = 0, len = primitives.length; i < len; i++) {
                    const primitive = primitives[i];
                    primitive.drawInfo = this._createWebGLBuffer(primitive.bufferInfo);
                    primitive.drawTex=null;
                    if (primitive.material.textures) {
                        me._flag.textureCount++;
                        // primitive.material.isTex=false;
                        Promise.all(gltf.images).then(function () {
                            primitive.drawTex=me._createTextures(primitive.material.textures);
                            // primitive.material.isTex=true;
                            me._flag.textureCount--;
                        });
                    }
                }
            }
            if(n.drawables.length>0&&n.drawables[0].getPrimitives().length>0) {
                const min = n.drawables[0].getPrimitives()[0].bufferInfo.attribs.a_position.min;
                const max = n.drawables[0].getPrimitives()[0].bufferInfo.attribs.a_position.max;
                n._bbox = this._calculateBBox(min, max, modelMatrix);
                n._id=gltf._id;
                if(layerOctree){
                    layerOctree.put(n);
                }
            }
            return n;
        });
    }

    _calculateBBox(min,max,modelMatrix) {
        //思路：min和max是对应方向上的最小最大值，这里组合为八个顶点
        let xyzs = [];
        xyzs.push(min[0], min[1], min[2],
            min[0], max[1], min[2],
            max[0], min[1], min[2],
            max[0], max[1], min[2],
            min[0], min[1], max[2],
            min[0], max[1], max[2],
            max[0], min[1], max[2],
            max[0], max[1], max[2]);
        let xMin = Number.POSITIVE_INFINITY,
            yMin = Number.POSITIVE_INFINITY,
            zMin = Number.POSITIVE_INFINITY,
            xMax = Number.NEGATIVE_INFINITY,
            yMax = Number.NEGATIVE_INFINITY,
            zMax = Number.NEGATIVE_INFINITY;
        for (let i = 0, len = xyzs.length; i < len; i += 3) {
            let vector = modelMatrix.multiplyVector4(new hmap.util.Vector4(xyzs[i], xyzs[i + 1], xyzs[i + 2], 1));
            let value1 = vector.getElement(0),
                value2 = vector.getElement(1),
                value3 = vector.getElement(2);
            if (xMin > value1) xMin = value1; else if (xMax < value1) xMax = value1;
            if (yMin > value2) yMin = value2; else if (yMax < value2) yMax = value2;
            if (zMin > value3) zMin = value3; else if (zMax < value3) zMax = value3;
        }
        return new hmap.basetype.BBox(xMin, yMin, zMin, xMax, yMax, zMax);
    }

    _createTextures(textures) {
        // const webglTexArray=[];//后期支持多个纹理的形式，当前只支持单张纹理
        // let tex;
        // for (const [name, value] of Object.entries(textures)) {
        //     tex=this._createTextureFromArray(value.texture.imgArrayBuffer, value.texCoord);
        // }
        // return tex;
        const colorTexture=textures.colorTexture;
        return this._createTextureFromArray(colorTexture.texture.imgArrayBuffer,colorTexture.texCoord);

    }

    _createTextureFromArray(imgArrayBuffer, uint = 0, opts = {}) {
        let texture = this.gl.createTexture();
        this.gl.activeTexture(this.gl.TEXTURE0 + uint);
        this.gl.bindTexture(opts.target || this.gl.TEXTURE_2D, texture);
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imgArrayBuffer);
        this.gl.generateMipmap(this.gl.TEXTURE_2D);
        this.gl.bindTexture(opts.target||this.gl.TEXTURE_2D,null);
        return texture;
    }

    _createWebGLBuffer(bufferInfo) {
        const {attribs, indices} = bufferInfo;
        let webglBuffersArr=[];
        let vao = this.gl.createVertexArray();
        this.gl.bindVertexArray(vao);
        for (const [name, value] of Object.entries(attribs)) {
            if (this.program.attributes[name] === undefined) continue;
            let glBuffer;
            if (!value.buffer.webglBuffer) {
                glBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(value.buffer.target || this.gl.ARRAY_BUFFER, glBuffer);
                this.gl.bufferData(value.buffer.target || this.gl.ARRAY_BUFFER, value.buffer.data, this.gl.STATIC_DRAW);
                value.buffer.webglBuffer = glBuffer;
                webglBuffersArr.push(value.buffer.webglBuffer);
            } else {
                glBuffer = value.buffer.webglBuffer;
                this.gl.bindBuffer(value.buffer.target || this.gl.ARRAY_BUFFER, glBuffer);
            }

            this.gl.enableVertexAttribArray(this.program.attributes[name]);
            this.gl.vertexAttribPointer(this.program.attributes[name], value.numComponents, value.type, false, value.stride, value.offset);
        }
        if (indices) {
            let inBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(indices.target || this.gl.ELEMENT_ARRAY_BUFFER, inBuffer);
            this.gl.bufferData(indices.target || this.gl.ELEMENT_ARRAY_BUFFER, indices.data, this.gl.STATIC_DRAW);
            webglBuffersArr.push(inBuffer);
        }
        this.gl.bindVertexArray(null);
        return {vao:vao,
                webglBuffersArr:webglBuffersArr};
    }

    _deleteWebGLBufferAndTexture(id){
        let gltf= this.gltfMap.get(id);
        gltf.nodes = gltf.nodes.map((n) => {
            for (const drawable of n.drawables) {
                const primitives = drawable.getPrimitives();
                for (let i = 0, len = primitives.length; i < len; i++) {
                    const primitive = primitives[i];
                    primitive.drawInfo = this._deleteWebGLBufferAndVao(primitive.drawInfo);
                    primitive.drawTex=this._deleteTexture(primitive.drawTex);
                }
            }
            return n;
        });
    }

    _deleteWebGLBufferAndVao(drawInfo){
        let webglBuffers=drawInfo.webglBuffersArr;
        for(let i=0,len=webglBuffers.length;i<len;i++){
            this.gl.deleteBuffer(webglBuffers[i]);
        }

        this.gl.deleteVertexArray(drawInfo.vao||null);
        // drawInfo.vao=null;
        return drawInfo;
    }

    _deleteTexture(drawTex){
        //暂时按一个处理，后期会转换为数组
        this.gl.deleteTexture(drawTex||null);
        return null;
    }

    render() {
        this.program.useProgram();
        let me = this;
        me._render();
        if (this._flag.textureCount !== 0) {
            return Promise.all(me._flag.promises).then(function () {
                me._render();
            });
        }
    }


    _render() {
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.flush();
        for (const id of this.gltfMap.keys()) {
            if(this._IsRender.get(id)){
                const modelMatrix = this.modelMap.get(id);
                const gltf = this.gltfMap.get(id);
                this._renderScenes(gltf, modelMatrix);
            }
        }
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.flush();
    }

    _renderDrawables(node) {
        for (const drawable of node.drawables) {
            this._renderPrimitive(node, drawable);
        }
    }

    _renderScenes(gltf, matrix) {
        for (const scene of gltf.scenes) {
            scene.root.updateWorldMatrix(matrix);
            scene.root.traverse(this._renderDrawables.bind(this));
        }
    }

    _renderPrimitive(node, drawable) {
        const {mesh} = drawable;
        this.program.useProgram();
        for (const primitive of mesh.primitives) {
            this.gl.bindVertexArray(primitive.drawInfo.vao);
            this.gl.bindTexture(this.gl.TEXTURE_2D,primitive.drawTex);
            this.program.setPrivateUniforms({
                u_vpMatrix: this.uniforms.vpMatrix.getElements(),
                u_worldMatrix: node.worldMatrix.getElements(),
                u_lightDirection: [0.5, -0.5, 0.5],
                u_color: primitive.material.colorFactor,
                u_ifTex: primitive.material.isTex,
                u_tex: 0,
                opacity: this.uniforms.opacity,
            });
            if(primitive.indices!==undefined){
                this.gl.drawElements(primitive.mode || 4, primitive.bufferInfo.numElements, primitive.bufferInfo.elementType, primitive.bufferInfo.byteOffset||0);
            }else{
                this.gl.drawArrays(primitive.mode||4,0,primitive.bufferInfo.numElements);
            }

            this.gl.bindVertexArray(null);
        }
    }
};
;"use strict";
hmap.renderer = hmap.renderer || {};
/**
 * @type {hmap.renderer.S3MTileRenderer}
 * @private
 */
hmap.renderer.S3MTileRenderer = class {

    constructor(gl, options) {
        this.CLASS_NAME = "hmap.renderer.S3MTileRenderer";
        this._id = hmap.util.Aid.createUnique(this.CLASS_NAME);
        this.gl = gl;
        this.curScreenTiles = [];                   //当前屏幕内的切片
        this._tileToDraw = new Map();               //将要绘制的切片

        this.rootCache = new Map();                //根节点默认全部缓存
        this.tileCache = new Map();                //切片缓存
        this.capacity = 300;                       //缓存容量
        this.tileNameQuene = [];                   //数组，保存切片的缓存顺序

        this._drawInfos = new Map();               //绘制的object数组;//drawInfo={vao:,material:,tileMatrix:,indexInfo:,vertexCount:,buffers:[]}
        this._drawInfosNoShow = new Map();
    }

    /**
     *  初始化program，在layer中调用
     *  @private
     */
    _initProgram(vs,fs) {
        const gl = this.gl;
        this._program = new hmap.program.S3MProgram(gl,vs,fs);
    }

    /**
     * 将解析之后的tile的数据写入vao
     * @param {Array} tileObjArray 通过解析之后的tile的数据
     */
    createDrawData(tileObjArray,tileName) {
        const me = this;
        tileObjArray.forEach(tileObj => {
            me._createBuffer(tileObj,tileName);
        });
    }

    /**
     *  需要缓存，但是不需要显示
     */
    addToNoShow(tileName){
        this._drawInfosNoShow.set(tileName,true);
    }
    /**
     * 添加到将要绘制的列表
     */
    addToDrawList(tileName){
        let rootCache = this.rootCache.get(tileName),
            tileCache = this.tileCache.get(tileName);
        this._drawInfos.set(tileName, rootCache || tileCache);
    }

    hasInDrawList(tileName){
        this._drawInfos.has(tileName);
    }

    /**
     *  切片是否存在于缓存中
     */
    hasCache(tileName){
        return  (this.hasRootCached(tileName) || this.hasTileCached(tileName));
    }

    /**
     * 添加到将要绘制的列表
     */
    removeFromDrawList(tileName){
        this._drawInfos.delete(tileName);
    }

    /**
     * 清空绘制的map
     */
    clearDrawInfos(){
        this._drawInfos.clear();
        this._drawInfosNoShow.clear();
    }

    /**
     * 根节点是否已经缓存
     */
    hasRootCached(tileName){
        return this.rootCache.has(tileName);
    }

    /**
     * 添加根节点缓存，根节点默认全部缓存
     */
    addRootCache(tileName){
        let tileDrawInfo = this._drawInfos.get(tileName);
        if(tileDrawInfo){
            this.rootCache.set(tileName,tileDrawInfo);
        }
    }

    /**
     * 切片是否已经缓存
     */
    hasTileCached(tileName){
        return this.tileCache.has(tileName);
    }

    /**
     * 将切片加入到缓存，同时检查切片缓存是否超过容量
     * @private
     * */
    addTileCache(tile){
        let tileName = tile._tileName,
            tileDrawInfo = this._drawInfos.get(tileName);
        if(tileDrawInfo){
            this.tileCache.set(tileName,tileDrawInfo);
            this.tileNameQuene.push(tileName);
        }
    }

    draw(uniforms,currZoom) {
        //this.gl.disable(this.gl.DEPTH_TEST);
        if(!this._program) return;
        if(currZoom >= 19){
            this.gl.disable(this.gl.CULL_FACE);
        }else{
            this.gl.enable(this.gl.CULL_FACE);
        }
        this._program.useProgram();
        this.gl.uniformMatrix4fv(this._program.uniforms.uProjMatrix,false,uniforms.uProjMatrix.getElements());
        this.gl.uniformMatrix4fv(this._program.uniforms.uViewMatrix,false,uniforms.uViewMatrix.getElements());
        for(let [key,drawInfos] of this._drawInfos){
            //for(let i=0,len=this._drawInfos.length;i<len;i++){
            if(drawInfos && drawInfos.length !== 0 && !this._drawInfosNoShow.get(key)){          //不在非显示列表之列
                for(let drawInfo of drawInfos){
                    uniforms.u_modelMatrix=drawInfo.tileMatrix;
                    this.gl.bindVertexArray(drawInfo.vao);
                    if(drawInfo.material!==null){
                        for(let i=0,len=drawInfo.material.textures.length;i<len;i++){
                            const tex=drawInfo.material.textures[i];
                            tex.enable(this.gl);
                            uniforms["u_texWidth"+i]=tex._info.width||256;
                        }
                    }
                    this._program.setPrivateUniforms(uniforms);
                    if(drawInfo.indexInfo!==null){
                        this.gl.drawElements(drawInfo.indexInfo.primitiveType,drawInfo.indexInfo.count,drawInfo.indexInfo.indexType,0);
                    }else{
                        this.gl.drawArrays(this.gl.POINTS,0,drawInfo.vertexCount);
                    }
                    this.gl.bindVertexArray(null);
                    if(drawInfo.material!==null){
                        for(let i=0,len=drawInfo.material.textures.length;i<len;i++){
                            const tex=drawInfo.material.textures[i];
                            tex.disable(this.gl);
                        }
                    }
                }
            }
        }
    }

    /**
     * 创建buffer、绑定到目标、将缓冲区分配给着色器的变量并激活变量
     * @returns {Object}
     * @private
     */
    _createBuffer(tileObj,tileName) {
        const gl = this.gl;
        let drawInfo={buffers:[]};//绘制使用的信息
        const vao = gl.createVertexArray();
        drawInfo.vao=vao;
        gl.bindVertexArray(vao);
        const vertexPackage = tileObj.vertexPackage;
        vertexPackage.vertexColor=null;//未用到的颜色数据，暂时置空
        drawInfo.vertexCount = vertexPackage.verticesCount;
        const vertexAttr = vertexPackage.attrLocation;
        const attriLocations=this._program.getAttributeLocations();
        const vertexAttributes = vertexPackage.vertexAttributes; //具体的逐顶点数据
        drawInfo.tileMatrix=tileObj.tileMatrix;
        //处理属性值
        for(const [name,location] of Object.entries(attriLocations)){
            const tempBuffer=gl.createBuffer();
            const tempData=vertexAttributes[vertexAttr[name]];
            const type=tempData.componentDatatype;
            const vertices = tempData.typedArray;
            gl.bindBuffer(gl.ARRAY_BUFFER, tempBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.vertexAttribPointer(location, tempData.componentsPerAttribute, type, tempData.normalize, tempData.strideInBytes, tempData.offsetInBytes);
            gl.enableVertexAttribArray(location);
            drawInfo.buffers.push(tempBuffer);
            tempData.typedArray = null;
        }

        //处理材质
        drawInfo.material=null;
        if(tileObj.material) {
            let material={};
            material.ambientColor=tileObj.material.ambientColor||null;
            material.diffuseColor=tileObj.material.diffuseColor||null;
            material.textures=[];
            for(let i=0,len=tileObj.material.textures.length;i<len;i++){
                let textureObj=tileObj.material.textures[i];
                let texture = new hmap.format.s3m.DDSTexture(textureObj.textureCode,textureObj.textureInfo);
                if(texture._texture===null){
                    texture.createCompressTexture(this.gl);
                    texture._info.imageBuffer = [];
                }
                material.textures.push(texture);
            }
            drawInfo.material=material;
        }
        //处理索引（未知内部索引全部应用，先处理第一个索引）
        drawInfo.indexInfo=null;
        if(tileObj.arrIndexPackage.length>0){
            let indices=tileObj.arrIndexPackage[0];//不知数据结构何意，暂时按0进行处理
            const indexBuffer=gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices.indicesTypedArray,gl.STATIC_DRAW);
            drawInfo.indexInfo={
                count:indices.indicesCount,
                primitiveType:indices.primitiveType,
                indexType:indices.indexType===1||vertexPackage.verticesCount>=64 * 1024?0x1405:0x1403
            };
            tileObj.arrIndexPackage[0].indicesTypedArray=null;
        }
        if(tileObj.arrIndexPackage.length > 1){
            for(let i=0;i<tileObj.arrIndexPackage.length;i++){
                tileObj.arrIndexPackage[i].indicesTypedArray=null;
            }
        }
        if(!this._drawInfos.get(tileName)){
            this._drawInfos.set(tileName,[]);
        }
        this._drawInfos.get(tileName).push(drawInfo);
        gl.bindVertexArray(null);
    }


    _deleteDrawInfo(fileName){
        let drawInfos=this._drawInfos.get(fileName);
        if(drawInfos){
            for(let drawInfo of drawInfos){
                this.gl.deleteVertexArray(drawInfo.vao);
                for(let i=0,len=drawInfo.buffers.length;i<len;i++){
                    this.gl.deleteBuffer(drawInfo.buffers[i]);
                }
                //以下代码为销毁纹理，根据测试存在多个tile共用一张纹理的情况，注释掉
                if(drawInfo.material!==null){
                    for(let i=0,len=drawInfo.material.textures.length;i<len;i++){
                        const tex=drawInfo.material.textures[i];
                        tex.destroy(this.gl);
                    }
                }
                this._drawInfos.delete(fileName);
                drawInfo=null;
            }
        }
    }

    _deleteDrawInfo_bak(fileName){
        let ind=this._indexMap.indexOf(fileName);
        if(ind===-1){
            return null;
        }else{
            let drawInfo=this._drawInfos[i];
            this.gl.deleteVertexArray(drawInfo.vao);
            for(let i=0,len=drawInfo.buffers.length;i<len;i++){
                this.gl.deleteBuffer(drawInfo.buffers[i]);
            }
            //以下代码为销毁纹理，根据测试存在多个tile共用一张纹理的情况，注释掉
            // if(drawInfo.material!==null){
            //     for(let i=0,len=drawInfo.material.textures.length;i<len;i++){
            //         const tex=drawInfo.material.textures[i];
            //         tex.destroy(this.gl);
            //     }
            // }
            this._drawInfos.splice(ind,1);
            this._indexMap.spilce(ind,1);
            drawInfo=null;
        }
    }
};;"use strict";
hmap.program=hmap.program||{};
/**
 * 绘制使用程序，基类
 * @type {hmap.program.Program}
 * @private
 */
hmap.program.Program=class {
    constructor(gl,vs,fs){
        if(!gl){
            throw "webgl context must not be null!";
        }
        this.gl=gl;
        this.vs=vs;
        this.fs=fs;
        this.program=this._createProgram(vs,fs);
        this.attributes=this._getAttributes();
        this.uniforms=this._getUniforms();
        this.attributesLayout=null;//在子类中实现
        this.uniformsLayout=null;//在子类中实现
        this.mode=null;//在子类中指定
    }

    /**
     * 单次绘制
     * @param data，buffer使用数据
     * @param img，图片。暂时没有使用
     */
    drawOnce(data,img){
        const gl=this.gl;
        //创建vbo
        const vbos=this.createVBOs(gl);
        //给vbo绑定数据
        this.setVBOs(vbos,data);
        //执行绘制
        this.draw(data.index.length);
    }

    /**
     * 使用该着色器程序
     */
    useProgram(){
        this.gl.useProgram(this.program);
    }

    /**
     * 结束着色器程序的使用
     */
    unUseProgram(){
        this.gl.useProgram(null);
    }

    /**
     * 设置上下文
     * @param gl
     */
    setGL(gl){
        this.gl=gl;
    }

    /**
     * 绘制调用,具体在子类中实现
     * @param drawInfo,绘制需要使用的信息，当前只是count
     */
    draw(drawInfo){}

    /**
     * 设置启用写入深度缓冲
     * @param flag {Boolean} 默认为true,即写入缓冲状态
     */
    setDepthMask(flag=true){
        this.gl.depthMask(flag);
    }

    /**
     * 设置颜色是否可以写入颜色缓冲
     * @param r {Boolean}
     * @param g {Boolean}
     * @param b {Boolean}
     * @param a {Boolean}
     */
    setColorMask(r,g,b,a){
        this.gl.colorMask(r,g,b,a);
    }

    /**
     * 设置渲染上下文的深度测试
     * @param enable {"enable"|"disable"} 是否开启深度测试,默认开启
     * @param pattern {num} 深度测试的参数,深度测试开启状态有效.默认less通过测试
     * 0:less 通过; 1:小于等于通过; 2:等于通过; 3:不等于通过; 4:大于等于通过;
     * 5:大于通过; 6:总是通过; 7:不通过
     */
    setDepthTest(enable="enable",pattern=null){
        const gl = this.gl;
        gl[enable](gl.DEPTH_TEST);
        switch(pattern){
            case 0:
                gl.depthFunc(gl.LESS);
                break;
            case 1:
                gl.depthFunc(gl.LEQUAL);
                break;
            case 2:
                gl.depthFunc(gl.EQUAL);
                break;
            case 3:
                gl.depthFunc(gl.NOTEQUAL);
                break;
            case 4:
                gl.depthFunc(gl.GEQUAL);
                break;
            case 5:
                gl.depthFunc(gl.GREATER);
                break;
            case 6:
                gl.depthFunc(gl.ALWAYS);
                break;
            case 7:
                gl.depthFunc(gl.NEVER);
                break;
            default:
                gl.depthFunc(gl.LESS);
                break;
        }
    }

    /**
     * 设置颜色混合
     * @param enable {"enable"|"disable"} 是否开启颜色混合,默认开启
     * @param pattern {num} 颜色混合参数,颜色混合开启状态有效.默认按透明度比例混合
     * 0:使用透明度混合; 2:焰火特效混合???
     */
    setColorBlend(enable="enable",pattern=null){
        const gl = this.gl;
        gl[enable](gl.BLEND);
        switch(pattern){
            case 0:
                gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                break;
            case 1:
                gl.blendFunc(gl.SRC_ALPHA,gl.ONE);
                break;
            default:
                gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                break;
        }
    }

    /**
     * 设置剔除操作
     * @param enable {"enable"|"disable"} 是否开启剔除操作,默认开启
     * @param pattern {num} 剔除参数,剔除开启有效;默认剔除顺时针
     */
    setCullFace(enable="enable",pattern=null){
        const gl = this.gl;
        gl[enable](gl.CULL_FACE);
        switch(pattern){
            case 0:
                gl.fontFace(gl.CCW);
                break;
            case 1:
                gl.fontFace(gl.CW);
                break;
            default:
                gl.fontFace(gl.CCW);
                break;
        }
    }

    /**
     * 设置多边形偏移
     * @param enable {"enable"|"disable"}, 是否开启多边形偏移,默认不开启
     * @param params {Array} 二维数组,多边形偏移参数,默认为[0.0,0.0]
     */
    setPolyOffset(enable="disable",params=[0,0]){
        this.gl[enable](this.gl.POLYGON_OFFSET_FILL);
        this.gl.polygonOffset(params[0]||0.0,params[1]||0.0);
    }

    /**
     * 设置视口大小
     * @param x {number},绘图区域起始位置像素距左下角宽度
     * @param y {number},绘图区域起始位置像素距左下角高度
     * @param width {number},绘图区域像素宽度
     * @param height {number},绘图区域像素高度
     */
    setViewport(x,y,width,height){
        const clientWidth=this.gl.clientWidth,clientHeight=this.gl.clientHeight;

        this.gl.viewport(x||0,y||0,width||clientWidth,height||clientHeight);
    }

    getAttributeLocations(){
        return this.attributes;
    }

    getUniformLocations(){
        return this.uniforms;
    }
    /**
     * 创建VBOs
     * @returns {{}}
     */
    createVBOs(){
        const gl=this.gl;
        const layout=this.attributesLayout;
        const vbos={};
        for(let attrName in layout){
            if(attrName==='index'){
                vbos['index'] = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,vbos.index);
            }else{
                vbos[attrName]=gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vbos[attrName]);
                gl.vertexAttribPointer(layout[attrName].location, layout[attrName].count, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(layout[attrName].location);
            }
        }
        return vbos;
    }

    /**
     * 添加VBOS数据
     * @param vbos
     * @param data
     * @param dynamic
     */
    setVBOs(vbos,data,dynamic=false){
        const layout=this.attributesLayout;
        for(let bufferName in vbos){
            //排除为空的情况
            if(!data[bufferName] || data[bufferName].length===0){
                continue;
            }
            this.setVBO(bufferName, vbos[bufferName], new layout[bufferName].type(data[bufferName]), dynamic);
        }
    }

    /**
     * 删除顶点缓冲区对象
     */
    deleteVBO(vbo){
        //if(this.gl.isBuffer(vbo)){// it is a waste time operation
        this.gl.deleteBuffer(vbo);
        //}
    }

    /**
     * 删除顶点对象
     */
    deleteVAO(vao){
        this.gl.deleteVertexArray(vao);      //删除vertex array
    }

    /**
     * 创建帧缓冲（未完成）
     * @param width {number} 帧缓冲的宽度,像素值
     * @param height {number} 帧缓冲的高度,像素值
     */
    createFramebuffer(width,height){

    }

    /**
     * 设置帧缓冲（未完成）
     */
    setFramebuffer(){}

    /**
     * 删除帧缓冲
     * @param framebuffer {WebGLFramebuffer} 帧缓冲对象
     */
    deleteFramebuffer(framebuffer){
        if(!this.gl.isFramebuffer(framebuffer))throw "parameter must be WebGLFramebuffer!";
        this.gl.deleteFramebuffer(framebuffer);
    }

    /**
     * 创建渲染缓冲（未完成）
     */
    createRenderbuffer(){}

    /**
     * 设置渲染缓冲（未完成）
     */
    setRenderbuffer(){}

    /**
     * 删除渲染缓冲
     * @param renderbuffer
     */
    deleteRenderbuffer(renderbuffer){
        if(!this.gl.isRenderbuffer(renderbuffer))throw "parameter must be WebGLRenderbuffer!";
        this.gl.deleteRenderbuffer(renderbuffer);
    }

    /**
     * 设置公用的uniform变量
     * @param uniforms
     */
    setPublicUniforms(u_mvpMatrix,u_fogColor,u_fogDist){
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix, false, u_mvpMatrix.getElements());
        this.gl.uniform4fv(this.uniforms.u_fogColor,u_fogColor);
        this.gl.uniform2fv(this.uniforms.u_fogDist,u_fogDist);
    }

    /**
     * 设置私有的uniform变量
     * @param uniforms uniforms的值
     */
    setPrivateUniforms(uniforms){}

    /**
     * 获取buffer的字节数
     * @param arrayBuffer
     * @param target {"ARRAY_BUFFER"|"ELEMENT_ARRAY_BUFFER"},默认为"ARRAY_BUFFER"
     */
    getBufferBytes(arrayBuffer,target){
        const gl = this.gl;
        if(!gl.isBuffer(arrayBuffer)) throw "parameter must be WebGLBuffer!";
        gl.bind(gl[target]||gl.ARRAY_BUFFER,arrayBuffer);
        return gl.getBufferParameter(gl[target]||gl.ARRAY_BUFFER, gl.BUFFER_SIZE);
    }

    /**
     * 获取buffer的使用方式
     * @param arrayBuffer
     * @param target {"ARRAY_BUFFER"|"ELEMENT_ARRAY_BUFFER"},默认为"ARRAY_BUFFER"
     */
    getBufferUsage(arrayBuffer,target){
        const gl = this.gl;
        if(!gl.isBuffer(arrayBuffer)) throw "parameter must be WebGLBuffer!";
        gl.bind(gl[target]||gl.ARRAY_BUFFER,arrayBuffer);
        return gl.getBufferParameter(gl[target]||gl.ARRAY_BUFFER, gl.BUFFER_USAGE);
    }

    /**
     * 获取着色器程序中的uniform变量
     * @private
     */
    _getUniforms(){
        const gl=this.gl,program=this.program;
        let uniformLocations={};
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const uniform = gl.getActiveUniform(program, i);
            if (uniform) {
                uniformLocations[uniform.name] = gl.getUniformLocation(program, uniform.name);
            }
        }
        return uniformLocations;
    }

    /**
     * 获取着色器程序中的顶点属性
     * @private
     */
    _getAttributes(){
        const gl=this.gl,program=this.program;
        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        let attributes={};
        for (let i = 0; i < numAttributes; i++) {
            const attribute = gl.getActiveAttrib(program, i);
            if (attribute) {
                attributes[attribute.name] = gl.getAttribLocation(program, attribute.name);
            }
        }
        return attributes;
    }

    /**
     * 向顶点buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addVerBuffer(buffer, array, dynamic) {
        const gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新buffer数据接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组,或者buffer数据
     * @param offset,偏移长度,默认为0,即全部替换
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upVerBuffer(buffer, array, offset=0,dynamic = false) {
        const gl = this.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 向索引buffer中填充数据
     * @param buffer,填充数据的顶点缓冲区
     * @param array,顶点缓冲区使用的类型化数组
     * @param dynamic,是否是更新的模式
     * @private
     */
    _addEleBuffer(buffer, array, dynamic) {
        const gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);
        } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }

    /**
     * 内部更新索引buffer接口
     * @param buffer,需要更新数据的顶点缓冲区
     * @param array,更新缓冲区使用的类型化数组,或者buffer数据
     * @param offset,偏移长度,默认为0,即全部替换
     * @param dynamic,当前缓冲区的使用模式
     * @private
     */
    _upEleBuffer(buffer, array, offset=0,dynamic = false) {
        const gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        if (dynamic) {
            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, array);
        } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
        }
    }


    /**
     * 添加图片纹理
     * @param img
     * @param unit
     * @param wrapS
     * @param wrapT
     * @returns {{texture: WebGLTexture, unit: *}}
     */
    addGLTexture(img,unit,wrapS="CLAMP_TO_EDGE",wrapT="CLAMP_TO_EDGE"){
        const gl=this.gl;
        let texture=gl.createTexture();
        gl.activeTexture(gl.TEXTURE0+unit);
        gl.bindTexture(gl.TEXTURE_2D,texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        // gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        if(!img){
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));
            return{texture:texture,unit:unit};
        }
        gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);//这里最慢，待改进
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[wrapS]);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[wrapT]);
        // gl.generateMipmap(gl.TEXTURE_2D);
        return{texture:texture,unit:unit};
    }

    /**
     * 设定立方体纹理的操作
     * @param images
     * @param params
     * @private
     */
    _glCubeTexture(images,params){}

    /**
     * 创建着色器程序
     * @param vs
     * @param fs
     * @return program {WebGLProgram}
     * @private
     */
    _createProgram(vs,fs){
        const gl=this.gl;
        const shaderMap=this._initShaders(vs,fs);
        const vsShader=shaderMap.get("vsShader"),fsShader=shaderMap.get("fsShader");
        let program = gl.createProgram();
        // Attach pre-existing shaders
        gl.attachShader(program, vsShader);
        gl.attachShader(program, fsShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            let info = this.gl.getProgramInfoLog(program);
            throw 'Could not compile WebGL program. \n\n' + info;
        }
        return program;
    }


    /**
     * 初始化着色器程序
     * @param vs
     * @param fs
     * @return {Map} {"vsShader":vsShader;"fsShader":fsShader}
     * @private
     */
    _initShaders(vs,fs){
        const gl=this.gl;
        const vsShader=this._compileShader(vs,gl.VERTEX_SHADER);
        const fsShader=this._compileShader(fs,gl.FRAGMENT_SHADER);
        const shaderMap=new Map();
        shaderMap.set("vsShader",vsShader).set("fsShader",fsShader);
        return shaderMap;
    }

    /**
     * 编译着色器代码
     * @param shaderSrc
     * @param shaderType
     * @return shader {WebGLShader}
     * @private
     */
    _compileShader(shaderSrc, shaderType) {
        const gl=this.gl;
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
            let info = gl.getShaderInfoLog(shader);
            throw new Error(info);
        }
        return shader;
    }

    /**
     * 向特定VBO中写入数据
     * @param {String} bufferName 当值为index时，写入到ELEMENT_ARRAY_BUFFER中，其他值则写入ARRAY_BUFFER中
     * @param {Object} vbo webgl的WebGlBuffer
     * @param {ArrayBuffer|null} data 类型化数组，当传入null值时，会使之前该缓冲区里的数据失效，释放GPU显存空间
     * @param {Boolean} dynamic 是否是更新的模式
     */
    setVBO(bufferName, vbo, data, dynamic=false){
        if(bufferName === 'index'){
            this._addEleBuffer(vbo ,data, dynamic);
        }else{
            this._addVerBuffer(vbo, data, dynamic);
        }
    }
};
;"use strict";
hmap.program=hmap.program||{};
/**
 * 颜色填充多边形渲染程序
 * @type {hmap.program.PolyColorProgram}
 * @private
 */
hmap.program.PolyColorProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.polyColor.vsD;
        const fs=hmap.shader.polyColor.fs;
        super(gl,vs,fs);
        this.attributesLayout=this._organizeAttributesLayout();
        this.mode=gl.TRIANGLES;
    }

    /**
     * 组织顶点属性信息，另包括索引
     * @returns {{a_position: {name: string, location: *, count: number, type: Float32ArrayConstructor}, a_positionL: {name: string, location: *, count: number, type: Float32ArrayConstructor}, a_color: {name: string, location: *, count: number, type: Float32ArrayConstructor}, a_checked: {name: string, location: *, count: number, type: Float32ArrayConstructor}, index: {name: string, location: number, count: number, type: Uint32ArrayConstructor}}}
     * @private
     */
    _organizeAttributesLayout(){
        return {
            a_position:  {name:"a_position",  location:this.attributes["a_position"],  count:3,  type:Float32Array},
            a_positionL:{name:"a_positionL",location:this.attributes["a_positionL"],count:3,type:Float32Array},
            a_color:     {name:"a_color",     location:this.attributes["a_color"],     count:4,  type:Float32Array},
            a_checked:   {name:"a_checked",   location:this.attributes["a_checked"],   count:1,  type:Float32Array},

            //额外添加的
            index:       {name:"index",       location:-1,                             count:1,  type:Uint32Array },
        };
    }

    /**
     * 设置私有统一变量
     * 注：后期共有统一变量可进行提取，或修改传输模式
     * @param uniforms uniforms的变量值，提取键值和变量命名相同
     */
    setPrivateUniforms(uniforms){
        //u_ifRTE,u_mvMatrix,u_projMatrix,u_camera
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);

        //添加LGD,u_farPlaneD,u_ifLGD,u_logConstant
        this.gl.uniform1f(this.uniforms.u_farPlaneD,uniforms.u_farPlaneD);
        this.gl.uniform1i(this.uniforms.u_ifLGD,uniforms.u_ifLGD);
        this.gl.uniform1f(this.uniforms.u_logConstant,uniforms.u_logConstant);
        this.gl.uniform1f(this.uniforms.u_opacity, uniforms.u_opacity);
    }

    /**
     * 绘制
     * @param indexCount
     */
    draw(indexCount){
        const gl=this.gl;
        const mode=gl.TRIANGLES;
        const count=indexCount;
        const style=gl.UNSIGNED_INT;
        //const style=gl.UNSIGNED_SHORT
        const offset=0;
        gl.drawElements(mode,count,style,offset);
    }
};
;"use strict";
hmap.program=hmap.program||{};
/**
 * FBX模型渲染程序
 * @type {hmap.program.FbxProgram}
 * @private
 */
hmap.program.FbxProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.FbxShader.vs;
        const fs=hmap.shader.FbxShader.fs;
        super(gl,vs,fs);
        this.attributesLayout=this._organizeAttributesLayout();
        this.mode=gl.TRIANGLES;
    }

    /**
     * 组织顶点属性信息，另包括索引
     * @private
     */
    _organizeAttributesLayout(){
        return {
            a_position:  {name:"a_position",  location:this.attributes["a_position"],  count:3,  type:Float32Array},
            a_positionL: {name:"a_positionL", location:this.attributes["a_positionL"],  count:3,  type:Float32Array},
            a_color:     {name:"a_color",     location:this.attributes["a_color"],  count:3,  type:Float32Array},
            a_normal:    {name:"a_normal",    location:this.attributes["a_normal"],    count:3,  type:Float32Array},
            a_texCoord:  {name:"a_texCoord",  location:this.attributes["a_texCoord"],  count:2,  type:Float32Array},
        };
    }


    draw(vertexNum){
        this.gl.drawArrays(this.mode, 0, vertexNum);
    }

    setPublicUniforms(uniforms){
        // 视图和投影矩阵
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());

        // 坐标精度
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        this.gl.uniform1f(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        // 深度精度
        this.gl.uniform1f(this.uniforms.u_farPlaneD,uniforms.u_farPlaneD);
        this.gl.uniform1i(this.uniforms.u_ifLGD,uniforms.u_ifLGD);
        this.gl.uniform1f(this.uniforms.u_logConstant,uniforms.u_logConstant);

        this.gl.uniform3fv(this.uniforms.eyePosition,uniforms.eyePosition);
        this.gl.uniform1f(this.uniforms.u_opacity,uniforms.u_opacity);

    }

    setGroupUniform(uniforms){
        // this.gl.uniformMatrix4fv(this.uniforms.u_normalMatrix, false, uniforms.u_normalMatrix.getElements());
        // this.gl.uniformMatrix4fv(this.uniforms.u_allMMatrix, false, uniforms.u_allMMatrix.getElements());

        this.gl.uniform3fv(this.uniforms.emissive,uniforms.emissive);
        this.gl.uniform3fv(this.uniforms.ambient,uniforms.ambient);

        this.gl.uniform3fv(this.uniforms.diffuse,uniforms.diffuse);

        this.gl.uniform3fv(this.uniforms.specular,uniforms.specular);
        this.gl.uniform1f(this.uniforms.shininess,uniforms.shininess);

        this.gl.uniform1f(this.uniforms.opacity,uniforms.opacity);
        
        // 纹理
        this.gl.uniform1i(this.uniforms.u_sampler, uniforms.u_sampler);
        this.gl.uniform1f(this.uniforms.u_useTexture,uniforms.u_useTexture);
    }

    // 设置模型中设置的光照的参数
    setModelLightUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.useEmissive,uniforms.useEmissive);
        this.gl.uniform1f(this.uniforms.useAmbient,uniforms.useAmbient);

        this.gl.uniform1f(this.uniforms.usePointDiffuse,uniforms.usePointDiffuse);
        this.gl.uniform3fv(this.uniforms.lightPosition,uniforms.lightPosition);

        this.gl.uniform1f(this.uniforms.useDirectDiffuse,uniforms.useDirectDiffuse);
        this.gl.uniform3fv(this.uniforms.lightDirection,uniforms.lightDirection);

        this.gl.uniform1f(this.uniforms.useSpecular,uniforms.useSpecular);

        this.gl.uniform1f(this.uniforms.u_opacityFactor, uniforms.u_opacityFactor);
    }

    setMeshPublic(uniforms){
        this.gl.uniformMatrix4fv(this.uniforms.u_normalMatrix, false, uniforms.u_normalMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_allMMatrix, false, uniforms.u_allMMatrix.getElements());
    }

}
;"use strict";
hmap.program=hmap.program||{};
hmap.program.GLTFProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.GLTFShader.vsShader;
        const fs=hmap.shader.GLTFShader.fsShader;
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        this.gl.uniformMatrix4fv(this.uniforms.u_vpMatrix,false,uniforms.u_vpMatrix);
        this.gl.uniformMatrix4fv(this.uniforms.u_worldMatrix,false,uniforms.u_worldMatrix);
        this.gl.uniform4fv(this.uniforms.u_color,uniforms.u_color);
        this.gl.uniform3fv(this.uniforms.u_lightDirection,uniforms.u_lightDirection);
        this.gl.uniform1i(this.uniforms.u_ifTex,uniforms.u_ifTex);
        this.gl.uniform1f(this.uniforms.u_opacity,uniforms.opacity);
    }
};
;"use strict";
hmap.program = hmap.program || {};
/**
 *点云渲染程序
 * @type {hmap.program.PointCloudProgram}
 * @private
 */
hmap.program.PointCloudProgram = class extends hmap.program.Program {
    constructor(gl, isCircle = false) {
        const vs = hmap.shader.pointcloud.vs;
        let fs = hmap.shader.pointcloud.fs;
        if (isCircle) {
            fs = hmap.shader.pointcloud.fs_circle;
        }
        super(gl, vs, fs);
        this.attributesLayout = this._organizeAttributesLayout();
        this.mode = gl.POINTS;
    }

    /**
     * 组织顶点属性信息
     * @returns {JSON}
     * @private
     */
    _organizeAttributesLayout() {
        return {
            a_position: {name: "a_position", location: this.attributes["a_position"], count: 3, type: Float32Array},
            a_color: {name: "a_color", location: this.attributes["a_color"], count: 4, type: Float32Array}
        };
    }

    active() {
        this.gl.useProgram(this.program);
        return this;
    }

    setPublicUniforms(uniforms) {
        const location = this.uniforms;
        this.gl.uniformMatrix4fv(location.u_vpMatrix, false, uniforms.u_vpMatrix);
        this.gl.uniform1f(location.u_size, uniforms.u_size);
    }

    draw(blocks) {
        for (let i = 0, len = blocks.length; i < len; i++) {
            const block = blocks[i];
            if (block.buffer === null) continue;
            const vao = block.buffer.vao;
            this.gl.bindVertexArray(vao);
            this.gl.drawArrays(this.gl.POINTS, 0, block.count);
            this.gl.bindVertexArray(null);
        }
        return this;
    }

    deleteVBOS(blocks) {
        for (let i = 0, len = blocks.length; i < len; i++) {
            const block = blocks[i];
            if (!block.buffer) continue;
            this.deleteVBO(block.buffer.vbos.a_position);
            this.deleteVBO(block.buffer.vbos.a_color);
            this.gl.bindVertexArray(null);
            this.deleteVAO(block.buffer.vao);
            block.buffer = null;
        }
    }

    createVAO() {
        const locations = this.attributesLayout;
        const vao = this.gl.createVertexArray();
        this.gl.bindVertexArray(vao);

        //a_position
        let position = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, position);
        this.gl.vertexAttribPointer(locations.a_position.location, 3, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(locations.a_position.location);

        //a_color
        let color = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, color);
        this.gl.vertexAttribPointer(locations.a_color.location, 4, this.gl.FLOAT, false, 0, 0);
        this.gl.enableVertexAttribArray(locations.a_color.location);

        this.gl.bindVertexArray(null);
        return {
            vao: vao,
            vbos: {
                a_position: position,
                a_color: color
            }
        };
    }

};"use strict";
hmap.program=hmap.program||{};
hmap.program.S3MProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        this.gl.uniformMatrix4fv(this.uniforms.uModel,false,uniforms.u_modelMatrix);
        if(this.uniforms.uTexture){
            this.gl.uniform1i(this.uniforms.uTexture,0);
            this.gl.uniform1f(this.uniforms.uTextureWidth,uniforms.u_texWidth0);
        }
        if(this.uniforms.uTexture2){
            this.gl.uniform1i(this.uniforms.uTexture2,1);
            this.gl.uniform1f(this.uniforms.uTexture2Width,uniforms.u_texWidth1);
        }
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.BarProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        this.gl.uniform1i(this.uniforms.u_ifLiner,uniforms.u_ifLiner);
        this.gl.uniform1f(this.uniforms.u_size,uniforms.u_size);
        this.gl.uniform1f(this.uniforms.u_height,uniforms.u_height);
        this.gl.uniform1f(this.uniforms.u_maxValue,uniforms.u_maxValue);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix,false,uniforms.u_vpMatrix.getElements());
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.EleWallProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量，未进行精度补偿形式
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        this.gl.uniform1f(this.uniforms.u_height,uniforms.u_height);
        this.gl.uniform1f(this.uniforms.u_distLast,uniforms.u_distLast);
        this.gl.uniform1f(this.uniforms.u_time,uniforms.u_time);
        this.gl.uniform4fv(this.uniforms.u_animParam,uniforms.u_animParam);
        this.gl.uniform4fv(this.uniforms.u_color0,uniforms.u_color0);
        this.gl.uniform4fv(this.uniforms.u_color1,uniforms.u_color1);
        this.gl.uniform1i(this.uniforms.u_tex,0);
        this.gl.uniform1i(this.uniforms.u_ifTex,uniforms.u_ifTex);
        this.gl.uniform1f(this.uniforms.u_repeat,uniforms.u_repeat);
        // this.gl.uniformMatrix4fv(this.uniforms.u_vpMatrix,false,uniforms.u_vpMatrix.getElements());

        //RTE
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.FilledCircleProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.FilledCircleShader.vsShader;
        const fs=hmap.shader.FilledCircleShader.fsShader;
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_time,uniforms.u_time);
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        //u_ifRTE,u_mvMatrix,u_projMatrix,u_camera
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        this.gl.uniform1f(this.uniforms.u_res,uniforms.u_res[0]);
        this.gl.uniform1f(this.uniforms.u_resL,uniforms.u_res[1]);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.HeatmapProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    setTextureUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        this.gl.uniform1f(this.uniforms.u_size,uniforms.u_size);
        this.gl.uniform1f(this.uniforms.u_maxValue,uniforms.u_maxValue);
        this.gl.uniform1f(this.uniforms.u_minValue,uniforms.u_minValue);
        //u_ifRTE,u_mvMatrix,u_projMatrix,u_camera
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
        this.gl.uniform1f(this.uniforms.u_res,uniforms.u_res[0]);
        this.gl.uniform1f(this.uniforms.u_resL,uniforms.u_res[1]);
    }
    setRenderUniforms(uniforms){
        // this.gl.uniform1i(this.uniforms.u_texture,0);
        // this.gl.uniform1i(this.uniforms.u_colorTexture,1);
        this.gl.uniform4fv(this.uniforms.u_fogColor,uniforms.u_fogColor);
        this.gl.uniform2fv(this.uniforms.u_fogDist,uniforms.u_fogDist);
    }
    setColorUniforms(uniforms){}
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.PieProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.PieShader.vsShader;
        const fs=hmap.shader.PieShader.fsShader;
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        this.gl.uniformMatrix4fv(this.uniforms.u_vpMatrix,false,uniforms.u_vpMatrix.getElements());
        this.gl.uniform2fv(this.uniforms.u_ifAuto,uniforms.u_ifAuto);
        this.gl.uniform2fv(this.uniforms.u_radius,uniforms.u_radius);
        this.gl.uniform1f(this.uniforms.u_maxWeight,uniforms.u_maxWeight);
        this.gl.uniform4fv(this.uniforms.u_color,uniforms.u_color);
        this.gl.uniform3fv(this.uniforms.u_center,uniforms.u_center);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.ScatterProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    setPointUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_time,uniforms.u_time);
        // console.log(uniforms.u_vpMatrix.getElements())
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix,false,uniforms.u_vpMatrix.getElements());
    }
    setCircleUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_time,uniforms.u_time);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix,false,uniforms.u_vpMatrix.getElements());
        this.gl.uniform2fv(this.uniforms.u_viewport,[this.gl.canvas.clientWidth, this.gl.canvas.clientHeight]);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.TadpoleProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    setPrivateUniforms(uniforms){
        //u_ifRTE,u_mvMatrix,u_projMatrix,u_camera
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.ViewshedProgram=class extends hmap.program.Program{
    constructor(gl){
        const vs=hmap.shader.ViewsedShader.vsShader;
        const fs=hmap.shader.ViewsedShader.fsShader;
        super(gl,vs,fs);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.FillWaterProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_time, uniforms.u_time);
        this.gl.uniformMatrix4fv(this.uniforms.u_vpMatrix,false,uniforms.u_vpMatrix.getElements());
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.FlowProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        this.gl.uniform1f(this.uniforms.u_framesParam, uniforms.u_framesParam);
        this.gl.uniform1i(this.uniforms.u_needLoop, uniforms.u_needLoop);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.ParticleProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        this.gl.uniform4fv(this.uniforms.u_color,new Float32Array(uniforms.u_color));
        this.gl.uniform1fv(this.uniforms.u_size,new Float32Array(uniforms.u_size));
        this.gl.uniform1fv(this.uniforms.u_offsetCount,new Float32Array(uniforms.u_offsetCount));
        this.gl.uniform1fv(this.uniforms.u_ctrlOffset,new Float32Array(uniforms.u_ctrlOffset));
        this.gl.uniform3fv(this.uniforms.u_originPosition,new Float32Array(uniforms.u_originPosition));
        this.gl.uniform3fv(this.uniforms.u_gravity,new Float32Array(uniforms.u_gravity));
        this.gl.uniform3fv(this.uniforms.u_inertia,new Float32Array(uniforms.u_inertia));
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.TrailProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        this.gl.uniform1i(this.uniforms.u_ifRTE,uniforms.u_ifRTE);
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);

        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        this.gl.uniform1f(this.uniforms.u_res,uniforms.u_res[0]);
        this.gl.uniform1f(this.uniforms.u_resL,uniforms.u_res[1]);
        this.gl.uniform4fv(this.uniforms.u_lineColor, uniforms.u_lineColor);
        this.gl.uniform1f(this.uniforms.u_lineWidth, uniforms.u_lineWidth);
        this.gl.uniform1i(this.uniforms.u_showLine, uniforms.u_showLine);
        this.gl.uniform1i(this.uniforms.u_useAlpha, uniforms.u_useAlpha);
        this.gl.uniform1f(this.uniforms.u_uvOffset, uniforms.u_uvOffset);
        this.gl.uniform1f(this.uniforms.u_placeLength, uniforms.u_placeLength);
        this.gl.uniform1f(this.uniforms.u_placeSpace, uniforms.u_placeSpace);
    }
};;"use strict";
hmap.program=hmap.program||{};
hmap.program.RainProgram=class extends hmap.program.Program{
    constructor(gl,vs,fs){
        super(gl,vs,fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms){
        // this.gl.uniform4fv(this.uniforms.u_color, new Float32Array(uniforms.u_color[0]));
        // this.gl.uniform1f(this.uniforms.u_speed, uniforms.u_speed[0]);
        this.gl.uniform1f(this.uniforms.u_time, uniforms.u_time);
        // this.gl.uniform1f(this.uniforms.u_size, uniforms.u_size[0]);
        this.gl.uniform1f(this.uniforms.u_initRes, uniforms.u_initRes);
        this.gl.uniform1f(this.uniforms.u_ewWind, uniforms.u_ewWind);
        this.gl.uniform1f(this.uniforms.u_nsWind, uniforms.u_nsWind);
        this.gl.uniform1f(this.uniforms.u_windForce, uniforms.u_windForce);
        this.gl.uniform1f(this.uniforms.u_resolution, uniforms.u_res[0] + uniforms.u_res[1]/Math.pow(10, 7));
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix, false, uniforms.u_vpMatrix.getElements());
    }
};;"use strict";
hmap.program = hmap.program || {};
hmap.program.SnowProgram = class extends hmap.program.Program {
    constructor(gl, vs, fs) {
        super(gl, vs, fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms) {
        this.gl.uniform1f(this.uniforms.u_time, uniforms.u_time);
        this.gl.uniform1f(this.uniforms.u_ewWind, uniforms.u_ewWind);
        this.gl.uniform1f(this.uniforms.u_nsWind, uniforms.u_nsWind);
        this.gl.uniform1f(this.uniforms.u_windForce, uniforms.u_windForce);
        //this.gl.uniform1f(this.uniforms.u_opacity, uniforms.u_opacity);
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix, false, uniforms.u_vpMatrix.getElements());
    }

};;"use strict";
hmap.program = hmap.program || {};
hmap.program.GridHeatProgram = class extends hmap.program.Program {
    constructor(gl, vs, fs) {
        super(gl, vs, fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms) {
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix, false, uniforms.u_vpMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);
    }

};;"use strict";
hmap.program = hmap.program || {};
hmap.program.HexGridHeatProgram = class extends hmap.program.Program {
    constructor(gl, vs, fs) {
        super(gl, vs, fs);
    }

    /**
     * 设置私有统一变量
     * @param uniforms
     * @private
     */
    setPrivateUniforms(uniforms) {
        this.gl.uniformMatrix4fv(this.uniforms.u_mvpMatrix, false, uniforms.u_vpMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_mvMatrix,false,uniforms.u_mvMatrix.getElements());
        this.gl.uniformMatrix4fv(this.uniforms.u_projMatrix,false,uniforms.u_projMatrix.getElements());
        this.gl.uniform1f(this.uniforms.u_unit,uniforms.u_unit);
        const camera=uniforms.u_camera;
        this.gl.uniform3fv(this.uniforms.u_cameraH,[camera.chx,camera.chy,camera.chz]);
        this.gl.uniform3fv(this.uniforms.u_cameraL,[camera.clx,camera.cly,camera.clz]);    
    }

};;hmap.format.Tile3DLoader = class {
    //构造
    constructor(options){
        if(!options.url){
            throw "the 3dtileset url must be given!"
        }
        this.url = options.url;
        this.maxZoom = options.maxZoom ? options.maxZoom : 24;
        this.minZoom = options.minZoom ? options.minZoom : 14;      //使用层级进行LOD策略，暂时用ScreenSpaceError不好解决的折中方案
        this.center = options.center;
        this.maxDepth = this.maxZoom - this.minZoom + 3;
        this.numberOfTilesTotal = 0;                //切片张数
        this._requestedTiles = [];                  //保存全部需要请求的切片
        this._processingQueue = [];                 //队列中的请求
        this.numberOfTileFailed = 0;                 //切片内容准备的数量
        this.modelMatrix = options.modelMatrix ? options.modelMatrix : new hmap.util.Matrix4();     //3dtile数据集的矩阵变换
        this.scratchStack = [];                     //堆栈
        this.allTileLoaded = false;                 //全部切片分支加载完成
        /**
         * 屏幕空间误差，用于lod显示三维切片
         * */
        this.dynamicScreenSpaceError = defined(options.dynamicScreenSpaceError) ? options.dynamicScreenSpaceError : false;
        /**
         *  屏幕空间误差密度  默认:0.00278
         */
        this.dynamicScreenSpaceErrorDensity = 0.00278;
        /**
         *  屏幕空间误差系数 默认4.0
         */
        this.dynamicScreenSpaceErrorFactor = 4.0;

        //屏幕空间误差计算密度
        this._dynamicScreenSpaceErrorComputedDensity = 0.0; // Updated based on the camera position and direction

        this._maximumScreenSpaceError = defined(options.maximumScreenSpaceError) ? options.maximumScreenSpaceError : 16;     //最大屏幕空间误差

        this.tileCache = new Map();                 //切片缓存
    }

    /**
     * 加载切片并返回
     * */
    load(){
        let me = this;
        let loadPromise = new Promise(function(loadResolve){
            me.parse(function(tileset){
                const promises  = [];
                //接下来要请求b3dm文件
                let tileTree = tileset.getTileTree();
                for(let i=0;i<tileTree.children.length;i++){
                    let promise = new Promise(function(resolve,reject){
                        let branch = tileTree.children[i];
                        branch.contentReadyPromise.then(function(){
                            resolve();
                        })
                    });
                    promises.push(promise);
                }
                Promise.all(promises).then(function(){          //切片的tileset加载完成，此时每个切片都具有树形层次结构
                    tileset.allTileLoaded = true;
                    loadResolve(tileset);
                })
            });
        })
        return loadPromise;
    }

    /**
     * 获取切片树
     * */
    getTileTree(){
        return this._root;
    }

    /**
     * 请求的切片深度
     * */
    getRequestDepth(mapZoom){
        let minZoom = this.minZoom;
        return (mapZoom - minZoom) + 3;
    }

    /**
     *  解析tileset.json文件的内容
     */
    parse(callback){
        let me = this;
        fetch(this.url,{
                responseType : 'text',
                headers: {
                    Accept : 'application/json'
                }
            }
        ).then(function(response){
            return response.json();
        }).then(function(tilesetJson){
            me._root = me.loadTileset(me.url, tilesetJson);
            let root = me._root;
            for(let i=0;i<root.children.length;i++){
                root.children[i].requestContent();          //tileset
            }
            if(typeof(callback)==='function'){
                callback(me);
            }
        })
    }

    /**
     * 加载3dtile数据集或者一张切片的tileset.json
     * @param {String} tileset.json文件的地址
     * @private
     */
    loadTileset(baseDir, tilesetJson, parentTile) {
        var asset = tilesetJson.asset;
        if (!asset) {
            throw 'Tileset must have an asset property.';
        }
        if (asset.version !== '0.0' && asset.version !== '1.0') {
            throw 'The tileset must be 3D Tiles version 0.0 or 1.0.';
        }
        var tilesetVersion = asset.version;          //tileset版本

        var rootTile = new hmap.format.Tile3D(this, baseDir, tilesetJson.root, parentTile);     //先不做请求

        if (parentTile) {
            parentTile.children.push(rootTile);
            rootTile._depth = parentTile._depth + 1;
        }

        var tileGroup = [];                         //保存所有的切片
        tileGroup.push(rootTile);

        while (tileGroup.length > 0) {              //逐级遍历tileset.json到b3dm
            var tile = tileGroup.pop();
            this.numberOfTilesTotal++;
            var children = tile._header.children;
            if (children) {
                var length = children.length;
                for (var i = 0; i < length; ++i) {
                    var childHeader = children[i];
                    var childTile = new hmap.format.Tile3D(this, baseDir, childHeader, tile);
                    tile.children.push(childTile);
                    childTile._depth = tile._depth + 1;
                    tileGroup.push(childTile);
                }
            }
        }
        return rootTile;
    }

    /**
     * 请求这个tileset中的tile
     * 在请求之前，按优先级对请求进行排序
     * */
    requestTiles() {
        var requestedTiles = this._requestedTiles;
        var length = requestedTiles.length;
        requestedTiles.sort(function(a,b){          //将请求按优先级顺序排列
            return a._priority - b._priority
        });
        for (var i = 0; i < length; ++i) {
            this.requestContent(requestedTiles[i]);
        }
    }

    /**
     * 针对hmap.format.Batched3DModelContent，请求切片，回调切片的内容
     * 当切片类型是tileset时，返回切片关系树
     * 当切片类型是b3dm时，返回Batched3dModel对象，并通过getGltf()的方法，获取直接用于gltf解析器的gltf
     * */
    requestContent(tile,callback) {
        tile.requestContent();      //请求切片内容
        tile.contentReadyPromise.then(function(tile){
            let returnOpt = {data:tile};
            if(tile.getContentType()==='b3dm'){
                returnOpt.type = 'b3dm';
            }else{                              //'tileset'
                returnOpt.type = 'tileset';
            }
            if(typeof(callback)==='function'){
                callback(returnOpt);
            }
        })
    }

    /**
     * 添加到处理队列
     * */
    addToProcessingQueue(tileset, tile) {
        return function() {
            tileset._processingQueue.push(tile);
            --tileset._statistics.numberOfPendingRequests;
            ++tileset._statistics.numberOfTilesProcessing;
        };
    }

    /**
     * 处理切片失败
     * */
    handleTileFailure(tileset, tile) {
        return function(error) {
            if (tileset._processingQueue.indexOf(tile) >= 0) {
                // Failed during processing
                --tileset._statistics.numberOfTilesProcessing;
            } else {
                // Failed when making request
                --tileset._statistics.numberOfPendingRequests;
            }

            var url = tile._contentResource.url;
            var message = defined(error.message) ? error.message : error.toString();
            if (tileset.tileFailed.numberOfListeners > 0) {
                tileset.tileFailed.raiseEvent({
                    url : url,
                    message : message
                });
            } else {
                throw new Error('Error: ' + message);
            }
        };
    }

    /**
     * 处理切片成功
     * */
    handleTileSuccess(tileset, tile) {
        return function() {
            --tileset._statistics.numberOfTilesProcessing;

            if (!tile.hasTilesetContent) {
                // RESEARCH_IDEA: ability to unload tiles (without content) for an
                // external tileset when all the tiles are unloaded.
                tileset._statistics.incrementLoadCounts(tile.content);
                ++tileset._statistics.numberOfTilesWithContentReady;

                // Add to the tile cache. Previously expired tiles are already in the cache and won't get re-added.
                tileset._cache.add(tile);
            }

            tileset.tileLoad.raiseEvent(tile);
        };
    }

    filterProcessingQueue(tileset) {
        var tiles = tileset._processingQueue;
        var length = tiles.length;

        var removeCount = 0;
        for (var i = 0; i < length; ++i) {
            var tile = tiles[i];
            if (tile._contentState !== Cesium3DTileContentState.PROCESSING) {
                ++removeCount;
                continue;
            }
            if (removeCount > 0) {
                tiles[i - removeCount] = tile;
            }
        }
        tiles.length -= removeCount;
    }

    processTiles(tileset, frameState) {
        filterProcessingQueue(tileset);
        var tiles = tileset._processingQueue;
        var length = tiles.length;
        // Process tiles in the PROCESSING state so they will eventually move to the READY state.
        for (var i = 0; i < length; ++i) {
            tiles[i].process(tileset, frameState);
        }
    }

    destroySubtree(tileset, tile) {
        var root = tile;
        var stack = this.scratchStack;
        stack.push(tile);
        while (stack.length > 0) {
            tile = stack.pop();
            var children = tile.children;
            var length = children.length;
            for (var i = 0; i < length; ++i) {
                stack.push(children[i]);
            }
            if (tile !== root) {
                destroyTile(tileset, tile);
                --tileset._statistics.numberOfTilesTotal;
            }
        }
        root.children = [];
    }

    unloadTile(tileset, tile) {
        tileset.tileUnload.raiseEvent(tile);
        tileset._statistics.decrementLoadCounts(tile.content);
        --tileset._statistics.numberOfTilesWithContentReady;
        tile.unloadContent();
    }

    /**
     * 销毁
     * */
    destroyTile(tileset, tile) {
        tileset._cache.unloadTile(tileset, tile, unloadTile);
        tile.destroy();
    }

    /**
     * 拆解
     * */
    unloadTiles(tileset) {
        tileset._cache.unloadTiles(tileset, unloadTile);
    }

    /**
     * 拆解上一屏缓存
     */
    trimLoadedTiles() {
        //this._cache.trim();
    }

    update(tileset, frameState) {
        if (frameState.mode === SceneMode.MORPHING) {
            return false;
        }

        if (!tileset.show || !tileset.ready) {
            return false;
        }

        if (!defined(tileset._loadTimestamp)) {
            tileset._loadTimestamp = JulianDate.clone(frameState.time);
        }

        // Update clipping planes
        var clippingPlanes = tileset._clippingPlanes;
        tileset._clippingPlanesOriginMatrixDirty = true;
        if (defined(clippingPlanes) && clippingPlanes.enabled) {
            clippingPlanes.update(frameState);
        }

        tileset._timeSinceLoad = Math.max(JulianDate.secondsDifference(frameState.time, tileset._loadTimestamp) * 1000, 0.0);

        tileset._skipLevelOfDetail = tileset.skipLevelOfDetail && !defined(tileset._classificationType) && !tileset._disableSkipLevelOfDetail && !tileset._allTilesAdditive;

        // Do out-of-core operations (new content requests, cache removal,
        // process new tiles) only during the render pass.
        var passes = frameState.passes;
        var isRender = passes.render;
        var isPick = passes.pick;
        var isAsync = passes.asynchronous;

        var statistics = tileset._statistics;
        statistics.clear();

        if (tileset.dynamicScreenSpaceError) {
            updateDynamicScreenSpaceError(tileset, frameState);
        }

        if (isRender) {
            tileset._cache.reset();
        }

        ++tileset._updatedVisibilityFrame;

        var ready;

        if (isAsync) {
            ready = Cesium3DTilesetAsyncTraversal.selectTiles(tileset, frameState);
        } else {
            ready = Cesium3DTilesetTraversal.selectTiles(tileset, frameState);
        }

        if (isRender || isAsync) {
            requestTiles(tileset);
        }

        if (isRender) {
            processTiles(tileset, frameState);
        }

        updateTiles(tileset, frameState);

        if (isRender) {
            unloadTiles(tileset);

            // Events are raised (added to the afterRender queue) here since promises
            // may resolve outside of the update loop that then raise events, e.g.,
            // model's readyPromise.
            raiseLoadProgressEvent(tileset, frameState);

            if (statistics.selected !== 0) {
                var credits = tileset._credits;
                if (defined(credits)) {
                    var length = credits.length;
                    for (var i = 0; i < length; i++) {
                        frameState.creditDisplay.addCredit(credits[i]);
                    }
                }
            }
        }

        // Update last statistics
        var statisticsLast = isAsync ? tileset._statisticsLastAsync : (isPick ? tileset._statisticsLastPick : tileset._statisticsLastRender);
        Cesium3DTilesetStatistics.clone(statistics, statisticsLast);

        return ready;
    }

    raiseLoadProgressEvent(tileset, frameState) {
        var statistics = tileset._statistics;
        var statisticsLast = tileset._statisticsLastRender;
        var numberOfPendingRequests = statistics.numberOfPendingRequests;
        var numberOfTilesProcessing = statistics.numberOfTilesProcessing;
        var lastNumberOfPendingRequest = statisticsLast.numberOfPendingRequests;
        var lastNumberOfTilesProcessing = statisticsLast.numberOfTilesProcessing;

        var progressChanged = (numberOfPendingRequests !== lastNumberOfPendingRequest) || (numberOfTilesProcessing !== lastNumberOfTilesProcessing);

        if (progressChanged) {
            frameState.afterRender.push(function() {
                tileset.loadProgress.raiseEvent(numberOfPendingRequests, numberOfTilesProcessing);
            });
        }

        tileset._tilesLoaded = (statistics.numberOfPendingRequests === 0) && (statistics.numberOfTilesProcessing === 0) && (statistics.numberOfAttemptedRequests === 0);

        if (progressChanged && tileset._tilesLoaded) {
            frameState.afterRender.push(function() {
                tileset.allTilesLoaded.raiseEvent();
            });
            if (!tileset._initialTilesLoaded) {
                tileset._initialTilesLoaded = true;
                frameState.afterRender.push(function() {
                    tileset.initialTilesLoaded.raiseEvent();
                });
            }
        }
    }

    /**
     * 更新
     * @private
     */
    update(frameState) {
        update(this, frameState);
    }

    /**
     * tileset.json中是否包含了文件的拓展名
     * @private
     */
    hasExtension(extensionName) {
        if (!defined(this._extensionsUsed)) {
            return false;
        }
        return (this._extensionsUsed.indexOf(extensionName) > -1);
    }

    /**
     * 销毁切片
     * @example
     * tileset = tileset && tileset.destroy();
     */
    destroy() {
        this._tileDebugLabels = this._tileDebugLabels && this._tileDebugLabels.destroy();
        this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();

        // Traverse the tree and destroy all tiles
        if (defined(this._root)) {
            var stack = this.scratchStack;
            stack.push(this._root);

            while (stack.length > 0) {
                var tile = stack.pop();
                tile.destroy();

                var children = tile.children;
                var length = children.length;
                for (var i = 0; i < length; ++i) {
                    stack.push(children[i]);
                }
            }
        }

        this._root = undefined;
        return destroyObject(this);
    }
}

function ForEach() {
}

/**
 * glTF 1.0的回退
 * @private
 */
ForEach.objectLegacy = function(objects, handler) {
    if (defined(objects)) {
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                var object = objects[objectId];
                var value = handler(object, objectId);

                if (defined(value)) {
                    return value;
                }
            }
        }
    }
};

/**
 * @private
 */
ForEach.object = function(arrayOfObjects, handler) {
    if (defined(arrayOfObjects)) {
        var length = arrayOfObjects.length;
        for (var i = 0; i < length; i++) {
            var object = arrayOfObjects[i];
            var value = handler(object, i);

            if (defined(value)) {
                return value;
            }
        }
    }
};

/**
 * 支持glTF 1.0 和 2.0
 * @private
 */
ForEach.topLevel = function(gltf, name, handler) {
    var gltfProperty = gltf[name];
    if (defined(gltfProperty) && !(gltfProperty instanceof Array)) {
        return ForEach.objectLegacy(gltfProperty, handler);
    }

    return ForEach.object(gltfProperty, handler);
};

ForEach.accessor = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'accessors', handler);
};

ForEach.accessorWithSemantic = function(gltf, semantic, handler) {
    var visited = {};
    return ForEach.mesh(gltf, function(mesh) {
        return ForEach.meshPrimitive(mesh, function(primitive) {
            var value = ForEach.meshPrimitiveAttribute(primitive, function(accessorId, attributeSemantic) {
                if (attributeSemantic.indexOf(semantic) === 0 && !defined(visited[accessorId])) {
                    visited[accessorId] = true;
                    value = handler(accessorId);

                    if (defined(value)) {
                        return value;
                    }
                }
            });

            if (defined(value)) {
                return value;
            }

            return ForEach.meshPrimitiveTarget(primitive, function(target) {
                return ForEach.meshPrimitiveTargetAttribute(target, function(accessorId, attributeSemantic) {
                    if (attributeSemantic.indexOf(semantic) === 0 && !defined(visited[accessorId])) {
                        visited[accessorId] = true;
                        value = handler(accessorId);

                        if (defined(value)) {
                            return value;
                        }
                    }
                });
            });
        });
    });
};

ForEach.accessorContainingVertexAttributeData = function(gltf, handler) {
    var visited = {};
    return ForEach.mesh(gltf, function(mesh) {
        return ForEach.meshPrimitive(mesh, function(primitive) {
            var value = ForEach.meshPrimitiveAttribute(primitive, function(accessorId) {
                if (!defined(visited[accessorId])) {
                    visited[accessorId] = true;
                    value = handler(accessorId);

                    if (defined(value)) {
                        return value;
                    }
                }
            });

            if (defined(value)) {
                return value;
            }

            return ForEach.meshPrimitiveTarget(primitive, function(target) {
                return ForEach.meshPrimitiveTargetAttribute(target, function(accessorId) {
                    if (!defined(visited[accessorId])) {
                        visited[accessorId] = true;
                        value = handler(accessorId);

                        if (defined(value)) {
                            return value;
                        }
                    }
                });
            });
        });
    });
};

ForEach.accessorContainingIndexData = function(gltf, handler) {
    var visited = {};
    return ForEach.mesh(gltf, function(mesh) {
        return ForEach.meshPrimitive(mesh, function(primitive) {
            var indices = primitive.indices;
            if (defined(indices) && !defined(visited[indices])) {
                visited[indices] = true;
                var value = handler(indices);

                if (defined(value)) {
                    return value;
                }
            }
        });
    });
};

ForEach.animation = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'animations', handler);
};

ForEach.animationChannel = function(animation, handler) {
    var channels = animation.channels;
    return ForEach.object(channels, handler);
};

ForEach.animationSampler = function(animation, handler) {
    var samplers = animation.samplers;
    return ForEach.object(samplers, handler);
};

ForEach.buffer = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'buffers', handler);
};

ForEach.bufferView = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'bufferViews', handler);
};

ForEach.camera = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'cameras', handler);
};

ForEach.image = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'images', handler);
};

ForEach.compressedImage = function(image, handler) {
    if (defined(image.extras)) {
        var compressedImages = image.extras.compressedImage3DTiles;
        for (var type in compressedImages) {
            if (compressedImages.hasOwnProperty(type)) {
                var compressedImage = compressedImages[type];
                var value = handler(compressedImage, type);

                if (defined(value)) {
                    return value;
                }
            }
        }
    }
};

ForEach.material = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'materials', handler);
};

ForEach.materialValue = function(material, handler) {
    var values = material.values;
    if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {
        values = material.extensions.KHR_techniques_webgl.values;
    }

    for (var name in values) {
        if (values.hasOwnProperty(name)) {
            var value = handler(values[name], name);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.mesh = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'meshes', handler);
};

ForEach.meshPrimitive = function(mesh, handler) {
    var primitives = mesh.primitives;
    if (defined(primitives)) {
        var primitivesLength = primitives.length;
        for (var i = 0; i < primitivesLength; i++) {
            var primitive = primitives[i];
            var value = handler(primitive, i);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.meshPrimitiveAttribute = function(primitive, handler) {
    var attributes = primitive.attributes;
    for (var semantic in attributes) {
        if (attributes.hasOwnProperty(semantic)) {
            var value = handler(attributes[semantic], semantic);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.meshPrimitiveTarget = function(primitive, handler) {
    var targets = primitive.targets;
    if (defined(targets)) {
        var length = targets.length;
        for (var i = 0; i < length; ++i) {
            var value = handler(targets[i], i);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.meshPrimitiveTargetAttribute = function(target, handler) {
    for (var semantic in target) {
        if (target.hasOwnProperty(semantic)) {
            var accessorId = target[semantic];
            var value = handler(accessorId, semantic);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.node = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'nodes', handler);
};

ForEach.nodeInTree = function(gltf, nodeIds, handler) {
    var nodes = gltf.nodes;
    if (defined(nodes)) {
        var length = nodeIds.length;
        for (var i = 0; i < length; i++) {
            var nodeId = nodeIds[i];
            var node = nodes[nodeId];
            if (defined(node)) {
                var value = handler(node, nodeId);

                if (defined(value)) {
                    return value;
                }

                var children = node.children;
                if (defined(children)) {
                    value = ForEach.nodeInTree(gltf, children, handler);

                    if (defined(value)) {
                        return value;
                    }
                }
            }
        }
    }
};

ForEach.nodeInScene = function(gltf, scene, handler) {
    var sceneNodeIds = scene.nodes;
    if (defined(sceneNodeIds)) {
        return ForEach.nodeInTree(gltf, sceneNodeIds, handler);
    }
};

ForEach.program = function(gltf, handler) {
    if (hasExtension(gltf, 'KHR_techniques_webgl')) {
        return ForEach.object(gltf.extensions.KHR_techniques_webgl.programs, handler);
    }

    return ForEach.topLevel(gltf, 'programs', handler);
};

ForEach.sampler = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'samplers', handler);
};

ForEach.scene = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'scenes', handler);
};

ForEach.shader = function(gltf, handler) {
    if (hasExtension(gltf, 'KHR_techniques_webgl')) {
        return ForEach.object(gltf.extensions.KHR_techniques_webgl.shaders, handler);
    }

    return ForEach.topLevel(gltf, 'shaders', handler);
};

ForEach.skin = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'skins', handler);
};

ForEach.techniqueAttribute = function(technique, handler) {
    var attributes = technique.attributes;
    for (var attributeName in attributes) {
        if (attributes.hasOwnProperty(attributeName)) {
            var value = handler(attributes[attributeName], attributeName);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.techniqueUniform = function(technique, handler) {
    var uniforms = technique.uniforms;
    for (var uniformName in uniforms) {
        if (uniforms.hasOwnProperty(uniformName)) {
            var value = handler(uniforms[uniformName], uniformName);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.techniqueParameter = function(technique, handler) {
    var parameters = technique.parameters;
    for (var parameterName in parameters) {
        if (parameters.hasOwnProperty(parameterName)) {
            var value = handler(parameters[parameterName], parameterName);

            if (defined(value)) {
                return value;
            }
        }
    }
};

ForEach.technique = function(gltf, handler) {
    if(gltf.extensionsUsed && gltf.extensionsUsed.indexOf('KHR_techniques_webgl') >= 0){
        return ForEach.object(gltf.extensions.KHR_techniques_webgl.techniques, handler);
    }
    return ForEach.topLevel(gltf, 'techniques', handler);
};

ForEach.texture = function(gltf, handler) {
    return ForEach.topLevel(gltf, 'textures', handler);
};


let Remove = function(){};

Remove.accessor = function(gltf, accessorId) {
    var accessors = gltf.accessors;

    accessors.splice(accessorId, 1);

    ForEach.mesh(gltf, function(mesh) {
        ForEach.meshPrimitive(mesh, function(primitive) {
            // Update accessor ids for the primitives.
            ForEach.meshPrimitiveAttribute(primitive, function(attributeAccessorId, semantic) {
                if (attributeAccessorId > accessorId) {
                    primitive.attributes[semantic]--;
                }
            });

            // Update accessor ids for the targets.
            ForEach.meshPrimitiveTarget(primitive, function(target) {
                ForEach.meshPrimitiveTargetAttribute(target, function(attributeAccessorId, semantic) {
                    if (attributeAccessorId > accessorId) {
                        target[semantic]--;
                    }
                });
            });
            var indices = primitive.indices;
            if (defined(indices) && indices > accessorId) {
                primitive.indices--;
            }
        });
    });

    ForEach.skin(gltf, function(skin) {
        if (defined(skin.inverseBindMatrices) && skin.inverseBindMatrices > accessorId) {
            skin.inverseBindMatrices--;
        }
    });

    ForEach.animation(gltf, function(animation) {
        ForEach.animationSampler(animation, function(sampler) {
            if (defined(sampler.input) && sampler.input > accessorId) {
                sampler.input--;
            }
            if (defined(sampler.output) && sampler.output > accessorId) {
                sampler.output--;
            }
        });
    });
};

Remove.buffer = function(gltf, bufferId) {
    var buffers = gltf.buffers;

    buffers.splice(bufferId, 1);

    ForEach.bufferView(gltf, function(bufferView) {
        if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {
            bufferView.buffer--;
        }
    });
};

Remove.bufferView = function(gltf, bufferViewId) {
    var bufferViews = gltf.bufferViews;

    bufferViews.splice(bufferViewId, 1);

    ForEach.accessor(gltf, function(accessor) {
        if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {
            accessor.bufferView--;
        }
    });

    ForEach.shader(gltf, function(shader) {
        if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {
            shader.bufferView--;
        }
    });

    ForEach.image(gltf, function(image) {
        if (defined(image.bufferView) && image.bufferView > bufferViewId) {
            image.bufferView--;
        }
        ForEach.compressedImage(image, function(compressedImage) {
            var compressedImageBufferView = compressedImage.bufferView;
            if (defined(compressedImageBufferView) && compressedImageBufferView > bufferViewId) {
                compressedImage.bufferView--;
            }
        });
    });

    if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {
        ForEach.mesh(gltf, function (mesh) {
            ForEach.meshPrimitive(mesh, function (primitive) {
                if (defined(primitive.extensions) &&
                    defined(primitive.extensions.KHR_draco_mesh_compression)) {
                    if (primitive.extensions.KHR_draco_mesh_compression.bufferView > bufferViewId) {
                        primitive.extensions.KHR_draco_mesh_compression.bufferView--;
                    }
                }
            });
        });
    }
};

/**
 * 可根据深浅复制
 * */
function clone(object, deep) {
    if (object === null || typeof object !== 'object') {
        return object;
    }

    deep = defined(deep) ? deep : false;

    var result = new object.constructor();
    for ( var propertyName in object) {
        if (object.hasOwnProperty(propertyName)) {
            var value = object[propertyName];
            if (deep) {
                value = clone(value, deep);
            }
            result[propertyName] = value;
        }
    }

    return result;
}



/**
 * 是否定义
 * */
function defined(a){
    return a != null && a != undefined;
}

/**
 * 用给定值填充数组或数组的一部分。
 * @param {Array} array 需要填充的数组
 * @param {*} value 数组需要填充的值
 * @param {Number} [start=0] 填充的开始位置，默认为0
 * @param {Number} [end=array.length] 填充的结束位置，默认为数组末位的位置
 * @returns {Array} 填充之后的数组
 * @private
 */
function arrayFill(array, value, start, end) {
    if (typeof array.fill === 'function') {
        return array.fill(value, start, end);
    }

    var length = array.length >>> 0;
    var relativeStart = defined(start) ? start : 0;
    // If negative, find wrap around position
    var k = (relativeStart < 0) ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);
    var relativeEnd = defined(end) ? end : length;
    // If negative, find wrap around position
    var last = (relativeEnd < 0) ? Math.max(length + relativeEnd, 0) : Math.min(relativeEnd, length);

    // Fill array accordingly
    while (k < last) {
        array[k] = value;
        k++;
    }
    return array;
}

/**
 * gltf是否有拓展
 * @private
 * */
function hasExtension(gltf, extension) {
    return defined(gltf.extensionsUsed) && (gltf.extensionsUsed.indexOf(extension) >= 0);
}

/**
 * 将object转成数组
 * */
function objectToArray(object, mapping) {
    var array = [];
    for (var id in object) {
        if (object.hasOwnProperty(id)) {
            var value = object[id];
            mapping[id] = array.length;
            array.push(value);
            if (!defined(value.name)) {
                value.name = id;
            }
        }
    }
    return array;
}

/**
 *  将元素添加到数组并返回元素的索引
 *  @param {Array} array 需要添加的数组
 *  @param {Object} element 需要添加的元素
 *  @param {Boolean} 当true时，如果发现重复的元素，则返回其索引，并且元素不会添加到数组中，默认为false
 *  @private
 */
function addToArray(array, element, checkDuplicates) {
    checkDuplicates = defined(checkDuplicates) ? checkDuplicates : false;
    if (checkDuplicates) {
        var index = array.indexOf(element);
        if (index > -1) {
            return index;
        }
    }
    array.push(element);
    return array.length - 1;
}

/**
 * 组件数据类型
 * @private
 * */
let ComponentDatatype = {

    BYTE : 5120,                    //BYTE

    UNSIGNED_BYTE : 5121,           //UNSIGNED_BYTE,

    SHORT : 5122,                   //SHORT

    UNSIGNED_SHORT : 5123,          //UNSIGNED_SHORT

    INT : 5124,                     //INT

    UNSIGNED_INT : 5125,            //UNSIGNED_INT

    FLOAT : 5126,                   //FLOAT

    DOUBLE : 5130                   //DOUBLE
};

ComponentDatatype.getSizeInBytes = function(componentDatatype){
    if (!defined(componentDatatype)) {
        throw 'value is required.';
    }
    switch (componentDatatype) {
        case ComponentDatatype.BYTE:
            return Int8Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.SHORT:
            return Int16Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.INT:
            return Int32Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.FLOAT:
            return Float32Array.BYTES_PER_ELEMENT;
        case ComponentDatatype.DOUBLE:
            return Float64Array.BYTES_PER_ELEMENT;
        default:
            throw 'componentDatatype is not a valid value.';
    }
};

ComponentDatatype.fromTypedArray = function(array) {
    if (array instanceof Int8Array) {
        return ComponentDatatype.BYTE;
    }
    if (array instanceof Uint8Array) {
        return ComponentDatatype.UNSIGNED_BYTE;
    }
    if (array instanceof Int16Array) {
        return ComponentDatatype.SHORT;
    }
    if (array instanceof Uint16Array) {
        return ComponentDatatype.UNSIGNED_SHORT;
    }
    if (array instanceof Int32Array) {
        return ComponentDatatype.INT;
    }
    if (array instanceof Uint32Array) {
        return ComponentDatatype.UNSIGNED_INT;
    }
    if (array instanceof Float32Array) {
        return ComponentDatatype.FLOAT;
    }
    if (array instanceof Float64Array) {
        return ComponentDatatype.DOUBLE;
    }
};

ComponentDatatype.validate = function(componentDatatype) {
    return defined(componentDatatype) &&
        (componentDatatype === ComponentDatatype.BYTE ||
            componentDatatype === ComponentDatatype.UNSIGNED_BYTE ||
            componentDatatype === ComponentDatatype.SHORT ||
            componentDatatype === ComponentDatatype.UNSIGNED_SHORT ||
            componentDatatype === ComponentDatatype.INT ||
            componentDatatype === ComponentDatatype.UNSIGNED_INT ||
            componentDatatype === ComponentDatatype.FLOAT ||
            componentDatatype === ComponentDatatype.DOUBLE);
};

ComponentDatatype.createTypedArray = function(componentDatatype, valuesOrLength) {
    if (!defined(componentDatatype)) {
        throw 'componentDatatype is required.';
    }
    if (!defined(valuesOrLength)) {
        throw 'valuesOrLength is required.';
    }

    switch (componentDatatype) {
        case ComponentDatatype.BYTE:
            return new Int8Array(valuesOrLength);
        case ComponentDatatype.UNSIGNED_BYTE:
            return new Uint8Array(valuesOrLength);
        case ComponentDatatype.SHORT:
            return new Int16Array(valuesOrLength);
        case ComponentDatatype.UNSIGNED_SHORT:
            return new Uint16Array(valuesOrLength);
        case ComponentDatatype.INT:
            return new Int32Array(valuesOrLength);
        case ComponentDatatype.UNSIGNED_INT:
            return new Uint32Array(valuesOrLength);
        case ComponentDatatype.FLOAT:
            return new Float32Array(valuesOrLength);
        case ComponentDatatype.DOUBLE:
            return new Float64Array(valuesOrLength);
        default:
            throw 'componentDatatype is not a valid value.';
    }
};

ComponentDatatype.createArrayBufferView = function(componentDatatype, buffer, byteOffset, length) {
    if (!defined(componentDatatype)) {
        throw 'componentDatatype is required.';
    }
    if (!defined(buffer)) {
        throw 'buffer is required.';
    }

    byteOffset = defined(byteOffset) ? byteOffset : 0;
    length = defined(length) ? length : (buffer.byteLength - byteOffset) / ComponentDatatype.getSizeInBytes(componentDatatype);

    switch (componentDatatype) {
        case ComponentDatatype.BYTE:
            return new Int8Array(buffer, byteOffset, length);
        case ComponentDatatype.UNSIGNED_BYTE:
            return new Uint8Array(buffer, byteOffset, length);
        case ComponentDatatype.SHORT:
            return new Int16Array(buffer, byteOffset, length);
        case ComponentDatatype.UNSIGNED_SHORT:
            return new Uint16Array(buffer, byteOffset, length);
        case ComponentDatatype.INT:
            return new Int32Array(buffer, byteOffset, length);
        case ComponentDatatype.UNSIGNED_INT:
            return new Uint32Array(buffer, byteOffset, length);
        case ComponentDatatype.FLOAT:
            return new Float32Array(buffer, byteOffset, length);
        case ComponentDatatype.DOUBLE:
            return new Float64Array(buffer, byteOffset, length);
        default:
            throw 'componentDatatype is not a valid value.';
    }
};

ComponentDatatype.fromName = function(name) {
    switch (name) {
        case 'BYTE':
            return ComponentDatatype.BYTE;
        case 'UNSIGNED_BYTE':
            return ComponentDatatype.UNSIGNED_BYTE;
        case 'SHORT':
            return ComponentDatatype.SHORT;
        case 'UNSIGNED_SHORT':
            return ComponentDatatype.UNSIGNED_SHORT;
        case 'INT':
            return ComponentDatatype.INT;
        case 'UNSIGNED_INT':
            return ComponentDatatype.UNSIGNED_INT;
        case 'FLOAT':
            return ComponentDatatype.FLOAT;
        case 'DOUBLE':
            return ComponentDatatype.DOUBLE;
        default:
            throw 'name is not a valid value.';
    }
};

/**
 * 返回一个函数，用于读取数据视图中的数据并将其转换为数组
 * @param {Number} componentType 将数据要转换的类型
 * @returns {ComponentReader} 读取和转换数据的函数
 * @private
 */
function getComponentReader(componentType) {
    switch (componentType) {
        case ComponentDatatype.BYTE:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getInt8(byteOffset + i * componentTypeByteLength);
                }
            };
        case ComponentDatatype.UNSIGNED_BYTE:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getUint8(byteOffset + i * componentTypeByteLength);
                }
            };
        case ComponentDatatype.SHORT:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getInt16(byteOffset + i * componentTypeByteLength, true);
                }
            };
        case ComponentDatatype.UNSIGNED_SHORT:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getUint16(byteOffset + i * componentTypeByteLength, true);
                }
            };
        case ComponentDatatype.INT:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getInt32(byteOffset + i * componentTypeByteLength, true);
                }
            };
        case ComponentDatatype.UNSIGNED_INT:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getUint32(byteOffset + i * componentTypeByteLength, true);
                }
            };
        case ComponentDatatype.FLOAT:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getFloat32(byteOffset + i * componentTypeByteLength, true);
                }
            };
        case ComponentDatatype.DOUBLE:
            return function (dataView, byteOffset, numberOfComponents, componentTypeByteLength, result) {
                for (var i = 0; i < numberOfComponents; ++i) {
                    result[i] = dataView.getFloat64(byteOffset + i * componentTypeByteLength, true);
                }
            };
    }
}










;hmap.format.GLTFConvert = class {
    /**
     * 构造函数
     * */
    constructor(gltf){
        this.gltf = gltf;
        gltf.asset = defined(this.gltf.asset) ? this.gltf.asset : {};
        gltf.asset.version = '2.0';

        this.knownExtensions = {
            CESIUM_RTC: true,
            KHR_materials_common: true,
            WEB3D_quantized_attributes: true
        }

        this.supportedBlendFactors = {
            ZERO: 0,
            ONE: 1,
            SRC_COLOR: 0x0300,
            ONE_MINUS_SRC_COLOR: 0x0301,
            SRC_ALPHA: 0x0302,
            ONE_MINUS_SRC_ALPHA: 0x0303,
            DST_ALPHA: 0x0304,
            ONE_MINUS_DST_ALPHA: 0x0305,
            DST_COLOR: 0x0306,
            ONE_MINUS_DST_COLOR: 0x0307,
        }

        this.knownSemantics = {
            POSITION: true,
            NORMAL: true,
            TANGENT: true
        }

        this.indexedSemantics = {
            COLOR: 'COLOR',
            JOINT : 'JOINTS',
            JOINTS: 'JOINTS',
            TEXCOORD: 'TEXCOORD',
            WEIGHT: 'WEIGHTS',
            WEIGHTS: 'WEIGHTS'
        };

        this.typeToGltfElementName = {
            accessor: 'accessors',
            buffer: 'buffers',
            bufferView: 'bufferViews'
        }

        this.dataTypeConst = {
            BYTE : 0x1400,
            UNSIGNED_BYTE : 0x1401,
            SHORT : 0x1402,
            UNSIGNED_SHORT : 0x1403,
            INT : 0x1404,
            UNSIGNED_INT : 0x1405,
            FLOAT : 0x1406,
            CULL_FACE : 0x0B44,
            BLEND : 0x0BE2
        }

        this.convert();
    }

    /**
     * 获取转换结果
     * @private
     * */
    getResult(){
        return this.gltf;
    }

    /**
     * 开始转换
     * @private
     * */
    convert(){
        // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.
        this.updateInstanceTechniques();
        // animation.samplers now refers directly to accessors and animation.parameters should be removed
        this.removeAnimationSamplersIndirection();
        // Remove empty nodes and re-assign referencing indices
        this.removeEmptyNodes();
        // Top-level objects are now arrays referenced by index instead of id
        this.objectsToArrays();
        // Animation.sampler objects cannot have names
        this.removeAnimationSamplerNames();
        // asset.profile no longer exists
        this.stripAsset();
        // Move known extensions from extensionsUsed to extensionsRequired
        this.requireKnownExtensions();
        // bufferView.byteLength and buffer.byteLength are required
        this.requireByteLength();
        // byteStride moved from accessor to bufferView
        this.moveByteStrideToBufferView();
        // accessor.min and accessor.max must be defined for accessors containing POSITION attributes
        this.requirePositionAccessorMinMax();
        // An animation sampler's input accessor must have min and max properties defined
        this.requireAnimationAccessorMinMax();
        // buffer.type is unnecessary and should be removed
        this.removeBufferType();
        // Remove format, internalFormat, target, and type
        this.removeTextureProperties();
        // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)
        this.requireAttributeSetIndex();
        // Add underscores to application-specific parameters
        this.underscoreApplicationSpecificSemantics();
        // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types
        this.updateAccessorComponentTypes();
        // Clamp camera parameters
        this.clampCameraParameters();
        // Move legacy technique render states to material properties and add KHR_blend extension blending functions
        this.moveTechniqueRenderStates();
        // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques
        this.moveTechniquesToExtension();
        // Remove empty arrays
        this.removeEmptyArrays();
    }

    updateInstanceTechniques() {
        var materials = this.gltf.materials;
        for (var materialId in materials) {
            if (materials.hasOwnProperty(materialId)) {
                var material = materials[materialId];
                var instanceTechnique = material.instanceTechnique;
                if (defined(instanceTechnique)) {
                    material.technique = instanceTechnique.technique;
                    material.values = instanceTechnique.values;
                    delete material.instanceTechnique;
                }
            }
        }
    }

    removeAnimationSamplersIndirection() {
        var animations = this.gltf.animations;
        for (var animationId in animations) {
            if (animations.hasOwnProperty(animationId)) {
                var animation = animations[animationId];
                var parameters = animation.parameters;
                if (defined(parameters)) {
                    var samplers = animation.samplers;
                    for (var samplerId in samplers) {
                        if (samplers.hasOwnProperty(samplerId)) {
                            var sampler = samplers[samplerId];
                            sampler.input = parameters[sampler.input];
                            sampler.output = parameters[sampler.output];
                        }
                    }
                    delete animation.parameters;
                }
            }
        }
    }

    removeEmptyNodes() {
        let gltf = this.gltf,me = this;
        ForEach.node(gltf, function(node, nodeId) {
            if (me.isNodeEmpty(node)) {
                me.deleteNode(nodeId);
            }
        });
        return gltf;
    }

    isNodeEmpty(node) {
        return (!defined(node.children) || node.children.length === 0) &&
            (!defined(node.meshes) || node.meshes.length === 0) &&
            !defined(node.camera) && !defined(node.skin) && !defined(node.skeletons) && !defined(node.jointName) &&
            (!defined(node.translation) || this.arrayEquals(node.translation,[0.0,0.0,0.0])) &&
            (!defined(node.scale) || this.arrayEquals(node.scale,[1.0, 1.0, 1.0])) &&
            (!defined(node.rotation) || this.arrayEquals(node.rotation,[0.0, 0.0, 0.0, 1.0])) &&
            (!defined(node.matrix) || this.arrayEquals(node.matrix,hmap.util.Matrix4().getElements())) &&
            !defined(node.extensions) && !defined(node.extras);
    }

    //检查字符串数组是否相等
    arrayEquals(srcArray,desArray){
        if(!(srcArray instanceof Array) || !(desArray instanceof Array)){
            return false;
        }
        for(let i=0;i<srcArray.length;i++){
            if(!desArray[i] || !(srcArray[i]===desArray[i])){
                return false;
            }
        }
        return true;
    }

    deleteNode(nodeId) {
        const gltf = this.gltf;
        // Remove from list of nodes in scene
        ForEach.scene(gltf, function(scene) {
            var sceneNodes = scene.nodes;
            if (defined(sceneNodes)) {
                var sceneNodesLength = sceneNodes.length;
                for (var i = sceneNodesLength; i >= 0; --i) {
                    if (sceneNodes[i] === nodeId) {
                        sceneNodes.splice(i, 1);
                        return;
                    }
                }
            }
        });

        ForEach.node(gltf, function(parentNode, parentNodeId) {
            if (defined(parentNode.children)) {
                var index = parentNode.children.indexOf(nodeId);
                if (index > -1) {
                    parentNode.children.splice(index, 1);

                    if (this.isNodeEmpty(parentNode)) {
                        this.deleteNode(parentNodeId);
                    }
                }
            }
        });

        delete gltf.nodes[nodeId];
    }

    objectsToArrays() {
        var i;
        var globalMapping = {
            accessors: {},
            animations: {},
            buffers: {},
            bufferViews: {},
            cameras: {},
            images: {},
            materials: {},
            meshes: {},
            nodes: {},
            programs: {},
            samplers: {},
            scenes: {},
            shaders: {},
            skins: {},
            textures: {},
            techniques: {}
        };

        //将关联名称映射到id
        var jointName;
        var jointNameToId = {};
        let gltf = this.gltf, nodes = gltf.nodes;
        for (var id in nodes) {
            if (nodes.hasOwnProperty(id)) {
                jointName = nodes[id].jointName;
                if (defined(jointName)) {
                    jointNameToId[jointName] = id;
                }
            }
        }

        //将顶层对象转换为数组
        for (var topLevelId in gltf) {
            if (gltf.hasOwnProperty(topLevelId) && defined(globalMapping[topLevelId])) {
                var objectMapping = {};
                var object = gltf[topLevelId];
                gltf[topLevelId] = objectToArray(object, objectMapping);
                globalMapping[topLevelId] = objectMapping;
            }
        }

        for (jointName in jointNameToId) {
            if (jointNameToId.hasOwnProperty(jointName)) {
                jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];
            }
        }

        if (defined(gltf.scene)) {
            gltf.scene = globalMapping.scenes[gltf.scene];
        }
        ForEach.bufferView(gltf, function(bufferView) {
            if (defined(bufferView.buffer)) {
                bufferView.buffer = globalMapping.buffers[bufferView.buffer];
            }
        });
        ForEach.accessor(gltf, function(accessor) {
            if (defined(accessor.bufferView)) {
                accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];
            }
        });
        ForEach.shader(gltf, function(shader) {
            var extensions = shader.extensions;
            if (defined(extensions)) {
                var binaryGltf = extensions.KHR_binary_glTF;
                if (defined(binaryGltf)) {
                    shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];
                    delete extensions.KHR_binary_glTF;
                }
                if (Object.keys(extensions).length === 0) {
                    delete shader.extensions;
                }
            }
        });
        ForEach.program(gltf, function(program) {
            if (defined(program.vertexShader)) {
                program.vertexShader = globalMapping.shaders[program.vertexShader];
            }
            if (defined(program.fragmentShader)) {
                program.fragmentShader = globalMapping.shaders[program.fragmentShader];
            }
        });
        ForEach.technique(gltf, function(technique) {
            if (defined(technique.program)) {
                technique.program = globalMapping.programs[technique.program];
            }
            ForEach.techniqueParameter(technique, function(parameter) {
                if (defined(parameter.node)) {
                    parameter.node = globalMapping.nodes[parameter.node];
                }
                var value = parameter.value;
                if (typeof value === 'string') {
                    parameter.value = {
                        index: globalMapping.textures[value]
                    };
                }
            });
        });
        ForEach.mesh(gltf, function(mesh) {
            ForEach.meshPrimitive(mesh, function(primitive) {
                if (defined(primitive.indices)) {
                    primitive.indices = globalMapping.accessors[primitive.indices];
                }
                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {
                    primitive.attributes[semantic] = globalMapping.accessors[accessorId];
                });
                if (defined(primitive.material)) {
                    primitive.material = globalMapping.materials[primitive.material];
                }
            });
        });
        ForEach.node(gltf, function(node) {
            var children = node.children;
            if (defined(children)) {
                var childrenLength = children.length;
                for (i = 0; i < childrenLength; ++i) {
                    children[i] = globalMapping.nodes[children[i]];
                }
            }
            if (defined(node.meshes)) {
                // Split out meshes on nodes
                var meshes = node.meshes;
                var meshesLength = meshes.length;
                if (meshesLength > 0) {
                    node.mesh = globalMapping.meshes[meshes[0]];
                    for (i = 1; i < meshesLength; ++i) {
                        var meshNode = {
                            mesh: globalMapping.meshes[meshes[i]]
                        };
                        var meshNodeId = addToArray(gltf.nodes, meshNode);
                        if (!defined(children)) {
                            children = [];
                            node.children = children;
                        }
                        children.push(meshNodeId);
                    }
                }
                delete node.meshes;
            }
            if (defined(node.camera)) {
                node.camera = globalMapping.cameras[node.camera];
            }
            if (defined(node.skin)) {
                node.skin = globalMapping.skins[node.skin];
            }
            if (defined(node.skeletons)) {
                // Assign skeletons to skins
                var skeletons = node.skeletons;
                var skeletonsLength = skeletons.length;
                if ((skeletonsLength > 0) && defined(node.skin)) {
                    var skin = gltf.skins[node.skin];
                    skin.skeleton = globalMapping.nodes[skeletons[0]];
                }
                delete node.skeletons;
            }
            if (defined(node.jointName)) {
                delete node.jointName;
            }
        });
        ForEach.skin(gltf, function(skin) {
            if (defined(skin.inverseBindMatrices)) {
                skin.inverseBindMatrices = globalMapping.accessors[skin.inverseBindMatrices];
            }
            var jointNames = skin.jointNames;
            if (defined(jointNames)) {
                var joints = [];
                var jointNamesLength = jointNames.length;
                for (i = 0; i < jointNamesLength; ++i) {
                    joints[i] = jointNameToId[jointNames[i]];
                }
                skin.joints = joints;
                delete skin.jointNames;
            }
        });
        ForEach.scene(gltf, function(scene) {
            var sceneNodes = scene.nodes;
            if (defined(sceneNodes)) {
                var sceneNodesLength = sceneNodes.length;
                for (i = 0; i < sceneNodesLength; ++i) {
                    sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];
                }
            }
        });
        ForEach.animation(gltf, function(animation) {
            var samplerMapping = {};
            animation.samplers = objectToArray(animation.samplers, samplerMapping);
            ForEach.animationSampler(animation, function(sampler) {
                sampler.input = globalMapping.accessors[sampler.input];
                sampler.output = globalMapping.accessors[sampler.output];
            });
            ForEach.animationChannel(animation, function(channel) {
                channel.sampler = samplerMapping[channel.sampler];
                var target = channel.target;
                if (defined(target)) {
                    target.node = globalMapping.nodes[target.id];
                    delete target.id;
                }
            });
        });
        ForEach.material(gltf, function(material) {
            if (defined(material.technique)) {
                material.technique = globalMapping.techniques[material.technique];
            }
            ForEach.materialValue(material, function(value, name) {
                if (typeof value === 'string') {
                    material.values[name] = {
                        index: globalMapping.textures[value]
                    };
                }
            });
            var extensions = material.extensions;
            if (defined(extensions)) {
                var materialsCommon = extensions.KHR_materials_common;
                if (defined(materialsCommon)) {
                    ForEach.materialValue(materialsCommon, function(value, name) {
                        if (typeof value === 'string') {
                            materialsCommon.values[name] = {
                                index: globalMapping.textures[value]
                            };
                        }
                    });
                }
            }
        });
        ForEach.image(gltf, function(image) {
            var extensions = image.extensions;
            if (defined(extensions)) {
                var binaryGltf = extensions.KHR_binary_glTF;
                if (defined(binaryGltf)) {
                    image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];
                    image.mimeType = binaryGltf.mimeType;
                    delete extensions.KHR_binary_glTF;
                }
                if (Object.keys(extensions).length === 0) {
                    delete image.extensions;
                }
            }
            ForEach.compressedImage(image, function(compressedImage) {
                var compressedExtensions = compressedImage.extensions;
                if (defined(compressedExtensions)) {
                    var compressedBinaryGltf = compressedExtensions.KHR_binary_glTF;
                    if (defined(compressedBinaryGltf)) {
                        compressedImage.bufferView = globalMapping.bufferViews[compressedBinaryGltf.bufferView];
                        compressedImage.mimeType = compressedBinaryGltf.mimeType;
                        delete compressedExtensions.KHR_binary_glTF;
                    }
                    if (Object.keys(extensions).length === 0) {
                        delete compressedImage.extensions;
                    }
                }
            });
        });
        ForEach.texture(gltf, function(texture) {
            if (defined(texture.sampler)) {
                texture.sampler = globalMapping.samplers[texture.sampler];
            }
            if (defined(texture.source)) {
                texture.source = globalMapping.images[texture.source];
            }
        });
    }

    /**
     * 移除动画采样器名称
     * @private
     * */
    removeAnimationSamplerNames() {
        let gltf = this.gltf;
        ForEach.animation(gltf, function(animation) {
            ForEach.animationSampler(animation, function(sampler) {
                delete sampler.name;
            });
        });
    }

    /**
     * 剥离资产属性
     * @private
     * */
    stripAsset() {
        let asset = this.gltf.asset;
        delete asset.profile;
        delete asset.premultipliedAlpha;
    }

    /**
     * 已知的拓展名
     * @private
     * */
    requireKnownExtensions() {
        let gltf = this.gltf, extensionsUsed = gltf.extensionsUsed;
        gltf.extensionsRequired = defined(gltf.extensionsRequired) ? gltf.extensionsRequired : [];
        if (defined(extensionsUsed)) {
            var extensionsUsedLength = extensionsUsed.length;
            for (var i = 0; i < extensionsUsedLength; ++i) {
                var extension = extensionsUsed[i];
                if (defined(this.knownExtensions[extension])) {
                    gltf.extensionsRequired.push(extension);
                }
            }
        }
    }

    /**
     * 需要的字节长度
     * @private
     * */
    requireByteLength() {
        let gltf = this.gltf,me = this;
        ForEach.buffer(gltf, function(buffer) {
            if (!defined(buffer.byteLength)) {
                buffer.byteLength = buffer.extras._pipeline.source.length;
            }
        });
        ForEach.accessor(gltf, function(accessor) {
            var bufferViewId = accessor.bufferView;
            if (defined(bufferViewId)) {
                var bufferView = gltf.bufferViews[bufferViewId];
                var accessorByteStride = me.computeAccessorByteStride(accessor);
                var accessorByteEnd = accessor.byteOffset + accessor.count * accessorByteStride;
                bufferView.byteLength = Math.max((defined(bufferView.byteLength)?bufferView.byteLength:0), accessorByteEnd);
            }
        });
    }

    computeAccessorByteStride(accessor) {
        return (defined(accessor.byteStride) && accessor.byteStride !== 0) ? accessor.byteStride : this.getAccessorByteStride(accessor);
    }

    /**
     * 返回提供的访问器的字节跨距
     * @private
     */
    getAccessorByteStride(accessor) {
        let gltf = this.gltf,bufferViewId = accessor.bufferView;
        if (defined(bufferViewId)) {
            var bufferView = gltf.bufferViews[bufferViewId];
            if (defined(bufferView.byteStride) && bufferView.byteStride > 0) {
                return bufferView.byteStride;
            }
        }
        return ComponentDatatype.getSizeInBytes(accessor.componentType) * this.numberOfComponentsForType(accessor.type);
    }

    /**
     * 组件类型
     * @private
     * */
    numberOfComponentsForType(type) {
        switch (type) {
            case 'SCALAR':
                return 1;
            case 'VEC2':
                return 2;
            case 'VEC3':
                return 3;
            case 'VEC4':
            case 'MAT2':
                return 4;
            case 'MAT3':
                return 9;
            case 'MAT4':
                return 16;
        }
    }

    /**
     *  将字节步幅移动到缓冲区视图
     *  @private
     * */
    moveByteStrideToBufferView() {
        let gltf = this.gltf;
        var i,j;
        var bufferView;
        var bufferViews = gltf.bufferViews;

        var bufferViewHasVertexAttributes = {};
        ForEach.accessorContainingVertexAttributeData(gltf, function(accessorId) {
            var accessor = gltf.accessors[accessorId];
            if (defined(accessor.bufferView)) {
                bufferViewHasVertexAttributes[accessor.bufferView] = true;
            }
        });

        //将缓冲区视图映射到访问器列表
        var bufferViewMap = {};
        ForEach.accessor(gltf, function(accessor) {
            if (defined(accessor.bufferView)) {
                bufferViewMap[accessor.bufferView] = bufferViewMap[accessor.bufferView] || [];
                bufferViewMap[accessor.bufferView].push(accessor);
            }
        });

        //具有不同字节步数的拆分访问器
        for (var bufferViewId in bufferViewMap) {
            if (bufferViewMap.hasOwnProperty(bufferViewId)) {
                bufferView = bufferViews[bufferViewId];
                var accessors = bufferViewMap[bufferViewId];
                accessors.sort(function(a, b) {
                    return a.byteOffset - b.byteOffset;
                });
                var currentByteOffset = 0;
                var currentIndex = 0;
                var accessorsLength = accessors.length;
                for (i = 0; i < accessorsLength; ++i) {
                    var accessor = accessors[i];
                    var accessorByteStride = this.computeAccessorByteStride(accessor);
                    var accessorByteOffset = accessor.byteOffset;
                    var accessorByteLength = accessor.count * accessorByteStride;
                    delete accessor.byteStride;

                    var hasNextAccessor = (i < accessorsLength - 1);
                    var nextAccessorByteStride = hasNextAccessor ? this.computeAccessorByteStride(accessors[i + 1]) : undefined;
                    if (accessorByteStride !== nextAccessorByteStride) {
                        var newBufferView = clone(bufferView, true);
                        if (bufferViewHasVertexAttributes[bufferViewId]) {
                            newBufferView.byteStride = accessorByteStride;
                        }
                        newBufferView.byteOffset += currentByteOffset;
                        newBufferView.byteLength = accessorByteOffset + accessorByteLength - currentByteOffset;
                        var newBufferViewId = addToArray(bufferViews, newBufferView);
                        for (j = currentIndex; j <= i; ++j) {
                            accessor = accessors[j];
                            accessor.bufferView = newBufferViewId;
                            accessor.byteOffset = accessor.byteOffset - currentByteOffset;
                        }
                        // Set current byte offset to next accessor's byte offset
                        currentByteOffset = hasNextAccessor ? accessors[i + 1].byteOffset : undefined;
                        currentIndex = i + 1;
                    }
                }
            }
        }
        //删除未使用的缓冲区视图
        this.removeUnusedElements();
    }

    removeUnusedElements() {
        this.removeUnusedElementsByType('accessor');
        this.removeUnusedElementsByType('bufferView');
        this.removeUnusedElementsByType('buffer');
        return this.gltf;
    }

    removeUnusedElementsByType(type) {
        let gltf = this.gltf, name = this.typeToGltfElementName[type];
        var arrayOfObjects = gltf[name];

        if (defined(arrayOfObjects)) {
            var removed = 0;
            var usedIds = getListOfElementsIdsInUse[type](gltf);
            var length = arrayOfObjects.length;

            for (var i = 0; i < length; ++i) {
                if (!usedIds[i]) {
                    Remove[type](gltf, i - removed);
                    removed++;
                }
            }
        }
    }


    requirePositionAccessorMinMax() {
        let gltf = this.gltf;
        ForEach.accessorWithSemantic(gltf, 'POSITION', function(accessorId) {
            var accessor = gltf.accessors[accessorId];
            if (!defined(accessor.min) || !defined(accessor.max)) {
                var minMax = this.findAccessorMinMax(gltf, accessor);
                accessor.min = minMax.min;
                accessor.max = minMax.max;
            }
        });
    }

    /**
     * 查找访问器的最小值和最大值
     * @private
     */
    findAccessorMinMax(accessor) {
        let gltf = this.gltf;
        var bufferViews = gltf.bufferViews;
        var buffers = gltf.buffers;
        var bufferViewId = accessor.bufferView;
        var numberOfComponents = this.numberOfComponentsForType(accessor.type);

        // According to the spec, when bufferView is not defined, accessor must be initialized with zeros
        if (!defined(accessor.bufferView)) {
            return {
                min: arrayFill(new Array(numberOfComponents), 0.0),
                max: arrayFill(new Array(numberOfComponents), 0.0)
            };
        }

        var min = arrayFill(new Array(numberOfComponents), Number.POSITIVE_INFINITY);
        var max = arrayFill(new Array(numberOfComponents), Number.NEGATIVE_INFINITY);

        var bufferView = bufferViews[bufferViewId];
        var bufferId = bufferView.buffer;
        var buffer = buffers[bufferId];
        var source = buffer.extras._pipeline.source;

        var count = accessor.count;
        var byteStride = this.getAccessorByteStride(accessor);
        var byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;
        var componentType = accessor.componentType;
        var componentTypeByteLength = ComponentDatatype.getSizeInBytes(componentType);
        var dataView = new DataView(source.buffer);
        var components = new Array(numberOfComponents);
        var componentReader = getComponentReader(componentType);

        for (var i = 0; i < count; i++) {
            componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);
            for (var j = 0; j < numberOfComponents; j++) {
                var value = components[j];
                min[j] = Math.min(min[j], value);
                max[j] = Math.max(max[j], value);
            }
            byteOffset += byteStride;
        }

        return {
            min: min,
            max: max
        };
    }

    requireAnimationAccessorMinMax() {
        let gltf = this.gltf;
        ForEach.animation(gltf, function(animation) {
            ForEach.animationSampler(animation, function(sampler) {
                var accessor = gltf.accessors[sampler.input];
                if (!defined(accessor.min) || !defined(accessor.max)) {
                    var minMax = this.findAccessorMinMax(gltf, accessor);
                    accessor.min = minMax.min;
                    accessor.max = minMax.max;
                }
            });
        });
    }

    removeBufferType() {
        let gltf = this.gltf;
        ForEach.buffer(gltf, function(buffer) {
            delete buffer.type;
        });
    }

    removeTextureProperties() {
        let gltf = this.gltf;
        ForEach.texture(gltf, function(texture) {
            delete texture.format;
            delete texture.internalFormat;
            delete texture.target;
            delete texture.type;
        });
    }

    requireAttributeSetIndex() {
        let gltf = this.gltf;
        ForEach.mesh(gltf, function(mesh) {
            ForEach.meshPrimitive(mesh, function(primitive) {
                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {
                    if (semantic === 'TEXCOORD') {
                        primitive.attributes.TEXCOORD_0 = accessorId;
                    } else if (semantic === 'COLOR') {
                        primitive.attributes.COLOR_0 = accessorId;
                    }
                });
                delete primitive.attributes.TEXCOORD;
                delete primitive.attributes.COLOR;
            });
        });
        ForEach.technique(gltf, function(technique) {
            ForEach.techniqueParameter(technique, function(parameter) {
                var semantic = parameter.semantic;
                if (defined(semantic)) {
                    if (semantic === 'TEXCOORD') {
                        parameter.semantic = 'TEXCOORD_0';
                    } else if (semantic === 'COLOR') {
                        parameter.semantic = 'COLOR_0';
                    }
                }
            });
        });
    }

    underscoreApplicationSpecificSemantics() {
        let gltf = this.gltf, me = this, mappedSemantics = {};
        ForEach.mesh(gltf, function(mesh) {
            ForEach.meshPrimitive(mesh, function(primitive) {
                /*eslint-disable no-unused-vars*/
                ForEach.meshPrimitiveAttribute(primitive, function(accessorId, semantic) {
                    if (semantic.charAt(0) !== '_') {
                        var setIndex = semantic.search(/_[0-9]+/g);
                        var strippedSemantic = semantic;
                        var suffix = '_0';
                        if (setIndex >= 0) {
                            strippedSemantic = semantic.substring(0, setIndex);
                            suffix = semantic.substring(setIndex);
                        }
                        var newSemantic;
                        var indexedSemantic = me.indexedSemantics[strippedSemantic];
                        if (defined(indexedSemantic)) {
                            newSemantic = indexedSemantic + suffix;
                            mappedSemantics[semantic] = newSemantic;
                        } else if (!defined(me.knownSemantics[strippedSemantic])) {
                            newSemantic = '_' + semantic;
                            mappedSemantics[semantic] = newSemantic;
                        }
                    }
                });
                for (var semantic in mappedSemantics) {
                    if (mappedSemantics.hasOwnProperty(semantic)) {
                        var mappedSemantic = mappedSemantics[semantic];
                        var accessorId = primitive.attributes[semantic];
                        if (defined(accessorId)) {
                            delete primitive.attributes[semantic];
                            primitive.attributes[mappedSemantic] = accessorId;
                        }
                    }
                }
            });
        });
        ForEach.technique(gltf, function(technique) {
            ForEach.techniqueParameter(technique, function(parameter) {
                var mappedSemantic = mappedSemantics[parameter.semantic];
                if (defined(mappedSemantic)) {
                    parameter.semantic = mappedSemantic;
                }
            });
        });
    }

    /**
     * 更新JOINTS_0和WEIGHTS_0属性引用的访问器以使用正确的组件类型
     * @param {Object} gltf A javascript object containing a glTF asset.
     * @returns {Object} The glTF asset with compressed meshes.
     * @private
     */
    updateAccessorComponentTypes() {
        let gltf = this.gltf,componentType,me = this;
        ForEach.accessorWithSemantic(gltf, 'JOINTS_0', function(accessorId) {
            var accessor = gltf.accessors[accessorId];
            componentType = accessor.componentType;
            if (componentType === this.dataTypeConst.BYTE) {
                me.convertType(accessor, ComponentDatatype.UNSIGNED_BYTE);
            } else if (componentType !== this.dataTypeConst.UNSIGNED_BYTE
                && componentType !== this.dataTypeConst.UNSIGNED_SHORT) {
                me.convertType(accessor, ComponentDatatype.UNSIGNED_SHORT);
            }
        });
        ForEach.accessorWithSemantic(gltf, 'WEIGHTS_0', function(accessorId) {
            var accessor = gltf.accessors[accessorId];
            componentType = accessor.componentType;
            if (componentType === this.dataTypeConst.BYTE) {
                me.convertType(accessor, ComponentDatatype.UNSIGNED_BYTE);
            } else if (componentType === this.dataTypeConst.SHORT) {
                me.convertType(accessor, ComponentDatatype.UNSIGNED_SHORT);
            }
        });

        return gltf;
    }

    convertType(accessor, updatedComponentType) {
        let gltf = this.gltf
        var typedArray = ComponentDatatype.createTypedArray(updatedComponentType, this.readAccessorPacked(gltf, accessor));
        var newBuffer = new Uint8Array(typedArray.buffer);
        accessor.bufferView = this.addBuffer(newBuffer);
        accessor.componentType = updatedComponentType;
        accessor.byteOffset = 0;
    }

    /**
     * 返回连续数组中的访问器数据
     * @private
     */
    readAccessorPacked(gltf, accessor) {
        var byteStride = this.getAccessorByteStride(accessor);
        var componentTypeByteLength = ComponentDatatype.getSizeInBytes(accessor.componentType);
        var numberOfComponents = this.numberOfComponentsForType(accessor.type);
        var count = accessor.count;
        var values = new Array(numberOfComponents * count);

        if (!defined(accessor.bufferView)) {
            arrayFill(values, 0);
            return values;
        }

        var bufferView = gltf.bufferViews[accessor.bufferView];
        var source = gltf.buffers[bufferView.buffer].extras._pipeline.source;
        var byteOffset = accessor.byteOffset + bufferView.byteOffset + source.byteOffset;

        var dataView = new DataView(source.buffer);
        var components = new Array(numberOfComponents);
        var componentReader = getComponentReader(accessor.componentType);

        for (var i = 0; i < count; ++i) {
            componentReader(dataView, byteOffset, numberOfComponents, componentTypeByteLength, components);
            for (var j = 0; j < numberOfComponents; ++j) {
                values[i * numberOfComponents + j] = components[j];
            }
            byteOffset += byteStride;
        }
        return values;
    }

    /**
     * 向gltf对象中添加缓冲区
     * @param {Object} js文件格式的gltf对象
     * @param {Buffer} 将添加到gltf.buffers的缓冲区对象。
     * @returns {Number} 新添加的缓冲区视图id
     * @private
     */
    addBuffer(buffer) {
        let gltf = this.gltf;
        var newBuffer = {
            byteLength: buffer.length,
            extras: {
                _pipeline: {
                    source: buffer
                }
            }
        };
        var bufferId = addToArray(gltf.buffers, newBuffer);
        var bufferView = {
            buffer: bufferId,
            byteOffset: 0,
            byteLength: buffer.length
        };
        return addToArray(gltf.bufferViews, bufferView);
    }

    /**
     * 摄像机参数
     * @private
     * */
    clampCameraParameters() {
        let gltf = this.gltf;
        ForEach.camera(gltf, function(camera) {
            var perspective = camera.perspective;
            if (defined(perspective)) {
                var aspectRatio = perspective.aspectRatio;
                if (defined(aspectRatio) && aspectRatio === 0.0) {
                    delete perspective.aspectRatio;
                }
                var yfov = perspective.yfov;
                if (defined(yfov) && yfov === 0.0) {
                    perspective.yfov = 1.0;
                }
            }
        });
    }

    /**
     * 将gltf 1.0技术渲染状态移动到gltf 2.0材质属性和KHR_blend扩展。
     * @param {Object} gltf 包含gltf属性的js对象
     * @returns {Object} 更新后的gltf属性
     * @private
     */
    moveTechniqueRenderStates() {
        let blendingForTechnique = {},materialPropertiesForTechnique = {};
        let gltf = this.gltf, techniquesLegacy = gltf.techniques;
        if (!defined(techniquesLegacy)) {
            return gltf;
        }
        let me = this;
        ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {
            var renderStates = techniqueLegacy.states;
            if (defined(renderStates)) {
                var materialProperties = materialPropertiesForTechnique[techniqueIndex] = {};

                // If BLEND is enabled, the material should have alpha mode BLEND
                if (me.isStateEnabled(renderStates, me.dataTypeConst.BLEND)) {
                    materialProperties.alphaMode = 'BLEND';

                    var blendFunctions = renderStates.functions;
                    if (defined(blendFunctions) && (defined(blendFunctions.blendEquationSeparate)
                            || defined(blendFunctions.blendFuncSeparate))) {
                        blendingForTechnique[techniqueIndex] = {
                            blendEquation: defined(blendFunctions.blendEquationSeparate) ? blendFunctions.blendEquationSeparate : defaultBlendEquation,
                            blendFactors: this.getSupportedBlendFactors(blendFunctions.blendFuncSeparate, defaultBlendFactors)
                        };
                    }
                }

                // If CULL_FACE is not enabled, the material should be doubleSided
                if (!me.isStateEnabled(renderStates, me.dataTypeConst.CULL_FACE)) {
                    materialProperties.doubleSided = true;
                }

                delete techniqueLegacy.states;
            }
        });

        if (Object.keys(blendingForTechnique).length > 0) {
            if (!defined(gltf.extensions)) {
                gltf.extensions = {};
            }

            this.addExtensionsUsed(gltf, 'KHR_blend');
        }

        ForEach.material(gltf, function (material) {
            if (defined(material.technique)) {
                var materialProperties = materialPropertiesForTechnique[material.technique];
                ForEach.objectLegacy(materialProperties, function (value, property) {
                    material[property] = value;
                });

                var blending = blendingForTechnique[material.technique];
                if (defined(blending)) {
                    if (!defined(material.extensions)) {
                        material.extensions = {};
                    }

                    material.extensions.KHR_blend = blending;
                }
            }
        });

        return gltf;
    }

    // If any of the blend factors are not supported, return the default
    getSupportedBlendFactors(value, defaultValue) {
        if (!defined(value)) {
            return defaultValue;
        }
        for (var i = 0; i < 4; i++) {
            if (this.supportedBlendFactors.indexOf(value[i]) === -1) {
                return defaultValue;
            }
        }
        return value;
    }

    /**
     * 将gltf1.0材质技术移到gltf2.0的KHR_techniques_webgl拓展
     * @param {Object} 包含gltf属性的js对象
     * @returns {Object} 更新后的gltf属性
     * @private
     */
    moveTechniquesToExtension() {
        let gltf = this.gltf, techniquesLegacy = gltf.techniques;
        var mappedUniforms = {}, updatedTechniqueIndices = {};
        if (defined(techniquesLegacy)) {
            var extension = {
                programs: [],
                shaders: [],
                techniques: []
            };

            // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions
            var glExtensions = gltf.glExtensionsUsed;
            delete gltf.glExtensionsUsed;

            ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {
                var technique = {
                    name: techniqueLegacy.name,
                    program: undefined,
                    attributes: {},
                    uniforms: {}
                };

                var parameterLegacy;
                ForEach.techniqueAttribute(techniqueLegacy, function (parameterName, attributeName) {
                    parameterLegacy = techniqueLegacy.parameters[parameterName];
                    technique.attributes[attributeName] = {
                        semantic: parameterLegacy.semantic
                    };
                });

                ForEach.techniqueUniform(techniqueLegacy, function (parameterName, uniformName) {
                    parameterLegacy = techniqueLegacy.parameters[parameterName];
                    technique.uniforms[uniformName] = {
                        count: parameterLegacy.count,
                        node: parameterLegacy.node,
                        type: parameterLegacy.type,
                        semantic: parameterLegacy.semantic,
                        value: parameterLegacy.value
                    };

                    // Store the name of the uniform to update material values.
                    mappedUniforms[parameterName] = uniformName;
                });

                var programLegacy = gltf.programs[techniqueLegacy.program];
                var program = {
                    name: programLegacy.name,
                    fragmentShader: undefined,
                    vertexShader: undefined,
                    glExtensions: glExtensions
                };

                var fs = gltf.shaders[programLegacy.fragmentShader];
                program.fragmentShader = addToArray(extension.shaders, fs, true);

                var vs = gltf.shaders[programLegacy.vertexShader];
                program.vertexShader = addToArray(extension.shaders, vs, true);

                technique.program = addToArray(extension.programs, program);

                // Store the index of the new technique to reference instead.
                updatedTechniqueIndices[techniqueIndex] = addToArray(extension.techniques, technique);
            });

            if (extension.techniques.length > 0) {
                if (!defined(gltf.extensions)) {
                    gltf.extensions = {};
                }

                gltf.extensions.KHR_techniques_webgl = extension;
                this.addExtensionsUsed(gltf, 'KHR_techniques_webgl');
                this.addExtensionsRequired(gltf, 'KHR_techniques_webgl');
            }
        }

        ForEach.material(gltf, function (material) {
            if (defined(material.technique)) {
                var materialExtension = {
                    technique: updatedTechniqueIndices[material.technique]
                };

                ForEach.objectLegacy(material.values, function (value, parameterName) {
                    if (!defined(materialExtension.values)) {
                        materialExtension.values = {};
                    }

                    var uniformName = mappedUniforms[parameterName];
                    materialExtension.values[uniformName] = value;
                });

                if (!defined(material.extensions)) {
                    material.extensions = {};
                }

                material.extensions.KHR_techniques_webgl = materialExtension;
            }

            delete material.technique;
            delete material.values;
        });

        delete gltf.techniques;
        delete gltf.programs;
        delete gltf.shaders;

        return gltf;
    }

    removeEmptyArrays() {
        let gltf = this.gltf;
        for (var topLevelId in gltf) {
            if (gltf.hasOwnProperty(topLevelId)) {
                var array = gltf[topLevelId];
                if ((array instanceof Array) && array.length === 0) {
                    delete gltf[topLevelId];
                }
            }
        }
        ForEach.node(gltf, function(node) {
            if (defined(node.children) && node.children.length === 0) {
                delete node.children;
            }
        });
    }

    /**
     * 添加一个拓展到gltf.extensionsUsed，如果不存在的话
     * @param {Object} gltf 包含gltf属性的js对象
     * @param {String} extension 需要添加的拓展
     * @private
     */
    addExtensionsUsed(extension) {
        let gltf = this.gltf, extensionsUsed = gltf.extensionsUsed;
        if (!defined(extensionsUsed)) {
            extensionsUsed = [];
            gltf.extensionsUsed = extensionsUsed;
        }
        addToArray(extensionsUsed, extension, true);
    }

    /**
     * 添加一个拓展到gltf.extensionsRequired，如果不存在的话
     * @param {Object} gltf 包含gltf属性的js对象
     * @param {String} extension 需要添加的拓展
     * @private
     */
    addExtensionsRequired(extension) {
        let gltf = this.gltf, extensionsRequired = gltf.extensionsRequired;
        if (!defined(extensionsRequired)) {
            extensionsRequired = [];
            gltf.extensionsRequired = extensionsRequired;
        }
        addToArray(extensionsRequired, extension, true);
        this.addExtensionsUsed(extension);
    }

    /**
     *  是否启用状态
     *  @private
     * */
    isStateEnabled(renderStates, state) {
        var enabled = renderStates.enable;
        if (!defined(enabled)) {
            return false;
        }
        return (enabled.indexOf(state) > -1);
    }

}

/**
 * 包含用于获取GLTF资产使用的元素列表的函数。
 * @private
 */
function getListOfElementsIdsInUse() {}

getListOfElementsIdsInUse.accessor = function(gltf) {
    // Calculate accessor's that are currently in use.
    var usedAccessorIds = {};

    ForEach.mesh(gltf, function(mesh) {
        ForEach.meshPrimitive(mesh, function(primitive) {
            ForEach.meshPrimitiveAttribute(primitive, function(accessorId) {
                usedAccessorIds[accessorId] = true;
            });
            ForEach.meshPrimitiveTarget(primitive, function(target) {
                ForEach.meshPrimitiveTargetAttribute(target, function(accessorId) {
                    usedAccessorIds[accessorId] = true;
                });
            });
            var indices = primitive.indices;
            if (defined(indices)) {
                usedAccessorIds[indices] = true;
            }
        });
    });

    ForEach.skin(gltf, function(skin) {
        if (defined(skin.inverseBindMatrices)) {
            usedAccessorIds[skin.inverseBindMatrices] = true;
        }
    });

    ForEach.animation(gltf, function(animation) {
        ForEach.animationSampler(animation, function(sampler) {
            if (defined(sampler.input)) {
                usedAccessorIds[sampler.input] = true;
            }
            if (defined(sampler.output)) {
                usedAccessorIds[sampler.output] = true;
            }
        });
    });

    return usedAccessorIds;
};

getListOfElementsIdsInUse.buffer = function(gltf) {
    // Calculate buffer's that are currently in use.
    var usedBufferIds = {};

    ForEach.bufferView(gltf, function(bufferView) {
        if (defined(bufferView.buffer)) {
            usedBufferIds[bufferView.buffer] = true;
        }
    });

    return usedBufferIds;
};

getListOfElementsIdsInUse.bufferView = function(gltf) {
    // Calculate bufferView's that are currently in use.
    var usedBufferViewIds = {};

    ForEach.accessor(gltf, function(accessor) {
        if (defined(accessor.bufferView)) {
            usedBufferViewIds[accessor.bufferView] = true;
        }
    });

    ForEach.shader(gltf, function(shader) {
        if (defined(shader.bufferView)) {
            usedBufferViewIds[shader.bufferView] = true;
        }
    });

    ForEach.image(gltf, function(image) {
        if (defined(image.bufferView)) {
            usedBufferViewIds[image.bufferView] = true;
        }
        ForEach.compressedImage(image, function(compressedImage) {
            if (defined(compressedImage.bufferView)) {
                usedBufferViewIds[compressedImage.bufferView] = true;
            }
        });
    });

    if (hasExtension(gltf, 'KHR_draco_mesh_compression')) {
        ForEach.mesh(gltf, function(mesh) {
            ForEach.meshPrimitive(mesh, function(primitive) {
                if (defined(primitive.extensions) &&
                    defined(primitive.extensions.KHR_draco_mesh_compression)) {
                    usedBufferViewIds[primitive.extensions.KHR_draco_mesh_compression.bufferView] = true;
                }
            });
        });
    }

    return usedBufferViewIds;
};hmap.format.Batched3dModel = class {
    constructor(options = {}){
        let gltfView10 = options.gltf;          //Uint8Array数组
        this.scale = defined(options.scale) ? options.scale : 1.0;
        this.modelMatrix = defined(options.modelMatrix) ? new hmap.util.Matrix4().copy(options.modelMatrix) : new hmap.util.Matrix4();
        this.silhouetteSize = defined(options.silhouetteSize) ? options.silhouetteSize : 0.0;
        this.cachedGltf = undefined;        //缓存
        this.id = options.id;
        this.ready = false;                 //内容是否已准备好
        this.readyPromise = undefined;
        this.gltf = undefined;
        this.initGltf(gltfView10);
    }

    /**
     * 将1.0格式的gltf二进制视图转化为2.0格式的gltf的json
     * @private
     * */
    initGltf(gltfView10){
        let me = this;
        this.readyPromise = new Promise(function(resolve){
            let gltf20 = new hmap.format.GLTFConvert(gltfView10).getResult();
            let typedArray = gltf20.buffers[0].extras._pipeline.source;
            let buffer = typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength);
            gltf20.buffers = buffer;            //适应解析的格式
            me.gltf = gltf20;
            me.ready = true;
            resolve(me);
        })
    }

    /**
     * 获取object类型的gltf，传给gltf解析器
     * @private
     * */
    getGltf(){
        return this.gltf;
    }

    /**
     * 获取b3dm模型矩阵
     * @private
     * */
    getModelMatrix(){
        return this.modelMatrix;
    }

    /**
     * 销毁模型并释放内存
     * @private
     * */
    destroy(){
        for ( var key in this) {        //销毁所有的对象
            if (typeof this[key] === 'function') {
                this[key] = function(){
                    throw "This object has been destroyed!";
                };
            }
        }
        this.scale = undefined;
        this.modelMatrix = undefined;
        this.silhouetteSize = undefined;
        this.cachedGltf = undefined;        //缓存
        this.id = undefined;
        this.ready = false;                 //内容是否已准备好
        this.readyPromise = undefined;
        if(this.gltf){
            for (var name in this.gltf) {
                if (this.gltf.hasOwnProperty(name)) {
                    delete this.gltf[name];
                }
            }
            this.gltf = undefined;
        }
    }
};hmap.format.Batched3DModelContent = class{
    /**
     *  构造b3dm内容解析
     * */
    constructor(tileset, tile, resource, arrayBuffer, byteOffset){
        this._tileset = tileset;            //数据集
        this._tile = tile;                  //b3dm所属的切片
        this._model = undefined;
        this._batchTable = undefined;
        this._features = undefined;

        this.contentReadyPromise = undefined;          //切片内容准备好

        this._rtcCenterTransform = undefined;
        this._contentModelMatrix = undefined;

        this.initTileContent(arrayBuffer, byteOffset);     //初始化
    }

    /**
     *  初始化切片的内容
     *  @private
     * */
    initTileContent(arrayBuffer, byteOffset) {
        let me = this;
        let contentResolve;
        me.contentReadyPromise = new Promise(function(resolve){
            contentResolve = resolve;
        })
        me.contentReadyPromise.resolve = contentResolve;

        var tileset = me._tileset, tile = me._tile;

        var byteStart = defined(byteOffset) ? byteOffset : 0;
        byteOffset = byteStart;
        let sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;           //元素的字节长度

        var uint8Array = new Uint8Array(arrayBuffer);
        var view = new DataView(arrayBuffer);
        byteOffset += sizeOfUint32;

        var version = view.getUint32(byteOffset, true);
        if (version !== 1) {                                        //暂时只支持1版本的切片
            throw 'Only Batched 3D Model version 1 is supported.  Version ' + version + ' is not.';
        }
        byteOffset += sizeOfUint32;

        var byteLength = view.getUint32(byteOffset, true);
        byteOffset += sizeOfUint32;

        var featureTableJsonByteLength = view.getUint32(byteOffset, true);
        byteOffset += sizeOfUint32;

        var featureTableBinaryByteLength = view.getUint32(byteOffset, true);
        byteOffset += sizeOfUint32;

        var batchTableJsonByteLength = view.getUint32(byteOffset, true);
        byteOffset += sizeOfUint32;

        var batchTableBinaryByteLength = view.getUint32(byteOffset, true);
        byteOffset += sizeOfUint32;

        // Legacy header #1: [batchLength] [batchTableByteLength]
        // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
        // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
        // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.
        // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.
        // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead
        if (batchTableJsonByteLength >= 570425344) {
            // First legacy check
            byteOffset -= sizeOfUint32 * 2;
            batchTableJsonByteLength = featureTableBinaryByteLength;
            batchTableBinaryByteLength = 0;
            featureTableJsonByteLength = 0;
            featureTableBinaryByteLength = 0;
            console.warn("This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]");
        } else if (batchTableBinaryByteLength >= 570425344) {
            // Second legacy check
            byteOffset -= sizeOfUint32;
            batchTableJsonByteLength = featureTableJsonByteLength;
            batchTableBinaryByteLength = featureTableBinaryByteLength;
            featureTableJsonByteLength = 0;
            featureTableBinaryByteLength = 0;
            console.warn("This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]");
        }

        if (featureTableJsonByteLength === 0) {
        } else {
            byteOffset += featureTableJsonByteLength;
        }

        byteOffset += featureTableBinaryByteLength;

        if (batchTableJsonByteLength > 0) {
            byteOffset += batchTableJsonByteLength;

            if (batchTableBinaryByteLength > 0) {
                byteOffset += batchTableBinaryByteLength;
            }
        }

        var gltfByteLength = byteStart + byteLength - byteOffset;
        if (gltfByteLength === 0) {
            throw 'glTF byte length must be greater than 0.';
        }

        var gltfView;
        if (byteOffset % 4 === 0) {
            gltfView = new Uint8Array(uint8Array.buffer, byteOffset, gltfByteLength);
        } else {
            console.warn('b3dm-glb-unaligned:The embedded glb is not aligned to a 4-byte boundary.');
            gltfView = new Uint8Array(uint8Array.subarray(byteOffset, byteOffset + gltfByteLength));
        }

        this._rtcCenterTransform = new hmap.util.Matrix4();
        /*var rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', ComponentDatatype.FLOAT, 3);
        if (defined(rtcCenter)) {
            this._rtcCenterTransform = new hmap.util.Matrix4().fromTranslation(Cartesian3.fromArray(rtcCenter));
        }*/

        this._contentModelMatrix = new hmap.util.Matrix4().multiply(tile.computedTransform, this._rtcCenterTransform, new hmap.util.Matrix4());

        let gltf10 = this.getGltf10FromTypedArray(gltfView);

        this._model = new hmap.format.Batched3dModel({
            gltf: gltf10,
            modelMatrix: this._contentModelMatrix,
            upAxis : tileset._gltfUpAxis
        });

        this._model.readyPromise.then(function(b3dm){
            me.contentReadyPromise.resolve(b3dm);         //resolve b3dm内容
        })
    }

    /**
     * 根据类型化数组，创建gltf1.0
     * @private
     * */
    getGltf10FromTypedArray(uint8Array){
        var dataView = new DataView(uint8Array.buffer);
        var header = new Array(5);
        for (var i = 0; i < 5; ++i) {
            header[i] = dataView.getUint32(uint8Array.byteOffset + i * 4, true);       //sizeOfUint32 4
        }

        let version = header[1], length = header[2];
        if (version !== 1) {
            throw 'Binary glTF version is required 1';
        }

        let jsonStart = 20, contentLength = header[3], binaryStart = jsonStart + contentLength;
        var contentString = this.getStringFromTypedArray(uint8Array, jsonStart, contentLength);
        var gltf10 = JSON.parse(contentString);

        this.addPipelineExtras(gltf10);

        var binaryBuffer = uint8Array.subarray(binaryStart, length);

        var buffers = gltf10.buffers;
        if (defined(buffers) && Object.keys(buffers).length > 0) {
            // In some older models, the binary glTF buffer is named KHR_binary_glTF
            var binaryGltfBuffer = defined(buffers.binary_glTF) ? buffers.binary_glTF : buffers.KHR_binary_glTF;
            if (defined(binaryGltfBuffer)) {
                binaryGltfBuffer.extras._pipeline.source = binaryBuffer;
            }
        }
        // Remove the KHR_binary_glTF extension
        this.removeExtensionsUsed(gltf10, 'KHR_binary_glTF');
        return gltf10;
    }

    /**
     *  同时处理gltf1.0和gltf2.0的额外属性
     *  @param {Object} gltf gltf对象
     *  @private
     */
    addPipelineExtras(gltf) {
        const me = this;
        ForEach.shader(gltf, function(shader) {
            me.addExtras(shader);
        });
        ForEach.buffer(gltf, function(buffer) {
            me.addExtras(buffer);
        });
        ForEach.image(gltf, function (image) {
            me.addExtras(image);
            ForEach.compressedImage(image, function(compressedImage) {
                me.addExtras(compressedImage);
            });
        });
    }

    /**
     * 添加属性extras
     * @private
     * */
    addExtras(object) {
        object.extras = defined(object.extras) ? object.extras : {};
        object.extras._pipeline = defined(object.extras._pipeline) ? object.extras._pipeline : {};
    }

    /**
     * 从gltf.extensionsUsed和gltf.extensionsRequired中移除拓展属性
     * @private
     * */
    removeExtensionsUsed(gltf, extension) {
        var extensionsUsed = gltf.extensionsUsed;
        if (defined(extensionsUsed)) {
            var index = extensionsUsed.indexOf(extension);
            if (index >= 0) {
                extensionsUsed.splice(index, 1);
            }
            this.removeExtensionsRequired(gltf, extension);
            if (extensionsUsed.length === 0) {
                delete gltf.extensionsUsed;
            }
        }
    }

    /**
     * 从gltf.extensionsRequired中移除拓展属性
     * @private
     */
    removeExtensionsRequired(gltf, extension) {
        var extensionsRequired = gltf.extensionsRequired;
        if (defined(extensionsRequired)) {
            var index = extensionsRequired.indexOf(extension);
            if (index >= 0) {
                extensionsRequired.splice(index, 1);
            }
            if (extensionsRequired.length === 0) {
                delete gltf.extensionsRequired;
            }
        }
    }

    /**
     * 将类型化数组转为字符串
     * @returns {String}
     * @private
     * */
    getStringFromTypedArray(uint8Array, byteOffset, byteLength) {
        if (!defined(uint8Array)) {
            throw 'Batched3DModel3DTileContent: uint8Array is required.';
        }
        if (byteOffset < 0) {
            throw 'byteOffset cannot be negative.';
        }
        if (byteLength < 0) {
            throw 'byteLength cannot be negative.';
        }
        if ((byteOffset + byteLength) > uint8Array.byteLength) {
            throw 'sub-region exceeds array bounds.';
        }
        byteOffset = defined(byteOffset) ? byteOffset : 0;
        byteLength = defined(byteLength) ? byteLength : (uint8Array.byteLength - byteOffset);
        uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);

        if ( typeof TextDecoder !== 'undefined' ) {         //es5自带的文本解码
            return new TextDecoder().decode( uint8Array );
        }
        var s = '';
        for ( var i = 0, il = uint8Array.length; i < il; i ++ ) {
            s += String.fromCharCode( uint8Array[ i ] );
        }
        return decodeURIComponent( escape( s ) );
    }

    /**
     * 销毁一张切片的内容，并释放内存
     * @private
     * */
    destroy(){
        for ( var key in this) {        //销毁所有的对象
            if (typeof this[key] === 'function') {
                this[key] = function(){
                    throw "This object has been destroyed!";
                };
            }
        }
        this._tileset = undefined;
        this._tile = undefined;
        this._model.destroy();
        this._model = undefined;
        this._batchTable = undefined;
        this._features = undefined;
        this.contentReadyPromise = undefined;
        this._rtcCenterTransform = undefined;
        this._contentModelMatrix = undefined;
    }
};hmap.format.Tile3D = class {
    constructor(tileset, baseDir, header, parent){
        this.basePath = (baseDir.lastIndexOf('/') === -1 ? './': baseDir.substr( 0, baseDir.lastIndexOf('/') + 1));          //获取基础路径
        this._tileset = tileset;
        this._header = header;
        this._contentState = false;             //切片加载状态
        this._depth = 0;
        var contentHeader = header.content;
        if(contentHeader && (contentHeader.uri || contentHeader.url)){
            if(contentHeader.uri){
                this.tileUrl = this.basePath + contentHeader.uri;     //切片json的路径
            }else{
                this.tileUrl = this.basePath + contentHeader.url;     //切片json的路径
            }
        }

        /**
         * 包围体，6个长度的数组，数值依次为：最小经度、最小纬度、最大经度、最大纬度、最小高程、最大高程
         * @private
         * */
        this.boundingVolume = header.boundingVolume;

        /**
         * 切片状态
         * */
        this.tileContentState={         //切片状态
            UNLOADED:"unloaded",
            READY:"ready",
            LOADING:"loading",
            PROCESSING:"processing",        //处理进程
            FAILED:"failed"
        }

        /**
         * 切片的自身转换
         * @type {hmap.util.Matrix4}
         */
        this.transform = header.transform ? new hmap.util.Matrix4(new Float32Array(header.transform)) : new hmap.util.Matrix4();            //自身矩阵转换
        var parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;                                 //父级数据集矩阵转换
        var computedTransform = new hmap.util.Matrix4().multiply(parentTransform).multiply(this.transform);                  //计算矩阵
        var parentInitialTransform = parent ? parent._initialTransform : new hmap.util.Matrix4();
        this._initialTransform = new hmap.util.Matrix4().multiply(parentInitialTransform).multiply(this.transform);           //自身矩阵

        /**
         * 切片最终矩阵变换
         */
        this.computedTransform = computedTransform;

        /**
         * 切片与相机的垂直方向上的距离
         * */
        this._verticalToCamera = 0;

        /**
         *  几何误差
         *  @type {Number}
         */
        this.geometricError = header.geometricError;            //几何误差
        if (!this.geometricError) {
            this.geometricError = parent ? parent.geometricError : this._tileset._geometricError;
            console.warn("Required property geometricError is undefined for this tile. Using parent's geometric error instead.");
        }

        /**
         *  切片的绘制类型，新增or替换
         * */
        var refine;
        if (header.refine) {
            refine = (header.refine.toUpperCase() === 'REPLACE') ? "REPLACE" : "ADD";
        } else if (parent) {
            refine = parent.refine;
        } else {
            refine = "REPLACE";
        }

        /**
         * 渲染之前指定切换的绘制类型，新增或替换
         * @private
         */
        this.refine = refine;

        /**
         * 保存切片的子切片
         * @type {Array<Tile3D>}
         * @readonly
         */
        this.children = [];

        this.parent = parent;

        this._content = undefined;
        this._contentType = undefined;
        this._contentState = this.tileContentState.UNLOADED;        //初始状态

        this._depth = 0;                //深度
        this._priority = 0.0;           //优先级
        this.scratchToTileCenter = 1;    //new Cartesian3();         //草稿指令表

        let readyResolve;
        this.tileContentReadyPromise = new Promise(function(resolve){
            readyResolve = resolve;
        })
        this.tileContentReadyPromise.resolve = readyResolve;
        this.hasContent = false;
        this.tileExpired = false;               //切片过期，不必要再显示
        this.hasRequest = false;
    }

    /**
     * 重置切片异步请求
     * */
    resetTileContentPromise(){
        let readyResolve;
        this.tileContentReadyPromise = new Promise(function(resolve){
            readyResolve = resolve;
        })
        this.tileContentReadyPromise.resolve = readyResolve;
    }

    /**
     * 获取深度,其中root.b3dm的深度为2
     * */
    geDepth(){
        return this._depth;
    }

    /**
     * 获取切片数据集
     * */
    getTileset(){
        return this._tileset;
    }

    /**
     * 获取切片内容
     * */
    getContent(){
        return this._content;
    }

    /**
     * 获取切片类型
     * */
    getContentType(){
        return this._contentType;
    }

    /**
     * 请求一张切片的内容
     * @private
     */
    requestContent() {
        var tileset = this._tileset;
        if(!this.tileUrl){
            console.warn("tile url can not be empty!");
            return;
        }
        let me = this;
        var promise = this.fetchArrayBuffer();                      //获取二进制数据
        promise.then(function(arrayBuffer){
            let uint8Array = new Uint8Array(arrayBuffer);
            let magic = me.getMagic(uint8Array);
            if(magic == 'b3dm'){                  //b3dm类型
                me._contentType = 'b3dm';
                me._content = new hmap.format.Batched3DModelContent(tileset, me, me.tileUrl, arrayBuffer, 0);       //解析切片中batched 3d model的内容
            }/*else if(magic == 'pnts'){          //点云类型
                me._contentType = 'pnts';
                me._content = new hmap.format.PointCloudContent(tileset, me, me.tileUrl, arrayBuffer, 0);
            }*/else{                              //root
                me._contentType = 'tileset'
                me._content = new hmap.format.Tile3DContent(tileset, me, me.tileUrl, arrayBuffer, 0);                     //tileset.json文件解析
            }
            me._contentState = me.tileContentState.PROCESSING;
            me._content.contentReadyPromise.then(function(content) {
                me._contentState = me.tileContentState.READY;
                me.tileContentReadyPromise.resolve(content);
            });
        },function(msg){
            me.requestRejectHandle(me)
        })
    }

    /**
     *  请求获得切片的二进制数组
     * */
    fetchArrayBuffer(){
        const me = this;
        let promise = new Promise(function(resolve,reject){
            fetch(me.tileUrl,{
                method: 'get',
                responseType: 'arraybuffer'         //获取arrayBuffer
            }).then(function(response){
                if(response.ok){
                    return response.arrayBuffer();      //二进制
                }else{
                    reject("tile content error:" + me.tileUrl);
                }
            }).then(function(arraybuffer){
                if(arraybuffer){
                    resolve(arraybuffer);
                }
            }).catch(function(e) {
                reject("failed to load:" + me.tileUrl);
            })
        })
        return promise;
    }

    /**
     * 切片请求失败函数处理
     * */
    requestRejectHandle(tile){
        tile._tileset._contentState = this.tileContentState.FAILED;
        tile._tileset.numberOfTileFailed++;
        tile._content = undefined;
    }

    /**
     * 获取前缀名，为了将b3dm文件和tileset.json分开处理
     * */
    getMagic(uint8Array, byteOffset) {
        byteOffset = defined(byteOffset) ? byteOffset : 0;
        return this.getStringFromTypedArray(uint8Array, byteOffset, Math.min(4, uint8Array.length));
    }

    /**
     * 将类型化数组转为字符串
     * */
    getStringFromTypedArray(uint8Array, byteOffset, byteLength) {
        if (!defined(uint8Array)) {
            throw 'Batched3DModel3DTileContent: uint8Array is required.';
        }
        if (byteOffset < 0) {
            throw 'byteOffset cannot be negative.';
        }
        if (byteLength < 0) {
            throw 'byteLength cannot be negative.';
        }
        if ((byteOffset + byteLength) > uint8Array.byteLength) {
            throw 'sub-region exceeds array bounds.';
        }
        byteOffset = defined(byteOffset) ? byteOffset : 0;
        byteLength = defined(byteLength) ? byteLength : (uint8Array.byteLength - byteOffset);
        uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);

        if ( typeof TextDecoder !== 'undefined' ) {         //es5自带的文本解码
            return new TextDecoder().decode( uint8Array );
        }
        var s = '';
        for ( var i = 0, il = uint8Array.length; i < il; i ++ ) {
            s += String.fromCharCode( uint8Array[ i ] );
        }
        return decodeURIComponent( escape( s ) );
    }

    /**
     * 计算屏幕空间误差，此项为lod的依据
     * @param {Boolean} useParentGeometricError 是否使用父级几何误差
     * @private
     */
    getScreenSpaceError(camera, useParentGeometricError) {
        let tileset = this._tileset;
        let parentGeometricError = defined(this.parent) ? this.parent.geometricError : tileset._geometricError;
        let geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;
        if (geometricError === 0.0) {
            // Leaf tiles do not have any error so save the computation
            return 0.0;
        }

        var error;
        let height = camera._containerHeight;           //绘制区域的高度
        // Avoid divide by zero when viewer is inside the tile
        var distance = Math.max(this._verticalToCamera, 0.0000001);

        let fovy = camera._fovy;                    //纵向的视角范围
        let sseDenominator = 2.0 * Math.tan(0.5 * fovy * Math.PI/180);

        error = (geometricError * height) / (distance * sseDenominator);
        //error = (tileset._maximumScreenSpaceError * height) / (distance * sseDenominator);
        if (tileset.dynamicScreenSpaceError) {
            var density = tileset._dynamicScreenSpaceErrorComputedDensity;
            var factor = tileset.dynamicScreenSpaceErrorFactor;

            var dynamicError = (1.0 - Math.exp(-(distance * density) * (distance * density)))* factor;
            error -= dynamicError;
        }
        return error;
    }

    /**
     * 计算相机到切片的中心的垂直距离
     * @private
     * */
    updateDistanceToCamera(camera){
        let cameraCoord = camera.getCoordinate();
        let cameraZ = cameraCoord.getOrdinate("Z")*110000; //相机高度，单位米

        let region = this.boundingVolume.region;
        let tileZ  = (region[4]+region[5])/2;     //切片中心高度，单位米
        this._verticalToCamera = cameraZ - tileZ;
    }

    /**
     * 根据包围体 获取切片经纬度范围
     * @private
     * */
    getExtent(){
        let bv = this.boundingVolume.region;
        if(bv instanceof Array){
            return new hmap.basetype.Extent(bv[0]*180/Math.PI, bv[1]*180/Math.PI, bv[2]*180/Math.PI, bv[3]*180/Math.PI);
        }
    }

    /**
     * 更新切片的可见性
     * @private
     * */
    updateVisibility(requestDepth){
        if(requestDepth == this._depth){
            this.visibility = true;
        }
        if(requestDepth > this._depth && this.children.length == 0){
            this.visibility = true;
        }
        if(requestDepth < this._depth && this._depth == 2){
            this.visibility = true;
        }
    }

    /**
     * 获取tile子级下，所有需要请求的切片，并追加到地图上去
     * @private
     * */
    getRequestTiles(requestDepth,tilesArray){
        let tiles = this.children;
        for(let i=0;i<tiles.length;i++){
            let tile = tiles[i];
            if(tile._depth < requestDepth && tile._depth != this._tileset.maxDepth){
                tile.getRequestTiles(requestDepth,tilesArray);
            }
            if(tile._depth == requestDepth ||(requestDepth < tile._depth && tile._depth == 2) || (tile._depth < requestDepth && tile._depth == this._tileset.maxDepth)){
                tilesArray.push(tile);
            }
        }
    }

    /**
     * 拆解、卸载一个切片的内容
     * @private
     */
    unloadContent() {
        if(this._content){
            this._content.destroy();
            this._content = undefined;
            this._contentType = undefined;
            this.hasRequest = false;
            this._contentState = this._contentState.UNLOADED;
        }
        this.resetTileContentPromise();             //重置
    }

    /**
     *  计算包围体与相机的距离
     * @param {FrameState} frameState 框架状态
     * @returns {Number} distance 距离
     * @private
     */
    distanceToTile(frameState) {
        var boundingVolume = getBoundingVolume(this, frameState);
        return boundingVolume.distanceToCamera(frameState);
    }

    /**
     * 计算切片包围体中心与相机的距离
     * @param {FrameState} frameState 框架状态
     * @returns {Number} distance 距离
     * @private
     */
    distanceToTileCenter(frameState) {
        var tileBoundingVolume = getBoundingVolume(this, frameState);
        var boundingVolume = tileBoundingVolume.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere
        var toCenter = Cartesian3.subtract(boundingVolume.center, frameState.camera.positionWC, this.scratchToTileCenter);
        var distance = Cartesian3.magnitude(toCenter);
        Cartesian3.divideByScalar(toCenter, distance, toCenter);
        var dot = Cartesian3.dot(frameState.camera.directionWC, toCenter);
        return distance * dot;
    }
};hmap.format.Tile3DContent = class {
    constructor(tileset, tile, tilesetUrl, arrayBuffer, byteOffset){
        this._tileset = tileset;
        this._tile = tile;
        this.tilesetUrl = tilesetUrl;
        this.contentReadyPromise = undefined;

        this.initTileContent(arrayBuffer, byteOffset);
    }

    /**
     * 初始化tileset内容
     * @private
     * */
    initTileContent(arrayBuffer, byteOffset) {
        byteOffset = defined(byteOffset) ? byteOffset : 0;
        var uint8Array = new Uint8Array(arrayBuffer);
        var jsonString = this.getStringFromTypedArray(uint8Array, byteOffset);
        const me = this;
        this.contentReadyPromise = new Promise(function(resolve,reject){
            try {
                let tilesetJson = JSON.parse(jsonString);
                let root = me._tileset.loadTileset(me.tilesetUrl, tilesetJson, me._tile);
                resolve(root);
            } catch (error) {
                reject('Invalid tile content:' + me.tilesetUrl);
            }
        });
    }

    /**
     * 根据类型化数组获取字符串
     * @private
     * */
    getStringFromTypedArray(uint8Array, byteOffset, byteLength) {
        if (!defined(uint8Array)) {
            throw 'Tileset3DTileContent: uint8Array is required.';
        }
        if (byteOffset < 0) {
            throw 'byteOffset cannot be negative.';
        }
        if (byteLength < 0) {
            throw 'byteLength cannot be negative.';
        }
        if ((byteOffset + byteLength) > uint8Array.byteLength) {
            throw 'sub-region exceeds array bounds.';
        }
        byteOffset =defined(byteOffset) ? byteOffset : 0;
        byteLength = defined(byteLength) ? byteLength : (uint8Array.byteLength - byteOffset);
        uint8Array = uint8Array.subarray(byteOffset, byteOffset + byteLength);

        if ( typeof TextDecoder !== 'undefined' ) {         //es5自带的文本解码
            return new TextDecoder().decode( uint8Array );
        }
        var s = '';
        for ( var i = 0, il = uint8Array.length; i < il; i ++ ) {
            s += String.fromCharCode( uint8Array[ i ] );
        }
        return decodeURIComponent( escape( s ) );
    }
};hmap.help = hmap.help || {};
hmap.help.PointsBlockHelper = class {
    constructor(blocks, size = 50000) {
        this._size = size;
        this._blocks = blocks;
        this._curBlock;
    }

    get() {
        if (!this._curBlock || this._curBlock.count >= this._size) {
            this._curBlock = this._createBlock();
        }
        return this._curBlock;
    }

    filterBlocks(extent) {
        return [...this._blocks.values()]
    }

    _createBlock() {
        let block = new hmap.core.PointsBlock();
        this._blocks.set(block.id, block);
        return block;
    }
};

hmap.core = hmap.core || {};
hmap.core.PointsBlock = class {
    constructor() {
        this.id = hmap.util.Aid.createUnique("block");
        this.buffer = null;
        this.points = [];
        this.colors = [];
        this.count = 0;
        this.doTask = 1;
    }

    add(data) {
        this.points.push.apply(this.points, [data[0], data[1], data[2]]);
        this.colors.push.apply(this.colors, [data[3]/255, data[4]/255, data[5]/255, data[6]]);
        this.count++;
    }

    clear() {
        this.buffer = null;
        this.colors = [];
        this.points = [];
    }
}

/*! -------- 版权归海康威视所有 -------- */